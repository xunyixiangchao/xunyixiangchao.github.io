{"pages":[],"posts":[{"title":"Activity启动模式","text":"从四个视角理解Android Activity启动模式系统视角： 1. Android的软件体系结构 1.2 Task Activity代码属于Application，但是Task属于Android操作系统 Task是可以跨应用的 手机查看Task：（用户角度）手机中按home键旁边那个方形键（recent-apps）时，屏幕上展示的就是一个个task。 代码中查看Task：（程序角度）adb shell dumpsys activity activities | sed -En -e ‘/Stack #/p’ -e ‘/Running activities/,/Run #0/p’ sed工具不用单独下载，D:\\soft\\Git\\usr\\bin\\sed.exe Git安装目录下包含，配置下环境变量就可以。 用户视角： 2.1 Task启动方式(launcher启动)Launcher启动 1、Task不存在 2、Task存在 2.2 Task启动方式（新建）1234Intent intent = new Intent(this, SecondActivity.class);intent.putExtra(&quot;message&quot;, &quot;message&quot;);intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);startActivity(intent); 通知： 1.系统通知2.自己 其他第三方应用： 1、Scheme协议2、第三方应用start launcher,新建 都是通过startActivity来创建的。 2.3 Task启动方式（恢复）恢复 这属于Activity生命周期由不可见到获得焦点的范畴 程序视角： 3.1 Activity和FragmentFragment是Android3.0后引入的一个新的API，他出现的初衷是为了适应大屏幕的平板电脑， 当然现在他仍然是平板APP UI设计的宠儿，而且我们普通手机开发也会加入这个Fragment， 我们可以把他看成一个小型的Activity，又称Activity片段！ 3.2 Activity的生命周期 Activity是否可见： PS:Fragment生命周期 Activity与Fragment生命周期 3.3 相邻状态之间的区别 A启动B 和 B返回A 1.onCreate和onStart之间有什么区别？ （1）可见与不可见的区别。前者不可见，后者可见。（2）执行次数的区别。onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。因此Bundle数据的恢复在onStart中进行比onCreate中执行更合适。 （3）onCreate能做的事onStart其实都能做，但是onstart能做的事onCreate却未必适合做。如前文所说的，setContentView和资源初始化在两者都能做，然而想动画的初始化在onStart中做比较好。 2.onStart方法和onResume方法有什么区别？ （1）是否在前台。onStart方法中Activity可见但不在前台，不可交互，而在onResume中在前台。（2）职责不同，onStart方法中主要还是进行初始化工作，而onResume方法，根据官方的建议，可以做开启动画和独占设备的操作。 3.onPause方法和onStop方法有什么区别？ （1）是否可见。onPause时Activity可见，onStop时Activity不可见，但Activity对象还在内存中。（2）在系统内存不足的时候可能不会执行onStop方法，因此程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但要注意不能太耗时。 4.onStop方法和onDestroy方法有什么区别？ onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Acivity被销毁 **PS:**闪屏页：在onStop()方法中进行finish(); 3.4 onNewIntent的生命周期 1、只对singleTop，singleTask，singleInstance有效，因为standard每次都是新建(不是绝对，使用了Intent.FLAG_ACTIVITY_NEW_TASK,要启动的Activity已经有Task在运行了，新的activity不会再创建，而是把当前堆栈的activity带到前台)，所以不存在onNewIntent； 2、只对startActivity有效，对于从Navigation切换回来的恢复无效； 4.1 Activity启动模式 4.2 standard启动模式1、standard 默认模式 系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，不管这个实例是否已经存在，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。这种模式的 Activity 被创建时它的 onCreate、onStart 都会被调用。这是一种典型的多实例实现，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。 a、当从非Activity的context启动activity时，需要带new_task的flag； b、当启动一个带有affinity的activity，如果这个activity已经有实例存在该task，则不会重新创建； c、如果从应用内启动的standard activity的Affinity就是App默认的Affinity，则会每次新建一个实例； 4.3 singleTop启动模式一个singleTop Activity 的实例可以无限多，唯一的区别是如果在栈顶已经有一个相同类型的Activity实例，Intent不会再创建一个Activity，而是通过onNewIntent()被发送到现有的Activity。 4.4 singleTask模式这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例，和 singleTop一样，系统也会回调其 onNewIntent。当一个具有 singleTask 模式的Activity请求启动后，比如 Activity A，系统首先会寻找是否存在 A 想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建 A 的实例后把 A 放到栈中。如果存在 A 所需的任务栈，这时要看 A 是否在栈中有实例存在，如果有实例存在，那么系统就会把 A 调到栈顶并调用它的 onNewIntent 方法，如果实例不存在，就创建 A 的实例并把 A 压入栈中 。 不需要关注NEW_TASK 4.5 singleInstance模式与 singleTask 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。也就是有此种模式的 Activity 只能单独地位于一个任务栈中 PS：4种模式只能在AndroidManifest.xml中定义（定义层定义的） 4.6 Intent Activity Flag启动层定义 5.1 启动模式的应用场景 launchMode 使用场景 singleTop 适合启动同类型的 Activity，例如： •接收通知启动的内容显示页面 •耗时操作返回页面 •登录页面 singleTask 适合作为程序入口，例如： •WebView页面 •扫一扫页面 •确认订单界面 •付款界面 singleInstance 适合需要与程序分离开的页面，例如： •闹铃的响铃界面 •来电页面 •锁屏页","link":"/2020/12/11/activity/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/12/08/hello-world/"},{"title":"AndroidStudio开发Gradle插件","text":"项目结构：gradlePlugin app src build.gradle buildSrc src main java com.lis.buildsrc MyPlugin.java build.gradle build.gradle 简单的Gradle插件BuildSrc如果开发的插件仅用于当前项目，不需要发布的话，只需要注意两点: 插件的Module名称必须是buildSrc(开头一定要小写) 无须resources目录 build.gradle的配置： 123456789101112131415apply plugin:'java' apply plugin:'groovy' repositories { google() jcenter() } dependencies { implementation gradleApi() //gradle sdk implementation localGroovy() //groovy sdk implementation 'com.android.tools.build:gradle:3.6.3' } sourceCompatibility = &quot;1.7&quot; targetCompatibility = &quot;1.7&quot; 这里引入groovy sdk和gradle sdk,因为开发Android插件，还需要Android专用的gradle（这里需要使用到google仓库） 然后我们编写插件，MyPlugin: 12345678910111213import org.gradle.api.Plugin;import org.gradle.api.Project;import org.gradle.api.logging.Logger;public class MyPlugin implements Plugin&lt;Project&gt; { @Override public void apply(Project project) { Logger logger = project.getLogger(); logger.error(&quot;=====================&quot;); logger.error(&quot;最简单的Gradle插件&quot;); logger.error(&quot;=====================&quot;); }} 在app的build.gradle中添加你的插件 注意：这里不加’ ‘单引号 1apply plugin: com.lis.buildsrc.MyPlugin 执行：**Build-make Module ‘app’**生成补丁。 在底部的 Buid-Build Output中便可以看到打印日志： =====================简单的Gradle插件 ===================== 插件的发布如果想复用你的gradle插件，就需要把它发布出去。 发布到本地仓库 发布到远程仓库 本地仓库项目结构： gradlePlugin app src build.gradle buildSrc src main java com.lis.buildsrc MyPlugin.java resources META-INF.gradle-plugins com.lis.myplugin.properties build.gradle build.gradle 在buildSrc的main文件夹下添加resources文件夹，在该文件夹下添加*META-INF**，META-INF*文件夹下添加**gradle-plugins 在**gradle-plugins**中添加com.lis.myplugin.properties 这里命名为 com.lis.myplugin.properties ，一定要注意后缀名称，那么使用插件时的名称就是com.lis.myplugin，文件里面的内容填写如下： 1implementation-class=com.lis.buildsrc.MyPlugin 这里指定的路径为MyPlugin的类名，即插件的入口类 buidSrc中的build.gradle，添加maven插件及发布用到的配置 123456789101112131415161718192021222324apply plugin:'java'apply plugin:'groovy'apply plugin: 'maven'repositories { google() jcenter()}tasks.withType(JavaCompile) { options.encoding = &quot;UTF-8&quot; } //编码格式dependencies { implementation gradleApi() //gradle sdk implementation localGroovy() //groovy sdk implementation 'com.android.tools.build:gradle:3.6.3'}uploadArchives { repositories.mavenDeployer { repository(url: uri('../repo')) //仓库的路径，此处是项目根目录下的 repo 的文件夹 pom.groupId = 'com.lis.gradleplugin' //groupId ，自行定义，一般是包名 pom.artifactId = 'myplugin' //artifactId ，自行定义 pom.version = '1.0.0' //version 版本号 }}sourceCompatibility = &quot;1.7&quot;targetCompatibility = &quot;1.7&quot; 同步后在gradle模块内，会出现发布按钮 双击uploadArchives ,插件就发布到了本地的maven仓库，这里我们是在项目的根目录里，所以会在GradlePlugin下生成repo文件夹及文件 使用插件: 在GradlePlugin根目录的build.gradle中添加本地仓库及插件引用 123456789101112131415161718192021222324252627282930313233buildscript { repositories { google() jcenter() //首先需要配置本地的 maven 仓库地址，这里填写的是相对路径，也可以是全路径 maven { url uri('./repo') } } dependencies { classpath 'com.android.tools.build:gradle:3.6.3' //然后，添加依赖的插件，形式是 groupId：artifactId：version //这些都是插件发布时，定义的名称 classpath 'com.lis.gradleplugin:myplugin:1.0.0' }}allprojects { repositories { google() jcenter() maven { url uri('./repo') } }}task clean(type: Delete) { delete rootProject.buildDir} 最后，在app的build.gradle里，添加插件 123456789101112131415161718192021222324252627282930313233apply plugin: 'com.android.application'apply plugin: 'com.lis.myplugin'//这里就填写 .properties 文件的名称android { compileSdkVersion 29 buildToolsVersion &quot;29.0.3&quot; defaultConfig { applicationId &quot;com.lis.gradleplugin&quot; minSdkVersion 21 targetSdkVersion 29 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } }}dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'androidx.appcompat:appcompat:1.1.0' implementation 'androidx.constraintlayout:constraintlayout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'androidx.test.ext:junit:1.1.1' androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'} apply plugin: 'com.lis.myplugin'这里的com.lis.myplugin即我们上面com.lis.myplugin.properties文件的名称 这就完成了本地仓库的插件使用！","link":"/2020/12/08/gradle/"},{"title":"View事件分发","text":"目录 MotionEvent 事件分发、拦截与消费 总流程 onTouch和onClick 源码分析： View.dispatchTouchEvent 总结： 事件分发源码解析： 事件：ACTION_DOWN 1.假设onInterceptTouchEvent没有拦截，这里intercepted为false; 2.假设onInterceptTouchEvent直接拦截，这里intercepted为true; 总结： 事件：ACTION_MOVE 1.假设onInterceptTouchEvent没有拦截 总结： 事件冲突 ViewGroup#onInterceptTouchEvent 冲突解决： 内部拦截法（在子View中解决） 内部拦截法总结： 外部拦截法（在父View中解决） MotionEvent 事件分发、拦截与消费 事件分发：Activity，ViewGroup， View 事件拦截： ViewGroup 事件消费：Activity， View 总流程 onTouch和onClick12345678910111213textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.e(&quot;Text&quot;, &quot;onClick&quot;); }});textView.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { Log.e(&quot;Text&quot;, &quot;onTouch&quot;+event.getAction()); return false; }}); 源码分析：View.dispatchTouchEvent12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean dispatchTouchEvent(MotionEvent event) { // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) { // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) { return false; } // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); } boolean result = false; if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { // Defensive cleanup for new gesture stopNestedScroll(); } if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } if (!result &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result;} 123456ListenerInfo li = mListenerInfo;if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true;} 这里li不等于空 在view.setOnTouchListener或setOnClickListener调用时 都会调用getListenerInfo()方法 123public void setOnTouchListener(OnTouchListener l) { getListenerInfo().mOnTouchListener = l;} 1234567ListenerInfo getListenerInfo() { if (mListenerInfo != null) { return mListenerInfo; } mListenerInfo = new ListenerInfo(); return mListenerInfo;} 所以这里li肯定不为空 (mViewFlags &amp; ENABLED_MASK) == ENABLED这里代表可view可用状态 所以li.mOnTouchListener.onTouch(this, event)这里如果返回为 为true时 result=true 123if (!result &amp;&amp; onTouchEvent(event)) { result = true;} 所以这里的onTouchEvent(event)方法就不会再走。 onTouchEvent中 1234567891011public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); ... case MotionEvent.ACTION_UP: if (!post(mPerformClick)) { performClickInternal(); }} performClickInternal–&gt;performClick 123456789101112131415161718192021public boolean performClick() { // We still need to call this method to handle the cases where performClick() was called // externally, instead of through performClickInternal() notifyAutofillManagerOnClick(); final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result;} 这里 li.mOnClickListener.onClick(this);调用了onClick方法，并返回true 总结：onTouch返回fasle时，调用onTouchEvent,再到onClick onTouch返回true时，不调用onTouchEvent和onClick onTouch=false—-&gt;onTouchEvent—-&gt;onClick onTouch=true 结束 事件分发源码解析：Activity#dispatchTouchEvent 123456789public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev);} getWindow().superDispatchTouchEvent(ev)–&gt;PhoneWindow#superDispatchTouchEvent 123public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event);} mDecor.superDispatchTouchEvent(event)–&gt;DecorView#superDispatchTouchEvent 123public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event);} 这里的dispatchTouchEvent–&gt;ViewGroup#dispatchTouchEvent 事件：ACTION_DOWN一进入down就会清除事件和状态 1234567if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();} 是否拦截的标识 1final boolean intercepted; 1.假设onInterceptTouchEvent没有拦截，这里intercepted为false;1234@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { return false;} 1234567891011121314if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; }} else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;} 12final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; 假设这里的canceled也为false(没有取消) 所以进入了这里 123456789101112131415161718192021TouchTarget newTouchTarget = null;boolean alreadyDispatchedToNewTouchTarget = false;if (!canceled &amp;&amp; !intercepted) { View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { } } 这里newTouchTarget为null,并且childrenCount也不可能为0 if (newTouchTarget == null &amp;&amp; childrenCount != 0)中 1final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); buildTouchDispatchChildList()方法对子View进行排序 12345678910111213for (int i = 0; i &lt; childrenCount; i++) { // add next child (in child order) to end of list final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View nextChild = mChildren[childIndex]; final float currentZ = nextChild.getZ(); // insert ahead of any Views with greater Z int insertIndex = i; while (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) { insertIndex--; } mPreSortedChildren.add(insertIndex, nextChild);} 这里Z轴越大越在数组后面，越小越在数组前面（页面上View越在上层越在数组后面，越底层越在数组前面） ​ 这里从排好序的preorderedList中，从最后往前取值（即先取z轴最上层的view） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false);} 这里判断取到的View是不是点击到的View（判断是否能够接收手指事件和点击区域是不是在View上） 不是的话继续循环拿取 12345if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue;} View.java 123protected boolean canReceivePointerEvents() { return (mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || getAnimation() != null;} 12345678910111213protected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint) { final float[] point = getTempPoint(); point[0] = x; point[1] = y; transformPointToViewLocal(point, child); // pointInView：x &gt;= 0 &amp;&amp; localY &gt;= 0 &amp;&amp; y &lt; ((mRight - mLeft) + 0) &amp;&amp;y &lt; ((mBottom - mTop) + 0) 判断触点是否在View上 final boolean isInView = child.pointInView(point[0], point[1]); if (isInView &amp;&amp; outLocalPoint != null) { outLocalPoint.set(point[0], point[1]); } return isInView;} 1234public boolean pointInView(float localX, float localY, float slop) { return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; ((mRight - mLeft) + slop) &amp;&amp; localY &lt; ((mBottom - mTop) + slop);} 这里获取TouchTarget，这里返回的还是空，因为mFirstTouchTarget初始为空 1newTouchTarget = getTouchTarget(child); 12345678private TouchTarget getTouchTarget(@NonNull View child) { for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) { if (target.child == child) { return target; } } return null;} dispatchTransformedTouchEvent –分发给谁处理事件 1dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign) 1234567891011121314151617181920212223private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; ... if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled;} 这里child不为空，所以就会调用child.dispatchTouchEvent(transformedEvent)–&gt;就到了上文onTouch和onClick的源码分析View.dispatchTouchEvent View.dispatchTouchEvent处理事件后，返回result为true 123if (!result &amp;&amp; onTouchEvent(event)) { result = true;} 就进入if，然后break;结束整个for循环，其他view就处理不了事件了。 1234567891011121314151617181920if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break;} 这里会调用addTouchTarget(),进行newTouchTarget赋值。 123456private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;} mFirstTouchTarget==newTouchTarget并且alreadyDispatchedToNewTouchTarget=true; 如果没有处理，当前循环就结束了， 进行下一次的for循环。 继续往下走：进入else了 12345678910111213141516171819202122232425262728293031323334if (mFirstTouchTarget == null) { handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);} else { TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; }} 1final TouchTarget next = target.next; 这里的next为null，最后target = next; 所以这里的while循环只会进入一次。（这里while是为多指触摸准备的，几个手指就会循环几次） 123if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } 这里都满足所以handled为true 最后返回 handled。整个Down事件就结束了。 2.假设onInterceptTouchEvent直接拦截，这里intercepted为true;1234@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { return true;} 1234567891011121314if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; }} else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;} 123if (!canceled &amp;&amp; !intercepted) { ...} 这里整个if语句都 不会进入 而且这里拦截了以后，ViewGroup的子View就不再往下分发事件（分发是在这个if中for循环中分发的） 这里mFirstTouchTarget为null， 12345if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);} 这里的child为null传入 1234567891011121314151617private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled;... // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } 所以会调用super.dispatchTouchEvent(transformedEvent); 即调用ViewGroup自己的dispatchTouchEvent方法来处理 总结：当ViewGroup#onInterceptTouchEvent为false时，就会调用子View的dispatchTouchEvent 当ViewGroup#onInterceptTouchEvent为true时，就会调用自身的dispatchTouchEvent 事件：ACTION_MOVE1.假设onInterceptTouchEvent没有拦截这里mFirstTouchTarget经过Down事件后不为null,所以intercepted为false 1234567891011121314if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; }} else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;} 进入下面if之前boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) 中直接进入下面 else中 123456789101112131415161718192021222324252627282930313233if (mFirstTouchTarget == null) { handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);} else { TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; }} 所以这里while走了else 12345678910111213141516171819202122232425while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next;} dispatchTransformedTouchEvent方法 中走了handled = child.dispatchTouchEvent(transformedEvent); 总结：当ViewGroup#onInterceptTouchEvent为false时，就会调用子View的dispatchTouchEvent 事件冲突ViewGroup#onInterceptTouchEventViewpager+Listview 冲突解决：内部拦截法（在子View中解决）1234567891011121314151617181920212223int mLastX;int mLastY;@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) { int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: getParent().requestDisallowInterceptTouchEvent(true);//请求不允许中断 break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if(Math.abs(deltaX)&gt; Math.abs(deltaY)){ //左右滑 getParent().requestDisallowInterceptTouchEvent(false);//允许中断 } break; } mLastX = x; mLastY = y; return super.dispatchTouchEvent(ev);} 12345678910111213141516171819@Overridepublic void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We're already in this state, assume our ancestors are too return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); }} 这里设置了 getParent().requestDisallowInterceptTouchEvent(true)后，disallowIntercept就为true，就不会走父View的onInterceptTouchEvent方法进行拦截，实现子View接收事件。 12345678910if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; }} 但是，不能在MotionEvent.ACTION_DOWN方法中设置。 在进入上面事件判断前会进行状态的初始化。所以在ACTION_DOWN事件中onInterceptTouchEvent肯定会执行。 1234if (actionMasked == MotionEvent.ACTION_DOWN) { cancelAndClearTouchTargets(ev); resetTouchState();} 解决方法：在父View中为ACTION_DOWN返回false 12345678@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { super.onInterceptTouchEvent(ev); return false; } return true;} 内部拦截法总结：MotionEvent.ACTION_DOWN时，父View中onInterceptTouchEvent设为false，子View调用getParent().requestDisallowInterceptTouchEvent(true);方法 MotionEvent.ACTION_MOVE时，父View中onInterceptTouchEvent设为true，非子View事件时getParent().requestDisallowInterceptTouchEvent(false);方法 外部拦截法（在父View中解决）在父View当中进行处理 1234567891011121314151617181920212223int mLastX;int mLastY;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: mLastX= (int) ev.getX(); mLastY= (int) ev.getY(); break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if (Math.abs(deltaX) &gt; Math.abs(deltaY)) { //左右滑 return true; } break; } return super.onInterceptTouchEvent(ev);}","link":"/2020/12/09/dispatch/"},{"title":"View基础","text":"Android自定义View概述 Android开发进阶的必经之路 为什么要自定义View 自定义View的基本方法 自定义控件分类 自定义View基础 View的分类 View类简介 AttributeSet与自定义属性 View视图结构 Android坐标系 View位置（坐标）描述 位置获取方式 Android中颜色相关内容 View树的绘制流程 View树的绘制流程是谁负责的？ view的添加 view的绘制流程 measure layout draw LayoutParams MarginLayoutParams LayoutParams与View如何建立联系 addView 自定义LayoutParams LayoutParams常见的子类 MeasureSpec 定义 MeasureSpecs 的意义 MeasureSpec值的确定 Android开发进阶的必经之路为什么要自定义View自定义View的基本方法自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。 测量：onMeasure()决定View的大小； 布局：onLayout()决定View在ViewGroup中的位置； 绘制：onDraw()决定绘制这个View。 自定义控件分类 自定义View: 只需要重写onMeasure()和onDraw() 自定义ViewGroup: 则只需要重写onMeasure()和onLayout() 自定义View基础View的分类视图View主要分为两类| 类别 | 解释 | 特点 || ——– | —————————————– | ———— || 单一视图 | 即一个View，如TextView | 不包含子View || 视图组 | 即多个View组成的ViewGroup，如LinearLayout | 包含子View | View类简介 View类是Android中各种组件的基类，如View是ViewGroup基类 View表现为显示在屏幕上的各种视图 Android中的UI组件都由View、ViewGroup组成。 View的构造函数：共有4个 12345678910111213141516171819202122232425// 如果View是在Java代码里面new的，则调用第一个构造函数 public CarsonView(Context context) { super(context); }// 如果View是在.xml里声明的，则调用第二个构造函数// 自定义属性是从AttributeSet参数传进来的 public CarsonView(Context context, AttributeSet attrs) { super(context, attrs); }// 不会自动调用// 一般是在第二个构造函数里主动调用// 如View有style属性时 public CarsonView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } //API21之后才使用 // 不会自动调用 // 一般是在第二个构造函数里主动调用 // 如View有style属性时 public CarsonView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); } AttributeSet与自定义属性 系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤： 通过&lt;declare-styleable&gt;为自定义View添加属性 在xml中为相应的属性声明属性值 在运行时（一般为构造函数）获取属性值 将获取到的属性值应用到View View视图结构 PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口 DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等 对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图： 一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。 Android坐标系Android的坐标系定义为： 屏幕的左上角为坐标原点 向右为x轴增大方向 向下为y轴增大方向 区别于一般的数学坐标系 View位置（坐标）描述View的位置由4个顶点决定的4个顶点的位置描述分别由4个值决定： 请记住：View的位置是相对于父控件而言的） Top：子View上边界到父view上边界的距离 Left：子View左边界到父view左边界的距离 Bottom：子View下边距到父View上边界的距离 Right：子View右边界到父view左边界的距离 位置获取方式View的位置是通过view.getxxx()函数进行获取：（以Top为例） 123456789// 获取Top位置public final int getTop() { return mTop; } // 其余如下： getLeft(); //获取子View左上角距父View左侧的距离 getBottom(); //获取子View右下角距父View顶部的距离 getRight(); //获取子View右下角距父View左侧的距离 与MotionEvent中 get()和getRaw()的区别 1234567//get() ：触摸点相对于其所在组件坐标系的坐标 event.getX(); event.getY();//getRaw() ：触摸点相对于屏幕默认坐标系的坐标 event.getRawX(); event.getRawY(); Android中颜色相关内容Android支持的颜色模式：以ARGB8888为例介绍颜色定义: View树的绘制流程View树的绘制流程是谁负责的？view树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的； view的添加 view的绘制流程 measure 系统为什么要有measure过程？ measure过程都干了点什么事？ 对于自适应的尺寸机制，如何合理的测量一颗View树？ 那么ViewGroup是如何向子View传递限制信息的？ ScrollView嵌套ListView问题？ layout 系统为什么要有layout过程？ layout过程都干了点什么事？ draw 系统为什么要有draw过程？ draw过程都干了点什么事？ LayoutParamsLayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。 事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类 MarginLayoutParamsMarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的 属性优先级问题MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级 margin &gt; horizontalMargin和verticalMargin &gt; leftMargin和RightMargin、topMargin和bottomMargin 属性覆盖问题优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释 Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value LayoutParams与View如何建立联系 在XML中定义View 在Java代码中直接生成View对应的实例对象 addView12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 重载方法1：添加一个子View * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams */public void addView(View child) { addView(child, -1);}/** * 重载方法2：在指定位置添加一个子View * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams * @param index View将在ViewGroup中被添加的位置（-1代表添加到末尾） */public void addView(View child, int index) { if (child == null) { throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;); } LayoutParams params = child.getLayoutParams(); if (params == null) { params = generateDefaultLayoutParams();// 生成当前ViewGroup默认的LayoutParams if (params == null) { throw new IllegalArgumentException(&quot;generateDefaultLayoutParams() cannot return null&quot;); } } addView(child, index, params);}/** * 重载方法3：添加一个子View * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height */public void addView(View child, int width, int height) { final LayoutParams params = generateDefaultLayoutParams(); // 生成当前ViewGroup默认的LayoutParams params.width = width; params.height = height; addView(child, -1, params);}/** * 重载方法4：添加一个子View，并使用传入的LayoutParams */@Overridepublic void addView(View child, LayoutParams params) { addView(child, -1, params);}/** * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams */public void addView(View child, int index, LayoutParams params) { if (child == null) { throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;); } // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false);}private void addViewInner(View child, int index, LayoutParams params, boolean preventRequestLayout) { ..... if (mTransition != null) { mTransition.addChild(this, child); } if (!checkLayoutParams(params)) { // ① 检查传入的LayoutParams是否合法 params = generateLayoutParams(params); // 如果传入的LayoutParams不合法，将进行转化操作 } if (preventRequestLayout) { // ② 是否需要阻止重新执行布局流程 child.mLayoutParams = params; // 这不会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw） } else { child.setLayoutParams(params); // 这会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw） } if (index &lt; 0) { index = mChildrenCount; } addInArray(child, index); // tell our children if (preventRequestLayout) { child.assignParent(this); } else { child.mParent = this; } .....} 自定义LayoutParams 创建自定义属性 12345678&lt;resources&gt; &lt;declare-styleable name=&quot;xxxViewGroup_Layout&quot;&gt; &lt;!-- 自定义的属性 --&gt; &lt;attr name=&quot;layout_simple_attr&quot; format=&quot;integer&quot;/&gt; &lt;!-- 使用系统预置的属性 --&gt; &lt;attr name=&quot;android:layout_gravity&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 继承MarginLayout 1234567891011121314151617181920212223242526public static class LayoutParams extends ViewGroup.MarginLayoutParams { public int simpleAttr; public int gravity; public LayoutParams(Context c, AttributeSet attrs) { super(c, attrs); // 解析布局属性 TypedArray typedArray = c.obtainStyledAttributes(attrs, R.styleable.SimpleViewGroup_Layout); simpleAttr = typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_layout_simple_attr, 0); gravity=typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_android_layout_gravity, -1); typedArray.recycle();//释放资源 } public LayoutParams(int width, int height) { super(width, height); } public LayoutParams(MarginLayoutParams source) { super(source); } public LayoutParams(ViewGroup.LayoutParams source) { super(source); }} 重写ViewGroup中几个与LayoutParams相关的方法 1234567891011121314151617181920212223// 检查LayoutParams是否合法@Overrideprotected boolean checkLayoutParams(ViewGroup.LayoutParams p) { return p instanceof SimpleViewGroup.LayoutParams;}// 生成默认的LayoutParams@Overrideprotected ViewGroup.LayoutParams generateDefaultLayoutParams() { return new SimpleViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);}// 对传入的LayoutParams进行转化@Overrideprotected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) { return new SimpleViewGroup.LayoutParams(p);}// 对传入的LayoutParams进行转化@Overridepublic ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) { return new SimpleViewGroup.LayoutParams(getContext(), attrs);} LayoutParams常见的子类在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类： ViewGroup.MarginLayoutParams FrameLayout.LayoutParams LinearLayout.LayoutParams RelativeLayout.LayoutParams RecyclerView.LayoutParams GridLayoutManager.LayoutParams StaggeredGridLayoutManager.LayoutParams ViewPager.LayoutParams WindowManager.LayoutParams MeasureSpec定义测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种： UNSPECIFIED父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大） EXACTLY父控件已经知道你所需的精确大小，你的最终大小应该就是这么大。 AT_MOST你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。 MeasureSpecs 的意义通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法 MeasureSpec值的确定MeasureSpec值到底是如何计算得来的呢?子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个 * 最可能符合条件的child view的测量规格。 * @param spec 父控件的测量规格 * @param padding 父控件里已经占用的大小 * @param childDimension child view布局LayoutParams里的尺寸 * @return child view 的测量规格 */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); //父控件的测量模式 int specSize = MeasureSpec.getSize(spec); //父控件的测量大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了 case MeasureSpec.EXACTLY: //如果child的布局参数有固定值，比如&quot;layout_width&quot; = &quot;100dp&quot; //那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } //如果child的布局参数是&quot;match_parent&quot;，也就是想要占满父控件 //而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了 else if (childDimension == LayoutParams.MATCH_PARENT) { resultSize = size; resultMode = MeasureSpec.EXACTLY; } //如果child的布局参数是&quot;wrap_content&quot;，也就是想要根据自己的逻辑决定自己大小， //比如TextView根据设置的字符串大小来决定自己的大小 //那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛 //所以测量模式就是AT_MOST，测量大小就是父控件的size else if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size case MeasureSpec.AT_MOST: //同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求 if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } //child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小 //但同样的，child的尺寸上限也是父控件的尺寸上限size else if (childDimension == LayoutParams.MATCH_PARENT) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } //child想要根据自己逻辑决定大小，那就自己决定呗 else if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; } break; } return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 针对上表，这里再做一下具体的说明 对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定 对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。1. 当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小； 2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间； 3. 当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。 4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。","link":"/2021/06/15/view/"},{"title":"OkHttp源码分析","text":"OkHttp请求流程 高并发请求分发器与线程池 责任链模式请求与响应拦截 目录 OkHttp介绍 简单使用： 使用流程： 调用流程： 分发器： 异步请求工作流程： OkHttp线程池的特点： AsyncCall 同步请求 拦截器： 获取响应： 责任链模式： 拦截器责任链： 五大拦截器功能： 拦截器详情： 一、重试及重定向拦截器 重试 重定向 总结 二、桥接拦截器 总结 三、缓存拦截器 缓存策略 流程： 详细流程： PS：请求头与响应头 四、连接拦截器 连接流程： 连接池清理： 代理连接： 五、请求服务器拦截器 Expect: 100-continue 总结 自定义拦截器 OkHttp总结 补充: 代理 OkHttp介绍由Square公司贡献的一个处理网络请求的开源项目，是目前Android使用最广泛的网络框架，从Android4。4开始HttpURLConnection的底层实现采用的是OkHttp。 支持HTTP/2并允许对同一主机的所有请求共享一个套接字 通过连接池，减少了请求延迟 默认通过GZip压缩数据 响应缓存，以免了重复请求的网络 请求失败自动重试主机的其他ip，自动重定向 …… 简单使用：123456789101112131415161718192021OkHttpClient okHttpClient = new OkHttpClient();Request request = new Request.Builder().url(&quot;http://www.baidu.com&quot;).build();Call call = okHttpClient.newCall(request);try { //同步请求 Response execute = call.execute();} catch (IOException e) { e.printStackTrace();}//异步请求call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { }}); 使用流程： 调用流程：OkHttp请求过程中最少需要接触OkHttpClient、Request、Call、Response，但是框架内部进行大量的逻辑处理。 所有的逻辑大部分集中在拦截器中，但是在进入拦截器之前还需要依靠分发器来调配请求任务。 分发器：内部维护队列与线程池，完成请求调配；Dispatcher 拦截器：五大默认拦截器完成整个请求过程； Interceptors 分发器：异步请求工作流程： Q：如何决定将请求放入ready还是running? Q：从running移动到ready的条件是什么？ Q：分发器线程池的工作行为？ Dispatcher中 A: client.dispatcher().enqueue(new AsyncCall(responseCallback)); 1234567891011121314synchronized void enqueue(AsyncCall call) { //1.running队列数小于最大请求数64（正在请求的的数量是有限制的，自己配置分发器时可以修改） //2.同一域名正在请求的个数也是有限制的小于5 //PS:最大同时请求数64，与同一台服务器请求数5 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) { //添加到running队列 runningAsyncCalls.add(call); //将runnable（call）提交到线程池当中 executorService().execute(call); } else { //不符合上面请求就加入到等待队列 readyAsyncCalls.add(call); }} A:client.dispatcher().finished(this);-&gt; promoteCalls()移动队列（异步时才有移动队列） 123456789101112131415161718192021private void promoteCalls() { //正在执行队列数 if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. //等待队列数得不为空 if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) { AsyncCall call = i.next(); //如果拿到的等待请求host，在请求的列表中已经存在5个 if (runningCallsForHost(call) &lt; maxRequestsPerHost) { //等待移除 i.remove(); //加入running runningAsyncCalls.add(call); //加入线程池 executorService().execute(call); } //判断正在执行队列数 if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. }} A:ThreadPoolExecutor 当一个任务通过execute(Runnable)方法添加到线程池时： 线程数量小于corePoolSize，新建线程(核心)来处理被添加的任务； 线程数量大于等于 corePoolSize，存在空闲线程，使用空闲线程执行新任务；- 线程数量大于等于 corePoolSize，不存在空闲线程，新任务被添加到等待队列，添加成功则等待空闲线程，添加失败： 线程数量小于maximumPoolSize，新建线程执行新任务； 线程数量等于maximumPoolSize，拒绝此任务。 1234567891011121314public synchronized ExecutorService executorService() { if (executorService == null) { //corePoolSize:核心线程数 0 不缓存线程，（0和1的表现是一样的）不用时就不占用线程，闲置60就会回收掉 //maximumPoolSize最大线程数（包括核心） //keepAliveTime 缓存60秒 //workQueue 队列 //threadFactory 创建一个thread //PS:和Executors.newCachedThreadPool();创建的线程池一样 executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); } return executorService;} SynchronousQueue implements BlockingQueue 是个阻塞队列 PS:三种阻塞队列 ArrayBlockingQueue：基于数组的阻塞队列，初始化需要指定固定大小。 LinkedBlockingQueue：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。 SynchronousQueue : 无容量的队列。 往队列中添加元素一定是失败的。 OkHttp线程池的特点：OkHttp提交请求，一定是往队列里提交，往队列中添加是一定是失败的，马上新建线程（没有到最大线程数）， 不需要等待。获得最大的并发量 AsyncCall继承NamedRunnable类实现Runnable接口 12345678910111213141516171819202122public abstract class NamedRunnable implements Runnable { protected final String name; public NamedRunnable(String format, Object... args) { this.name = Util.format(format, args); } /** * run方法其实调用的AsyncCall的execute() */ @Override public final void run() { String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try { execute(); } finally { Thread.currentThread().setName(oldName); } } protected abstract void execute();} 同步请求加入队列，执行完移除队列 1234synchronized void executed(RealCall call) { //同步直接加入running队列，这里的running是同步队列不是异步的 runningSyncCalls.add(call);} 拦截器：默认五大拦截器：（责任链模式）重定向与重试，Header、Body处理，缓存处理，连接处理，服务器通讯 请求是顺序的，响应是逆序的 获取响应：无论同步还是异常都是通过getResponseWithInterceptorChain 获得请求结果：Response 123456789101112131415161718192021222324Response getResponseWithInterceptorChain() throws IOException { // 拦截器集合 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); //重定向与重试 interceptors.add(retryAndFollowUpInterceptor); //Header,Body处理 interceptors.add(new BridgeInterceptor(client.cookieJar())); //缓存处理 interceptors.add(new CacheInterceptor(client.internalCache())); //连接处理 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } //服务器通讯 interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);} 责任链模式：（一排，最后一位往前一个个传纸条[请求]，传到第一个又一个个往后传[响应]） 为请求创建了一个接收者对象的链，在处理请求的时候执行过滤(各司其职)。 责任链上的处理者负责处理请求，客户只需要将请求发送到责任链即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 拦截器责任链： 五大拦截器功能： 重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。 桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。 缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。 连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。 请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。 拦截器详情：一、重试及重定向拦截器第一个拦截器:RetryAndFollowUpInterceptor，主要就是完成两件事情：重试与重定向。 重试场景：请求超时；域名解析后多个IP，如果一个IP失败了，重试其他IP 设置是否允许重试 12//设置是否允许重试 默认是允许new OkHttpClient().newBuilder().retryOnConnectionFailure(true); 在RetryAndFollowUpInterceptor中失败时，进入recover方法 12345678910111213141516171819202122try { //todo 请求出现了异常，那么releaseConnection依旧为true。 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false;} catch (RouteException e) { //todo 路由异常，连接未成功，请求还没发出去 //The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), streamAllocation, false, request)) { throw e.getLastConnectException(); } releaseConnection = false; //重试 continue;} catch (IOException e) { //todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接) // ConnectionShutdownException只对HTTP2存在。假定它就是false //An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue;} 在recover中 获取是否允许重试，如果不允许就抛异常，结束。 123456789101112131415161718192021222324private boolean recover(IOException e, StreamAllocation streamAllocation, boolean requestSendStarted, Request userRequest) { streamAllocation.streamFailed(e); //todo 1、在配置OkhttpClient是设置了不允许重试（默认允许），则一旦发生请求失败就不再重试 //The application layer has forbidden retries. if (!client.retryOnConnectionFailure()) return false; //todo 2、由于requestSendStarted只在http2的io异常中为true，先不管http2 //We can't send the request body again. if (requestSendStarted &amp;&amp; userRequest.body() instanceof UnrepeatableRequestBody) return false; //todo 3、判断是不是属于重试的异常 //This exception is fatal. if (!isRecoverable(e, requestSendStarted)) return false; //todo 4、是不是存在更多的路线 （多个ip，多个代理） //No more routes to attempt. if (!streamAllocation.hasMoreRoutes()) return false; // For failure recovery, use the same route selector with a new connection. return true; } 重试的异常包括哪些： 在 todo 3的isRecoverable方法中 12345678910111213141516171819202122232425262728private boolean isRecoverable(IOException e, boolean requestSendStarted) { // 1.是不是协议异常（code为204,205代表没有响应体，同时响应数据长度还大于0两都冲突，参照CallServerInterceptor中 // if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0)） //：不重试 if (e instanceof ProtocolException) { return false; } //2.socket超时异常 返回true:重试 if (e instanceof InterruptedIOException) { return e instanceof SocketTimeoutException &amp;&amp; !requestSendStarted; } //3.//SSL证书不正确 可能证书格式损坏 有问题：不重试 if (e instanceof SSLHandshakeException) { // If the problem was a CertificateException from the X509TrustManager, // do not retry. if (e.getCause() instanceof CertificateException) { return false; } } //4.SSL证书校验 ：不重试 if (e instanceof SSLPeerUnverifiedException) { return false; } return true;} 所以在socket超时异常时会进行重试，其他异常不再进行重试 重定向场景：30X，资源改变 最大重定向次数为：20 12345678//todo 处理3和4xx的一些状态码，如301 302重定向Request followUp = followUpRequest(response, streamAllocation.route());if (followUp == null) { if (!forWebSocket) { streamAllocation.release(); } return response;} 1Request followUpRequest(Response userResponse, Route route) 在followUpRequest中响应码 407: 1234567891011//407 身份校验case HTTP_PROXY_AUTH: Proxy selectedProxy = route != null ? route.proxy() : client.proxy(); if (selectedProxy.type() != Proxy.Type.HTTP) { throw new ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not &quot; + &quot;using proxy&quot;); } //用户没有设置就返回null,重定向就结束了 return client.proxyAuthenticator().authenticate(route, userResponse); 用户设置身份校验 123456789101112131415//设置身份校验的代理new OkHttpClient.Builder().proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress( &quot;localhost&quot;, 8080)))//设置身份校验(默认不设置这个）.proxyAuthenticator(new Authenticator() { @Nullable @Override public Request authenticate(Route route, Response response) throws IOException { //参照Authenticator接口注释 return response.request().newBuilder() .header(&quot;Proxy-Authorization&quot;, Credentials.basic(&quot;用户名&quot;,&quot;密码&quot;)) .build(); }}).build(); 401: 1234// 401 需要身份验证 有些服务器接口需要验证使用者身份 在请求头中添加 “Authorization”case HTTP_UNAUTHORIZED: //类似407身份验证，设置authenticator() return client.authenticator().authenticate(route, userResponse); 重定向： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 308 永久重定向// 307 临时重定向case HTTP_PERM_REDIRECT:case HTTP_TEMP_REDIRECT: // 如果请求方式不是GET或者HEAD，框架不会自动重定向请求 if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) { return null; } // 300 301 302 303case HTTP_MULT_CHOICE:case HTTP_MOVED_PERM:case HTTP_MOVED_TEMP:case HTTP_SEE_OTHER: // 如果用户不允许重定向，那就返回null if (!client.followRedirects()) return null; // 从响应头取出location String location = userResponse.header(&quot;Location&quot;); if (location == null) return null; // 根据location 配置新的请求 url HttpUrl url = userResponse.request().url().resolve(location); // 如果为null，说明协议有问题，取不出来HttpUrl，那就返回null，不进行重定向 if (url == null) return null; // 如果重定向在http到https之间切换，需要检查用户是不是允许(默认允许) boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme()); if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null; Request.Builder requestBuilder = userResponse.request().newBuilder(); /** * 重定向请求中 只要不是 PROPFIND 请求，无论是POST还是其他的方法都要改为GET请求方式， * 即只有 PROPFIND 请求才能有请求体 */ //请求不是get与head if (HttpMethod.permitsRequestBody(method)) { final boolean maintainBody = HttpMethod.redirectsWithBody(method); // 除了 PROPFIND 请求之外都改成GET请求 if (HttpMethod.redirectsToGet(method)) { requestBuilder.method(&quot;GET&quot;, null); } else { RequestBody requestBody = maintainBody ? userResponse.request().body() : null; requestBuilder.method(method, requestBody); } // 不是 PROPFIND 的请求，把请求头中关于请求体的数据删掉 if (!maintainBody) { requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); requestBuilder.removeHeader(&quot;Content-Type&quot;); } } // 在跨主机重定向时，删除身份验证请求头 if (!sameConnection(userResponse, url)) { requestBuilder.removeHeader(&quot;Authorization&quot;); } return requestBuilder.url(url).build(); 408请求超时： 123456789101112131415161718192021// 408 客户端请求超时 case HTTP_CLIENT_TIMEOUT: // 408 算是连接失败了，所以判断用户是不是允许重试 if (!client.retryOnConnectionFailure()) { return null; } // UnrepeatableRequestBody实际并没发现有其他地方用到 if (userResponse.request().body() instanceof UnrepeatableRequestBody) { return null; } // 如果是本身这次的响应就是重新请求的产物同时上一次之所以重请求还是因为408，那我们这次不再重请求了 if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) { return null; } // 如果服务器告诉我们了 Retry-After 多久后重试，那框架不管了。 if (retryAfter(userResponse, 0) &gt; 0) { return null; } return userResponse.request(); 503: // 503 服务不可用 和408差不多，但是只在服务器告诉你 Retry-After：0（意思就是立即重试） 才重请求 12345678910case HTTP_UNAVAILABLE: if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) { return null; }if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) { return userResponse.request();}return null; 重定向总结：服务器返回300 301 302 303需要重定向，会获取返回头的Location中的新地址。 如果此方法followUpRequest返回空，那就表示不需要再重定向了，直接返回响应；但是如果返回非空，那就要重新请求返回的Request，但是需要注意的是，我们的followup在拦截器中定义的最大次数为20次。 总结本拦截器是整个责任链中的第一个，这意味着它会是首次接触到Request与最后接收到Response的角色，在这个拦截器中主要功能就是判断是否需要重试与重定向。 重试的前提是出现了RouteException或者IOException。一但在后续的拦截器执行过程中出现这两个异常，就会通过recover方法进行判断是否进行连接重试。 重定向发生在重试的判定之后，如果不满足重试的条件，还需要进一步调用followUpRequest根据Response 的响应码(当然，如果直接请求失败，Response都不存在就会抛出异常)。followup最大发生20次。 二、桥接拦截器两大作用：补全请求头，处理响应（保存cookie，GzipSource） 补全请求与响应后处理 请求头 说明 Content-Type 请求体类型,如：application/x-www-form-urlencoded Content-Length/Transfer-Encoding 请求体解析方式 Host 请求的主机站点 Connection: Keep-Alive 保持长连接 Accept-Encoding: gzip 接受响应支持gzip压缩 Cookie cookie身份辨别 User-Agent 请求的用户信息，如:操作系统、浏览器等 得到响应： 1、读取Set-Cookie响应头并调用接口告知用户，在下次请求则会读取对应的数据设置进入请求头，默认CookieJar无实现； ​ 2、响应头Content-Encoding为gzip，使用GzipSource包装便于解析。 总结桥接拦截器的执行逻辑主要就是以下几点 对用户构建的Request进行添加或者删除相关头部信息，以转化成能够真正进行网络请求的Request将符合网络请求规范的Request交给下一个拦截器处理，并获取Response如果响应体经过了GZIP压缩，那就需要解压，再构建成用户可用的Response并返回 三、缓存拦截器CacheInterceptor，在发出请求前，判断是否命中缓存。如果命中则可以不请求，直接使用缓存的响应。 (只会存在Get请求的缓存) 步骤为: 1、从缓存中获得对应请求的响应缓存 2、创建CacheStrategy ,创建时会判断是否能够使用缓存，在CacheStrategy 中存在两个成员:networkRequest与cacheResponse。他们的组合如下: networkRequest cacheResponse 说明 Null Not Null 直接使用缓存 Not Null Null 向服务器发起请求 Null Null 直接gg，okhttp直接返回504 Not Null Not Null 发起请求，若得到响应为304(无修改)，则更新缓存响应并返回 即：networkRequest存在则优先发起网络请求，否则使用cacheResponse缓存，若都不存在则请求失败！ 3、交给下一个责任链继续处理 4、后续工作，返回304则用缓存的响应；否则使用网络响应并缓存本次响应（只缓存Get请求的响应） 缓存拦截器的工作说起来比较简单，但是具体的实现，需要处理的内容很多。在缓存拦截器中判断是否可以使用缓存，或是请求服务器都是通过CacheStrategy判断。 缓存策略123//todo 缓存策略:根据各种条件(请求头)组成 请求与缓存CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); 12345678910public CacheStrategy get() { CacheStrategy candidate = getCandidate(); //todo 如果可以使用缓存，那networkRequest必定为null；指定了只使用缓存但是networkRequest又不为null，冲突。那就gg(拦截器返回504) if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) { // We're forbidden from using the network and the cache is insufficient. return new CacheStrategy(null, null); } return candidate;} 流程： 没有缓存，就进行网络请求 如果是Https请求，缓存中没有保存握手信息，发起网络请求 通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求（isCacheable方法）：不允许用 如果请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性（用户配置不进行缓存）：不想用 如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存 响应的缓存有效期 这一步为进一步根据缓存响应中的一些信息判定缓存是否处于有效期内。如果满足： 缓存存活时间 &lt; 缓存新鲜度 - 缓存最小新鲜度 + 过期后继续使用时长 代表可以使用缓存。其中新鲜度可以理解为有效时间，而这里的 “缓存新鲜度-缓存最小新鲜度” 就代表了缓存真正有效的时间。 缓存过期处理 如果继续执行，表示缓存已经过期无法使用。此时我们判定缓存的响应中如果存在Etag，则使用If-None-Match交给服务器进行验证；如果存在Last-Modified或者Data，则使用If-Modified-Since交给服务器验证。服务器如果无修改则会返回304，这时候注意： 由于是缓存过期而发起的请求(与第4个判断用户的主动设置不同)，如果服务器返回304，那框架会自动更新缓存，所以此时CacheStrategy既包含networkRequest也包含cacheResponse 详细流程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109private CacheStrategy getCandidate() { // No cached response. //todo 1、没有缓存,进行网络请求 if (cacheResponse == null) { return new CacheStrategy(request, null); } //todo 2、https请求，但是没有握手信息,进行网络请求 // OkHttp会保存ssl握手信息 handshake,如果这次发起了https请求， // 但是缓存的响应信息中没有握手信息，发起网络请求 //Drop the cached response if it's missing a required handshake. if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) { return new CacheStrategy(request, null); } //todo 3、主要是通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求 //If this response shouldn't have been stored, it should never be used //as a response source. This check should be redundant as long as the //persistence store is well-behaved and the rules are constant. if (!isCacheable(cacheResponse, request)) { return new CacheStrategy(request, null); } CacheControl requestCaching = request.cacheControl(); //todo 4、如果 请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性 // 或者请求头包含 If-Modified-Since：时间 值为lastModified或者data 如果服务器没有在该头部指定的时间之后修改了请求的数据，服务器返回304(无修改) // 或者请求头包含 If-None-Match：值就是Etag（资源标记）服务器将其与存在服务端的Etag值进行比较；如果匹配，返回304 // 请求头中只要存在三者中任意一个，进行网络请求 if (requestCaching.noCache() || hasConditions(request)) { return new CacheStrategy(request, null); } //todo 5、如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存 CacheControl responseCaching = cacheResponse.cacheControl(); if (responseCaching.immutable()) { return new CacheStrategy(null, cacheResponse); } //todo 6、根据 缓存响应的 控制缓存的响应头 判断是否允许使用缓存 // 6.1、获得缓存的响应从创建到现在的时间 long ageMillis = cacheResponseAge(); //todo // 6.2、获取这个响应有效缓存的时长 long freshMillis = computeFreshnessLifetime(); if (requestCaching.maxAgeSeconds() != -1) { //todo 如果请求中指定了 max-age 表示指定了能拿的缓存有效时长，就需要综合响应有效缓存时长与请求能拿缓存的时长，获得最小的能够使用响应缓存的时长 freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds())); } //todo // 6.3 请求包含 Cache-Control:min-fresh=[秒] 能够使用还未过指定时间的缓存 （请求认为的缓存有效时间） long minFreshMillis = 0; if (requestCaching.minFreshSeconds() != -1) { minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds()); } //todo // 6.4 // 6.4.1、Cache-Control:must-revalidate 可缓存但必须再向源服务器进行确认 // 6.4.2、Cache-Control:max-stale=[秒] 缓存过期后还能使用指定的时长 如果未指定多少秒，则表示无论过期多长时间都可以；如果指定了，则只要是指定时间内就能使用缓存 // 前者会忽略后者，所以判断了不必须向服务器确认，再获得请求头中的max-stale long maxStaleMillis = 0; if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) { maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds()); } //todo // 6.5 不需要与服务器验证有效性 &amp;&amp; 响应存在的时间+请求认为的缓存有效时间 小于 缓存有效时长+过期后还可以使用的时间 // 允许使用缓存 if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) { Response.Builder builder = cacheResponse.newBuilder(); //todo 如果已过期，但未超过 过期后继续使用时长，那还可以继续使用，只用添加相应的头部字段 if (ageMillis + minFreshMillis &gt;= freshMillis) { builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \\&quot;Response is stale\\&quot;&quot;); } //todo 如果缓存已超过一天并且响应中没有设置过期时间也需要添加警告 long oneDayMillis = 24 * 60 * 60 * 1000L; if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) { builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \\&quot;Heuristic expiration\\&quot;&quot;); } return new CacheStrategy(null, builder.build()); } // Find a condition to add to the request. If the condition is satisfied, the // response body // will not be transmitted. //todo 7、缓存过期了 String conditionName; String conditionValue; if (etag != null) { conditionName = &quot;If-None-Match&quot;; conditionValue = etag; } else if (lastModified != null) { conditionName = &quot;If-Modified-Since&quot;; conditionValue = lastModifiedString; } else if (servedDate != null) { conditionName = &quot;If-Modified-Since&quot;; conditionValue = servedDateString; } else { return new CacheStrategy(request, null); // No condition! Make a regular request. } //todo 如果设置了 If-None-Match/If-Modified-Since 服务器是可能返回304(无修改)的,使用缓存的响应体 Headers.Builder conditionalRequestHeaders = request.headers().newBuilder(); Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue); Request conditionalRequest = request.newBuilder() .headers(conditionalRequestHeaders.build()) .build(); return new CacheStrategy(conditionalRequest, cacheResponse);} PS：请求头与响应头 响应头 说明 例子 Date 消息发送的时间 Date: Sat, 18 Nov 2028 06:17:41 GMT Expires 资源过期的时间 Expires: Sat, 18 Nov 2028 06:17:41 GMT Last-Modified 资源最后修改时间 Last-Modified: Fri, 22 Jul 2016 02:57:17 GMT ETag 资源在服务器的唯一标识 ETag: “16df0-5383097a03d40” Age 服务器用缓存响应请求，该缓存从产生到现在经过多长时间(秒) Age: 3825683 Cache-Control - - 请求头 说明 例子 If-Modified-Since 服务器没有在指定的时间后修改请求对应资源,返回304(无修改) If-Modified-Since: Fri, 22 Jul 2016 02:57:17 GMT If-None-Match 服务器将其与请求对应资源的Etag值进行比较，匹配返回304 If-None-Match: “16df0-5383097a03d40” Cache-Control - - 其中Cache-Control可以在请求头存在，也能在响应头存在，对应的value可以设置多种组合： max-age=[秒] ：资源最大有效时间; public ：表明该资源可以被任何用户缓存，比如客户端，代理服务器等都可以缓存资源; private：表明该资源只能被单个用户缓存，默认是private。 no-store：资源不允许被缓存 no-cache：(请求)不使用缓存 immutable：(响应)资源不会改变 min-fresh=[秒]：(请求)缓存最小新鲜度(用户认为这个缓存有效的时长) must-revalidate：(响应)不允许使用过期缓存 max-stale=[秒]：(请求)缓存过期后多久内仍然有效 假设存在max-age=100，min-fresh=20。这代表了用户认为这个缓存的响应，从服务器创建响应 到 能够缓存使用的时间为100-20=80s。但是如果max-stale=100。这代表了缓存有效时间80s过后，仍然允许使用100s，可以看成缓存有效时长为180s。 四、连接拦截器连接流程： ConnectInterceptor，打开与目标服务器的连接，并执行下一个拦截器。它简短的可以直接完整贴在这里： 1234567891011121314151617181920public final class ConnectInterceptor implements Interceptor { public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) { this.client = client; } @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); }} 首先我们看到的StreamAllocation这个对象是在第一个拦截器：重定向拦截器创建的，但是真正使用的地方却在这里。 *”当一个请求发出，需要建立连接，连接建立后需要使用流用来读写数据”*；而这个StreamAllocation就是协调请求、连接与数据流三者之间的关系，它负责为一次请求寻找连接，然后获得流来实现网络通信。 这里使用的newStream方法实际上就是去查找或者建立一个与请求主机有效的连接，返回的HttpCodec中包含了输入输出流，并且封装了对HTTP请求报文的编码与解码，直接使用它就能够与请求主机完成HTTP通信。 123456789101112131415161718192021222324public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) { int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try { //todo 找到一个健康的连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); //todo 利用连接实例化流HttpCodec对象，如果是HTTP/2返回Http2Codec，否则返回Http1Codec HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) { codec = resultCodec; return resultCodec; } } catch (IOException e) { throw new RouteException(e); }} StreamAllocation中简单来说就是维护连接：RealConnection——封装了Socket与一个Socket连接池。可复用的RealConnection findHealthyConnection方法中 12345678910111213141516171819202122232425262728293031private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException { while (true) { //todo 找到一个连接 RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); //todo 如果这个连接是新建立的，那肯定是健康的，直接返回 //If this is a brand new connection, we can skip the extensive health checks. synchronized (connectionPool) { if (candidate.successCount == 0) { return candidate; } } //todo 如果不是新创建的，需要检查是否健康 //Do a (potentially slow) check to confirm that the pooled connection is still good. // If it // isn't, take it out of the pool and start again. if (!candidate.isHealthy(doExtensiveHealthChecks)) { //todo 不健康 关闭连接，释放Socket,从连接池移除 // 继续下次寻找连接操作 noNewStreams(); continue; } return candidate; }} findConnection方法中的 尝试从连接池获取连接，如果有可复用的连接,会给第三个参数 this的connection赋值 1Internal.instance.get(connectionPool, address, this, null); 调到了（ConnectionPool）connectionPool.get方法 12345678910@Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) { assert (Thread.holdsLock(this)); for (RealConnection connection : connections) { if (connection.isEligible(address, route)) { streamAllocation.acquire(connection, true); return connection; } } return null;} isEligible判断是否能够复用 使用http1.1就不能用 如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口 都相同那就可以复用 123456789101112131415161718192021222324252627282930313233343536373839404142434445public boolean isEligible(Address address, @Nullable Route route) { // If this connection is not accepting new streams, we're done. // TODO: 实际上就是在使用http1.1就不能用 if (allocations.size() &gt;= allocationLimit || noNewStreams) return false; // If the non-host fields of the address don't overlap, we're done. // TODO: 如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口（域名没有判断，所以下面马上判断） if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false; // If the host exactly matches, we're done: this connection can carry the address. //todo: 都相同那就可以复用了 if (address.url().host().equals(this.route().address().url().host())) { return true; // This connection is a perfect match. } // At this point we don't have a hostname match. But we still be able to carry the // request if // our connection coalescing requirements are met. See also: // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/ // 1. This connection must be HTTP/2. if (http2Connection == null) return false; // 2. The routes must share an IP address. This requires us to have a DNS address for both // hosts, which only happens after route planning. We can't coalesce connections that use a // proxy, since proxies don't tell us the origin server's IP address. if (route == null) return false; if (route.proxy().type() != Proxy.Type.DIRECT) return false; if (this.route.proxy().type() != Proxy.Type.DIRECT) return false; if (!this.route.socketAddress().equals(route.socketAddress())) return false; // 3. This connection's server certificate's must cover the new host. if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false; if (!supportsUrl(address.url())) return false; // 4. Certificate pinning must match the host. try { address.certificatePinner().check(address.url().host(), handshake().peerCertificates()); } catch (SSLPeerUnverifiedException e) { return false; } return true; // The caller's address can be carried by this connection.} 没找到，必须新建一个连接了 1234567891011121314 if (!foundPooledConnection) { if (selectedRoute == null) { selectedRoute = routeSelection.next(); } // Create a connection and assign it to this allocation immediately. This makes // it possible // for an asynchronous cancel() to interrupt the handshake we're about to do. route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); acquire(result, false); }} 连接池清理： findConnection方法中： 12//todo 将新创建的连接放到连接池中Internal.instance.put(connectionPool, result); 调的是ConnectionPool.put方法 123456789void put(RealConnection connection) { assert (Thread.holdsLock(this)); if (!cleanupRunning) { cleanupRunning = true; //启动清理 executor.execute(cleanupRunnable); } connections.add(connection);} 123456789101112131415161718192021private final Runnable cleanupRunnable = new Runnable() { @Override public void run() { while (true) { //todo:最快多久后需要清理 long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) { //todo:因为等待是纳秒级，wait方法可以接收纳秒级控制，但是把毫秒与纳秒分开 long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) { try { //todo:参数多一个纳秒，控制更加精确 ConnectionPool.this.wait(waitMillis, (int) waitNanos); } catch (InterruptedException ignored) { } } } } }}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647long cleanup(long now) { int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; // Find either a connection to evict, or the time that the next eviction is due. synchronized (this) { for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) { RealConnection connection = i.next(); // If the connection is in use, keep searching. if (pruneAndGetAllocationCount(connection, now) &gt; 0) { inUseConnectionCount++; continue; } idleConnectionCount++; // TODO: 获得这个连接闲置多久 // If the connection is ready to be evicted, we're done. long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) { longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; } } //超过保活时间（5分钟）或者池内数量超过了5个，马上移除，然后返回0，表示不等待，马上再次检查 if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) { // We've found a connection to evict. Remove it from the list, then close it below (outside // of the synchronized block). connections.remove(longestIdleConnection); } else if (idleConnectionCount &gt; 0) { // A connection will be ready to evict soon. // TODO: 池内存在闲置连接，就等待，保活时间（5分钟）-最长闲置时间=还能闲置多久 再检查 return keepAliveDurationNs - longestIdleDurationNs; } else if (inUseConnectionCount &gt; 0) { // All connections are in use. It'll be at least the keep alive duration 'til we run again. // TODO: 有使用中的连接就等待5分钟，再检查 return keepAliveDurationNs; } else { // No connections, idle or in use. // TODO: 都不满足，可能池内没任何连接，直接停止清理（put后再次启用） cleanupRunning = false; return -1; } } 代理连接： findConnection中 123//todo 实际上就是创建socket连接，但是要注意的是如果存在http代理的情况result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); RealConnection.connect 123456789101112if (route.requiresTunnel()) { //todo http隧道代理 connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) { // We were unable to connect the tunnel but properly closed down our // resources. break; }} else { //todo 创建socket连接 connectSocket(connectTimeout, readTimeout, call, eventListener);} 有http代理先设置代理头，最终都用调用connectSocket方法 1234567891011121314151617181920private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call, EventListener eventListener) throws IOException { Request tunnelRequest = createTunnelRequest(); HttpUrl url = tunnelRequest.url(); for (int i = 0; i &lt; MAX_TUNNEL_ATTEMPTS; i++) { connectSocket(connectTimeout, readTimeout, call, eventListener); tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url); if (tunnelRequest == null) break; // Tunnel successfully created. // The proxy decided to close the connection after an auth challenge. We need to // create a new // connection, but this time with the auth credentials. closeQuietly(rawSocket); rawSocket = null; sink = null; source = null; eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null); }} 12345678private Request createTunnelRequest() { return new Request.Builder() .url(route.address().url()) .header(&quot;Host&quot;, Util.hostHeader(route.address().url(), true)) .header(&quot;Proxy-Connection&quot;, &quot;Keep-Alive&quot;) // For HTTP/1.0 proxies like Squid. .header(&quot;User-Agent&quot;, Version.userAgent()) .build();} 1234567891011121314151617181920212223242526272829303132333435363738/** * todo:创建socket连接 * Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */private void connectSocket(int connectTimeout, int readTimeout, Call call, EventListener eventListener) throws IOException { Proxy proxy = route.proxy(); Address address = route.address(); //todo:没有代理直接new一个Socket（），有代理就创建一个带代理参数的socket rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy); eventListener.connectStart(call, route.socketAddress(), proxy); rawSocket.setSoTimeout(readTimeout); try { // TODO: socket.connect Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); } catch (ConnectException e) { ConnectException ce = new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress()); ce.initCause(e); throw ce; } // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0 // More details: // https://github.com/square/okhttp/issues/3245 // https://android-review.googlesource.com/#/c/271775/ try { source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); } catch (NullPointerException npe) { if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) { throw new IOException(npe); } }} 五、请求服务器拦截器Expect: 100-continue一般出现于上传大容量请求体或者需要验证。代表了先询问服务器是否原因接收发送请求体数据。（先只发送请求头） OkHttp的做法：如果服务器允许则返回100，客户端继续发送请求体；如果服务器不允许则直接返回给用户。 同时服务器也可能会忽略此请求头，一直无法读取应答，此时抛出超时异常。 CallServerInterceptor，利用HttpCodec发出请求到服务器并且解析生成Response。 首先调用httpCodec.writeRequestHeaders(request); 将请求头写入到缓存中(直到调用flushRequest()才真正发送给服务器)。然后马上进行第一个逻辑判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public final class CallServerInterceptor implements Interceptor { private final boolean forWebSocket; public CallServerInterceptor(boolean forWebSocket) { this.forWebSocket = forWebSocket; } @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); //todo:拼接请求的数据 httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; //todo:如果没有请求体或者不是post跳过 if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) { // If there's a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100 // Continue&quot; response before transmitting the request body. If we don't get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. // todo: 如果是post请求，并包含了100-continue,不发请求体，读服务器的响应 if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) { // todo: 发送请求头 httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); } //服务返回100，responseBuilder会置为null if (responseBuilder == null) { // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); //todo：写入请求体 request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); } else if (!connection.isMultiplexed()) { // If the &quot;Expect: 100-continue&quot; expectation wasn't met, prevent the HTTP/1 // connection // from being reused. Otherwise we're still obligated to transmit the request // body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); } } httpCodec.finishRequest(); // TODO: 读取服务器响应 if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false); } Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); // todo: 服务器允许继续发送响应体 if (code == 100) { // server sent a 100-continue even though we did not request one. // try again to read the actual response responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); } realChain.eventListener() .responseHeadersEnd(realChain.call(), response); if (forWebSocket &amp;&amp; code == 101) { // Connection is upgrading, but we need to ensure interceptors see a non-null // response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); } else { response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); } if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) { streamAllocation.noNewStreams(); } if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) { throw new ProtocolException( &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength()); } return response; } static final class CountingSink extends ForwardingSink { long successfulCount; CountingSink(Sink delegate) { super(delegate); } @Override public void write(Buffer source, long byteCount) throws IOException { super.write(source, byteCount); successfulCount += byteCount; } }} 整个if都和一个请求头有关： Expect: 100-continue。这个请求头代表了在发送请求体之前需要和服务器确定是否愿意接受客户端发送的请求体。所以permitsRequestBody判断为是否会携带请求体的方式(POST)，如果命中if，则会先给服务器发起一次查询是否愿意接收请求体，这时候如果服务器愿意会响应100(没有响应体，responseBuilder 即为nul)。这时候才能够继续发送剩余请求数据。 但是如果服务器不同意接受请求体，那么我们就需要标记该连接不能再被复用，调用noNewStreams()关闭相关的Socket。 123456789101112// TODO: 读取服务器响应if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false);}Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); 这时responseBuilder的情况即为： 1、POST方式请求，请求头中包含Expect，服务器允许接受请求体，并且已经发出了请求体，responseBuilder为null; 2、POST方式请求，请求头中包含Expect，服务器不允许接受请求体，responseBuilder不为null 3、POST方式请求，未包含Expect，直接发出请求体，responseBuilder为null; 4、POST方式请求，没有请求体，responseBuilder为null; 5、GET方式请求，responseBuilder为null; 对应上面的5种情况，读取响应头并且组成响应Response，注意：此Response没有响应体。同时需要注意的是，如果服务器接受 Expect: 100-continue这是不是意味着我们发起了两次Request？那此时的响应头是第一次查询服务器是否支持接受请求体的，而不是真正的请求对应的结果响应。 所以 如果响应是100，这代表了是请求Expect: 100-continue成功的响应，需要马上再次读取一份响应头，这才是真正的请求对应结果响应头。 最后： forWebSocket代表websocket的请求，我们直接进入else，这里就是读取响应体数据。然后判断请求和服务器是不是都希望长连接，一旦有一方指明close，那么就需要关闭socket。而如果服务器返回204/205，一般情况而言不会存在这些返回码，但是一旦出现这意味着没有响应体，但是解析到的响应头中包含Content-Lenght且不为0，这表响应体的数据字节长度。此时出现了冲突，直接抛出协议异常！ 总结在这个拦截器中就是完成HTTP协议报文的封装与解析。 自定义拦截器123456789new OkHttpClient().newBuilder().addInterceptor(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { // todo: ....... final Response response = chain.proceed(chain.request()); // todo: ....... return response; }}); 一定要调用chain.proceed,并将response返回。 不调用的话，会使责任链中断，后面其他就没法执行了。 OkHttp总结整个OkHttp功能的实现就在这五个默认的拦截器中，所以先理解拦截器模式的工作机制是先决条件。这五个拦截器分别为: 重试拦截器、桥接拦截器、缓存拦截器、连接拦截器、请求服务拦截器。每一个拦截器负责的工作不一样，就好像工厂流水线，最终经过这五道工序，就完成了最终的产品。 但是与流水线不同的是，OkHttp中的拦截器每次发起请求都会在交给下一个拦截器之前干一些事情，在获得了结果之后又干一些事情。整个过程在请求向是顺序的，而响应向则是逆序。 当用户发起一个请求后，会由任务分发起Dispatcher将请求包装并交给重试拦截器处理。 1、重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。 2、桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。 3、缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。 4、连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。 5、请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。 在经过了这一系列的流程后，就完成了一次HTTP请求！ 补充: 代理在使用OkHttp时，如果用户在创建OkHttpClient时，配置了proxy或者proxySelector，则会使用配置的代理，并且proxy优先级高于proxySelector。而如果未配置，则会获取机器配置的代理并使用。 123456789//JDK : ProxySelectortry { URI uri = new URI(&quot;http://restapi.amap.com&quot;); List&lt;Proxy&gt; proxyList = ProxySelector.getDefault().select(uri); System.out.println(proxyList.get(0).address()); System.out.println(proxyList.get(0).type());} catch (URISyntaxException e) { e.printStackTrace();} 因此，如果我们不需要自己的App中的请求走代理，则可以配置一个proxy(Proxy.NO_PROXY)，这样也可以避免被抓包。NO_PROXY的定义如下： 12345public static final Proxy NO_PROXY = new Proxy();private Proxy() { this.type = Proxy.Type.DIRECT; this.sa = null;} 代理在Java中对应的抽象类有三种类型: 1234567public static enum Type { DIRECT, HTTP, SOCKS; private Type() { }} DIRECT：无代理，HTTP：http代理，SOCKS：socks代理。第一种自然不用多说，而Http代理与Socks代理有什么区别？ 对于Socks代理，在HTTP的场景下，代理服务器完成TCP数据包的转发工作;而Http代理服务器，在转发数据之外，还会解析HTTP的请求及响应，并根据请求及响应的内容做一些处理。 RealConnection的connectSocket方法: 123456//如果是Socks代理则 new Socket(proxy); 否则相当于直接:new Socket()rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);//connect方法socket.connect(address); 设置了SOCKS代理的情况下，创建Socket时，为其传入proxy，连接时还是以HTTP服务器为目标地址；但是如果设置的是Http代理，创建Socket是与Http代理服务器建立连接。 在connect方法时传递的address来自于下面的集合inetSocketAddressesRouteSelector的resetNextInetSocketAddress方法： 123456789101112131415161718192021222324252627282930313233private void resetNextInetSocketAddress(Proxy proxy) throws IOException { // ...... if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) { //无代理和socks代理，使用http服务器域名与端口 socketHost = address.url().host(); socketPort = address.url().port(); } else { SocketAddress proxyAddress = proxy.address(); if (!(proxyAddress instanceof InetSocketAddress)) { throw new IllegalArgumentException( &quot;Proxy.address() is not an &quot; + &quot;InetSocketAddress: &quot; + proxyAddress.getClass()); } InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress; socketHost = getHostString(proxySocketAddress); socketPort = proxySocketAddress.getPort(); } // ...... if (proxy.type() == Proxy.Type.SOCKS) { //socks代理 connect http服务器 （DNS没用，由代理服务器解析域名） inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort)); } else { //无代理，dns解析http服务器 //http代理,dns解析http代理服务器 List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost); //...... for (int i = 0, size = addresses.size(); i &lt; size; i++) { InetAddress inetAddress = addresses.get(i); inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort)); } }} 设置代理时，Http服务器的域名解析会被交给代理服务器执行。但是如果是设置了Http代理，会对Http代理服务器的域名使用OkhttpClient配置的dns解析代理服务器，Http服务器的域名解析被交给代理服务器解析。 上述代码就是代理与DNS在OkHttp中的使用，但是还有一点需要注意，Http代理也分成两种类型：普通代理与隧道代理。 其中普通代理不需要额外的操作，扮演「中间人」的角色，在两端之间来回传递报文。这个“中间人”在收到客户端发送的请求报文时，需要正确的处理请求和连接状态，同时向服务器发送新的请求，在收到响应后，将响应结果包装成一个响应体返回给客户端。在普通代理的流程中，代理两端都是有可能察觉不到”中间人“的存在。 但是隧道代理不再作为中间人，无法改写客户端的请求，而仅仅是在建立连接后，将客户端的请求，通过建立好的隧道，无脑的转发给终端服务器。隧道代理需要发起Http CONNECT请求，这种请求方式没有请求体，仅供代理服务器使用，并不会传递给终端服务器。请求头 部分一旦结束，后面的所有数据，都被视为应该转发给终端服务器的数据，代理需要把他们无脑的直接转发，直到从客户端的 TCP 读通道关闭。CONNECT 的响应报文，在代理服务器和终端服务器建立连接后，可以向客户端返回一个 200 Connect established 的状态码，以此表示和终端服务器的连接，建立成功。 RealConnection的connect方法 1234567891011if (route.requiresTunnel()) { connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) { // We were unable to connect the tunnel but properly closed down our // resources. break; }} else { connectSocket(connectTimeout, readTimeout, call, eventListener);} requiresTunnel方法的判定为：当前请求为https并且存在http代理，这时候connectTunnel中会发起: 1234CONNECT xxxx HTTP/1.1Host: xxxxProxy-Connection: Keep-AliveUser-Agent: okhttp/${version} 的请求，连接成功代理服务器会返回200；如果返回407表示代理服务器需要鉴权(如：付费代理)，这时需要在请求头中加入Proxy-Authorization： 123456789101112131415 Authenticator authenticator = new Authenticator() { @Nullable @Override public Request authenticate(Route route, Response response) throws IOException { if(response.code == 407){ //代理鉴权 String credential = Credentials.basic(&quot;代理服务用户名&quot;, &quot;代理服务密码&quot;); return response.request().newBuilder() .header(&quot;Proxy-Authorization&quot;, credential) .build(); } return null; } };new OkHttpClient.Builder().proxyAuthenticator(authenticator);","link":"/2020/12/10/okhttp/"}],"tags":[{"name":"activity","slug":"activity","link":"/tags/activity/"},{"name":"dispatch","slug":"dispatch","link":"/tags/dispatch/"},{"name":"OkHttp","slug":"OkHttp","link":"/tags/OkHttp/"}],"categories":[]}