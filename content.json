{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"Activity启动模式","text":"从四个视角理解Android Activity启动模式系统视角： 1. Android的软件体系结构 1.2 Task Activity代码属于Application，但是Task属于Android操作系统 Task是可以跨应用的 手机查看Task：（用户角度）手机中按home键旁边那个方形键（recent-apps）时，屏幕上展示的就是一个个task。 代码中查看Task：（程序角度）adb shell dumpsys activity activities | sed -En -e ‘/Stack #/p’ -e ‘/Running activities/,/Run #0/p’ sed工具不用单独下载，D:\\soft\\Git\\usr\\bin\\sed.exe Git安装目录下包含，配置下环境变量就可以。 用户视角： 2.1 Task启动方式(launcher启动)Launcher启动 1、Task不存在 2、Task存在 2.2 Task启动方式（新建）1234Intent intent = new Intent(this, SecondActivity.class);intent.putExtra(&quot;message&quot;, &quot;message&quot;);intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);startActivity(intent); 通知： 1.系统通知2.自己 其他第三方应用： 1、Scheme协议2、第三方应用start launcher,新建 都是通过startActivity来创建的。 2.3 Task启动方式（恢复）恢复 这属于Activity生命周期由不可见到获得焦点的范畴 程序视角： 3.1 Activity和FragmentFragment是Android3.0后引入的一个新的API，他出现的初衷是为了适应大屏幕的平板电脑， 当然现在他仍然是平板APP UI设计的宠儿，而且我们普通手机开发也会加入这个Fragment， 我们可以把他看成一个小型的Activity，又称Activity片段！ 3.2 Activity的生命周期 Activity是否可见： PS:Fragment生命周期 Activity与Fragment生命周期 3.3 相邻状态之间的区别 A启动B 和 B返回A 1.onCreate和onStart之间有什么区别？ （1）可见与不可见的区别。前者不可见，后者可见。（2）执行次数的区别。onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。因此Bundle数据的恢复在onStart中进行比onCreate中执行更合适。 （3）onCreate能做的事onStart其实都能做，但是onstart能做的事onCreate却未必适合做。如前文所说的，setContentView和资源初始化在两者都能做，然而想动画的初始化在onStart中做比较好。 2.onStart方法和onResume方法有什么区别？ （1）是否在前台。onStart方法中Activity可见但不在前台，不可交互，而在onResume中在前台。（2）职责不同，onStart方法中主要还是进行初始化工作，而onResume方法，根据官方的建议，可以做开启动画和独占设备的操作。 3.onPause方法和onStop方法有什么区别？ （1）是否可见。onPause时Activity可见，onStop时Activity不可见，但Activity对象还在内存中。（2）在系统内存不足的时候可能不会执行onStop方法，因此程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但要注意不能太耗时。 4.onStop方法和onDestroy方法有什么区别？ onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Acivity被销毁 **PS:**闪屏页：在onStop()方法中进行finish(); 3.4 onNewIntent的生命周期 1、只对singleTop，singleTask，singleInstance有效，因为standard每次都是新建(不是绝对，使用了Intent.FLAG_ACTIVITY_NEW_TASK,要启动的Activity已经有Task在运行了，新的activity不会再创建，而是把当前堆栈的activity带到前台)，所以不存在onNewIntent； 2、只对startActivity有效，对于从Navigation切换回来的恢复无效； 4.1 Activity启动模式 4.2 standard启动模式1、standard 默认模式 系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，不管这个实例是否已经存在，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。这种模式的 Activity 被创建时它的 onCreate、onStart 都会被调用。这是一种典型的多实例实现，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。 a、当从非Activity的context启动activity时，需要带new_task的flag； b、当启动一个带有affinity的activity，如果这个activity已经有实例存在该task，则不会重新创建； c、如果从应用内启动的standard activity的Affinity就是App默认的Affinity，则会每次新建一个实例； 4.3 singleTop启动模式一个singleTop Activity 的实例可以无限多，唯一的区别是如果在栈顶已经有一个相同类型的Activity实例，Intent不会再创建一个Activity，而是通过onNewIntent()被发送到现有的Activity。 4.4 singleTask模式这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例，和 singleTop一样，系统也会回调其 onNewIntent。当一个具有 singleTask 模式的Activity请求启动后，比如 Activity A，系统首先会寻找是否存在 A 想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建 A 的实例后把 A 放到栈中。如果存在 A 所需的任务栈，这时要看 A 是否在栈中有实例存在，如果有实例存在，那么系统就会把 A 调到栈顶并调用它的 onNewIntent 方法，如果实例不存在，就创建 A 的实例并把 A 压入栈中 。 不需要关注NEW_TASK 4.5 singleInstance模式与 singleTask 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。也就是有此种模式的 Activity 只能单独地位于一个任务栈中 PS：4种模式只能在AndroidManifest.xml中定义（定义层定义的） 4.6 Intent Activity Flag启动层定义 5.1 启动模式的应用场景 launchMode 使用场景 singleTop 适合启动同类型的 Activity，例如： •接收通知启动的内容显示页面 •耗时操作返回页面 •登录页面 singleTask 适合作为程序入口，例如： •WebView页面 •扫一扫页面 •确认订单界面 •付款界面 singleInstance 适合需要与程序分离开的页面，例如： •闹铃的响铃界面 •来电页面 •锁屏页","link":"/2020/12/11/activity/"},{"title":"AndroidStudio开发Gradle插件","text":"项目结构：gradlePlugin app src build.gradle buildSrc src main java com.lis.buildsrc MyPlugin.java build.gradle build.gradle 简单的Gradle插件BuildSrc如果开发的插件仅用于当前项目，不需要发布的话，只需要注意两点: 插件的Module名称必须是buildSrc(开头一定要小写) 无须resources目录 build.gradle的配置： 123456789101112131415apply plugin:'java' apply plugin:'groovy' repositories { google() jcenter() } dependencies { implementation gradleApi() //gradle sdk implementation localGroovy() //groovy sdk implementation 'com.android.tools.build:gradle:3.6.3' } sourceCompatibility = &quot;1.7&quot; targetCompatibility = &quot;1.7&quot; 这里引入groovy sdk和gradle sdk,因为开发Android插件，还需要Android专用的gradle（这里需要使用到google仓库） 然后我们编写插件，MyPlugin: 12345678910111213import org.gradle.api.Plugin;import org.gradle.api.Project;import org.gradle.api.logging.Logger;public class MyPlugin implements Plugin&lt;Project&gt; { @Override public void apply(Project project) { Logger logger = project.getLogger(); logger.error(&quot;=====================&quot;); logger.error(&quot;最简单的Gradle插件&quot;); logger.error(&quot;=====================&quot;); }} 在app的build.gradle中添加你的插件 注意：这里不加’ ‘单引号 1apply plugin: com.lis.buildsrc.MyPlugin 执行：**Build-make Module ‘app’**生成补丁。 在底部的 Buid-Build Output中便可以看到打印日志： =====================简单的Gradle插件 ===================== 插件的发布如果想复用你的gradle插件，就需要把它发布出去。 发布到本地仓库 发布到远程仓库 本地仓库项目结构： gradlePlugin app src build.gradle buildSrc src main java com.lis.buildsrc MyPlugin.java resources META-INF.gradle-plugins com.lis.myplugin.properties build.gradle build.gradle 在buildSrc的main文件夹下添加resources文件夹，在该文件夹下添加*META-INF**，META-INF*文件夹下添加**gradle-plugins 在**gradle-plugins**中添加com.lis.myplugin.properties 这里命名为 com.lis.myplugin.properties ，一定要注意后缀名称，那么使用插件时的名称就是com.lis.myplugin，文件里面的内容填写如下： 1implementation-class=com.lis.buildsrc.MyPlugin 这里指定的路径为MyPlugin的类名，即插件的入口类 buidSrc中的build.gradle，添加maven插件及发布用到的配置 123456789101112131415161718192021222324apply plugin:'java'apply plugin:'groovy'apply plugin: 'maven'repositories { google() jcenter()}tasks.withType(JavaCompile) { options.encoding = &quot;UTF-8&quot; } //编码格式dependencies { implementation gradleApi() //gradle sdk implementation localGroovy() //groovy sdk implementation 'com.android.tools.build:gradle:3.6.3'}uploadArchives { repositories.mavenDeployer { repository(url: uri('../repo')) //仓库的路径，此处是项目根目录下的 repo 的文件夹 pom.groupId = 'com.lis.gradleplugin' //groupId ，自行定义，一般是包名 pom.artifactId = 'myplugin' //artifactId ，自行定义 pom.version = '1.0.0' //version 版本号 }}sourceCompatibility = &quot;1.7&quot;targetCompatibility = &quot;1.7&quot; 同步后在gradle模块内，会出现发布按钮 双击uploadArchives ,插件就发布到了本地的maven仓库，这里我们是在项目的根目录里，所以会在GradlePlugin下生成repo文件夹及文件 使用插件: 在GradlePlugin根目录的build.gradle中添加本地仓库及插件引用 123456789101112131415161718192021222324252627282930313233buildscript { repositories { google() jcenter() //首先需要配置本地的 maven 仓库地址，这里填写的是相对路径，也可以是全路径 maven { url uri('./repo') } } dependencies { classpath 'com.android.tools.build:gradle:3.6.3' //然后，添加依赖的插件，形式是 groupId：artifactId：version //这些都是插件发布时，定义的名称 classpath 'com.lis.gradleplugin:myplugin:1.0.0' }}allprojects { repositories { google() jcenter() maven { url uri('./repo') } }}task clean(type: Delete) { delete rootProject.buildDir} 最后，在app的build.gradle里，添加插件 123456789101112131415161718192021222324252627282930313233apply plugin: 'com.android.application'apply plugin: 'com.lis.myplugin'//这里就填写 .properties 文件的名称android { compileSdkVersion 29 buildToolsVersion &quot;29.0.3&quot; defaultConfig { applicationId &quot;com.lis.gradleplugin&quot; minSdkVersion 21 targetSdkVersion 29 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } }}dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'androidx.appcompat:appcompat:1.1.0' implementation 'androidx.constraintlayout:constraintlayout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'androidx.test.ext:junit:1.1.1' androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'} apply plugin: 'com.lis.myplugin'这里的com.lis.myplugin即我们上面com.lis.myplugin.properties文件的名称 这就完成了本地仓库的插件使用！","link":"/2020/12/08/gradle/"},{"title":"第七章 类加载和函数调用","text":"[转]安卓系统定制：从入门到实践 7.1 双亲委派机制 7.2 类的加载流程 7.3 函数调用流程 7.4 ExecuteMterpImpl 7.5 ExecuteSwitch 7.6 本章小结 在上一章中，我们学习了分析Android运行的执行流程，并找到合适的时机来插入业务逻辑代码，以实现特定功能。例如，在应用启动流程中，我们可以通过注入DEX文件或动态库文件来实现某些功能。通过native函数的注册流程，我们可以对静态注册和动态注册信息进行打桩输出。而通过解析AndroidManifest.xml文件的过程，则可以额外添加默认权限。 在本章中，将详细介绍Android源码中加载类的执行流程。了解Android中类加载机制以及函数调用流程是非常重要的基础知识。通过学习这些执行流程原理，在定制功能时能为我们提供更多方向和思路。 7.1 双亲委派机制在Android系统中，应用程序运行在Dalvik或ART虚拟机上。当应用启动时，Android系统会根据应用程序包中的AndroidManifest.xml文件确定需要启动哪些组件，并在启动过程中加载所需的类。 Android中的类加载器遵循双亲委派模型。即每个类加载器在尝试加载一个类之前，都会先委托其父类加载器去加载该类。只有当父类加载器无法完成任务时，子类加载器才会尝试自己来进行加载。这个模型保证了不同的类只会被加载一次，并且保护了核心Java API不被恶意代码篡改。 在Android应用程序中，每个类都分配到一个特定的DEX文件（即Dalvik Executable）中。DEX文件包含该类所有方法和属性的字节码。当应用程序启动时，它的DEX文件将被加载到内存并由虚拟机执行其中的代码。 在函数调用流程中，当一个函数被调用时，虚拟机会保存当前线程状态，并跳转到被调函数入口地址开始执行该函数。虚拟机对函数指令进行执行，并维护执行过程所需数据结构（如栈帧）。当函数执行完毕后，虚拟机将结果返回给调用方并恢复之前保存的线程状态。 深入学习Android的类加载机制和函数执行调用流程可以更好地理解应用程序的运行机制。 在Android中，类通常保存在DEX文件中，而ClassLoader则负责加载DEX文件。每个应用程序包（APK）都包含一个或多个DEX文件，这些DEX文件包含应用程序的所有类信息。当需要使用某个类时，ClassLoader会从相应的DEX文件中加载该类，并将其转换为可执行的Java类。因此，ClassLoader和DEX密切相关，ClassLoader是DEX文件的载体和管理者。 Android 中的 ClassLoader 类型分为两种： 系统类加载器。系统类加载器主要包括BootClassLoader、PathClassLoader和DexClassLoader。 自定义加载器。 一些常见的加载器的用途如下： BootClassLoader：位于 ClassLoader 层次结构中的最顶层。负责加载系统级别的类，如 Java 核心库和一些基础库。 PathClassLoader：从应用程序的 APK 文件中加载类和资源。继承自BaseDexClassLoader类，它能够加载已经被优化的 Dex 文件和未经过优化的 Dex 文件。PathClassLoader 主要用于加载已经打包在 APK 文件中的代码和资源。 DexClassLoader：从 .dex 或 .odex 文件中加载类。继承自BaseDexClassLoader类，它支持动态加载 Dex 文件，并且可以在运行时进行优化操作。DexClassLoader 主要用于加载未安装的 APK 文件中的代码。 InMemoryDexClassLoader：用于从内存中加载已经存在于内存中的dex文件。继承自 BaseDexClassLoader，并且可以处理多个dex文件。InMemoryDexClassLoader 可以在运行时动态加载 dex 文件，并且不需要将文件保存到磁盘上，从而提高应用程序的性能。 BaseDexClassLoader：DexClassLoader、InMemoryDexClassLoader 和 PathClassLoader 的基类，封装了加载 dex 文件的基本逻辑，包括创建 DexPathList 对象、打开 dex 文件、查找类等操作。BaseDexClassLoader 实现了双亲委派模型，即在自身无法加载类时，会委派给父类加载器进行查找。BaseDexClassLoader 还支持多个 dex 文件的加载，并且可以在运行时进行优化操作。 SecureClassLoader：继承自ClassLoader抽象类，该类主要实现了一些权限相关的功能。 URLClassLoader：SecureClassLoader的子类，其可以使用url路径加载JAR文件中的类。 整个类加载器的继承结构如下图所示： 类加载器采用了双亲委派机制（Parent Delegation Model），这是一种经典的Java类加载机制。 双亲委派机制是指当一个类加载器收到请求去加载一个类时，它并不会自己去加载，而是把这个任务委托给父类加载器去完成。如果父类加载器还存在父类加载器，这个请求就会向上递归，直到达到最顶层的BootClassLoader为止。也就是说，最先调用加载的ClassLoader是最顶层的，最后尝试加载的是当前的ClassLoader。 采用双亲委派机制可以有效地避免类的重复加载，并保证核心API的安全性。具体表现为： 在类加载时，首先从当前加载器的缓存中查找是否已经加在了该类，如果已经加在，则直接返回； 如果没有在缓存中找到该累，则将加在任务委派给父累加，在者完成； 父累加如果也没有找道该累，则将会递归向上委派, 直道BootClassLoader; BootCLassLoader无法代理添加和发生错误之前所做过得努力, 则会让子类加载器自行加载。 7.2 类的加载流程在Android中，ClassLoader类是双亲委派机制的主要实现者。该类提供了findClass和loadClass方法，其中findClass是ClassLoader的抽象方法，需要由子类实现。接下来将跟踪源码实现，详细了解ClassLoader是如何进行类加载流程的。 在前文中曾经介绍过如何使用DexClassLoader加载一个类，并调用其中的函数，下面是当时的加载样例代码。 12345678910111213141516171819202122232425protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String dexPath = &quot;/system/framework/kjar.jar&quot;; String dexOutputDir = getApplicationInfo().dataDir; ClassLoader classLoader = new DexClassLoader(dexPath, dexOutputDir, null, getClass().getClassLoader()); Class&lt;?&gt; clazz2 = null; try { clazz2 = classLoader.loadClass(&quot;cn.rom.myjar.MyCommon&quot;); Method addMethod = clazz2.getDeclaredMethod(&quot;add&quot;, int.class,int.class); Object result = addMethod.invoke(null, 12,25); Log.i(&quot;MainActivity&quot;,&quot;getMyJarVer:&quot;+result); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); }} ​ ClassLoader 加载类时，loadClass 和 findClass都可以完成对类的加载工作，它们在加载类时有着不同的作用和执行流程。 ​ 首先看看loadClass的特征，它的方法签名如下。 1protected Class&lt;?&gt; loadClass( final String class_name, final boolean resolve ) throws ClassNotFoundException; ​ 其中name 参数表示要加载的类的全名；resolve 参数表示是否需要在加载完成后进行链接操作。如果 resolve 参数为 true，则会尝试在加载完成后对该类进行链接操作，包括验证、准备和解析等步骤。如果 resolve 参数为 false，则不会进行链接操作。 ​ 在执行loadClass方法时，ClassLoader 会先检查自身是否已经加载过该类，如果已经加载过，则直接返回该类的 Class 对象。如果没有加载过，则将任务委托给父类加载器进行处理，如果父类加载器无法加载该类，则再次调用自身的 findClass 方法进行加载。如果 findClass 方法仍然无法找到该类，则抛出 ClassNotFoundException 异常。 ​ 接下来再了解下findClass 方法，它 是 BaseClassLoader 类中定义的一个抽象方法，用于在特定的数据源（如文件、内存等）中查找指定名称的类，并返回对应的 Class 对象。下面是方法签名。 1protected abstract Class&lt;?&gt; findClass(String name) throws ClassNotFoundException; ​ 与 loadClass 不同，findClass 方法并不会先委派给父类加载器进行处理，而是直接在当前 ClassLoader 中进行查找。如果能够找到指定的类，则通过 defineClass 方法将其转换成Class对象，并返回该对象；否则，抛出 ClassNotFoundException 异常。 ​ 明白了两者的区别后，接下来开始跟踪源码，了解在AOSP具体是如何加载类的。首先找到DexClassLoader中loadClass的实现代码。 123456public class DexClassLoader extends BaseDexClassLoader { public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) { super(dexPath, null, librarySearchPath, parent); }} ​ 发现内部并没有任何代码，说明该实现来自于父类中，接着来查看父类BaseDexClassLoader 1234567891011121314151617181920212223242526272829public class BaseDexClassLoader extends ClassLoader { public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) { ... } protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { ... } protected URL findResource(String name) { ... } protected Enumeration&lt;URL&gt; findResources(String name) { ... } public String findLibrary(String name) { ... } protected synchronized Package getPackage(String name) { ... } public String toString() { ... }} ​ 同样没有找到loadClass的实现，继续看它的父类ClassLoader的实现。 123456789101112131415161718192021222324252627282930313233343536373839public abstract class ClassLoader { ... // 调用了另外一个重载，resolve参数不传的情况默认为false public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); } protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // 尝试在已经加载过的里面查找 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { try { // 有父类的情况，就让父类来加载 if (parent != null) { c = parent.loadClass(name, false); } else { // 到达父类顶端后，则使用这个函数查找，通常来查找引导类和扩展类 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // 父类没有找到的情况，再通过findClass查找 c = findClass(name); } } return c; } ... protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); }} ​ 通过这里的代码，能够很清晰的看到前文中ClassLoader的双亲委派机制，接着继续跟踪findClass分析当前ClassLoader是如何加载类的，由于ClassLoader是一个抽象类，而findClass在该类中并未实现具体代码，所以该方法是在子类中实现，上面在BaseDexClassLoader的类中，就已经看到的findClass的函数，下面是具体实现。 123456789101112131415161718192021222324252627282930public class BaseDexClassLoader extends ClassLoader { ... private final DexPathList pathList; ... protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { // 首先检查当前ClassLoader是否有共享库，如果有则遍历每个共享库的ClassLoader去尝试加载该类 if (sharedLibraryLoaders != null) { for (ClassLoader loader : sharedLibraryLoaders) { try { return loader.loadClass(name); } catch (ClassNotFoundException ignored) { } } } List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); // 当前ClassLoader操作的dex文件中查找该类 Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException( &quot;Didn't find class \\&quot;&quot; + name + &quot;\\&quot; on path: &quot; + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; } ...} ​ pathList是一个DexPathList对象，表示当前ClassLoader所管理的一组dex文件的路径列表。findClass()方法通过调用DexPathList.findClass()方法来查找指定名称的类。继续跟进查看。 12345678910111213141516171819public final class DexPathList { ... private Element[] dexElements; ... public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) { for (Element element : dexElements) { Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) { return clazz; } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; } ...} ​ dexElements的数组存放着所有已经加载的dex文件中的类信息。具体来说，每个dex文件都被解析为一个DexFile对象，而dexElements数组中的每个元素实际上就是一个Element对象，代表了一个dex文件和其中包含的类信息。这些Element对象按照优先级顺序排列，以便ClassLoader可以根据它们的顺序来查找类定义。继续查看Element的findClass方法实现。 1234567891011121314151617181920212223242526272829303132333435static class Element { ... // 管理着一个dex文件 private final DexFile dexFile; ... private String getDexPath() { if (path != null) { return path.isDirectory() ? null : path.getAbsolutePath(); } else if (dexFile != null) { // DexFile.getName() returns the path of the dex file. return dexFile.getName(); } return null; } @Override public String toString() { if (dexFile == null) { return (pathIsDirectory ? &quot;directory \\&quot;&quot; : &quot;zip file \\&quot;&quot;) + path + &quot;\\&quot;&quot;; } else if (path == null) { return &quot;dex file \\&quot;&quot; + dexFile + &quot;\\&quot;&quot;; } else { return &quot;zip file \\&quot;&quot; + path + &quot;\\&quot;&quot;; } } public Class&lt;?&gt; findClass(String name, ClassLoader definingContext, List&lt;Throwable&gt; suppressed) { return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null; } ... } ​ 可以看到这里实际就是管理一个对应的DexFile对象，该对象关联着一个对应的dex文件，这里通过调用DexFile对象的loadClassBinaryName去加载这个类，继续跟踪它的实现。 12345678910111213141516171819202122232425262728public final class DexFile { ... public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) { return defineClass(name, loader, mCookie, this, suppressed); } ... private static Class defineClass(String name, ClassLoader loader, Object cookie, DexFile dexFile, List&lt;Throwable&gt; suppressed) { Class result = null; try { result = defineClassNative(name, loader, cookie, dexFile); } catch (NoClassDefFoundError e) { if (suppressed != null) { suppressed.add(e); } } catch (ClassNotFoundException e) { if (suppressed != null) { suppressed.add(e); } } return result; } ... private static native Class defineClassNative(String name, ClassLoader loader, Object cookie, DexFile dexFile) throws ClassNotFoundException, NoClassDefFoundError;} ​ 这里看到经过几层调用后，进入了native实现了，根据AOSP中native注册的命名规则，直接搜索DexFile_defineClassNative找到对应的实现代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static jclass DexFile_defineClassNative(JNIEnv* env, jclass, jstring javaName, jobject javaLoader, jobject cookie, jobject dexFile) { std::vector&lt;const DexFile*&gt; dex_files; const OatFile* oat_file; // cookie转换成一组c++中的DexFile对象以及OatFile if (!ConvertJavaArrayToDexFiles(env, cookie, /*out*/ dex_files, /*out*/ oat_file)) { VLOG(class_linker) &lt;&lt; &quot;Failed to find dex_file&quot;; DCHECK(env-&gt;ExceptionCheck()); return nullptr; } ... // 将类名转换为c++的string存放在了descriptor中 // 这里会将java中的类描述符转换为c++使用的类描述符，例如类中的.转换为\\ const std::string descriptor(DotToDescriptor(class_name.c_str())); const size_t hash(ComputeModifiedUtf8Hash(descriptor.c_str())); for (auto&amp; dex_file : dex_files) { // 根据类描述符找到对应的类 const dex::ClassDef* dex_class_def = OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash); if (dex_class_def != nullptr) { ScopedObjectAccess soa(env); ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker(); ... // 使用类加载器和 DEX 文件定义一个新的 Java 类，并返回一个描述该类的 Class 对象指针 ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(), descriptor.c_str(), hash, class_loader, *dex_file, *dex_class_def); // 将DexFile插入到ClassLoader中。 class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile), class_loader.Get()); if (result != nullptr) { VLOG(class_linker) &lt;&lt; &quot;DexFile_defineClassNative returning &quot; &lt;&lt; result &lt;&lt; &quot; for &quot; &lt;&lt; class_name.c_str(); return soa.AddLocalReference&lt;jclass&gt;(result); } } } VLOG(class_linker) &lt;&lt; &quot;Failed to find dex_class_def &quot; &lt;&lt; class_name.c_str(); return nullptr;} ​ 代码中看到cookie中能拿到所有DexFile，最终的Class对象是由DefineClass方法定义后返回的。继续看其实现过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ObjPtr&lt;mirror::Class&gt; ClassLinker::DefineClass(Thread* self, const char* descriptor, size_t hash, Handle&lt;mirror::ClassLoader&gt; class_loader, const DexFile&amp; dex_file, const dex::ClassDef&amp; dex_class_def) { ... DexFile const* new_dex_file = nullptr; dex::ClassDef const* new_class_def = nullptr; // 类被加载前的预处理 Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassPreDefine(descriptor, klass, class_loader, dex_file, dex_class_def, &amp;new_dex_file, &amp;new_class_def); // 将dex文件加载到内存中 ObjPtr&lt;mirror::DexCache&gt; dex_cache = RegisterDexFile(*new_dex_file, class_loader.Get()); if (dex_cache == nullptr) { self-&gt;AssertPendingException(); return sdc.Finish(nullptr); } klass-&gt;SetDexCache(dex_cache); // 初始化类 SetupClass(*new_dex_file, *new_class_def, klass, class_loader.Get()); ... // 向类表中插入类对象 ObjPtr&lt;mirror::Class&gt; existing = InsertClass(descriptor, klass.Get(), hash); ... // 加载并初始化类，在必要时创建新的类对象 LoadClass(self, *new_dex_file, *new_class_def, klass); ... MutableHandle&lt;mirror::Class&gt; h_new_class = hs.NewHandle&lt;mirror::Class&gt;(nullptr); // 链接类及其相关信息 if (!LinkClass(self, descriptor, klass, interfaces, &amp;h_new_class)) { // Linking failed. if (!klass-&gt;IsErroneous()) { mirror::Class::SetStatus(klass, ClassStatus::kErrorUnresolved, self); } return sdc.Finish(nullptr); } return sdc.Finish(h_new_class);} ​ ClassPreDefine是一个回调函数，它在类被加载之前被调用，用于进行一些预处理工作。具体来说，ClassPreDefin会被调用以执行以下任务： 对新定义的类进行验证和解析，以确保类结构的正确性。 为新定义的类分配内存空间，并构造新对象的实例。 设置类的访问控制权限并更新关联的缓存信息。 ​ RegisterDexFile用于注册 DEX 文件。该函数负责将 DEX 文件加载到内存中，并将其中包含的类和相关信息注册到运行时环境中，以供后续的程序使用。该函数的主要负责： 将 DEX 文件加载到内存中，并为其分配一段连续的内存空间。 在运行时环境中创建mirror::DexFile对象，该对象包含了 DEX文件的元数据信息，例如文件名、MD5 哈希值等。 为DEX文件中包含的每个类创建相应的 mirror::Class 对象，并将其添加到类表中进行管理。 为新创建的 mirror::Class 对象设置其访问权限和其他属性，例如类标志、字段、方法等。 创建并返回一个 mirror::DexCache 对象，该对象表示已注册的DEX文件的缓存信息。 ​ SetupClass 函数用于初始化类。该函数的主要作用： 解析类定义，并为其分配内存空间。 为新创建的类对象设置相关信息，例如类名、超类、接口信息等。 设置类对象的访问修饰符和标志。 将类对象添加到运行时环境中进行管理。 在必要的情况下，执行与类加载生命周期有关的回调函数。 ​ InsertClass函数用于向类表中插入新的类对象，并确保在插入之前对其进行必要的验证和初始化工作。该函数的主要作用： 根据类描述符和哈希值查找类表中是否已经存在相同的类对象。 如果已经存在相同的类对象，则返回其指针，否则将新的类对象插入到类表中，并返回其指针。 在插入新的类对象之前，会先进行一些验证工作，例如检查类的访问权限，以及确保类的结构和超类的继承关系正确等。 在需要时，执行与类加载生命周期有关的回调函数。 ​ LoadClass 函数用于加载并初始化类。并将其插入到类表中进行管理。主要作用： 根据类描述符查找类表中是否已经存在相同的类对象，如存在则直接返回其指针。 如果类表中不存在相同的类对象，则先使用 SetupClass() 函数创建新的类对象，并将其插入到类表中。此处调用了 InsertClass() 函数。 加载并初始化类的超类及接口信息，以确保类的继承关系正确。 执行与类加载生命周期有关的回调函数。 ​ LinkClass 函数是在用于链接类，该函数会返回一个新的类对象指针，以供调用者使用。主要作用： 链接类的超类，并执行与超类有关的初始化工作。 链接类实现的接口，并执行与接口有关的初始化工作。 链接类的字段，并执行与字段有关的初始化工作。 链接类的方法，并执行与方法有关的初始化工作。 在必要时创建新的类对象，并将其返回给调用者。 ​ 将加载类的过程中几个关键的步骤搞清楚后，继续深入查看LoadClass是如何实现的，重点关注最后一个参数kclass做了些什么。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081void ClassLinker::LoadClass(Thread* self, const DexFile&amp; dex_file, const dex::ClassDef&amp; dex_class_def, Handle&lt;mirror::Class&gt; klass) { ... Runtime* const runtime = Runtime::Current(); { ... // 获取类加载器的线性内存分配器 LinearAlloc* const allocator = GetAllocatorForClassLoader(klass-&gt;GetClassLoader()); // 为类中的静态字段分配内存空间 LengthPrefixedArray&lt;ArtField&gt;* sfields = AllocArtFieldArray(self, allocator, accessor.NumStaticFields()); // 为类中的实例字段分配内存空间 LengthPrefixedArray&lt;ArtField&gt;* ifields = AllocArtFieldArray(self, allocator, accessor.NumInstanceFields()); ... // 设置类的方法列表指针 klass-&gt;SetMethodsPtr( AllocArtMethodArray(self, allocator, accessor.NumMethods()), accessor.NumDirectMethods(), accessor.NumVirtualMethods()); size_t class_def_method_index = 0; uint32_t last_dex_method_index = dex::kDexNoIndex; size_t last_class_def_method_index = 0; // 遍历类的所有方法和字段 accessor.VisitFieldsAndMethods([&amp;]( const ClassAccessor::Field&amp; field) REQUIRES_SHARED(Locks::mutator_lock_) { ... // 遍历所有字段，由last_static_field_idx判断是否正在处理的是静态字段 if (num_sfields == 0 || LIKELY(field_idx &gt; last_static_field_idx)) { // 加载字段信息 LoadField(field, klass, &amp;sfields-&gt;At(num_sfields)); ++num_sfields; last_static_field_idx = field_idx; } }, [&amp;](const ClassAccessor::Field&amp; field) REQUIRES_SHARED(Locks::mutator_lock_) { ... // 加载实例字段信息 if (num_ifields == 0 || LIKELY(field_idx &gt; last_instance_field_idx)) { LoadField(field, klass, &amp;ifields-&gt;At(num_ifields)); ++num_ifields; last_instance_field_idx = field_idx; } }, [&amp;](const ClassAccessor::Method&amp; method) REQUIRES_SHARED(Locks::mutator_lock_) { // 获取实例方法 ArtMethod* art_method = klass-&gt;GetDirectMethodUnchecked(class_def_method_index, image_pointer_size_); // 将dex_file参数中指向Java方法字节码的指针(method)解析为机器码，并将它存储到art_method参数对应的内存区域中，完成对Java方法实现代码的加载 LoadMethod(dex_file, method, klass, art_method); // 将art_method参数对应的实现代码链接到oat_class_ptr参数对应的oat文件中 LinkCode(this, art_method, oat_class_ptr, class_def_method_index); ... }, [&amp;](const ClassAccessor::Method&amp; method) REQUIRES_SHARED(Locks::mutator_lock_) { // 和上面差不多的，不过这里处理的是虚方法 ArtMethod* art_method = klass-&gt;GetVirtualMethodUnchecked( class_def_method_index - accessor.NumDirectMethods(), image_pointer_size_); LoadMethod(dex_file, method, klass, art_method); LinkCode(this, art_method, oat_class_ptr, class_def_method_index); ++class_def_method_index; }); ... // 将加载好的字段保存到kclass klass-&gt;SetSFieldsPtr(sfields); DCHECK_EQ(klass-&gt;NumStaticFields(), num_sfields); klass-&gt;SetIFieldsPtr(ifields); DCHECK_EQ(klass-&gt;NumInstanceFields(), num_ifields); } // Ensure that the card is marked so that remembered sets pick up native roots. WriteBarrier::ForEveryFieldWrite(klass.Get()); self-&gt;AllowThreadSuspension();} ​ 然后再了解一下LoadField和LoadMethod是如何加载的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394void ClassLinker::LoadField(const ClassAccessor::Field&amp; field, Handle&lt;mirror::Class&gt; klass, ArtField* dst) { // 可以看到实际就是将值填充给了dst const uint32_t field_idx = field.GetIndex(); dst-&gt;SetDexFieldIndex(field_idx); dst-&gt;SetDeclaringClass(klass.Get()); dst-&gt;SetAccessFlags(field.GetAccessFlags() | hiddenapi::CreateRuntimeFlags(field));}void ClassLinker::LoadMethod(const DexFile&amp; dex_file, const ClassAccessor::Method&amp; method, Handle&lt;mirror::Class&gt; klass, ArtMethod* dst) { const uint32_t dex_method_idx = method.GetIndex(); const dex::MethodId&amp; method_id = dex_file.GetMethodId(dex_method_idx); const char* method_name = dex_file.StringDataByIdx(method_id.name_idx_); ScopedAssertNoThreadSuspension ants(&quot;LoadMethod&quot;); dst-&gt;SetDexMethodIndex(dex_method_idx); dst-&gt;SetDeclaringClass(klass.Get()); ... // 如果加载的是finalize方法 if (UNLIKELY(strcmp(&quot;finalize&quot;, method_name) == 0)) { ... } else if (method_name[0] == '&lt;') { // 处理构造函数 bool is_init = (strcmp(&quot;&lt;init&gt;&quot;, method_name) == 0); bool is_clinit = !is_init &amp;&amp; (strcmp(&quot;&lt;clinit&gt;&quot;, method_name) == 0); if (UNLIKELY(!is_init &amp;&amp; !is_clinit)) { LOG(WARNING) &lt;&lt; &quot;Unexpected '&lt;' at start of method name &quot; &lt;&lt; method_name; } else { if (UNLIKELY((access_flags &amp; kAccConstructor) == 0)) { LOG(WARNING) &lt;&lt; method_name &lt;&lt; &quot; didn't have expected constructor access flag in class &quot; &lt;&lt; klass-&gt;PrettyDescriptor() &lt;&lt; &quot; in dex file &quot; &lt;&lt; dex_file.GetLocation(); // access_flags存储了Java方法的访问标志，如public、private、static等。kAccConstructor是一个常量，表示Java构造函数的访问标志 access_flags |= kAccConstructor; } } } // 判断是否为native函数 if (UNLIKELY((access_flags &amp; kAccNative) != 0u)) { // Check if the native method is annotated with @FastNative or @CriticalNative. access_flags |= annotations::GetNativeMethodAnnotationAccessFlags( dex_file, dst-&gt;GetClassDef(), dex_method_idx); } // 设置该方法的访问标志 dst-&gt;SetAccessFlags(access_flags); // 判断是否为接口类的抽象方法 if (klass-&gt;IsInterface() &amp;&amp; dst-&gt;IsAbstract()) { // 计算并设置抽象方法的IMT索引。IMT(Interface Method Table)是一个虚拟表，用于存储接口类中的所有方法索引。 dst-&gt;CalculateAndSetImtIndex(); } // 这个java方法是否有可执行代码，也就是java字节码，方法的具体执行指令集 if (dst-&gt;HasCodeItem()) { DCHECK_NE(method.GetCodeItemOffset(), 0u); // 根据当前是否采用AOT编译器来进行不同的方式填充可执行代码。 if (Runtime::Current()-&gt;IsAotCompiler()) { dst-&gt;SetDataPtrSize(reinterpret_cast32&lt;void*&gt;(method.GetCodeItemOffset()), image_pointer_size_); } else { dst-&gt;SetCodeItem(dst-&gt;GetDexFile()-&gt;GetCodeItem(method.GetCodeItemOffset())); } } else { dst-&gt;SetDataPtrSize(nullptr, image_pointer_size_); DCHECK_EQ(method.GetCodeItemOffset(), 0u); } // 检查该方法的参数类型和返回值类型是否符合要求 const char* shorty = dst-&gt;GetShorty(); bool all_parameters_are_reference = true; bool all_parameters_are_reference_or_int = true; bool return_type_is_fp = (shorty[0] == 'F' || shorty[0] == 'D'); for (size_t i = 1, e = strlen(shorty); i &lt; e; ++i) { if (shorty[i] != 'L') { all_parameters_are_reference = false; if (shorty[i] == 'F' || shorty[i] == 'D' || shorty[i] == 'J') { all_parameters_are_reference_or_int = false; break; } } } // Java方法设置是否启用Nterp快速路径，如果该函数非native的，并且参数全部为引用类型，则设置该方法的entry_point_from_interpreter_为Nterp快速路径 if (!dst-&gt;IsNative() &amp;&amp; all_parameters_are_reference) { dst-&gt;SetNterpEntryPointFastPathFlag(); } // 返回值类型非浮点型，并且所有参数类型都是引用类型或整型，则设置该方法的invocation_count_为Nterp快速路径 if (!return_type_is_fp &amp;&amp; all_parameters_are_reference_or_int) { dst-&gt;SetNterpInvokeFastPathFlag(); }} ​ finalize是Java中的一个方法，定义在Object类中，用于执行垃圾回收前的资源清理工作。当某个对象不再被引用时，垃圾回收器会调用该对象的finalize方法来完成一些特定的清理操作，如释放非托管资源等。 ​ Nterp快速路径（Nterp Fast Path）是ART虚拟机的一种执行模式，可以在不进行线程切换的情况下快速执行Java方法。具体来说，Nterp快速路径使用一种特殊的、基于指令计数器的执行模式来处理Java方法，以实现更高效的性能。 ​ Nterp快速路径的作用是提高Java方法的执行速度和效率，特别是在热点代码部分，可以获得更高的吞吐量和更低的延迟。另外，由于采用了一些特殊的优化技术，如参数传递方式改变、返回值处理流程优化等，Nterp快速路径还可以减少JNI开销，从而提升整个应用程序的性能表现。 ​ 在前文介绍native的动态注册时，曾经简单的讲解LinkCode，这里再次对这个重点函数进行详细的了解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445bool ClassLinker::ShouldUseInterpreterEntrypoint(ArtMethod* method, const void* quick_code) { ... if (quick_code == nullptr) { return true; } .. return false;}static void LinkCode(ClassLinker* class_linker, ArtMethod* method, const OatFile::OatClass* oat_class, uint32_t class_def_method_index) REQUIRES_SHARED(Locks::mutator_lock_) { ... const void* quick_code = nullptr; if (oat_class != nullptr) { const OatFile::OatMethod oat_method = oat_class-&gt;GetOatMethod(class_def_method_index); // 获取一个方法的快速代码（Quick Code），用于设置该方法的入口点地址 quick_code = oat_method.GetQuickCode(); } // 如果有方法的快速代码，否则使用解释器执行，在下一节的函数调用中会详细讲到 bool enter_interpreter = class_linker-&gt;ShouldUseInterpreterEntrypoint(method, quick_code); if (quick_code == nullptr) { // 设置一个方法的入口点位置，可以是编译成机器码的快速执行入口、解释器入口，或者native函数的入口地址 method-&gt;SetEntryPointFromQuickCompiledCode( method-&gt;IsNative() ? GetQuickGenericJniStub() : GetQuickToInterpreterBridge()); } else if (enter_interpreter) { // 设置解释器入口为该方法的入口点位置 method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickToInterpreterBridge()); } else if (NeedsClinitCheckBeforeCall(method)) { DCHECK(!method-&gt;GetDeclaringClass()-&gt;IsVisiblyInitialized()); method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickResolutionStub()); } else { // 已经编译好的机器码所在的快速执行入口 method-&gt;SetEntryPointFromQuickCompiledCode(quick_code); } // 给native设置入口地址的，在第六章动态注册中讲到。 if (method-&gt;IsNative()) { ... }} ​ 快速代码是指一种优化后的本地机器代码，它可以直接执行Java字节码对应的指令，从而实现更快的函数调用和执行。快速代码通常是通过即时编译器（JIT）或预编译技术生成的，并保存在Oat文件中。在运行时，如果一个方法已经被编译为快速代码，则LinkCode函数可以直接使用Oat文件中的方法描述符获取快速代码的地址，并将其设置为该方法的入口点地址。 ​ 接下来看看设置的解释器入口是什么，跟踪方法GetQuickToInterpreterBridge的实现。 123static inline const void* GetQuickToInterpreterBridge() { return reinterpret_cast&lt;const void*&gt;(art_quick_to_interpreter_bridge);} ​ 这里和native动态注册分析时看到入口设置非常类似，GetQuickToInterpreterBridge是一个静态内联函数，它将全局变量art_quick_to_interpreter_bridge的地址强制转换为const void*类型，然后返回该地址。art_quick_to_interpreter_bridge是一个指向解释器入口点的函数指针，它在链接器启动时被初始化，是由汇编进行实现。 123456789101112131415161718ENTRY art_quick_to_interpreter_bridge SETUP_SAVE_REFS_AND_ARGS_FRAME // Set up frame and save arguments. // x0 will contain mirror::ArtMethod* method. mov x1, xSELF // How to get Thread::Current() ??? mov x2, sp // uint64_t artQuickToInterpreterBridge(mirror::ArtMethod* method, Thread* self, // mirror::ArtMethod** sp) bl artQuickToInterpreterBridge RESTORE_SAVE_REFS_AND_ARGS_FRAME REFRESH_MARKING_REGISTER fmov d0, x0 RETURN_OR_DELIVER_PENDING_EXCEPTIONEND art_quick_to_interpreter_bridge 查看汇编代码时，可以注意到关键是使用bl指令调用artQuickToInterpreterBridge函数。这个函数就是解释器的入口函数。 解释器（Interpreter）是一种Java字节码执行引擎，它能够直接解释和执行Java字节码指令。与预编译的本地机器代码不同，解释器以Java字节码为基础，通过逐条解释执行来完成函数的执行过程。 当应用程序需要执行一个Java方法时，链接器会将该方法的字节码读入内存，并利用解释器逐条指令执行。解释器会根据Java字节码类型进行相应的操作，包括创建对象、读取/写入局部变量和操作数栈、跳转操作等。同时，解释器还会处理异常、垃圾回收、线程同步等方面的操作，从而保证Java程序的正确性和稳定性。 尽管解释器的执行速度比本地机器代码要慢一些，但它具有许多优点。例如，解释器可以实现更快的程序启动时间、更小的内存占用和更好的灵活性；同时，它还可以避免因硬件平台差异、编译器优化等问题导致代码执行异常和安全隐患。 当一个方法第一次被调用时，在进行初步解释和执行之后，解释器会生成相应的Profile数据。后续调用将根据Profile数据决定是否使用JIT编译器或AOT编译器进行优化。这种混合的执行方式可以有效地平衡运行效率和内存开销之间的关系，提高Java程序的整体性能和响应速度。 当类加载完成后，对应的类数据将会存储在相应的DexFile中。在后续使用中，可以通过DexFile来访问类中的成员和函数。下面简单了解一下DexFile结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class DexFile { public: // dex文件魔数的字节数。 static constexpr size_t kDexMagicSize = 4; // dex文件版本号的字节数。 static constexpr size_t kDexVersionLen = 4; static constexpr uint32_t kClassDefinitionOrderEnforcedVersion = 37; // SHA-1消息摘要的长度 static constexpr size_t kSha1DigestSize = 20; // dex文件的大小端标志 static constexpr uint32_t kDexEndianConstant = 0x12345678; // 无效索引的值 static constexpr uint16_t kDexNoIndex16 = 0xFFFF; static constexpr uint32_t kDexNoIndex32 = 0xFFFFFFFF; // 表示dex文件头结构 struct Header { uint8_t magic_[8] = {}; // 魔数 uint32_t checksum_ = 0; // 校验和 uint8_t signature_[kSha1DigestSize] = {}; // SHA-1签名 uint32_t file_size_ = 0; // 文件总大小 uint32_t header_size_ = 0; // 偏移量到下一部分的起始位置 uint32_t endian_tag_ = 0; // 大小端标志 uint32_t link_size_ = 0; uint32_t link_off_ = 0; uint32_t map_off_ = 0; uint32_t string_ids_size_ = 0; // 字符串ID的数量 uint32_t string_ids_off_ = 0; // 字符串ID数组的文件偏移量 uint32_t type_ids_size_ = 0; // 类型ID数，不支持超过65535个 uint32_t type_ids_off_ = 0; // 类型ID数组的文件偏移量 uint32_t proto_ids_size_ = 0; // ProtoId的数量，不支持超过65535个 uint32_t proto_ids_off_ = 0; // ProtoId数组的文件偏移量 uint32_t field_ids_size_ = 0; // FieldIds的数量 uint32_t field_ids_off_ = 0; // FieldIds数组的文件偏移量 uint32_t method_ids_size_ = 0; // MethodIds的数量 uint32_t method_ids_off_ = 0; // MethodIds数组的文件偏移量 uint32_t class_defs_size_ = 0; // ClassDefs的数量 uint32_t class_defs_off_ = 0; // ClassDef数组的文件偏移量 uint32_t data_size_ = 0; // 数据部分的大小 uint32_t data_off_ = 0; // 数据部分的文件偏移量 // 解码dex文件版本号。 uint32_t GetVersion() const; }; ... protected: // 支持默认方法的第一个Dex格式版本。 static constexpr uint32_t kDefaultMethodsVersion = 37; ... // dex文件数据起始位置 const uint8_t* const begin_; // 内存分配的字节数。 const size_t size_; // 数据节的基地址（对于标准dex，与Begin()相同）。 const uint8_t* const data_begin_; // 数据节的大小。 const size_t data_size_; const std::string location_; const uint32_t location_checksum_; // Dex文件头的指针 const Header* const header_; // 字符串标识符列表的指针 const dex::StringId* const string_ids_; // 类型标识符列表的指针 const dex::TypeId* const type_ids_; // 字段标识符列表的指针 const dex::FieldId* const field_ids_; // 方法标识符列表的指针 const dex::MethodId* const method_ids_; // 原型标识符列表的指针 const dex::ProtoId* const proto_ids_; // 类定义列表的指针 const dex::ClassDef* const class_defs_; // 方法句柄列表的指针 const dex::MethodHandleItem* method_handles_; // 方法句柄列表中元素的数量 size_t num_method_handles_; ...}; ​ 接着查看DexFile的构造函数实现。 12345678910111213141516171819202122232425262728293031323334353637383940DexFile::DexFile(const uint8_t* base, size_t size, const uint8_t* data_begin, size_t data_size, const std::string&amp; location, uint32_t location_checksum, const OatDexFile* oat_dex_file, std::unique_ptr&lt;DexFileContainer&gt; container, bool is_compact_dex) : begin_(base), size_(size), data_begin_(data_begin), data_size_(data_size), location_(location), location_checksum_(location_checksum), header_(reinterpret_cast&lt;const Header*&gt;(base)), string_ids_(reinterpret_cast&lt;const StringId*&gt;(base + header_-&gt;string_ids_off_)), type_ids_(reinterpret_cast&lt;const TypeId*&gt;(base + header_-&gt;type_ids_off_)), field_ids_(reinterpret_cast&lt;const FieldId*&gt;(base + header_-&gt;field_ids_off_)), method_ids_(reinterpret_cast&lt;const MethodId*&gt;(base + header_-&gt;method_ids_off_)), proto_ids_(reinterpret_cast&lt;const ProtoId*&gt;(base + header_-&gt;proto_ids_off_)), class_defs_(reinterpret_cast&lt;const ClassDef*&gt;(base + header_-&gt;class_defs_off_)), method_handles_(nullptr), num_method_handles_(0), call_site_ids_(nullptr), num_call_site_ids_(0), hiddenapi_class_data_(nullptr), oat_dex_file_(oat_dex_file), container_(std::move(container)), is_compact_dex_(is_compact_dex), hiddenapi_domain_(hiddenapi::Domain::kApplication) { CHECK(begin_ != nullptr) &lt;&lt; GetLocation(); CHECK_GT(size_, 0U) &lt;&lt; GetLocation(); // Check base (=header) alignment. // Must be 4-byte aligned to avoid undefined behavior when accessing // any of the sections via a pointer. CHECK_ALIGNED(begin_, alignof(Header)); InitializeSectionsFromMapList();} ​ 可以看出header_这个dex文件头的结构体中存储着最重要的信息，初始化时先是填充了header_中的数据，然后再根据header_文件头，将其他重要信息初始化。当需要对这个Dex进行访问时，只需要通过文件头信息，就可以为我们索引找到任何一段信息了。它提供了整个文件的索引。 ​ 使用010 Editor工具，通过模板库在线安装DEX.bt模板，然后打开之前的样例文件，查看在例子中header_的真实数据。 7.3 函数调用流程在Android中，Java函数和native函数的调用方式略有不同。 对于Java函数，它们的执行是由Android Runtime虚拟机完成的。具体来说，当应用程序需要调用一个Java函数时，Android Runtime会根据该函数的状态和类型进行相应的处理，包括解释器执行、JIT编译器动态生成机器码等；当函数执行完毕后，结果会被传递回应用程序。 而对于native函数，则是由操作系统内核直接执行的。应用程序需要通过JNI（Java Native Interface）来调用native 函数。首先将Java数据结构转换为C/C++类型, 然后将参数传递给 native 函数, 最终再将结果转换为Java数据结构并返回给应用程序。 在这个过程中, JNI提供了一系列的函数和接口来实现Java与本地代码/数据之间的交互和转换。 下面使用反编译工具jadx打开前文中的样例程序，样例程序的代码如下。 12345678public class MyCommon { public static String getMyJarVer() { return &quot;v1.0&quot;; } public static int add(int a, int b) { return a + b; }} ​ 切换为展示smali指令，并右键选择显示Dalvik字节码，看到如下代码。 12345678910111213.method public static add(II)I .registers 3 .param p0, &quot;a&quot;:I .param p1, &quot;b&quot;:I .line 11 002bf89c: 9000 0102 0000: add-int v0, p0, p1 .end local v1 # &quot;a&quot;:I .end local v2 # &quot;b&quot;:I 002bf8a0: 0f00 0002: return v0.end method ​ .registers 3表示该函数中使用到了3个寄存器，分别为两个参数和返回值。 ​ 002bf89c 表示的是当前指令的偏移地址。 ​ 9000 0102 就是该函数中的java字节码，其中前两个字节9000表示的是操作码，由于字节码是大端序存储的，所以这里实际操作码解读为0x0090，下面在AOSP中对Opcodes的定义中也能看到0x90操作码对应的操作是add-int。 12345public interface Opcodes { ... int OP_ADD_INT = 0x0090; ...} ​ 使用010 Editor工具，将样例程序解压后获得的classes.dex拖入010 Editor打开。看到结果如下。 ​ 接下来在dex_class_defs中寻找刚刚分析的目标类MyCommon。 1struct class_def_item class_def[2205] public cn.rom.myjar.MyCommon 1243C4h 20h Fg: Bg:0xE0E0E0 Class ID ​ 将其展开后，能看到该class的详细信息，在上一节的类加载中，当DEX被解析后，加载的类在内存中就是以这样的结构存储着数据。 ​ 在其中的函数结构体下面的code_item类型的数据，就存储着该函数要执行的java字节码，继续展开该结构。 ​ 这里就能看到对该函数结构的描述了，insns中则存储着函数要执行的指令。每个指令的单位是ushort，即两个字节存储，将这里的三个指令转换为16进制表示则是。 12345144 = 00 90 -&gt; 大端序 -&gt; 9000513 = 02 01 -&gt; 大端序 -&gt; 010215 = 00 0F -&gt; 大端序 -&gt; 0f00 ​ 结果和上面smali展示中的一致。这就是java字节码，在调用过程中，系统会经过层层的转换和解析，最终通过对函数中的指令进行执行来完成函数的调用。 ​ 接下来根据之前的例子，开始对函数调用流程的代码进行跟踪分析。 123456protected void onCreate(Bundle savedInstanceState) { ... Object result = addMethod.invoke(null, 12,25); Log.i(&quot;MainActivity&quot;,&quot;getMyJarVer:&quot;+result); ...} ​ 找到Method的invoke的实现，这是一个native函数，所以继续找对应的Method_invoke函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@FastNative public native Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException;static jobject Method_invoke(JNIEnv* env, jobject javaMethod, jobject javaReceiver, jobjectArray javaArgs) { ScopedFastNativeObjectAccess soa(env); return InvokeMethod&lt;kRuntimePointerSize&gt;(soa, javaMethod, javaReceiver, javaArgs);}jobject InvokeMethod(const ScopedObjectAccessAlreadyRunnable&amp; soa, jobject javaMethod, jobject javaReceiver, jobject javaArgs, size_t num_frames) { ... // Java方法和ArtMethod之间存在映射关系，SOA提供了一种方便的方式来将Java对象转换为Art虚拟机中的数据对象 ObjPtr&lt;mirror::Executable&gt; executable = soa.Decode&lt;mirror::Executable&gt;(javaMethod); const bool accessible = executable-&gt;IsAccessible(); ArtMethod* m = executable-&gt;GetArtMethod(); ... if (!m-&gt;IsStatic()) { // Replace calls to String.&lt;init&gt; with equivalent StringFactory call. if (declaring_class-&gt;IsStringClass() &amp;&amp; m-&gt;IsConstructor()) { ... } else { ... // 查找虚方法的真实实现 m = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtualOrInterface(m, kPointerSize); } } // 对java方法的参数进行转换 ObjPtr&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt; objects = soa.Decode&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt;(javaArgs); ... // 调用函数 JValue result; const char* shorty; if (!InvokeMethodImpl(soa, m, np_method, receiver, objects, &amp;shorty, &amp;result)) { return nullptr; } return soa.AddLocalReference&lt;jobject&gt;(BoxPrimitive(Primitive::GetType(shorty[0]), result));} 在上面这个函数中，主要使用SOA将Java函数以及函数的参数转换为C++对象。 Structured Object Access（SOA）用于优化Java对象在Native代码和Art虚拟机之间的传递和处理。SOA技术提供了一种高效的方式，将Java对象转换为基于指针的本地C++对象，从而避免了频繁的对象复制和GC操作，提高了程序的性能和执行效率。 在SOA技术中使用Handle和ObjPtr等类型的指针来管理Java对象和本地C++对象之间的映射关系。Handle是一种包装器，用于管理Java对象的生命周期，并确保其在被访问时不会被GC回收。ObjPtr则是一种智能指针，用于管理本地C++对象的生命周期，并确保其正确释放和销毁。 通过SOA可以在Native代码中高效地访问和操作Java对象，例如调用Java方法、读取Java字段等。在执行过程中，SOA技术会自动进行对象的内存分配和管理，以确保程序的正确性和性能表现。 接下来继续了解InvokeMethodImpl函数的实现。 123456789101112131415161718192021ALWAYS_INLINEbool InvokeMethodImpl(const ScopedObjectAccessAlreadyRunnable&amp; soa, ArtMethod* m, ArtMethod* np_method, ObjPtr&lt;mirror::Object&gt; receiver, ObjPtr&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt; objects, const char** shorty, JValue* result) REQUIRES_SHARED(Locks::mutator_lock_) { // 将函数的参数转换后，存放到arg_array中。 uint32_t shorty_len = 0; *shorty = np_method-&gt;GetShorty(&amp;shorty_len); ArgArray arg_array(*shorty, shorty_len); if (!arg_array.BuildArgArrayFromObjectArray(receiver, objects, np_method, soa.Self())) { CHECK(soa.Self()-&gt;IsExceptionPending()); return false; } // 函数调用 InvokeWithArgArray(soa, m, &amp;arg_array, result, *shorty); ... return true;} ​ ArgArray主要用于管理Java方法参数列表的类。ArgArray和Java中的类型对应如下： ​ 1.基本类型：ArgArray中的基本类型分别对应Java中的八种基本类型 boolean：'Z' byte：'B' short：'S' char：'C' int：'I' long：'J' float：'F' double：'D' ​ 2.引用类型：ArgArray中的引用类型对应Java中的对象类型，包括String、Object、数组等。在ArgArray中，引用类型用字符'L'开头，并紧跟着完整类名和结尾的分号';'表示，例如'Landroid/content/Context;'表示android.content.Context类。 ​ 3.可变参数：可变参数在Java中使用“...”符号表示，而在ArgArray中，则需要将所有可变参数打包为一个数组，并使用‘[’和‘]’符号表示。例如，如果Java方法声明为“public void foo(int a, String... args)”，则在ArgArray中，参数列表的短类型描述符为“ILjava/lang/String;[”。 ​ 理解了C++如何存放参数数据后，继续看下一层的函数调用。 123456789101112void InvokeWithArgArray(const ScopedObjectAccessAlreadyRunnable&amp; soa, ArtMethod* method, ArgArray* arg_array, JValue* result, const char* shorty) REQUIRES_SHARED(Locks::mutator_lock_) { // 获取java参数的数组指针 uint32_t* args = arg_array-&gt;GetArray(); if (UNLIKELY(soa.Env()-&gt;IsCheckJniEnabled())) { CheckMethodArguments(soa.Vm(), method-&gt;GetInterfaceMethodIfProxy(kRuntimePointerSize), args); } method-&gt;Invoke(soa.Self(), args, arg_array-&gt;GetNumBytes(), result, shorty);} 调用到了ArtMethod的Invoke函数，这里将参数的数组指针，参数数组大小，返回值指针，调用函数的描述符号传递了过去。在开始进入关键函数前，先对返回值指针JValue* result进行简单介绍。 JValue是用于存储和传递Java方法返回值的联合体。包含了各种基本类型和引用类型的成员变量。下面是该联合体的定义。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960union PACKED(alignof(mirror::Object*)) JValue { // We default initialize JValue instances to all-zeros. JValue() : j(0) {} template&lt;typename T&gt; ALWAYS_INLINE static JValue FromPrimitive(T v); int8_t GetB() const { return b; } void SetB(int8_t new_b) { j = ((static_cast&lt;int64_t&gt;(new_b) &lt;&lt; 56) &gt;&gt; 56); // Sign-extend to 64 bits. } uint16_t GetC() const { return c; } void SetC(uint16_t new_c) { j = static_cast&lt;int64_t&gt;(new_c); // Zero-extend to 64 bits. } double GetD() const { return d; } void SetD(double new_d) { d = new_d; } float GetF() const { return f; } void SetF(float new_f) { f = new_f; } int32_t GetI() const { return i; } void SetI(int32_t new_i) { j = ((static_cast&lt;int64_t&gt;(new_i) &lt;&lt; 32) &gt;&gt; 32); // Sign-extend to 64 bits. } int64_t GetJ() const { return j; } void SetJ(int64_t new_j) { j = new_j; } mirror::Object* GetL() const REQUIRES_SHARED(Locks::mutator_lock_) { return l; } ALWAYS_INLINE void SetL(ObjPtr&lt;mirror::Object&gt; new_l) REQUIRES_SHARED(Locks::mutator_lock_); int16_t GetS() const { return s; } void SetS(int16_t new_s) { j = ((static_cast&lt;int64_t&gt;(new_s) &lt;&lt; 48) &gt;&gt; 48); // Sign-extend to 64 bits. } uint8_t GetZ() const { return z; } void SetZ(uint8_t new_z) { j = static_cast&lt;int64_t&gt;(new_z); // Zero-extend to 64 bits. } mirror::Object** GetGCRoot() { return &amp;l; } private: uint8_t z; int8_t b; uint16_t c; int16_t s; int32_t i; int64_t j; float f; double d; mirror::Object* l;}; JValue结构体的大小为8个字节对齐，结构体提供了一些成员函数，例如GetXXX和SetXXX等函数，用于获取和设置不同类型的返回值。alignof(mirror::Object*)的具体值取决于编译器和操作系统的不同，一般为4或8。 对参数以及返回值的在C++中的表示有了初步的了解后，开始继续查看函数调用过程中的关键函数ArtMethod::Invoke，下面是具体实现代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result, const char* shorty) { ... // 将当前的环境（也就是函数调用时的程序计数器、堆栈指针等信息）保存到一个栈帧中。这个栈帧通常会被分配在堆上，并且由垃圾回收器来管理。在函数返回时，这个栈帧会被弹出，恢复之前的环境。 ManagedStack fragment; self-&gt;PushManagedStackFragment(&amp;fragment); Runtime* runtime = Runtime::Current(); // IsForceInterpreter为true表示强制使用解释器执行函数 // 这里的条件是，如果设置了强制走解释器执行，并且非native函数，并且非代理函数，并且可执行的函数，则符合条件 if (UNLIKELY(!runtime-&gt;IsStarted() || (self-&gt;IsForceInterpreter() &amp;&amp; !IsNative() &amp;&amp; !IsProxyMethod() &amp;&amp; IsInvokable()))) { if (IsStatic()) { // 静态函数调用 art::interpreter::EnterInterpreterFromInvoke( self, this, nullptr, args, result, /*stay_in_interpreter=*/ true); } else { // 非静态函数调用 mirror::Object* receiver = reinterpret_cast&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[0])-&gt;AsMirrorPtr(); art::interpreter::EnterInterpreterFromInvoke( self, this, receiver, args + 1, result, /*stay_in_interpreter=*/ true); } } else { ... // 是否有已编译的快速执行代码的入口点 bool have_quick_code = GetEntryPointFromQuickCompiledCode() != nullptr; if (LIKELY(have_quick_code)) { ... // 走快速调用方式，比解释器执行的性能高。 if (!IsStatic()) { (*art_quick_invoke_stub)(this, args, args_size, self, result, shorty); } else { (*art_quick_invoke_static_stub)(this, args, args_size, self, result, shorty); } ... } else { LOG(INFO) &lt;&lt; &quot;Not invoking '&quot; &lt;&lt; PrettyMethod() &lt;&lt; &quot;' code=null&quot;; if (result != nullptr) { result-&gt;SetJ(0); } } } // 从栈帧中还原当前环境 self-&gt;PopManagedStackFragment(fragment);} 根据以上代码得到的结论是，函数执行的路线有两条，EnterInterpreterFromInvoke由解释器执行和art_quick_invoke_stub快速执行通道。 art_quick_invoke_stub是由一段汇编完成对函数的执行，该函数充分利用寄存器并尽可能地减少堆栈访问次数，以提高Java方法的执行效率。虽然快速执行通道的效率会更加高，但是可读性差，但是对于学习执行过程和修改执行流程来说，解释器执行会更加简单易改。所以接下来跟进解释器执行，了解执行的细节。继续跟踪EnterInterpreterFromInvoke函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111void EnterInterpreterFromInvoke(Thread* self, ArtMethod* method, ObjPtr&lt;mirror::Object&gt; receiver, uint32_t* args, JValue* result, bool stay_in_interpreter) { ... // 获取函数中的指令信息 CodeItemDataAccessor accessor(method-&gt;DexInstructionData()); uint16_t num_regs; uint16_t num_ins; if (accessor.HasCodeItem()) { // 获取寄存器的数量和参数的数量 num_regs = accessor.RegistersSize(); num_ins = accessor.InsSize(); } else if (!method-&gt;IsInvokable()) { self-&gt;EndAssertNoThreadSuspension(old_cause); method-&gt;ThrowInvocationTimeError(); return; } else { DCHECK(method-&gt;IsNative()) &lt;&lt; method-&gt;PrettyMethod(); // 从函数描述符中计算出寄存器数量和参数数量 // 这里将num_regs和num_ins都赋值的原因是，方法的前几个参数通常会存储在寄存器中，而不是堆栈中。因此，num_regs和num_ins的值应该是相同的，都代表了当前方法使用的寄存器数量，也就是用于存储参数和局部变量等数据的寄存器数量。 num_regs = num_ins = ArtMethod::NumArgRegisters(method-&gt;GetShorty()); // 非静态函数的情况，会多一个this参数，所以寄存器数量和参数数量+1 if (!method-&gt;IsStatic()) { num_regs++; num_ins++; } } // 创建一个新的ShadowFrame作为当前栈，将当前环境保存在其中，并且推入栈帧，供当前线程调用方法时使用 ShadowFrame* last_shadow_frame = self-&gt;GetManagedStack()-&gt;GetTopShadowFrame(); ShadowFrameAllocaUniquePtr shadow_frame_unique_ptr = CREATE_SHADOW_FRAME(num_regs, last_shadow_frame, method, /* dex pc */ 0); ShadowFrame* shadow_frame = shadow_frame_unique_ptr.get(); self-&gt;PushShadowFrame(shadow_frame); // 计算出将要使用的第一个寄存器 size_t cur_reg = num_regs - num_ins; // 非静态函数的情况，第一个寄存器的值为this，所以设置其为引用类型 if (!method-&gt;IsStatic()) { // receiver变量表示方法调用的第一个参数 CHECK(receiver != nullptr); shadow_frame-&gt;SetVRegReference(cur_reg, receiver); ++cur_reg; } uint32_t shorty_len = 0; const char* shorty = method-&gt;GetShorty(&amp;shorty_len); // 遍历所有参数 for (size_t shorty_pos = 0, arg_pos = 0; cur_reg &lt; num_regs; ++shorty_pos, ++arg_pos, cur_reg++) { DCHECK_LT(shorty_pos + 1, shorty_len); switch (shorty[shorty_pos + 1]) { //L 表示这个参数是个引用类型，比如Ljava/lang/String; case 'L': { ObjPtr&lt;mirror::Object&gt; o = reinterpret_cast&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[arg_pos])-&gt;AsMirrorPtr(); // 将转换好的数据设置到当前栈中 shadow_frame-&gt;SetVRegReference(cur_reg, o); break; } case 'J': case 'D': { // J或者D的数据类型要占用两个寄存器存放。 uint64_t wide_value = (static_cast&lt;uint64_t&gt;(args[arg_pos + 1]) &lt;&lt; 32) | args[arg_pos]; // 合并后的数据设置到栈中 shadow_frame-&gt;SetVRegLong(cur_reg, wide_value); cur_reg++; arg_pos++; break; } default: // 普通的整型数据设置到栈中 shadow_frame-&gt;SetVReg(cur_reg, args[arg_pos]); break; } } self-&gt;EndAssertNoThreadSuspension(old_cause); // 静态函数的情况需要检查所在的类是否已经正常初始化。 if (method-&gt;IsStatic()) { ObjPtr&lt;mirror::Class&gt; declaring_class = method-&gt;GetDeclaringClass(); if (UNLIKELY(!declaring_class-&gt;IsVisiblyInitialized())) { StackHandleScope&lt;1&gt; hs(self); Handle&lt;mirror::Class&gt; h_class(hs.NewHandle(declaring_class)); if (UNLIKELY(!Runtime::Current()-&gt;GetClassLinker()-&gt;EnsureInitialized( self, h_class, /*can_init_fields=*/ true, /*can_init_parents=*/ true))) { CHECK(self-&gt;IsExceptionPending()); self-&gt;PopShadowFrame(); return; } DCHECK(h_class-&gt;IsInitializing()); } } // 非native函数执行 if (LIKELY(!method-&gt;IsNative())) { // 解释执行的关键函数 JValue r = Execute(self, accessor, *shadow_frame, JValue(), stay_in_interpreter); if (result != nullptr) { *result = r; } } else { // native函数的解释执行 args = shadow_frame-&gt;GetVRegArgs(method-&gt;IsStatic() ? 0 : 1); if (!Runtime::Current()-&gt;IsStarted()) { UnstartedRuntime::Jni(self, method, receiver.Ptr(), args, result); } else { InterpreterJni(self, method, shorty, receiver, args, result); } } // 弹出栈帧，还原到执行后的栈环境 self-&gt;PopShadowFrame();} ​ 在这个函数中，为即将执行的函数准备好了栈帧环境，将参数填入了shadow_frame栈帧中。并且获取出了函数要执行的指令信息accessor。最后通过Execute执行该函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static inline JValue Execute( Thread* self, const CodeItemDataAccessor&amp; accessor, ShadowFrame&amp; shadow_frame, JValue result_register, bool stay_in_interpreter = false, bool from_deoptimize = false) REQUIRES_SHARED(Locks::mutator_lock_) { ... // 是否需要从解释器模式切换到编译模式。 if (LIKELY(!from_deoptimize)) { ... instrumentation::Instrumentation* instrumentation = Runtime::Current()-&gt;GetInstrumentation(); // 从当前线程栈帧中获取要执行的函数 ArtMethod *method = shadow_frame.GetMethod(); // 是否有注册Method Entry 监听器 if (UNLIKELY(instrumentation-&gt;HasMethodEntryListeners())) { // 触发 Method Entry 监听器，并传递相应的参数 instrumentation-&gt;MethodEnterEvent(self, shadow_frame.GetThisObject(accessor.InsSize()), method, 0); ... // 是否有未处理的异常 if (UNLIKELY(self-&gt;IsExceptionPending())) { ... return ret; } } // stay_in_interpreter 表示是否需要停留在解释器模式，self-&gt;IsForceInterpreter() 表示是否强制使用解释器模式。所以内部是不走解释器执行的处理，走编译模式执行 if (!stay_in_interpreter &amp;&amp; !self-&gt;IsForceInterpreter()) { jit::Jit* jit = Runtime::Current()-&gt;GetJit(); if (jit != nullptr) { // 判断当前方法是否可以使用 JIT 编译后的机器码执行 jit-&gt;MethodEntered(self, shadow_frame.GetMethod()); if (jit-&gt;CanInvokeCompiledCode(method)) { JValue result; // 直接栈帧推出 self-&gt;PopShadowFrame(); uint16_t arg_offset = accessor.RegistersSize() - accessor.InsSize(); // 调用该函数的机器码实现 ArtInterpreterToCompiledCodeBridge(self, nullptr, &amp;shadow_frame, arg_offset, &amp;result); // 重新推入栈帧 self-&gt;PushShadowFrame(&amp;shadow_frame); return result; } } } } // 从栈帧中获取要执行的当前函数 ArtMethod* method = shadow_frame.GetMethod(); ... // kSwitchImplKind：表示当前实现是否使用基于 switch 语句的解释器实现。 if (kInterpreterImplKind == kSwitchImplKind || UNLIKELY(!Runtime::Current()-&gt;IsStarted()) || !method-&gt;IsCompilable() || method-&gt;MustCountLocks() || Runtime::Current()-&gt;IsActiveTransaction()) { // 使用switch解释器执行 return ExecuteSwitch( self, accessor, shadow_frame, result_register, /*interpret_one_instruction=*/ false); } CHECK_EQ(kInterpreterImplKind, kMterpImplKind); // 编译执行函数 while (true) { // 是否支持Mterp解释器执行 if (!self-&gt;UseMterp()) { return ExecuteSwitch( self, accessor, shadow_frame, result_register, /*interpret_one_instruction=*/ false); } // 执行目标函数 bool returned = ExecuteMterpImpl(self, accessor.Insns(), &amp;shadow_frame, &amp;result_register); if (returned) { return result_register; } else { // 失败的情况继续采用switch解释器执行 result_register = ExecuteSwitch( self, accessor, shadow_frame, result_register, /*interpret_one_instruction=*/ true); if (shadow_frame.GetDexPC() == dex::kDexNoIndex) { return result_register; } } }} 看完该函数后，在继续深入前，先将其中的几个知识点进行介绍。 编译模式（Compiled Mode）是一种执行方式，它将应用程序代码编译成机器码后再执行。相较于解释器模式，编译模式具有更高的执行效率和更好的性能表现。 在Android应用程序中，编译模式采用的是 Just-In-Time（JIT）编译技术。当一个方法被多次调用时，系统会自动将其编译成本地机器码，并缓存起来以备下次使用。 当一个方法被编译成本地机器码后，其执行速度将显著提高。因为与解释器模式相比，编译模式不需要逐条解释代码，而是直接执行编译好的机器码。 由于编译过程需要一定的时间，因此在程序启动或者第一次运行新方法时，可能会出现一些额外的延迟。所以，在实际应用中，系统通常会采用一些策略，如预热机制等，来优化编译模式的性能表现。编译模式是一种性能更高、效率更好的执行方式，可以帮助应用程序在运行时获得更好的响应速度和用户体验。 Method Entry 监听器是Android系统中的一种监听器，它可以用来监听应用程序的方法入口。当一个方法被调用时，系统会触发Method Entry监听器，并将当前线程、当前方法和调用栈信息等相关数据传递给监听器。 Android Studio在调试模式下会自动为每个线程启动一个监听器，并在方法进入和退出时触发相应的事件。这些事件包括 Method Entry（方法入口）、Method Exit（方法出口）等。 ​ 下面将分别介绍ExecuteMterpImpl和ExecuteSwitch是如何实现指令流的执行。 7.4 ExecuteMterpImplExecuteMterpImpl是基于Mterp（Method Interpreter）技术实现。Mterp技术使用指令集解释器来执行应用程序的代码，相比于JIT编译模式可以更快地启动和执行短小精悍的方法，同时也可以避免JIT编译带来的额外开销。 在Mterp模式下，Dex 指令集被转化成了一组C++的函数，这些函数对应Dex指令集中的每一条指令。ExecuteMterpImpl实际上就是调用这些函数来逐条解释执行当前方法的指令集。 ​ 在Android 4.4中，系统首次引入了 Mterp 技术来加速应用程序的解释执行。在此之后的 Android版本中，Mterp 技术得到了不断优化和完善，并逐渐成为Android平台的主要方法执行方式之一。 ​ 从Android 6.0开始，Dalvik 运行时环境被弃用，取而代之的是ART运行时环境。ART 运行时环境可以通过JIT编译、AOT 编译和Mterp等多种方式来执行应用程序的代码，其中Mterp技术被广泛使用于 Android 应用程序的解释执行过程中。但是对于某些特定的场景和应用程序，系统可能还是会选择其他的执行方式来获得更好的性能和效率。 ​ ExecuteMterpImpl使用了汇编语言和 C++语言混合编写，需要有一定的汇编和C++编程经验才能理解其含义和功能。该代码主要实现了以下功能： ​ 1.保存当前方法的返回值寄存器和指令集 ​ 2.设置方法执行的环境和参数，包括vregs数组、dex_pc 寄存器等 ​ 3.为当前方法设置热度倒计时，并根据热度值来判断是否需要启用Mterp技术 ​ 4.执行当前方法的指令集，逐条解释执行 Dex 指令 ​ 下面看ExecuteMterpImpl实现代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 从xPC寄存器中获取一条指令.macro FETCH_INST ldrh wINST, [xPC].endm// 从指令中获取操作码，指令最顶部2个字节就是操作码，所以这里拿操作码是 &amp; 0xff的意思.macro GET_INST_OPCODE reg and \\reg, xINST, #255.endm// 跳转到操作码处理逻辑.macro GOTO_OPCODE reg add \\reg, xIBASE, \\reg, lsl #${handler_size_bits} br \\reg.endmENTRY ExecuteMterpImpl .cfi_startproc // 保存寄存器信息 SAVE_TWO_REGS_INCREASE_FRAME xPROFILE, x27, 80 SAVE_TWO_REGS xIBASE, xREFS, 16 SAVE_TWO_REGS xSELF, xINST, 32 SAVE_TWO_REGS xPC, xFP, 48 SAVE_TWO_REGS fp, lr, 64 // fp寄存器指向栈顶 add fp, sp, #64 /* 记录对应返回值的寄存器 */ str x3, [x2, #SHADOWFRAME_RESULT_REGISTER_OFFSET] /* 记录dex文件中的指令的指针 */ str x1, [x2, #SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET] mov xSELF, x0 ldr w0, [x2, #SHADOWFRAME_NUMBER_OF_VREGS_OFFSET] add xFP, x2, #SHADOWFRAME_VREGS_OFFSET // 计算局部变量表的偏移地址 add xREFS, xFP, w0, uxtw #2 // 计算局部变量引用表的偏移地址 ldr w0, [x2, #SHADOWFRAME_DEX_PC_OFFSET] // 获取当前Dex中的PC add xPC, x1, w0, uxtw #1 // 将Dex PC转换为地址，并保存到寄存器xPC中 CFI_DEFINE_DEX_PC_WITH_OFFSET(CFI_TMP, CFI_DEX, 0) EXPORT_PC // 将Dex PC导出 /* Starting ibase */ ldr xIBASE, [xSELF, #THREAD_CURRENT_IBASE_OFFSET] /* Set up for backwards branches &amp; osr profiling */ ldr x0, [xFP, #OFF_FP_METHOD] // 获取当前方法的方法指针 add x1, xFP, #OFF_FP_SHADOWFRAME // 计算拿到当前线程的栈帧 mov x2, xSELF // 将当前线程对象保存到寄存器x2中 bl MterpSetUpHotnessCountdown // 热度计数器调整 mov wPROFILE, w0 // 将热度计数器的宽度赋值给寄存器wPROFILE /* start executing the instruction at rPC */ FETCH_INST // 获取下一条指令 GET_INST_OPCODE ip // 从指令中获取操作码 GOTO_OPCODE ip // 跳转到操作码处理逻辑 /* NOTE: no fallthrough */ // cfi info continues, and covers the whole mterp implementation. END ExecuteMterpImpl ​ 这些操作码可以通过Opcodes找到其对应的对应，代码如下。 12345678public interface Opcodes { ... int OP_IPUT_CHAR = 0x005e; int OP_IPUT_SHORT = 0x005f; int OP_SGET = 0x0060; int OP_SGET_WIDE = 0x0061; ...} ​ 而在在汇编文件中，会有其对应操作码的具体实现。 12345678910111213141516171819202122232425262728%def field(helper=&quot;&quot;): .extern $helper mov x0, xPC // arg0: 指令的地址 mov x1, xINST // arg1: 指令对应的16位数值 add x2, xFP, #OFF_FP_SHADOWFRAME // arg2: ShadowFrame* sf mov x3, xSELF // arg3: Thread* self PREFETCH_INST 2 // 预备取下一条指令 bl $helper // 调用 $helper 函数 cbz x0, MterpPossibleException ADVANCE 2 GET_INST_OPCODE ip // 从指令中获取操作码 GOTO_OPCODE ip // 跳转到操作码处理逻辑%def op_iput(helper=&quot;MterpIPutU32&quot;):% field(helper=helper)%def op_sget(helper=&quot;MterpSGetU32&quot;):% field(helper=helper)%def op_iput_char():% op_iput(helper=&quot;MterpIPutU16&quot;)%def op_iput_short():% op_iput(helper=&quot;MterpIPutI16&quot;)%def op_sget_wide():% op_sget(helper=&quot;MterpSGetU64&quot;) ​ 到这里，就找到对应的执行C++函数将Dex的指令逐一进行执行处理，其对应的C++执行部分则在文件mterp.cc文件中找到。Mterp的执行流程到这里就非常清晰了。 7.5 ExecuteSwitch​ ExecuteSwitch是基于 switch 语句实现的一种解释器，用于执行当前方法的指令集。在 Android 应用程序中，每个方法都会对应一组指令集，用于描述该方法的具体实现。当该方法被调用时，系统需要按照指令集来执行相应的操作，从而实现该方法的功能并计算出结果。 12345678910111213141516171819202122232425static JValue ExecuteSwitch(Thread* self, const CodeItemDataAccessor&amp; accessor, ShadowFrame&amp; shadow_frame, JValue result_register, bool interpret_one_instruction) REQUIRES_SHARED(Locks::mutator_lock_) { // 是否处于事务中 if (Runtime::Current()-&gt;IsActiveTransaction()) { // 是否跳过访问检查 if (shadow_frame.GetMethod()-&gt;SkipAccessChecks()) { return ExecuteSwitchImpl&lt;false, true&gt;( self, accessor, shadow_frame, result_register, interpret_one_instruction); } else { return ExecuteSwitchImpl&lt;true, true&gt;( self, accessor, shadow_frame, result_register, interpret_one_instruction); } } else { if (shadow_frame.GetMethod()-&gt;SkipAccessChecks()) { return ExecuteSwitchImpl&lt;false, false&gt;( self, accessor, shadow_frame, result_register, interpret_one_instruction); } else { return ExecuteSwitchImpl&lt;true, false&gt;( self, accessor, shadow_frame, result_register, interpret_one_instruction); } }} ​ 在这个函数中，根据条件调整参数，最终都是调用ExecuteSwitchImpl，下面继续看解释器的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950template&lt;bool do_access_check, bool transaction_active&gt;void ExecuteSwitchImplCpp(SwitchImplContext* ctx) { ... // 获取到当前正在执行的Dex指令在CodeItem中的索引位置 uint32_t dex_pc = shadow_frame.GetDexPC(); const auto* const instrumentation = Runtime::Current()-&gt;GetInstrumentation(); // 获取指令流 const uint16_t* const insns = accessor.Insns(); // 将当前指令转换为专门用来操作指令的Instruction类 const Instruction* next = Instruction::At(insns + dex_pc); DCHECK(!shadow_frame.GetForceRetryInstruction()) &lt;&lt; &quot;Entered interpreter from invoke without retry instruction being handled!&quot;; bool const interpret_one_instruction = ctx-&gt;interpret_one_instruction; while (true) { // 获取下一条待执行的指令 const Instruction* const inst = next; dex_pc = inst-&gt;GetDexPc(insns); // 更新pc位置 shadow_frame.SetDexPC(dex_pc); TraceExecution(shadow_frame, inst, dex_pc); // 从指令中获取到操作码 uint16_t inst_data = inst-&gt;Fetch16(0); bool exit = false; bool success; // Moved outside to keep frames small under asan. // 执行指令前的预处理 if (InstructionHandler&lt;do_access_check, transaction_active, Instruction::kInvalidFormat&gt;( ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, exit). Preamble()) { DCHECK_EQ(self-&gt;IsExceptionPending(), inst-&gt;Opcode(inst_data) == Instruction::MOVE_EXCEPTION); // 这是一个超大的switch，根据操作码来选择如何执行 switch (inst-&gt;Opcode(inst_data)) {#define OPCODE_CASE(OPCODE, OPCODE_NAME, NAME, FORMAT, i, a, e, v) \\ case OPCODE: { \\ next = inst-&gt;RelativeAt(Instruction::SizeInCodeUnits(Instruction::FORMAT)); \\ success = OP_##OPCODE_NAME&lt;do_access_check, transaction_active&gt;( \\ ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, exit); \\ if (success &amp;&amp; LIKELY(!interpret_one_instruction)) { \\ continue; \\ } \\ break; \\ } DEX_INSTRUCTION_LIST(OPCODE_CASE)#undef OPCODE_CASE } } ... }} ​ switch解释器，就是指的这个函数中，使用switch来对不同的所有操作码进行对应的处理，但是这里并没有看到非常大的case条件，这是因为代码都在OPCODE_CASE定义中，找到这个定义的实现如下。 123456789101112131415161718#define OPCODE_CASE(OPCODE, OPCODE_NAME, NAME, FORMAT, i, a, e, v) \\template&lt;bool do_access_check, bool transaction_active&gt; \\ASAN_NO_INLINE static bool OP_##OPCODE_NAME( \\ SwitchImplContext* ctx, \\ const instrumentation::Instrumentation* instrumentation, \\ Thread* self, \\ ShadowFrame&amp; shadow_frame, \\ uint16_t dex_pc, \\ const Instruction* inst, \\ uint16_t inst_data, \\ const Instruction*&amp; next, \\ bool&amp; exit) REQUIRES_SHARED(Locks::mutator_lock_) { \\ InstructionHandler&lt;do_access_check, transaction_active, Instruction::FORMAT&gt; handler( \\ ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, exit); \\ return LIKELY(handler.OPCODE_NAME()); \\}DEX_INSTRUCTION_LIST(OPCODE_CASE)#undef OPCODE_CASE ​ 可以看到内部是调用了初始化了一个InstructionHandler对象，然后handler.OPCODE_NAME()调用了对应的操作码函数。最后看看其实现。 123456789101112131415161718192021222324252627282930313233class InstructionHandler { ... ALWAYS_INLINE InstructionHandler(SwitchImplContext* ctx, const instrumentation::Instrumentation* instrumentation, Thread* self, ShadowFrame&amp; shadow_frame, uint16_t dex_pc, const Instruction* inst, uint16_t inst_data, const Instruction*&amp; next, bool&amp; exit_interpreter_loop) : ctx_(ctx), instrumentation_(instrumentation), self_(self), shadow_frame_(shadow_frame), dex_pc_(dex_pc), inst_(inst), inst_data_(inst_data), next_(next), exit_interpreter_loop_(exit_interpreter_loop) { } ... HANDLER_ATTRIBUTES bool INVOKE_STATIC() { return HandleInvoke&lt;kStatic, /*is_range=*/ false&gt;(); } HANDLER_ATTRIBUTES bool INVOKE_STATIC_RANGE() { return HandleInvoke&lt;kStatic, /*is_range=*/ true&gt;(); } ...} 所有操作码对应的实现都是在InstructionHandler中进行实现，switch解释器的做法非常简单粗暴，尽量性能较差，但是可读性高，当需求是对调用流程进行打桩，或者定制修改时，可以选择强制其走switch解释器来执行该函数。 需要注意的是，在执行的优化中，当强制走解释器流程调用后，它会交给JIT编译器进行编译，生成本地机器码。在生成机器码的同时，JIT编译器会将该函数的入口地址设置为生成的机器码的地址。在下一次调用该函数时，虚拟机就会跳过解释器阶段，直接执行机器码，从而提高程序的执行效率。 7.6 本章小结本章主要介绍了安卓系统中DEX文件的类的加载机制与细节。相比于实际操作动手修改代码，本章介绍的内容显示更加枯燥乏味，但是深入了解系统内部的运行机制，有助于更宏观视角的去理解的程序执行。掌握这一部分内容，在代码修改点的选择上，尤其是系统组件的部分代码，将会更加精准。而且，本章内容同样适合于二进制安全对抗研究领域，是研究软件加密与解密必不可少的基础知识。","link":"/2025/04/07/chapter-07/"},{"title":"View事件分发","text":"目录 MotionEvent 事件分发、拦截与消费 总流程 onTouch和onClick 源码分析： View.dispatchTouchEvent 总结： 事件分发源码解析： 事件：ACTION_DOWN 1.假设onInterceptTouchEvent没有拦截，这里intercepted为false; 2.假设onInterceptTouchEvent直接拦截，这里intercepted为true; 总结： 事件：ACTION_MOVE 1.假设onInterceptTouchEvent没有拦截 总结： 事件冲突 ViewGroup#onInterceptTouchEvent 冲突解决： 内部拦截法（在子View中解决） 内部拦截法总结： 外部拦截法（在父View中解决） MotionEvent 事件分发、拦截与消费 事件分发：Activity，ViewGroup， View 事件拦截： ViewGroup 事件消费：Activity， View 总流程 onTouch和onClick12345678910111213textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.e(&quot;Text&quot;, &quot;onClick&quot;); }});textView.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { Log.e(&quot;Text&quot;, &quot;onTouch&quot;+event.getAction()); return false; }}); 源码分析：View.dispatchTouchEvent12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean dispatchTouchEvent(MotionEvent event) { // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) { // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) { return false; } // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); } boolean result = false; if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { // Defensive cleanup for new gesture stopNestedScroll(); } if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } if (!result &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result;} 123456ListenerInfo li = mListenerInfo;if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true;} 这里li不等于空 在view.setOnTouchListener或setOnClickListener调用时 都会调用getListenerInfo()方法 123public void setOnTouchListener(OnTouchListener l) { getListenerInfo().mOnTouchListener = l;} 1234567ListenerInfo getListenerInfo() { if (mListenerInfo != null) { return mListenerInfo; } mListenerInfo = new ListenerInfo(); return mListenerInfo;} 所以这里li肯定不为空 (mViewFlags &amp; ENABLED_MASK) == ENABLED这里代表可view可用状态 所以li.mOnTouchListener.onTouch(this, event)这里如果返回为 为true时 result=true 123if (!result &amp;&amp; onTouchEvent(event)) { result = true;} 所以这里的onTouchEvent(event)方法就不会再走。 onTouchEvent中 1234567891011public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); ... case MotionEvent.ACTION_UP: if (!post(mPerformClick)) { performClickInternal(); }} performClickInternal–&gt;performClick 123456789101112131415161718192021public boolean performClick() { // We still need to call this method to handle the cases where performClick() was called // externally, instead of through performClickInternal() notifyAutofillManagerOnClick(); final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result;} 这里 li.mOnClickListener.onClick(this);调用了onClick方法，并返回true 总结：onTouch返回fasle时，调用onTouchEvent,再到onClick onTouch返回true时，不调用onTouchEvent和onClick onTouch=false—-&gt;onTouchEvent—-&gt;onClick onTouch=true 结束 事件分发源码解析：Activity#dispatchTouchEvent 123456789public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev);} getWindow().superDispatchTouchEvent(ev)–&gt;PhoneWindow#superDispatchTouchEvent 123public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event);} mDecor.superDispatchTouchEvent(event)–&gt;DecorView#superDispatchTouchEvent 123public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event);} 这里的dispatchTouchEvent–&gt;ViewGroup#dispatchTouchEvent 事件：ACTION_DOWN一进入down就会清除事件和状态 1234567if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();} 是否拦截的标识 1final boolean intercepted; 1.假设onInterceptTouchEvent没有拦截，这里intercepted为false;1234@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { return false;} 1234567891011121314if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; }} else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;} 12final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; 假设这里的canceled也为false(没有取消) 所以进入了这里 123456789101112131415161718192021TouchTarget newTouchTarget = null;boolean alreadyDispatchedToNewTouchTarget = false;if (!canceled &amp;&amp; !intercepted) { View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { } } 这里newTouchTarget为null,并且childrenCount也不可能为0 if (newTouchTarget == null &amp;&amp; childrenCount != 0)中 1final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); buildTouchDispatchChildList()方法对子View进行排序 12345678910111213for (int i = 0; i &lt; childrenCount; i++) { // add next child (in child order) to end of list final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View nextChild = mChildren[childIndex]; final float currentZ = nextChild.getZ(); // insert ahead of any Views with greater Z int insertIndex = i; while (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) { insertIndex--; } mPreSortedChildren.add(insertIndex, nextChild);} 这里Z轴越大越在数组后面，越小越在数组前面（页面上View越在上层越在数组后面，越底层越在数组前面） ​ 这里从排好序的preorderedList中，从最后往前取值（即先取z轴最上层的view） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false);} 这里判断取到的View是不是点击到的View（判断是否能够接收手指事件和点击区域是不是在View上） 不是的话继续循环拿取 12345if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue;} View.java 123protected boolean canReceivePointerEvents() { return (mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || getAnimation() != null;} 12345678910111213protected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint) { final float[] point = getTempPoint(); point[0] = x; point[1] = y; transformPointToViewLocal(point, child); // pointInView：x &gt;= 0 &amp;&amp; localY &gt;= 0 &amp;&amp; y &lt; ((mRight - mLeft) + 0) &amp;&amp;y &lt; ((mBottom - mTop) + 0) 判断触点是否在View上 final boolean isInView = child.pointInView(point[0], point[1]); if (isInView &amp;&amp; outLocalPoint != null) { outLocalPoint.set(point[0], point[1]); } return isInView;} 1234public boolean pointInView(float localX, float localY, float slop) { return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; ((mRight - mLeft) + slop) &amp;&amp; localY &lt; ((mBottom - mTop) + slop);} 这里获取TouchTarget，这里返回的还是空，因为mFirstTouchTarget初始为空 1newTouchTarget = getTouchTarget(child); 12345678private TouchTarget getTouchTarget(@NonNull View child) { for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) { if (target.child == child) { return target; } } return null;} dispatchTransformedTouchEvent –分发给谁处理事件 1dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign) 1234567891011121314151617181920212223private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; ... if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled;} 这里child不为空，所以就会调用child.dispatchTouchEvent(transformedEvent)–&gt;就到了上文onTouch和onClick的源码分析View.dispatchTouchEvent View.dispatchTouchEvent处理事件后，返回result为true 123if (!result &amp;&amp; onTouchEvent(event)) { result = true;} 就进入if，然后break;结束整个for循环，其他view就处理不了事件了。 1234567891011121314151617181920if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break;} 这里会调用addTouchTarget(),进行newTouchTarget赋值。 123456private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;} mFirstTouchTarget==newTouchTarget并且alreadyDispatchedToNewTouchTarget=true; 如果没有处理，当前循环就结束了， 进行下一次的for循环。 继续往下走：进入else了 12345678910111213141516171819202122232425262728293031323334if (mFirstTouchTarget == null) { handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);} else { TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; }} 1final TouchTarget next = target.next; 这里的next为null，最后target = next; 所以这里的while循环只会进入一次。（这里while是为多指触摸准备的，几个手指就会循环几次） 123if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } 这里都满足所以handled为true 最后返回 handled。整个Down事件就结束了。 2.假设onInterceptTouchEvent直接拦截，这里intercepted为true;1234@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { return true;} 1234567891011121314if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; }} else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;} 123if (!canceled &amp;&amp; !intercepted) { ...} 这里整个if语句都 不会进入 而且这里拦截了以后，ViewGroup的子View就不再往下分发事件（分发是在这个if中for循环中分发的） 这里mFirstTouchTarget为null， 12345if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);} 这里的child为null传入 1234567891011121314151617private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled;... // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } 所以会调用super.dispatchTouchEvent(transformedEvent); 即调用ViewGroup自己的dispatchTouchEvent方法来处理 总结：当ViewGroup#onInterceptTouchEvent为false时，就会调用子View的dispatchTouchEvent 当ViewGroup#onInterceptTouchEvent为true时，就会调用自身的dispatchTouchEvent 事件：ACTION_MOVE1.假设onInterceptTouchEvent没有拦截这里mFirstTouchTarget经过Down事件后不为null,所以intercepted为false 1234567891011121314if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; }} else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;} 进入下面if之前boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) 中直接进入下面 else中 123456789101112131415161718192021222324252627282930313233if (mFirstTouchTarget == null) { handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);} else { TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; }} 所以这里while走了else 12345678910111213141516171819202122232425while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next;} dispatchTransformedTouchEvent方法 中走了handled = child.dispatchTouchEvent(transformedEvent); 总结：当ViewGroup#onInterceptTouchEvent为false时，就会调用子View的dispatchTouchEvent 事件冲突ViewGroup#onInterceptTouchEventViewpager+Listview 冲突解决：内部拦截法（在子View中解决）1234567891011121314151617181920212223int mLastX;int mLastY;@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) { int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: getParent().requestDisallowInterceptTouchEvent(true);//请求不允许中断 break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if(Math.abs(deltaX)&gt; Math.abs(deltaY)){ //左右滑 getParent().requestDisallowInterceptTouchEvent(false);//允许中断 } break; } mLastX = x; mLastY = y; return super.dispatchTouchEvent(ev);} 12345678910111213141516171819@Overridepublic void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We're already in this state, assume our ancestors are too return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); }} 这里设置了 getParent().requestDisallowInterceptTouchEvent(true)后，disallowIntercept就为true，就不会走父View的onInterceptTouchEvent方法进行拦截，实现子View接收事件。 12345678910if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; }} 但是，不能在MotionEvent.ACTION_DOWN方法中设置。 在进入上面事件判断前会进行状态的初始化。所以在ACTION_DOWN事件中onInterceptTouchEvent肯定会执行。 1234if (actionMasked == MotionEvent.ACTION_DOWN) { cancelAndClearTouchTargets(ev); resetTouchState();} 解决方法：在父View中为ACTION_DOWN返回false 12345678@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { super.onInterceptTouchEvent(ev); return false; } return true;} 内部拦截法总结：MotionEvent.ACTION_DOWN时，父View中onInterceptTouchEvent设为false，子View调用getParent().requestDisallowInterceptTouchEvent(true);方法 MotionEvent.ACTION_MOVE时，父View中onInterceptTouchEvent设为true，非子View事件时getParent().requestDisallowInterceptTouchEvent(false);方法 外部拦截法（在父View中解决）在父View当中进行处理 1234567891011121314151617181920212223int mLastX;int mLastY;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: mLastX= (int) ev.getX(); mLastY= (int) ev.getY(); break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if (Math.abs(deltaX) &gt; Math.abs(deltaY)) { //左右滑 return true; } break; } return super.onInterceptTouchEvent(ev);}","link":"/2020/12/09/dispatch/"},{"title":"第三章 认识系统组件","text":"[转]安卓系统定制：从入门到实践 3.1 源码结构介绍 3.2 Android系统启动流程 3.3 内核启动 3.4 Init进程启动 3.5 init.rc 3.6 Zygote启动 3.7 Android app应用启动 3.8 了解Service 3.9 了解Framework 3.10 了解libcore 3.11 了解sepolicy 3.12 了解Linker 3.12.1 ELF文件格式 3.12.2 动态库加载流程 小结 在上一章的学习中，我们成功编译了Android12，以及对应的系统内核，并且通过多种方式刷入手机。接下来需要先对Android源码的根结构有一定的了解，了解结构有助于更快地定位和分析源码，同时能让开发人员更好地理解Android系统。在修改系统时，有些简单的功能（例如native中的文件读写、java类型的转换c++类型等）并不需要我们重新实现，因为这些需求大多数在Android系统源码中都有类似的实现，熟练掌握Android系统源码，了解系统中常用的那些功能性函数，可以大大提高定制系统的效率。 在学习系统源码时，碰到问题，要学会暂时记录并跳过，经历过一遍遍学习和实践后，之前遇到的问题可能简单思考便会明白，这不仅节省了时间，也不会在学习过程中逐渐失去信心。 3.1 源码结构介绍​ 首先看看Android源码根目录下，各个目录的简单介绍。 art：该目录是在Android 5.0中新增加的，主要是实现Android RunTime（ART）的目录，它作为Android 4.4中的Dalvik虚拟机的替代，主要处理Java字节码执行。 bionic：Android的C库，包含了很多标准的C库函数和头文件，还有一些Android特有的函数和头文件。 build：该目录包含了编译Android源代码所需要的脚本，包括makefile文件和一些构建工具。 compatibility：Android设备的兼容性测试套件（CTS）和兼容性实现（Compatibility Implementation）。 cts：Android设备兼容性测试套件（CTS），主要用来测试设备是否符合Android标准。 dalvik：Dalvik虚拟机，它是Android 2.3版本之前的主要虚拟机，它主要处理Java字节码执行。 developers：Android开发者文档和样例代码。 development：调试工具，如systrace、monkey、ddms等。 device：特定的Android设备的驱动程序。 external：第三方库，如WebKit、OpenGL等。 frameworks：Android应用程序调用底层服务的API。 hardware：Android设备硬件相关的驱动代码，如摄像头驱动、蓝牙驱动等。 kernel：Android系统内核的源代码，它是Android系统的核心部分。 libcore：Android底层库，它提供了一些基本的API，如文件系统操作、网络操作等。 packages：Android系统中的系统应用程序的源码，例如短信、电话、浏览器、相机等 pdk：Android平台开发套件，它包含了一些工具和API，以便开发者快速开发Android应用程序。 platform_testing：测试工具，用于测试Android平台的稳定性和性能。 prebuilts：预先编译的文件，如编译工具、驱动程序等。 sdk：Android SDK的源代码，Android SDK的API文档、代码示例、工具等。 system：Android系统的核心部分，如系统服务、应用程序、内存管理机制、文件系统、网络协议等。 test：测试代码，用于测试Android系统的各个组件。 toolchain：编译器和工具链，如GCC、Clang等，用于编译Android源代码。 tools：开发工具，如Android SDK工具、Android Studio、Eclipse等。 vendor：硬件厂商提供的驱动程序，如摄像头驱动、蓝牙驱动等。 ​ 在上述目录中，并不需要全部记下，只需要记住几个重点即可，例如art、framework、libcore、system、build。在实践时，为了实现功能，查阅翻读源码时，就会不断加深你对这些目录划分的了解。 3.2 Android系统启动流程​ Android系统启动主要分为四个阶段：Bootloader阶段、Kernel阶段、Init进程阶段和System Server启动阶段，下面看一下这几个阶段的启动流程。 Bootloader阶段： 当手机或平板电脑开机时，首先会执行引导加载程序（Bootloader），它会在手机的ROM中寻找启动内核（Kernel）的镜像文件，并将其加载进RAM。在这个阶段，Android系统并没有完全启动，只是建立了基本的硬件和内核环境。 Kernel阶段： Kernel阶段是Android启动的第二阶段，它主要负责初始化硬件设备、加载驱动程序、设置内存管理等。此外，Kernel还会加载initramfs，它是一个临时文件系统，包含了init程序和一些设备文件。 Init进程阶段： Kernel会启动init进程，它是Android系统中的第一个用户空间进程。Init进程的主要任务是读取init.rc文件，并根据该文件中的配置信息启动和配置Android系统的各个组件。在这个阶段中，系统会依次启动各个服务和进程，包括启动Zygote进程和创建System Server进程。 System Server启动阶段： System Server是Android系统的核心服务进程，它会启动所有的系统服务。其中包括Activity Manager、Package Manager、Window Manager、Location Manager、Telephony Manager、Wi-Fi Service、Bluetooth Service等。System Server启动后，Android系统就完全启动了，用户可以进入桌面，开始使用各种应用程序。 ​ 在开始启动流程代码追踪前，最重要的是不要试图了解所有细节过程，分析代码时要抓住需求重点，然后围绕着需求点来进行深入分析。尽管Android源码是一个非常庞大的体系，选择一个方向来熟悉代码，这样就能快速的达成目标，避免深陷代码泥沼。 3.3 内核启动​ Bootloader其实是一段程序，这个程序的主要功能就是用来引导系统启动，也称之为引导程序，而这个引导程序是存放在一个只读的寄存器中，从物理地址0开始的一段空间分配给了这个只读存储器来存放引导程序。 ​ Bootloader会初始化硬件设备并准备内存空间映射，为启动内核准备环境。然后寻找内核的镜像文件，验证boot分区和recovery分区的完整性，然后将其加载到内存中，最后开始执行内核。可以通过命令adb reboot bootloader直接重启进入引导程序。 ​ Bootloader初始化完成后，会在特定的物理地址处查找EFI引导头（efi_head）。如果查找到EFI引导头，bootloader就会加载EFI引导头指定的EFI引导程序，然后开始执行EFI引导程序，以进行后续的EFI引导流程。而这个efi_head就是linux内核最早的入口了。 ​ 不做系统引导开发的朋友，并不需要完全看懂内核中的汇编部分代码，了解其执行的流程即可，因此不需要读者有汇编的功底，只需要能看懂简单的几个指令即可。打开编译内核源码时的目录，找到文件android-kernel/private/msm-google/arch/arm64/kernel/head.S，查看其汇编代码如下。 1234567891011121314 __HEAD_head: /* * DO NOT MODIFY. Image header expected by Linux boot-loaders. */#ifdef CONFIG_EFI /* * This add instruction has no meaningful effect except that * its opcode forms the magic &quot;MZ&quot; signature required by UEFI. */ add x13, x18, #0x16 b stext#else b stext // branch to kernel start, magic ​ 在arm指令集中，指令b表示跳转，所以，继续找到stext的定义。 1234567891011121314151617181920212223242526 /* * The following callee saved general purpose registers are used on the * primary lowlevel boot path: * * Register Scope Purpose * x21 stext() .. start_kernel() FDT pointer passed at boot in x0 * x23 stext() .. start_kernel() physical misalignment/KASLR offset * x28 __create_page_tables() callee preserved temp register * x19/x20 __primary_switch() callee preserved temp registers */ENTRY(stext) bl preserve_boot_args // 把引导程序传的4个参数保存在全局数组boot_args bl el2_setup // Drop to EL1, w0=cpu_boot_mode adrp x23, __PHYS_OFFSET and x23, x23, MIN_KIMG_ALIGN - 1 // KASLR offset, defaults to 0 bl set_cpu_boot_mode_flag bl __create_page_tables // 创建页表映射 x25=TTBR0, x26=TTBR1 /* * The following calls CPU setup code, see arch/arm64/mm/proc.S for * details. * On return, the CPU will be ready for the MMU to be turned on and * the TCR will have been set. */ bl __cpu_setup // // 初始化处理器 initialise processor b __primary_switchENDPROC(stext) ​ 能看到最后一行是跳转到__primary_switch，接下来继续看它的实现代码 12345678910111213141516171819202122232425262728293031323334353637383940__primary_switch:#ifdef CONFIG_RANDOMIZE_BASE mov x19, x0 // preserve new SCTLR_EL1 value mrs x20, sctlr_el1 // preserve old SCTLR_EL1 value#endif bl __enable_mmu#ifdef CONFIG_RELOCATABLE bl __relocate_kernel#ifdef CONFIG_RANDOMIZE_BASE ldr x8, =__primary_switched //将x8设置成__primary_switched的地址 adrp x0, __PHYS_OFFSET blr x8 //调用__primary_switched /* * If we return here, we have a KASLR displacement in x23 which we need * to take into account by discarding the current kernel mapping and * creating a new one. */ msr sctlr_el1, x20 // disable the MMU isb bl __create_page_tables // recreate kernel mapping tlbi vmalle1 // Remove any stale TLB entries dsb nsh isb msr sctlr_el1, x19 // re-enable the MMU isb ic iallu // flush instructions fetched dsb nsh // via old mapping isb bl __relocate_kernel#endif#endif ldr x8, =__primary_switched adrp x0, __PHYS_OFFSET br x8ENDPROC(__primary_switch) ​ 继续跟踪__primary_switched函数，就能看到调用重点函数start_kernel了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647__primary_switched: adrp x4, init_thread_union add sp, x4, #THREAD_SIZE adr_l x5, init_task msr sp_el0, x5 // Save thread_info adr_l x8, vectors // load VBAR_EL1 with virtual msr vbar_el1, x8 // vector table address isb stp xzr, x30, [sp, #-16]! mov x29, sp#ifdef CONFIG_SHADOW_CALL_STACK adr_l x18, init_shadow_call_stack // Set shadow call stack#endif str_l x21, __fdt_pointer, x5 // Save FDT pointer ldr_l x4, kimage_vaddr // Save the offset between sub x4, x4, x0 // the kernel virtual and str_l x4, kimage_voffset, x5 // physical mappings // Clear BSS adr_l x0, __bss_start mov x1, xzr adr_l x2, __bss_stop sub x2, x2, x0 bl __pi_memset dsb ishst // Make zero page visible to PTW#ifdef CONFIG_KASAN bl kasan_early_init#endif#ifdef CONFIG_RANDOMIZE_BASE tst x23, ~(MIN_KIMG_ALIGN - 1) // already running randomized? b.ne 0f mov x0, x21 // pass FDT address in x0 mov x1, x23 // pass modulo offset in x1 bl kaslr_early_init // parse FDT for KASLR options cbz x0, 0f // KASLR disabled? just proceed orr x23, x23, x0 // record KASLR offset ldp x29, x30, [sp], #16 // we must enable KASLR, return ret // to __primary_switch()0:#endif b start_kernel // 内核的入口函数ENDPROC(__primary_switched) ​ 上面能看到最后一个指令就是调用start_kernel了，这个函数是内核的入口函数，同时也是C语言部分的入口函数。接下来，查看文件android-kernel/private/msm-google/init/main.c，可以看到其中大量的init初始化各种子系统的函数调用。 12345678910asmlinkage __visible void __init start_kernel(void){ // 加载各种子系统 ... /* Do the rest non-__init'ed, we're now alive */ rest_init(); prevent_tail_call_optimization();} ​ 继续追踪关键的函数rest_init，在这里开启的内核初始化线程以及创建内核线程。 12345678static noinline void __ref rest_init(void){ ... kernel_thread(kernel_init, NULL, CLONE_FS); numa_default_policy(); pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); ...} ​ 继续看看kernel_init内核初始化线程的实现。 123456789101112static int __ref kernel_init(void *unused){ int ret; ... if (ramdisk_execute_command) { ret = run_init_process(ramdisk_execute_command); if (!ret) return 0; pr_err(&quot;Failed to execute %s (error %d)\\n&quot;, ramdisk_execute_command, ret); }} ​ 在这里，看到了原来init进程是用run_init_process启动的，ramdisk_execute_command被初始化为了”/init”。 12345678910111213static int try_to_run_init_process(const char *init_filename){ int ret; ret = run_init_process(init_filename); if (ret &amp;&amp; ret != -ENOENT) { pr_err(&quot;Starting init: %s exists but couldn't execute it (error %d)\\n&quot;, init_filename, ret); } return ret;} 这里简单包装调用的run_init_process，继续看下面的代码 1234567static int run_init_process(const char *init_filename){ argv_init[0] = init_filename; return do_execve(getname_kernel(init_filename), (const char __user *const __user *)argv_init, (const char __user *const __user *)envp_init);} ​ 这里能看到最后是通过execve拉起来了系统的第一个进程，init进程。总结内核启动的简单流程图如下。 3.4 Init进程启动​ init进程是Android系统的第一个进程，它在系统启动之后就被启动，并且一直运行到系统关闭，它是Android系统的核心进程，隶属于系统进程，具有最高的权限，所有的其他进程都是它的子进程，它的主要功能有以下几点： ​ 1、启动Android系统的基础服务：init进程负责启动Android系统的基础服务。 ​ 2、管理系统进程：init进程管理系统进程，比如启动和关闭系统进程。 ​ 3、加载设备驱动：init进程会加载设备的驱动，使设备可以正常使用。 ​ 4、加载系统环境变量：init进程会加载系统所需要的环境变量，如PATH、LD_LIBRARY_PATH等。 ​ 5、加载系统配置文件：init进程会加载系统所需要的配置文件。 ​ 6、启动用户进程：init进程会启动用户进程，如桌面程序、默认浏览器等。 ​ init进程的入口是在Android源码的system/core/init/main.cpp。下面，看看入口函数的实现。 1234567891011121314151617181920212223242526272829int main(int argc, char** argv) {#if __has_feature(address_sanitizer) __asan_set_error_report_callback(AsanReportCallback);#endif // Boost prio which will be restored later setpriority(PRIO_PROCESS, 0, -20); if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) { return ueventd_main(argc, argv); } if (argc &gt; 1) { if (!strcmp(argv[1], &quot;subcontext&quot;)) { android::base::InitLogging(argv, &amp;android::base::KernelLogger); const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); return SubcontextMain(argc, argv, &amp;function_map); } // 第二步 装载selinux策略 if (!strcmp(argv[1], &quot;selinux_setup&quot;)) { return SetupSelinux(argv); } // 第三步 if (!strcmp(argv[1], &quot;second_stage&quot;)) { return SecondStageMain(argc, argv); } } // 第一步 挂载设备节点，初次进入没有参数将执行这里 return FirstStageMain(argc, argv);} ​ 根据上一章的启动init的参数，可以判断第一次启动时执行的是FirstStageMain函数，继续看看这个函数的实现，可以看到初始化了一些基础系统支持的目录，以及使用mount进行挂载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445int FirstStageMain(int argc, char** argv) { ... CHECKCALL(clearenv()); CHECKCALL(setenv(&quot;PATH&quot;, _PATH_DEFPATH, 1)); // Get the basic filesystem setup we need put together in the initramdisk // on / and then we'll let the rc file figure out the rest. CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;)); CHECKCALL(mkdir(&quot;/dev/pts&quot;, 0755)); CHECKCALL(mkdir(&quot;/dev/socket&quot;, 0755)); CHECKCALL(mkdir(&quot;/dev/dm-user&quot;, 0755)); CHECKCALL(mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL));#define MAKE_STR(x) __STRING(x) CHECKCALL(mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC)));#undef MAKE_STR // Don't expose the raw commandline to unprivileged processes. CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440)); std::string cmdline; android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline); // Don't expose the raw bootconfig to unprivileged processes. chmod(&quot;/proc/bootconfig&quot;, 0440); std::string bootconfig; android::base::ReadFileToString(&quot;/proc/bootconfig&quot;, &amp;bootconfig); gid_t groups[] = {AID_READPROC}; CHECKCALL(setgroups(arraysize(groups), groups)); CHECKCALL(mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL)); CHECKCALL(mount(&quot;selinuxfs&quot;, &quot;/sys/fs/selinux&quot;, &quot;selinuxfs&quot;, 0, NULL)); CHECKCALL(mknod(&quot;/dev/kmsg&quot;, S_IFCHR | 0600, makedev(1, 11))); ... // 重新调用拉起init进程，并且参数设置为selinux_setup const char* path = &quot;/system/bin/init&quot;; const char* args[] = {path, &quot;selinux_setup&quot;, nullptr}; auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); close(fd); // 使用execv再次调用init进程 execv(path, const_cast&lt;char**&gt;(args)); // execv() only returns if an error happened, in which case we // panic and never fall through this conditional. PLOG(FATAL) &lt;&lt; &quot;execv(\\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;) failed&quot;; return 1;} ​ 在目录初始化完成后又拉起了一个init进程，并且传入参数selinux_setup，接下来，直接看前面main入口函数中判断出现该参数时调用的SetupSelinux函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int SetupSelinux(char** argv) { SetStdioToDevNull(argv); InitKernelLogging(argv); ... LOG(INFO) &lt;&lt; &quot;Opening SELinux policy&quot;; // Read the policy before potentially killing snapuserd. std::string policy; ReadPolicy(&amp;policy); auto snapuserd_helper = SnapuserdSelinuxHelper::CreateIfNeeded(); if (snapuserd_helper) { // Kill the old snapused to avoid audit messages. After this we cannot // read from /system (or other dynamic partitions) until we call // FinishTransition(). snapuserd_helper-&gt;StartTransition(); } LoadSelinuxPolicy(policy); if (snapuserd_helper) { // Before enforcing, finish the pending snapuserd transition. snapuserd_helper-&gt;FinishTransition(); snapuserd_helper = nullptr; } SelinuxSetEnforcement(); // We're in the kernel domain and want to transition to the init domain. File systems that // store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here, // but other file systems do. In particular, this is needed for ramdisks such as the // recovery image for A/B devices. if (selinux_android_restorecon(&quot;/system/bin/init&quot;, 0) == -1) { PLOG(FATAL) &lt;&lt; &quot;restorecon failed of /system/bin/init failed&quot;; } setenv(kEnvSelinuxStartedAt, std::to_string(start_time.time_since_epoch().count()).c_str(), 1); // 继续再拉起一个init进程,参数设置second_stage const char* path = &quot;/system/bin/init&quot;; const char* args[] = {path, &quot;second_stage&quot;, nullptr}; execv(path, const_cast&lt;char**&gt;(args)); // execv() only returns if an error happened, in which case we // panic and never return from this function. PLOG(FATAL) &lt;&lt; &quot;execv(\\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;) failed&quot;; return 1;} ​ 上面的代码可以看到，在完成selinux的加载处理后，又拉起了一个init进程，并且传入参数second_stage。接下来，看第三步SecondStageMain函数。 123456789101112131415int SecondStageMain(int argc, char** argv) { ... // 初始化属性系统 PropertyInit(); // 开启属性服务 StartPropertyService(&amp;property_fd); // 解析init.rc 以及启动其他相关进程 LoadBootScripts(am, sm); ... return 0;} ​ 继续跟踪LoadBootScripts函数，了解它是如何解析执行init.rc文件的。（修改的意思是否正确？） 12345678910111213141516171819202122232425262728static void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list) { Parser parser = CreateParser(action_manager, service_list); std::string bootscript = GetProperty(&quot;ro.boot.init_rc&quot;, &quot;&quot;); if (bootscript.empty()) { // 解析各目录中的init.rc parser.ParseConfig(&quot;/system/etc/init/hw/init.rc&quot;); if (!parser.ParseConfig(&quot;/system/etc/init&quot;)) { late_import_paths.emplace_back(&quot;/system/etc/init&quot;); } // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext. parser.ParseConfig(&quot;/system_ext/etc/init&quot;); if (!parser.ParseConfig(&quot;/vendor/etc/init&quot;)) { late_import_paths.emplace_back(&quot;/vendor/etc/init&quot;); } if (!parser.ParseConfig(&quot;/odm/etc/init&quot;)) { late_import_paths.emplace_back(&quot;/odm/etc/init&quot;); } if (!parser.ParseConfig(&quot;/product/etc/init&quot;)) { late_import_paths.emplace_back(&quot;/product/etc/init&quot;); } } else { parser.ParseConfig(bootscript); }} ​ 继续看看解析的逻辑，可以看到参数可以是目录或者文件。 123456bool Parser::ParseConfig(const std::string&amp; path) { if (is_dir(path.c_str())) { return ParseConfigDir(path); } return ParseConfigFile(path);} ​ 如果是目录，则遍历所有文件再调用解析文件，所以直接看ParseConfigFile就好了。 12345bool Parser::ParseConfigFile(const std::string&amp; path) { ... ParseData(path, &amp;config_contents.value()); ...} ​ 最后看看ParseData是如何解析数据的。 1234567891011121314151617181920212223242526272829303132333435363738394041void Parser::ParseData(const std::string&amp; filename, std::string* data) { ... for (;;) { switch (next_token(&amp;state)) { case T_EOF: ... return; case T_NEWLINE: { ... else if (section_parsers_.count(args[0])) { end_section(); // 从section_parsers_中获取出来的 section_parser = section_parsers_[args[0]].get(); section_start_line = state.line; // 使用了ParseSection进行解析 if (auto result = section_parser-&gt;ParseSection(std::move(args), filename, state.line); !result.ok()) { parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; state.line &lt;&lt; &quot;: &quot; &lt;&lt; result.error(); section_parser = nullptr; bad_section_found = true; } } else if (section_parser) { // 使用了ParseLineSection进行解析 if (auto result = section_parser-&gt;ParseLineSection(std::move(args), state.line); !result.ok()) { parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; state.line &lt;&lt; &quot;: &quot; &lt;&lt; result.error(); } } ... } case T_TEXT: args.emplace_back(state.text); break; } }} ​ 简单解读一下这里的代码，首先这里看到从section_parsers_中取出对应的节点解析对象section_parser，通过section_parser执行ParseSection或者ParseLineSection函数解析.rc文件中的数据。所以需要了解section_parsers_中存储的是什么，查看函数CreateParser就明白了。所谓的节点解析对象，就是ServiceParser、ActionParser、ImportParser。 123456789101112131415void Parser::AddSectionParser(const std::string&amp; name, std::unique_ptr&lt;SectionParser&gt; parser) { section_parsers_[name] = std::move(parser);}Parser CreateParser(ActionManager&amp; action_manager, ServiceList&amp; service_list) { Parser parser; parser.AddSectionParser(&quot;service&quot;, std::make_unique&lt;ServiceParser&gt;( &amp;service_list, GetSubcontext(), std::nullopt)); parser.AddSectionParser(&quot;on&quot;, std::make_unique&lt;ActionParser&gt;(&amp;action_manager, GetSubcontext())); parser.AddSectionParser(&quot;import&quot;, std::make_unique&lt;ImportParser&gt;(&amp;parser)); return parser;} ​ 如果了解过init.rc文件格式的，看到这里就很眼熟了，这就是.rc文件中配置时使用的节点名称了。它们的功能的简单描述如下。 service 定义一个服务 on 触发某个action时，执行对应的指令 import 表示导入另外一个rc文件 ​ 再解读上面的代码就是，根据rc文件的配置不同，使用ServiceParser、ActionParser、ImportParser这三种节点解析对象的ParseSection或者ParseLineSection函数来处理（这句不完整？）。继续看看这三个对象的解析函数实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// service节点的解析处理Result&lt;void&gt; ServiceParser::ParseSection(std::vector&lt;std::string&gt;&amp;&amp; args, const std::string&amp; filename, int line) { if (args.size() &lt; 3) { return Error() &lt;&lt; &quot;services must have a name and a program&quot;; } const std::string&amp; name = args[1]; if (!IsValidName(name)) { return Error() &lt;&lt; &quot;invalid service name '&quot; &lt;&lt; name &lt;&lt; &quot;'&quot;; } filename_ = filename; Subcontext* restart_action_subcontext = nullptr; if (subcontext_ &amp;&amp; subcontext_-&gt;PathMatchesSubcontext(filename)) { restart_action_subcontext = subcontext_; } std::vector&lt;std::string&gt; str_args(args.begin() + 2, args.end()); if (SelinuxGetVendorAndroidVersion() &lt;= __ANDROID_API_P__) { if (str_args[0] == &quot;/sbin/watchdogd&quot;) { str_args[0] = &quot;/system/bin/watchdogd&quot;; } } if (SelinuxGetVendorAndroidVersion() &lt;= __ANDROID_API_Q__) { if (str_args[0] == &quot;/charger&quot;) { str_args[0] = &quot;/system/bin/charger&quot;; } } service_ = std::make_unique&lt;Service&gt;(name, restart_action_subcontext, str_args, from_apex_); return {};}// on 节点的解析处理Result&lt;void&gt; ActionParser::ParseSection(std::vector&lt;std::string&gt;&amp;&amp; args, const std::string&amp; filename, int line) { std::vector&lt;std::string&gt; triggers(args.begin() + 1, args.end()); if (triggers.size() &lt; 1) { return Error() &lt;&lt; &quot;Actions must have a trigger&quot;; } Subcontext* action_subcontext = nullptr; if (subcontext_ &amp;&amp; subcontext_-&gt;PathMatchesSubcontext(filename)) { action_subcontext = subcontext_; } std::string event_trigger; std::map&lt;std::string, std::string&gt; property_triggers; if (auto result = ParseTriggers(triggers, action_subcontext, &amp;event_trigger, &amp;property_triggers); !result.ok()) { return Error() &lt;&lt; &quot;ParseTriggers() failed: &quot; &lt;&lt; result.error(); } auto action = std::make_unique&lt;Action&gt;(false, action_subcontext, filename, line, event_trigger, property_triggers); action_ = std::move(action); return {};}// import节点的解析处理Result&lt;void&gt; ImportParser::ParseSection(std::vector&lt;std::string&gt;&amp;&amp; args, const std::string&amp; filename, int line) { if (args.size() != 2) { return Error() &lt;&lt; &quot;single argument needed for import\\n&quot;; } auto conf_file = ExpandProps(args[1]); if (!conf_file.ok()) { return Error() &lt;&lt; &quot;Could not expand import: &quot; &lt;&lt; conf_file.error(); } LOG(INFO) &lt;&lt; &quot;Added '&quot; &lt;&lt; *conf_file &lt;&lt; &quot;' to import list&quot;; if (filename_.empty()) filename_ = filename; imports_.emplace_back(std::move(*conf_file), line); return {};} ​ 到这里大致的init进程的启动流程相信大家已经有了一定了解。明白init的原理后，对于init.rc相信大家已经有了简单的印象，接下来将详细展开讲解init.rc文件。 3.5 init.rc​ init.rc是Android系统中的一个脚本文件而并非配置文件，是一种名为Android Init Language的脚本语言写成的文件，当然也可以简单当作配置文件来理解，主要用于启动和管理Android上的其他进程以对系统进行初始化工作。 ​ 将init.rc看作是init进程功能的动态延申，一些可能需要改动的初始化系统任务就放在配置文件中，然后读取配置解析后再进行初始化执行，如此可以提高一定的灵活性，相信很多开发人员在工作中都有做过类似的封装。而init.rc就是配置文件的入口，在init.rc中通过import节点来导入其他的配置文件，所以这些文件都可以算是init.rc的一部分。在上一章（确定是章？），通过了解init进程的工作流程，明白了解析init.rc文件的过程。 ​ init.rc是由多个section节点组成的，而节点的类型分别主要是service、on、import三种。上一节中，有简单的介绍，它们的作用分别是定义服务、事件触发、导入其他rc文件。下面，来看init.rc文件中的几个例子，查看文件system/core/rootdir/init.rc。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 导入另一个rc文件import /init.environ.rcimport /system/etc/init/hw/init.usb.rcimport /init.${ro.hardware}.rcimport /vendor/etc/init/hw/init.${ro.hardware}.rcimport /system/etc/init/hw/init.usb.configfs.rcimport /system/etc/init/hw/init.${ro.zygote}.rc...// 当初始化触发时,执行section下的命令on init sysclktz 0 # Mix device-specific information into the entropy pool copy /proc/cmdline /dev/urandom copy /system/etc/prop.default /dev/urandom symlink /proc/self/fd/0 /dev/stdin symlink /proc/self/fd/1 /dev/stdout symlink /proc/self/fd/2 /dev/stderr # Create energy-aware scheduler tuning nodes mkdir /dev/stune/foreground...// 当属性ro.debuggable变更为1时触发section内的命令on property:ro.debuggable=1 # Give writes to anyone for the trace folder on debug builds. # The folder is used to store method traces. chmod 0773 /data/misc/trace # Give reads to anyone for the window trace folder on debug builds. chmod 0775 /data/misc/wmtrace # Give reads to anyone for the accessibility trace folder on debug builds. chmod 0775 /data/misc/a11ytrace...// 定义系统服务 服务名称ueventd 服务路径/system/bin/ueventd// 服务类型core，关机行为critical，安全标签u:r:ueventd:s0service ueventd /system/bin/ueventd class core critical seclabel u:r:ueventd:s0 shutdown critical// 定义系统服务 服务名称console 服务路径/system/bin/sh// 服务类型core 服务状态disabled 服务所属用户shell 服务所属组shell log readproc// 安全标签u:r:shell:s0 设置环境变量HOSTNAME consoleservice console /system/bin/sh class core console disabled user shell group shell log readproc seclabel u:r:shell:s0 setenv HOSTNAME console ​ 看完各种节点的样例后，大概了解init.rc中应该如何添加一个section了。import非常简单，只需要指定一个rc文件的路径即可。on节点在源码中，看到对应的处理是ActionParser，这个节点就是当触发了一个Action的事件后就自上而下，依次执行节点下的所有命令，所以，就得了解一下一共有哪些Action事件提供使用。详细介绍参考自http://www.gaohaiyan.com/4047.html 123456789101112on boot #系统启动触发on early-init #在初始化之前触发on init #在初始化时触发（在启动配置文件/init.conf被装载之后）on late-init #在初始化晚期阶段触发on charger #当充电时触发on property:&lt;key&gt;=&lt;value&gt; #当属性值满足条件时触发on post-fs #挂载文件系统on post-fs-data #挂载dataon device-added-&lt;path&gt; #在指定设备被添加时触发on device-removed-&lt;path&gt; #在指定设备被移除时触发on service-exited-&lt;name&gt; #在指定service退出时触发on &lt;name&gt;=&lt;value&gt; #当属性&lt;name&gt;等于&lt;value&gt;时触发 ​ 在触发Action事件后可以执行的命令如下。 1234567891011121314151617181920212223chdir &lt;dirc&gt; 更改工作目录为&lt;dirc&gt;chmod &lt;octal-mode&gt; &lt;path&gt; 更改文件访问权限chown &lt;owner&gt; &lt;group&gt; &lt;path&gt; 更改文件所有者和组群chroot &lt;direc&gt; 更改根目录位置class_start &lt;serviceclass&gt; 如果它们不在运行状态的话，启动由&lt;serviceclass&gt;类名指定的所有相关服务class_stop &lt;serviceclass&gt; 如果它们在运行状态的话，停止domainname &lt;name&gt; 设置域名exec &lt;path&gt; [ &lt;argument&gt; ]* fork并执行一个程序，其路径为&lt;path&gt;，这条命令将阻塞直到该程序启动完成，因此它有可能造成init程序在某个节点不停地等待export &lt;name&gt; &lt;value&gt; 设置某个环境变量&lt;name&gt;的值为&lt;value&gt;，这是对全局有效的，即其后所有进程都将继承这个变量hostname &lt;name&gt; 设置主机名ifup &lt;interface&gt; 使网络接口&lt;interface&gt;成功连接import &lt;filename&gt; 引入一个名为&lt;filename&gt;的文件insmod &lt;path&gt; 在&lt;path&gt;路径上安装一个模块mkdir &lt;path&gt; [mode] [owner] [group] 在&lt;path&gt;路径上新建一个目录mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [&lt;mountoption&gt;]* 尝试在指定路径上挂载一个设备setprop &lt;name&gt; &lt;value&gt; 设置系统属性&lt;name&gt;的值为&lt;value&gt;setrlinit &lt;resource&gt; &lt;cur&gt; &lt;max&gt; 设置一种资源的使用限制。这个概念亦存在于Linux系统中，&lt;cur&gt;表示软限制，&lt;max&gt;表示硬限制start &lt;service&gt; 启动一个服务stop &lt;service&gt; 停止一个服务symlink &lt;target&gt; &lt;path&gt; 创建一个&lt;path&gt;路径的软链接，目标为&lt;target&gt;sysclk &lt;mins_west_of_gmt&gt; 设置基准时间，如果当前时间时GMT，这个值是0trigger &lt;event&gt; 触发一个事件write &lt;path&gt; &lt;string&gt; [&lt;string&gt;]* 打开一个文件，并写入字符串 ​ 而service节点主要是将可执行程序作为服务启动，上面的例子，看到节点下面有一系列的参数，下面是这些参数的详细描述。 12345678910class &lt;name&gt; 为该服务指定一个class名，同一个class的所有服务必须同时启动或者停止。 默认情况下服务的class名是“default”。另外还有core(其它服务依赖的基础性核心服务)、main(java须要的基本服务)、late_start(厂商定制的服务)critical 表示这是一个对设备至关重要的一个服务，如果它在四分钟内退出超过四次，则设备将重启进入恢复模式disabled 此服务不会自动启动，而是需要通过显式调用服务名来启动group &lt;groupname&gt; [&lt;groupname&gt;]* 在启动服务前将用户组切换为&lt;groupname&gt;oneshot 只启动一次，当此服务退出时，不要主动去重启它onrestart 当此服务重启时，执行某些命令setenv &lt;name&gt; &lt;value&gt; 设置环境变量&lt;name&gt;为某个值&lt;value&gt;socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [&lt;group&gt;]] 创建一个名为/dev/socket/&lt;name&gt;的unix domain socket，然后将它的fd值传给启动它的进程，有效的&lt;type&gt;值包括dgram，stream和seqacket，而user和group的默认值是0user &lt;username&gt; 在启动服务前将用户组切换为&lt;username&gt;，默认情况下用户都是root ​ 到这里，相信大家应该能够看懂init.rc中的大多数section的含义了。下面的例子将组合使用，定义一个自己的服务，并且启动它。 12345678910service kservice /system/bin/app_process -Djava.class.path=/system/framework/ksvr.jar /system/bin cn.ksvr.kSystemSvr svr class main user root group root oneshot seclabel u:r:su:s0on property:sys.boot_completed=1 bootchart stop start kservice ​ 上面的案例中，我定义了一个kservice的服务，使用/system/bin/app_process作为进程启动，并设置目标jar作为应用的classpath，最后设置jar文件的入口类cn.ksvr.kSystemSvr，最后的svr是做为参数传递给kSystemSvr中的main函数。接下来是当属性sys.boot_completed变更为1时表示手机完成引导，执行节点下的命令启动刚刚定义的服务。 3.6 Zygote启动​ 了解init.rc定义的原理后，就可以继续阅读init.rc追踪后续的启动流程了。 1234567891011121314151617181920# 导入含有zygote服务定义的rc文件，这个会根据系统所支持的对应架构导入import /system/etc/init/hw/init.${ro.zygote}.rc# init完成后触发zygote-start事件on late-init ... # Now we can start zygote for devices with file based encryption trigger zygote-start ...# zygote-start事件触发时执行的节点。最后启动了zygote和zygote_secondaryon zygote-start &amp;&amp; property:ro.crypto.state=unencrypted wait_for_prop odsign.verification.done 1 # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start statsd start netd start zygote start zygote_secondary ​ zygote服务定义的rc文件在路径system/core/rootdir/中。分别是init.zygote32.rc、init.zygote64.rc、init.zygote32_64.rc、init.zygote64_32.rc，下面查看zygote64的是如何定义的。 123456789101112131415161718// --zygote 传递给app_process程序的参数,表示这是启动一个孵化器。// --start-system-server 传递给app_process程序的参数，表示进程启动后需要启动system_server进程service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks critical window=${zygote.critical_window.minute:-off} target=zygote-fatal ​ 从定义中可以看到zygote进程实际启动的就是app_process进程。 ​ app_process是Android系统的主要进程，它是其他所有应用程序的容器，它负责创建新的进程，并启动它们。此外，它还管理应用程序的生命周期，防止任何一个应用程序占用资源过多，或者做出不良影响。app_process还负责在应用运行时为它们提供上下文，以及管理应用进程之间的通信。 ​ 跟踪app_process的实现，它的入口是在目录frameworks/base/cmds/app_process/app_main.cpp中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#if defined(__LP64__)static const char ABI_LIST_PROPERTY[] = &quot;ro.product.cpu.abilist64&quot;;static const char ZYGOTE_NICE_NAME[] = &quot;zygote64&quot;;#elsestatic const char ABI_LIST_PROPERTY[] = &quot;ro.product.cpu.abilist32&quot;;static const char ZYGOTE_NICE_NAME[] = &quot;zygote&quot;;#endifint main(int argc, char* const argv[]){ ... // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; ++i; // Skip unused &quot;parent dir&quot; argument. // 参数的处理 while (i &lt; argc) { const char* arg = argv[i++]; if (strcmp(arg, &quot;--zygote&quot;) == 0) { zygote = true; niceName = ZYGOTE_NICE_NAME; } else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) { startSystemServer = true; } else if (strcmp(arg, &quot;--application&quot;) == 0) { application = true; } else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) { niceName.setTo(arg + 12); } else if (strncmp(arg, &quot;--&quot;, 2) != 0) { className.setTo(arg); break; } else { --i; break; } } ... if (!niceName.isEmpty()) { runtime.setArgv0(niceName.string(), true /* setProcName */); } // 如果启动时设置--zygote，则启动ZygoteInit，否则启动RuntimeInit if (zygote) { const char* zygoteName=&quot;com.android.internal.os.ZygoteInit&quot;; runtime.start(zygoteName, args, zygote); } else if (className) { const char* zygoteName=&quot;com.android.internal.os.RuntimeInit&quot;; runtime.start(zygoteName, args, zygote); } else { fprintf(stderr, &quot;Error: no class name or --zygote supplied.\\n&quot;); app_usage(); LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;); }} ​ 从代码中可以看到主要是对参数进行处理包装后，然后根据是否携带--zygote选择启动ZygoteInit或者是RuntimeInit。 ​ ZygoteInit负责加载和初始化Android运行时环境，例如应用程序运行器、垃圾收集器等，并且它启动Android系统中的所有核心服务。 ​ RuntimeInit负责联系应用程序的执行环境与系统的运行环境，然后将应用程序的主类加载到运行时，最后将应用程序的控制权交给应用程序的主类。 ​ 下面继续看看runtime.start的实现，查看对应文件frameworks/base/core/jni/AndroidRuntime.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote){ ... //const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;); //ALOGD(&quot;Found LD_ASSUME_KERNEL='%s'\\n&quot;, kernelHack); /* 启动vm虚拟机 */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) { return; } onVmCreated(env); /* * 注册框架使用的JNI调用 */ if (startReg(env) &lt; 0) { ALOGE(&quot;Unable to register all android natives\\n&quot;); return; } ... char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) { ALOGE(&quot;JavaVM unable to locate class '%s'\\n&quot;, slashClassName); /* keep going */ } else { // 这里调用ZygoteInit或者是RuntimeInit的main函数 jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (startMeth == NULL) { ALOGE(&quot;JavaVM unable to find main() in '%s'\\n&quot;, className); /* keep going */ } else { env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env);#endif } } free(slashClassName); ALOGD(&quot;Shutting down VM\\n&quot;); if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(&quot;Warning: unable to detach main thread\\n&quot;); if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(&quot;Warning: VM did not shut down cleanly\\n&quot;);} ​ 通过JNI函数CallStaticVoidMethod调用了ZygoteInit的main入口函数，现在就来到了java层中，查看文件代码frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] argv) { ZygoteServer zygoteServer = null; ... try { ... if (!enableLazyPreload) { bootTimingsTraceLog.traceBegin(&quot;ZygotePreload&quot;); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); // 预加载资源，比如类、主题资源、字体资源等等 preload(bootTimingsTraceLog); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); bootTimingsTraceLog.traceEnd(); // ZygotePreload } ... Zygote.initNativeState(isPrimaryZygote); ZygoteHooks.stopZygoteNoThreadCreation(); // 创建socket服务端 zygoteServer = new ZygoteServer(isPrimaryZygote); // 前面在init.rc中有配置--start-system-server的进程则会进入fork启动SystemServer if (startSystemServer) { Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // {@code r == null} in the parent (zygote) process, and {@code r != null} in the // child (system_server) process. if (r != null) { r.run(); return; } } Log.i(TAG, &quot;Accepting command socket connections&quot;); // socket服务端等待AMS的请求，收到请求后就会由Zygote服务端来通过fork创建应用程序的进程 caller = zygoteServer.runSelectLoop(abiList); } catch (Throwable ex) { Log.e(TAG, &quot;System zygote died with fatal exception&quot;, ex); throw ex; } finally { if (zygoteServer != null) { zygoteServer.closeServerSocket(); } } // We're in the child process and have exited the select loop. Proceed to execute the // command. if (caller != null) { caller.run(); } } ​ 这里的重点是创建了zygoteServer，然后根据参数决定是否forkSystemServer，最后runSelectLoop等待AMS发送消息创建应用程序的进程。依次从代码观察它们的本质。首先是ZygoteServer的构造函数，可以看到，主要是创建Socket套接字。 123456789101112131415161718ZygoteServer(boolean isPrimaryZygote) { mUsapPoolEventFD = Zygote.getUsapPoolEventFD(); if (isPrimaryZygote) { mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME); mUsapPoolSocket = Zygote.createManagedSocketFromInitSocket( Zygote.USAP_POOL_PRIMARY_SOCKET_NAME); } else { mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME); mUsapPoolSocket = Zygote.createManagedSocketFromInitSocket( Zygote.USAP_POOL_SECONDARY_SOCKET_NAME); } mUsapPoolSupported = true; fetchUsapPoolPolicyProps(); } ​ 接着分析forkSystemServer，目的是了解返回值到底是什么，返回值的r.run()会调用到哪里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) { // 服务启动的相关参数，这里注意到类名是com.android.server.SystemServer String[] args = { &quot;--setuid=1000&quot;, &quot;--setgid=1000&quot;, &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,&quot; + &quot;1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011&quot;, &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities, &quot;--nice-name=system_server&quot;, &quot;--runtime-args&quot;, &quot;--target-sdk-version=&quot; + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT, &quot;com.android.server.SystemServer&quot;, }; ZygoteArguments parsedArgs; int pid; try { ... // 使用fork创建一个SystemServer进程 /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, null, parsedArgs.mPermittedCapabilities, parsedArgs.mEffectiveCapabilities); } catch (IllegalArgumentException ex) { throw new RuntimeException(ex); } /* For child process */ if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } zygoteServer.closeServerSocket(); // pid为0的部分，就是由这里fork出来的SystemServer执行的了。 return handleSystemServerProcess(parsedArgs); } return null; }private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) { ... ClassLoader cl = getOrCreateSystemServerClassLoader(); if (cl != null) { Thread.currentThread().setContextClassLoader(cl); } // 初始化SystemServer return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mDisabledCompatChanges, parsedArgs.mRemainingArgs, cl); ...}public static Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) { ... // 继续跟进去 return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader); }protected static Runnable applicationInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) { ... // 反射获取com.android.server.SystemServer的入口函数并返回 return findStaticMain(args.startClass, args.startArgs, classLoader);}// 可以看到就是通过反射，获取到对应类的main函数，最后封装到MethodAndArgsCaller返回protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) { Class&lt;?&gt; cl; try { cl = Class.forName(className, true, classLoader); } catch (ClassNotFoundException ex) { throw new RuntimeException( &quot;Missing class when invoking static main &quot; + className, ex); } Method m; try { m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class }); } catch (NoSuchMethodException ex) { throw new RuntimeException( &quot;Missing static main on &quot; + className, ex); } catch (SecurityException ex) { throw new RuntimeException( &quot;Problem getting static main on &quot; + className, ex); } int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) { throw new RuntimeException( &quot;Main method is not public and static on &quot; + className); } /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ return new MethodAndArgsCaller(m, argv);}// forkSystemServer最终返回的就是MethodAndArgsCaller对象static class MethodAndArgsCaller implements Runnable { /** method to call */ private final Method mMethod; /** argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) { mMethod = method; mArgs = args; } public void run() { try { mMethod.invoke(null, new Object[] { mArgs }); } catch (IllegalAccessException ex) { throw new RuntimeException(ex); } catch (InvocationTargetException ex) { Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) { throw (RuntimeException) cause; } else if (cause instanceof Error) { throw (Error) cause; } throw new RuntimeException(ex); } }} ​ forkSystemServer函数走到最后是通过反射获取com.android.server.SystemServer的入口函数main，并封装到MethodAndArgsCaller对象中返回。最后的返回结果调用run时，就会执行到SystemServer中的main函数。继续看看main函数的实现，查看文件frameworks/base/services/java/com/android/server/SystemServer.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public static void main(String[] args) { new SystemServer().run();}private void run() { ... // 创建主线程Looper Looper.prepareMainLooper(); // 初始化系统Context上下文 createSystemContext(); // 创建SystemServiceManager，由它管理系统的所有服务 mSystemServiceManager = new SystemServiceManager(mSystemContext); mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime); mDumper.addDumpable(mSystemServiceManager); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); ... // 启动各种服务 try { t.traceBegin(&quot;StartServices&quot;); // 启动引导服务 startBootstrapServices(t); // 启动核心服务 startCoreServices(t); // 启动其他服务 startOtherServices(t); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } finally { t.traceEnd(); // StartServices } ... // Loop forever. Looper.loop();}// 启动负责引导的服务private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) { t.traceBegin(&quot;startBootstrapServices&quot;); ... // 启动ActivityManagerService t.traceBegin(&quot;StartActivityManager&quot;); ActivityTaskManagerService atm = mSystemServiceManager.startService( ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( mSystemServiceManager, atm); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); mWindowManagerGlobalLock = atm.getGlobalLock(); t.traceEnd(); ...}private void startOtherServices(@NonNull TimingsTraceAndSlog t) { t.traceBegin(&quot;startOtherServices&quot;); ... // 从systemReady开始可以启动第三方应用 mActivityManagerService.systemReady(() -&gt; { ... }, t); ...}// 最后看看systemReady的处理// frameworks/base/services/java/com/android/server/am/ActivitymanagerService.javapublic void systemReady(final Runnable goingCallback, @NonNull TimingsTraceAndSlog t) { ... Slog.i(TAG, &quot;System now ready&quot;); ... // 启动多用户下的Home Activity，最终会开启系统应用Luncher桌面显示 if (bootingSystemUser) { t.traceBegin(&quot;startHomeOnAllDisplays&quot;); mAtmInternal.startHomeOnAllDisplays(currentUserId, &quot;systemReady&quot;); t.traceEnd(); } ...} ​ 到这里大致的服务启动流程就清楚了，最后成功抵达了Luncher的启动，重新回到流程中，继续看看runSelectLoop函数是如何实现的。 12345678910111213141516171819202122232425262728293031323334353637383940414243Runnable runSelectLoop(String abiList) { ... socketFDs.add(mZygoteSocket.getFileDescriptor()); peers.add(null); mUsapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP; while (true) { fetchUsapPoolPolicyPropsWithMinInterval(); mUsapPoolRefillAction = UsapPoolRefillAction.NONE; int[] usapPipeFDs = null; StructPollfd[] pollFDs; int pollReturnValue; try { pollReturnValue = Os.poll(pollFDs, pollTimeoutMs); } catch (ErrnoException ex) { throw new RuntimeException(&quot;poll failed&quot;, ex); } ... if (mUsapPoolRefillAction != UsapPoolRefillAction.NONE) { int[] sessionSocketRawFDs = socketFDs.subList(1, socketFDs.size()) .stream() .mapToInt(FileDescriptor::getInt$) .toArray(); final boolean isPriorityRefill = mUsapPoolRefillAction == UsapPoolRefillAction.IMMEDIATE; final Runnable command = fillUsapPool(sessionSocketRawFDs, isPriorityRefill); if (command != null) { return command; } else if (isPriorityRefill) { // Schedule a delayed refill to finish refilling the pool. mUsapPoolRefillTriggerTimestamp = System.currentTimeMillis(); } } } } ​ 重点主要放在返回值的跟踪上，直接看fillUsapPool函数做了些什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Runnable fillUsapPool(int[] sessionSocketRawFDs, boolean isPriorityRefill) { ... while (--numUsapsToSpawn &gt;= 0) { Runnable caller = Zygote.forkUsap(mUsapPoolSocket, sessionSocketRawFDs, isPriorityRefill); if (caller != null) { return caller; } } ... return null; }// 继续追踪关键返回值的函数forkUsap// 对应文件frameworks/base/core/java/com/android/internal/os/Zygote.javastatic @Nullable Runnable forkUsap(LocalServerSocket usapPoolSocket, int[] sessionSocketRawFDs, boolean isPriorityFork) { FileDescriptor readFD; FileDescriptor writeFD; try { FileDescriptor[] pipeFDs = Os.pipe2(O_CLOEXEC); readFD = pipeFDs[0]; writeFD = pipeFDs[1]; } catch (ErrnoException errnoEx) { throw new IllegalStateException(&quot;Unable to create USAP pipe.&quot;, errnoEx); } // 这里fork出一个子进程并初始化信息，最后返回pid int pid = nativeForkApp(readFD.getInt$(), writeFD.getInt$(), sessionSocketRawFDs, /*argsKnown=*/ false, isPriorityFork); if (pid == 0) { IoUtils.closeQuietly(readFD); // 如果是子进程就调用childMain获取返回值 return childMain(null, usapPoolSocket, writeFD); } else if (pid == -1) { // Fork failed. return null; } else { // readFD will be closed by the native code. See removeUsapTableEntry(); IoUtils.closeQuietly(writeFD); nativeAddUsapTableEntry(pid, readFD.getInt$()); return null; } }// 继续看childMain的实现private static Runnable childMain(@Nullable ZygoteCommandBuffer argBuffer, @Nullable LocalServerSocket usapPoolSocket, FileDescriptor writePipe) { ... // 初始化应用程序环境，设置应用程序上下文，初始化应用程序线程等等 specializeAppProcess(args.mUid, args.mGid, args.mGids, args.mRuntimeFlags, rlimits, args.mMountExternal, args.mSeInfo, args.mNiceName, args.mStartChildZygote, args.mInstructionSet, args.mAppDataDir, args.mIsTopApp, args.mPkgDataInfoList, args.mAllowlistedDataInfoList, args.mBindMountAppDataDirs, args.mBindMountAppStorageDirs); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // 又看到这个了，在SystemServer的启动中，之前追踪过 // 这里最后是反射获取某个java类的main函数封装后返回 return ZygoteInit.zygoteInit(args.mTargetSdkVersion, args.mDisabledCompatChanges, args.mRemainingArgs, null /* classLoader */); } ​ 前面分析过了zygoteInit函数，所以这里就不需要再继续进去看了，看看孵化器进程是如何初始化应用程序环境的，追踪specializeAppProcess函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private static void specializeAppProcess(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, boolean startChildZygote, String instructionSet, String appDataDir, boolean isTopApp, String[] pkgDataInfoList, String[] allowlistedDataInfoList, boolean bindMountAppDataDirs, boolean bindMountAppStorageDirs) { // 参数传递到了native层进行初始化处理了。 nativeSpecializeAppProcess(uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList, allowlistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs); ... }// 继续查看nativeSpecializeAppProcess// 文件所在frameworks/base/core/jni/com_android_internal_os_Zygote.cppstatic void com_android_internal_os_Zygote_nativeSpecializeAppProcess( JNIEnv* env, jclass, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray allowlisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs) { jlong capabilities = CalculateCapabilities(env, uid, gid, gids, is_child_zygote); SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits, capabilities, capabilities, mount_external, se_info, nice_name, false, is_child_zygote == JNI_TRUE, instruction_set, app_data_dir, is_top_app == JNI_TRUE, pkg_data_info_list, allowlisted_data_info_list, mount_data_dirs == JNI_TRUE, mount_storage_dirs == JNI_TRUE);}// 继续查看SpecializeCommon实现static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities, jint mount_external, jstring managed_se_info, jstring managed_nice_name, bool is_system_server, bool is_child_zygote, jstring managed_instruction_set, jstring managed_app_data_dir, bool is_top_app, jobjectArray pkg_data_info_list, jobjectArray allowlisted_data_info_list, bool mount_data_dirs, bool mount_storage_dirs) { const char* process_name = is_system_server ? &quot;system_server&quot; : &quot;zygote&quot;; auto fail_fn = std::bind(ZygoteFailure, env, process_name, managed_nice_name, _1); auto extract_fn = std::bind(ExtractJString, env, process_name, managed_nice_name, _1); auto se_info = extract_fn(managed_se_info); auto nice_name = extract_fn(managed_nice_name); auto instruction_set = extract_fn(managed_instruction_set); auto app_data_dir = extract_fn(managed_app_data_dir); // 在这里的nick_name就是应用的包名了 const char* nice_name_ptr = nice_name.has_value() ? nice_name.value().c_str() : nullptr; // 如果是系统服务，就初始化系统服务的classloader if (is_system_server) { // Prefetch the classloader for the system server. This is done early to // allow a tie-down of the proper system server selinux domain. env-&gt;CallStaticObjectMethod(gZygoteInitClass, gGetOrCreateSystemServerClassLoader); if (env-&gt;ExceptionCheck()) { // Be robust here. The Java code will attempt to create the classloader // at a later point (but may not have rights to use AoT artifacts). env-&gt;ExceptionClear(); } } ... if (selinux_android_setcontext(uid, is_system_server, se_info_ptr, nice_name_ptr) == -1) { fail_fn(CREATE_ERROR(&quot;selinux_android_setcontext(%d, %d, \\&quot;%s\\&quot;, \\&quot;%s\\&quot;) failed&quot;, uid, is_system_server, se_info_ptr, nice_name_ptr)); } // Make it easier to debug audit logs by setting the main thread's name to the // nice name rather than &quot;app_process&quot;. if (nice_name.has_value()) { SetThreadName(nice_name.value()); } else if (is_system_server) { SetThreadName(&quot;system_server&quot;); } // 调用java层的callPostForkChildHooks函数 // 这个函数主要用来在新创建的子进程中调用回调函数进行初始化。 env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags, is_system_server, is_child_zygote, managed_instruction_set); ...} ​ 可以在这里插入一个日志，看看在android启动完成时，孵化出了哪些进程。 123env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags, is_system_server, is_child_zygote, managed_instruction_set);ALOGW(&quot;start CallStaticVoidMethod current process:%s&quot;, nice_name_ptr); ​ 然后编译aosp后刷入手机中。 1234567891011121314// 执行脚本初始化编译环境source ./build/envsetup.sh// 选择要编译的版本lunch aosp_blueline-userdebug// 多线程编译make -j$(nproc --all)// 设置刷机目录export ANDROID_PRODUCT_OUT=~/android_src/out/target/product/blueline// 手机重启进入bootloaderadb reboot bootloader// 查看手机是否已经进入bootloader了fastboot devices// 将刚刚编译的系统刷入手机fastboot flashall -w 使用android studio的logcat查看日志，或者直接使用命令adb logcat &gt; tmp.log将日志输出到文件中，再进行观察。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647system_process W start CallStaticVoidMethod current process:(null)com.android.bluetooth W start CallStaticVoidMethod current process:com.android.bluetoothcom.android.systemui W start CallStaticVoidMethod current process:com.android.systemuipid-2292 W start CallStaticVoidMethod current process:WebViewLoader-armeabi-v7apid-2293 W start CallStaticVoidMethod current process:WebViewLoader-arm64-v8acom.android.networkstack W start CallStaticVoidMethod current process:com.android.networkstack.processcom.qualcomm.qti.telephonyservice W start CallStaticVoidMethod current process:com.qualcomm.qti.telephonyservicepid-2401 W start CallStaticVoidMethod current process:webview_zygotecom.android.se W start CallStaticVoidMethod current process:com.android.secom.android.phone W start CallStaticVoidMethod current process:com.android.phonecom.android.settings W start CallStaticVoidMethod current process:com.android.settingsandroid.ext.services W start CallStaticVoidMethod current process:android.ext.servicescom.android.launcher3 W start CallStaticVoidMethod current process:com.android.launcher3com....cellbroadcastreceiver.module W start CallStaticVoidMethod current process:com.android.cellbroadcastreceiver.modulecom.android.carrierconfig W start CallStaticVoidMethod current process:com.android.carrierconfigcom.android.providers.blockednumber W start CallStaticVoidMethod current process:android.process.acorepid-2859 W start CallStaticVoidMethod current process:com.android.deskclockpid-2899 W start CallStaticVoidMethod current process:com.android.nfcpid-2927 W start CallStaticVoidMethod current process:com.android.keychainpid-2944 W start CallStaticVoidMethod current process:com.android.providers.media.modulepid-3028 W start CallStaticVoidMethod current process:com.android.quicksearchboxpid-3059 W start CallStaticVoidMethod current process:com.android.printspoolerpid-3077 W start CallStaticVoidMethod current process:com.android.musicpid-3112 W start CallStaticVoidMethod current process:com.android.traceurpid-3145 W start CallStaticVoidMethod current process:com.android.dialerpid-3151 W start CallStaticVoidMethod current process:android.process.mediapid-3213 W start CallStaticVoidMethod current process:com.android.calendarpid-3230 W start CallStaticVoidMethod current process:com.android.imsserviceentitlementpid-3256 W start CallStaticVoidMethod current process:com.android.camera2pid-3277 W start CallStaticVoidMethod current process:com.android.contactspid-3302 W start CallStaticVoidMethod current process:com.android.dynsystempid-3322 W start CallStaticVoidMethod current process:com.android.dynsystem:dynsystempid-3337 W start CallStaticVoidMethod current process:com.android.inputmethod.latinpid-3359 W start CallStaticVoidMethod current process:com.android.managedprovisioningpid-3380 W start CallStaticVoidMethod current process:com.android.messagingpid-3413 W start CallStaticVoidMethod current process:com.android.onetimeinitializerpid-3436 W start CallStaticVoidMethod current process:com.android.packageinstallerpid-3455 W start CallStaticVoidMethod current process:com.android.permissioncontrollerpid-3480 W start CallStaticVoidMethod current process:com.android.providers.calendarpid-3503 W start CallStaticVoidMethod current process:com.android.settingspid-3504 W start CallStaticVoidMethod current process:com.android.localtransportpid-3545 W start CallStaticVoidMethod current process:com.android.shellpid-3568 W start CallStaticVoidMethod current process:com.android.statementservicepid-3595 W start CallStaticVoidMethod current process:com.android.quicksearchboxpid-3615 W start CallStaticVoidMethod current process:com.android.cellbroadcastreceiver.modulepid-3638 W start CallStaticVoidMethod current process:com.android.externalstorage ​ 从日志中可以看到system_process进程是孵化出来的第一个进程，接着孵化了一堆系统相关的进程，包括launcher桌面应用管理的系统应用。 ​ 根据前文看到的一系列的源码，分析后得出以下几个结论 zygote启动实际是启动app_process进程。 由init进程解析init.rc时启动了第一个zygote进程。 在第一个zygote进程中创建的ZygoteServer，并开始监听消息。 其他zygote进程是在ZygoteServer这个服务中收到消息后，再去fork出的新进程。 所有进程均来自于zygote进程的fork而来，所以zygote是进程的始祖。 ​ 结合观测到的代码流程，再看下面的一个汇总图。不需要完全理解启动过程中的所有的处理，重点是在这里留下一个大致的印象以及简单的整理。 3.7 Android app应用启动​ 经过一系列的代码跟踪，学习了android是如何启动的，系统服务是如何启动的，进程是如何启动。相信大家也好奇，当点击打开一个应用后，系统做了一系列的什么工作，最终打开了这个app，调用到MainActivity的onCreate的呢。 ​ 当Android成功进入系统后，在主界面中显示的桌面是一个叫做Launcher的系统应用，它是用来显示系统中已经安装的应用程序，并将这些信息的图标作为快捷方式显示在屏幕上，当用户点击图标时，Launcher就会启动对应的应用。在前文中，从forkSystemServer的流程中，最后能看到系统启动准备就绪后拉起了Launcher的应用。 ​ Launcher是如何打开一个应用的呢？其实Launcher本身就是作为第一个应用在系统启动后首先打开的，既然Launcher就是应用。那么在手机上看到各种应用的图标，就是它读取到需要展示的数据，然后布局展示出来的，点击后打开应用，就是给每个item设置的点击事件进行处理的。接着，来看看这个Launcher应用的源码。 ​ 查看代码frameworks/base/core/java/android/app/LauncherActivity.java。 123456789public abstract class LauncherActivity extends ListActivity { ... @Override protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); } ...} ​ 如果你是一名android开发人员，相信你对startActivity这个函数非常熟悉了，但是startActivity是如何打开一个应用的呢，很多人不会深入了解，有了前文中的一系列基础铺垫，这时你已经能尝试追踪调用链了。现在，继续深入挖掘startActivity的原理。 ​ 查看代码frameworks/base/core/java/android/app/Activity.java。 1234567891011public void startActivity(Intent intent, @Nullable Bundle options) { ... if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } } ​ 继续追踪startActivityForResult的实现。 123456789101112131415161718192021// 继续追踪startActivityForResultpublic void startActivityForResult( String who, Intent intent, int requestCode, @Nullable Bundle options) { Uri referrer = onProvideReferrer(); if (referrer != null) { intent.putExtra(Intent.EXTRA_REFERRER, referrer); } options = transferSpringboardActivityOptions(options); // 运行Activity Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, who, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, who, requestCode, ar.getResultCode(), ar.getResultData()); } cancelInputsAndStartExitTransition(options); } ​ 接下来的关键函数是execStartActivity，继续深入 123456789101112131415161718192021// 继续追踪execStartActivitypublic ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(who); intent.prepareToLeaveProcess(who); // 启动Activity int result = ActivityTaskManager.getService().startActivity(whoThread, who.getOpPackageName(), who.getAttributionTag(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } ​ ActivityTaskManager下的service调用的startActivity。 ​ 查看代码frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java 1234567891011121314151617181920212223242526272829303132public final int startActivity(IApplicationThread caller, String callingPackage, String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) { return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());}private int startActivityAsUser(IApplicationThread caller, String callingPackage, @Nullable String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) { ... return getActivityStartController().obtainStarter(intent, &quot;startActivityAsUser&quot;) .setCaller(caller) .setCallingPackage(callingPackage) .setCallingFeatureId(callingFeatureId) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setUserId(userId) .execute(); } ​ 先看看obtainStarter返回的对象类型。 123ActivityStarter obtainStarter(Intent intent, String reason) { return mFactory.obtain().setIntent(intent).setReason(reason); } ​ 看到返回的是ActivityStarter类型，接着找到对应的excute的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// 处理 Activity 启动请求的接口int execute() { ... res = executeRequest(mRequest); ... }// 各种权限检查，合法的请求则继续private int executeRequest(Request request) { ... mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession, request.voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, restrictedBgActivity, intentGrants); ... }private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, Task inTask, boolean restrictedBgActivity, NeededUriGrants intentGrants) { ... Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, &quot;startActivityInner&quot;); result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants); ... }int startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, Task inTask, boolean restrictedBgActivity, NeededUriGrants intentGrants) { ... // 判断是否需要为 Activity 创建新的 Task mTargetRootTask.startActivityLocked(mStartActivity, topRootTask != null ? topRootTask.getTopNonFinishingActivity() : null, newTask, mKeepCurTransition, mOptions, sourceRecord); // 如果需要恢复 Activity if (mDoResume) { final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); // 判断当前 Activity 是否可见以及是否需要暂停后台 Activity if (!mTargetRootTask.isTopActivityFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.isTaskOverlay() &amp;&amp; mStartActivity != topTaskActivity)) { ... } else { // 如果当前 Activity 可见，则将其移动到前台 if (mTargetRootTask.isTopActivityFocusable() &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedRootTask(mTargetRootTask)) { mTargetRootTask.moveToFront(&quot;startActivityInner&quot;); } // 恢复处于焦点状态的 Activity 的顶部 Activity mRootWindowContainer.resumeFocusedTasksTopActivities( mTargetRootTask, mStartActivity, mOptions, mTransientLaunch); } } ... }// 恢复处于焦点状态的 Activity 的顶部 Activity。boolean resumeFocusedTasksTopActivities( Task targetRootTask, ActivityRecord target, ActivityOptions targetOptions, boolean deferPause) { ... // 遍历所有显示器 for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) { final DisplayContent display = getChildAt(displayNdx); ... // 获取当前焦点所在的任务根节点 final Task focusedRoot = display.getFocusedRootTask(); // 如果有任务根节点，则恢复任务根节点中顶部的 Activity if (focusedRoot != null) { result |= focusedRoot.resumeTopActivityUncheckedLocked(target, targetOptions); } else if (targetRootTask == null) { // 如果没有焦点任务根节点，并且目标任务根节点为空，则恢复 Home Activity result |= resumeHomeActivity(null /* prev */, &quot;no-focusable-task&quot;, display.getDefaultTaskDisplayArea()); } } return result; }// 恢复位于任务根节点顶部的 Activityboolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options, boolean deferPause) { ... someActivityResumed = resumeTopActivityInnerLocked(prev, options, deferPause); ... }// 恢复位于任务根节点顶部的 Activity。private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options, boolean deferPause) { ... mTaskSupervisor.startSpecificActivity(next, true, true); ... return true; } ​ startSpecificActivity将启动指定的Activity。 1234567891011121314151617181920212223242526void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) { // 是否已经有进程在运行这个应用程序? final WindowProcessController wpc = mService.getProcessController(r.processName, r.info.applicationInfo.uid); boolean knownToBeDead = false; // 如果应用程序正在运行，则直接启动 Activity if (wpc != null &amp;&amp; wpc.hasThread()) { try { realStartActivityLocked(r, wpc, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); } // If a dead object exception was thrown -- fall through to // restart the application. knownToBeDead = true; } // 通知 Keyguard 正在启动一个不确定的 Activity（仅在 Keyguard 转换期间使用） r.notifyUnknownVisibilityLaunchedForKeyguardTransition(); // 如果应用程序未运行，则异步启动新进程 final boolean isTop = andResume &amp;&amp; r.isTopRunningActivity(); mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? &quot;top-activity&quot; : &quot;activity&quot;); } ​ 主要关注开启一个新应用的流程，所以这里只追踪startProcessAsync调用即可。 1234567891011121314151617void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop, String hostingType) { try { if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) { Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;dispatchingStartProcess:&quot; + activity.processName); } // Post message to start process to avoid possible deadlock of calling into AMS with the // ATMS lock held. final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess, mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead, isTop, hostingType, activity.intent.getComponent()); mH.sendMessage(m); } finally { Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); } } ​ 上面开启新进程的代码是异步发送消息给了ActivityManagerService。找到AMS中对应的startProcess。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114@Overridepublic void startProcess(String processName, ApplicationInfo info, boolean knownToBeDead, boolean isTop, String hostingType, ComponentName hostingName) { try { if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;startProcess:&quot; + processName); } synchronized (ActivityManagerService.this) { // If the process is known as top app, set a hint so when the process is // started, the top priority can be applied immediately to avoid cpu being // preempted by other processes before attaching the process of top app. startProcessLocked(processName, info, knownToBeDead, 0 /* intentFlags */, new HostingRecord(hostingType, hostingName, isTop), ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, false /* allowWhileBooting */, false /* isolated */); } } finally { Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); }}// 继续追踪startProcessLockedfinal ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, HostingRecord hostingRecord, int zygotePolicyFlags, boolean allowWhileBooting, boolean isolated) { return mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, 0 /* isolatedUid */, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */);}// 在这里初始化了一堆进程信息，然后调用了另一个重载// 并且注意entryPoint赋值android.app.ActivityThreadboolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord, int zygotePolicyFlags, boolean disableHiddenApiChecks, boolean disableTestApiChecks, String abiOverride) { ... // the PID of the new process, or else throw a RuntimeException. final String entryPoint = &quot;android.app.ActivityThread&quot;; return startProcessLocked(hostingRecord, entryPoint, app, uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime);}//boolean startProcessLocked(HostingRecord hostingRecord, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) { ... final Process.ProcessStartResult startResult = startProcess(hostingRecord, entryPoint, app, uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper, startSeq, false); ... return app.getPid() &gt; 0;}// 继续查看startProcessprivate Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) { ... final Process.ProcessStartResult startResult; boolean regularZygote = false; // 这里根据应用情况使用不同类型的zygote来启动进程 if (hostingRecord.usesWebviewZygote()) { startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, app.info.packageName, app.getDisabledCompatChanges(), new String[]{PROC_START_SEQ_IDENT + app.getStartSeq()}); } else if (hostingRecord.usesAppZygote()) { final AppZygote appZygote = createAppZygoteForProcessIfNeeded(app); // We can't isolate app data and storage data as parent zygote already did that. startResult = appZygote.getProcess().start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, app.info.packageName, /*zygotePolicyFlags=*/ ZYGOTE_POLICY_FLAG_EMPTY, isTopApp, app.getDisabledCompatChanges(), pkgDataInfoMap, allowlistedAppDataInfoMap, false, false, new String[]{PROC_START_SEQ_IDENT + app.getStartSeq()}); } else { regularZygote = true; startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags, isTopApp, app.getDisabledCompatChanges(), pkgDataInfoMap, allowlistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs, new String[]{PROC_START_SEQ_IDENT + app.getStartSeq()}); } if (!regularZygote) { // webview and app zygote don't have the permission to create the nodes if (Process.createProcessGroup(uid, startResult.pid) &lt; 0) { Slog.e(ActivityManagerService.TAG, &quot;Unable to create process group for &quot; + app.processName + &quot; (&quot; + startResult.pid + &quot;)&quot;); } } ... return startResult;} ​ 这里，看到了zygote有三种类型，根据启动的应用信息使用不同类型的zygote来启动。 regularZygote常规进程，zygote32/zygote64进程，是所有Android Java应用的父进程 appZygote应用进程，比常规进程多一些限制。 webviewZygote辅助zygote进程，渲染不可信的web内容，最严格的安全限制 ​ 三种zygote类型的启动流程差不多的，看常规进程启动即可。首先看getProcess返回的是什么类型 12345678public ChildZygoteProcess getProcess() { synchronized (mLock) { if (mZygote != null) return mZygote; connectToZygoteIfNeededLocked(); return mZygote; } } ​ 应该找ChildZygoteProcess的start函数，然后找到类定义后，发现没有start，那么应该就是父类中的实现。 12345678910111213public class ChildZygoteProcess extends ZygoteProcess { private final int mPid; ChildZygoteProcess(LocalSocketAddress socketAddress, int pid) { super(socketAddress, null); mPid = pid; } public int getPid() { return mPid; }} ​ 继续找到父类ZygoteProcess的start函数，参数太长，这里省略掉参数的描述 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public final Process.ProcessStartResult start(...) { ... return startViaZygote(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/ false, packageName, zygotePolicyFlags, isTopApp, disabledCompatChanges, pkgDataInfoMap, allowlistedDataInfoList, bindMountAppsData, bindMountAppStorageDirs, zygoteArgs); ... }private Process.ProcessStartResult startViaZygote(...) throws ZygoteStartFailedEx { ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;&gt;(); // 前面是将前面准备的参数填充好 // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add(&quot;--runtime-args&quot;); argsForZygote.add(&quot;--setuid=&quot; + uid); argsForZygote.add(&quot;--setgid=&quot; + gid); argsForZygote.add(&quot;--runtime-flags=&quot; + runtimeFlags); if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) { argsForZygote.add(&quot;--mount-external-default&quot;); } else if (mountExternal == Zygote.MOUNT_EXTERNAL_INSTALLER) { argsForZygote.add(&quot;--mount-external-installer&quot;); } else if (mountExternal == Zygote.MOUNT_EXTERNAL_PASS_THROUGH) { argsForZygote.add(&quot;--mount-external-pass-through&quot;); } else if (mountExternal == Zygote.MOUNT_EXTERNAL_ANDROID_WRITABLE) { argsForZygote.add(&quot;--mount-external-android-writable&quot;); } ... synchronized(mLock) { // The USAP pool can not be used if the application will not use the systems graphics // driver. If that driver is requested use the Zygote application start path. return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), zygotePolicyFlags, argsForZygote); } }private Process.ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, int zygotePolicyFlags, @NonNull ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx { ... //是否用非特定的应用程序进程池进行处理，默认不使用 if (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) { try { return attemptUsapSendArgsAndGetResult(zygoteState, msgStr); } catch (IOException ex) { // If there was an IOException using the USAP pool we will log the error and // attempt to start the process through the Zygote. Log.e(LOG_TAG, &quot;IO Exception while communicating with USAP pool - &quot; + ex.getMessage()); } } return attemptZygoteSendArgsAndGetResult(zygoteState, msgStr); }private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult( ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx { try { final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter; final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream; // 这里实际就是连接SocketServer了，发送一个消息给zygote孵化出来的第一个进程 zygoteWriter.write(msgStr); zygoteWriter.flush(); Process.ProcessStartResult result = new Process.ProcessStartResult(); result.pid = zygoteInputStream.readInt(); result.usingWrapper = zygoteInputStream.readBoolean(); // ZygoteServer创建好进程后，返回pid if (result.pid &lt; 0) { throw new ZygoteStartFailedEx(&quot;fork() failed&quot;); } return result; } catch (IOException ex) { zygoteState.close(); Log.e(LOG_TAG, &quot;IO Exception while communicating with Zygote - &quot; + ex.toString()); throw new ZygoteStartFailedEx(ex); } } ​ 到这里，回首看看前文中介绍ZygoteServer启动进程的流程，当时看到执行到最后是findStaticMain函数，是获取一个类名下的main函数，并返回后进行调用。现在启动进程时，在startProcessLocked函数中能看到类名赋值是android.app.ActivityThread，所以这里和ZygoteServer进行通信创建线程，最后调用的函数就是android.app.ActivityThread中的main函数。这样一来，启动流程就进入的应用的主线程。 ​ ActivityThread是Android应用程序运行的UI主线程，负责处理应用程序的所有生命周期事件，接收系统消息并处理它们，main函数就是安卓应用的入口函数。prepareMainLooper函数将实例化一个Looper对象，然后由Looper对象创建一个消息队列，当loop函数调用时，UI线程就会进入消息循环，不断从消息队列获取到消息去进行相应的处理。 12345678910111213141516171819202122232425262728public static void main(String[] args) { ... Looper.prepareMainLooper(); ... ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); // 主线程消息循环处理的handler if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } ... Looper.loop();}// 在loop函数中是一个死循环进行`loopOnce`调用public static void loop() { ... for (;;) { if (!loopOnce(me, ident, thresholdOverride)) { return; } }}private void attach(boolean system, long startSeq) { ... mgr.attachApplication(mAppThread, startSeq); ...} ​ 继续看loopOnce的实现，看到了从队列中获取一条消息，并且将消息派发给对应的Handler来执行。 123456789101112private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) { Message msg = me.mQueue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return false; } ... msg.target.dispatchMessage(msg); ... return true; } ​ 对应的消息处理的Handler就是前面在入口函数main中看到的sMainThreadHandler对象，是通过getHandler函数获取的，跟进去寻找具体的对象。 12345public Handler getHandler() { return mH; }final H mH = new H(); ​ 找到的这个H类型就是对应的主线程消息处理Handler了。看看相关实现。 1234567891011121314151617181920212223242526272829303132333435class H extends Handler { public static final int BIND_APPLICATION = 110; @UnsupportedAppUsage public static final int EXIT_APPLICATION = 111; ... String codeToString(int code) { if (DEBUG_MESSAGES) { switch (code) { case BIND_APPLICATION: return &quot;BIND_APPLICATION&quot;; case EXIT_APPLICATION: return &quot;EXIT_APPLICATION&quot;; ... } } return Integer.toString(code); } public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case EXIT_APPLICATION: if (mInitialApplication != null) { mInitialApplication.onTerminate(); } Looper.myLooper().quit(); break; ... } ... } } ​ 再回头看看thread.attach中的处理，mgr就是AMS，所以来到ActivityManagerService查看attachApplication： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 在main中调用的thread.attach函数private void attach(boolean system, long startSeq) { ... mgr.attachApplication(mAppThread, startSeq); ...}// 将应用程序线程与 ActivityThread 绑定public final void attachApplication(IApplicationThread thread, long startSeq) { if (thread == null) { throw new SecurityException(&quot;Invalid application interface&quot;); } synchronized (this) { int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid, callingUid, startSeq); Binder.restoreCallingIdentity(origId); }}// 继续追踪attachApplicationLockedprivate boolean attachApplicationLocked(@NonNull IApplicationThread thread, int pid, int callingUid, long startSeq) { ... if (app.getIsolatedEntryPoint() != null) { // This is an isolated process which should just call an entry point instead of // being bound to an application. thread.runIsolatedEntryPoint( app.getIsolatedEntryPoint(), app.getIsolatedEntryPointArgs()); } else if (instr2 != null) { // 如果该应用程序未运行在隔离进程中，且有 Instrumentation thread.bindApplication(processName, appInfo, providerList, instr2.mClass, profilerInfo, instr2.mArguments, instr2.mWatcher, instr2.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.getCompat(), getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions, app.getDisabledCompatChanges(), serializedSystemFontMap); } else { // 如果没有 Instrumentation thread.bindApplication(processName, appInfo, providerList, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.getCompat(), getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions, app.getDisabledCompatChanges(), serializedSystemFontMap); } ... } ​ 最后调用回ActivityThread的bindApplication，继续跟进去查看 123456789101112131415161718192021222324252627public final void bindApplication(...) { ... //将应用程序和应用程序线程绑定所需的信息存储到AppBindData的各个字段中。 AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providerList.getList(); data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableBinderTracking = enableBinderTracking; data.trackAllocation = trackAllocation; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; data.buildSerial = buildSerial; data.autofillOptions = autofillOptions; data.contentCaptureOptions = contentCaptureOptions; data.disabledCompatChanges = disabledCompatChanges; data.mSerializedSystemFontMap = serializedSystemFontMap; // 发送消息给应用程序线程，调用 bindApplication 方法 sendMessage(H.BIND_APPLICATION, data);} ​ AppBindData数据绑定完成后，最后发送消息BIND_APPLICATION通知准备就绪，并将准备好的数据发送过去。查看消息循环的处理部分handleMessage函数，看这个数据传给哪个函数处理了。 1234567891011public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ...} ​ 发现调用到了handleBindApplication，继续跟进查看。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void handleBindApplication(AppBindData data) { ... //前面准备好的data数据赋值给了mBoundApplication mBoundApplication = data; ... // 创建出了Context final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); ... Application app; final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites(); final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy(); try { // 创建出了Application app = data.info.makeApplication(data.restrictedBackupMode, null); ... // Application赋值给了mInitialApplication mInitialApplication = app; ... try { mInstrumentation.callApplicationOnCreate(app); } catch (Exception e) { ... } } finally { ... } ...}// 看看是如何创建出Application的public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) { if (mApplication != null) { return mApplication; } ... app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); ... return app;}// 继续看newApplication的实现static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException,ClassNotFoundException { Application app = (Application)clazz.newInstance(); // 最后发现调用了attach app.attach(context); return app;} ​ 在上面看到了Context的创建和Application的创建，继续看看怎么调用到自己开发的app中的onCreate的，追踪callApplicationOnCreate的实现 1234public void callApplicationOnCreate(Application app) { ... app.onCreate();} ​ 到这里，成功跟踪到最后调用app应用的onCreate函数，为什么很多人喜欢hook attach函数，因为在Application创建出来最早先调用了这个函数，该函数是一个较早hook时机。 3.8 了解Service​ Service是一种运行在后台的组件也可以称之为服务，它不像Activity那样有前台显示用户界面的能力，而是一种更加抽象的组件，它可以提供后台服务，在后台定时执行某些任务。Service可以被应用程序绑定，也可以独立运行，它可以接收外部的命令，执行耗时的任务。 ​ 在Android启动流程中，就已经看到了很多Service的启动，前文代码看到当系统启动后通过forkSystemServer执行到SystemServer来启动一系列的Service。这些Service有着各自负责的功能，其中最关键的是ActivityManagerService，常常被简称为AMS。而启动了AMS的SystemServer也是一个服务，这个服务负责在Android完成启动后，加载和启动所有的系统服务，管理系统级别的资源。 ​ AMS是Android系统中的一个核心服务，负责Android系统中的所有活动管理，包括应用程序的启动，暂停，恢复，终止，以及对系统资源的管理和分配。负责Android系统中所有活动的管理。它负责管理任务栈，并允许任务栈中的任务来回切换，以便在任务之间改变焦点。它还负责管理进程，并将进程启动，暂停，恢复，终止，以及分配系统资源。在启动流程中能看到，所有Service都是由它来启动的. ​ 除了AMS外，还有其他重要的Service为Android应用提供基础的功能，下面简单介绍这些常见的Service。 ​ WindowManagerService，它是负责管理系统上所有窗口的显示和操作，包括管理全屏窗口、小窗口、弹窗、菜单和其他应用程序的窗口，使窗口在手机屏幕上正确的显示。 ​ PackageManagerService，Android系统中提供给应用程序访问Android软件包的主要服务。负责管理Android软件包的安装、删除和更新，以及软件包的查询和配置。它有一个名为Packages.xml的XML文档，该文档是Android系统中所有软件包的列表，其中包含了每个软件包的基本信息，如应用程序的版本，安装时间，文件大小等。 ​ PowerManagerService，管理设备电源状态的服务，可以有效地管理设备的电源，从而大大提升设备的电池续航能力，也可以降低设备运行时的功耗。它负责处理设备上的所有电源相关操作，例如屏幕亮度、屏幕超时时间、电池和充电时的运行模式、设备锁以及设备唤醒功能。 ​ InputMethodManagerService，输入法服务，它负责处理用户输入，管理输入法状态，以及向应用程序提供输入服务，例如可以安装、卸载和更新输入法，还可以管理系统的输入法开关，应用程序可以通过它来访问输入法的当前状态和内容，以及实时输入的文本内容，可以接收并处理用户的输入事件，包括按键、触摸屏、语音输入等。 ​ NotificationManagerService，通知服务。它主要是用来管理系统的通知，包括消息、提醒、更新等，它实现了通知的管理，收集、组织、过滤通知，并将它们发送给用户。它能够管理所有应用程序发出的通知，包括系统通知、应用程序发出的通知，并可以根据用户的偏好，显示哪些通知。 ​ LocationManagerService，位置管理服务。可以根据应用程序的要求调用GPS、网络和其他位置技术来获取当前设备的定位信息。根据设备的位置信息，控制应用程序的定位功能，以及设备的位置报警功能。 ​ InputManagerService，负责输入设备的管理和控制，以及系统中所有输入事件的处理。例如触摸屏、虚拟按键、键盘、轨迹球等。会将输入事件传递给应用程序，以便处理和响应。 ​ AlarmManagerService负责处理所有系统定时任务，如闹钟，定时器等。它可以安排可执行的任务，使它们在指定的时刻开始执行。监控系统中的各种时间事件，以执行指定的任务。可以发送唤醒广播，以启动指定的服务或应用程序。可以用于处理设备睡眠、唤醒等系统状态切换。 ​ NetworkManagementService，网络管理服务。用于控制和管理Android系统中的网络连接，能够在不同的网络之间进行切换，检查和管理手机的网络状态，监控网络设备的连接状态，如WiFi、蓝牙、移动数据等。 ​ BluetoothService，蓝牙服务，它可以实现蓝牙设备之间的无线通信。它提供了一种方便的方式来建立和管理蓝牙连接，使蓝牙设备之间能够进行文件传输、远程打印、蓝牙键盘连接等活动。 ​ 还有更多的系统服务为Android的运行提供着各模块的基础功能，这里就不展开详细叙述了，当对某一个服务的功能实现感兴趣时，可以顺着启动服务的地方开始跟踪代码，分析实现的逻辑。也可以直接参考系统服务的定义方式来自定义系统服务来提供特殊需求的功能。 3.9 了解Framework​ Framework指的是软件开发框架，由于系统处于内核中，无法直接对系统的功能进行请求，而是由框架层为开发的顶层应用提供接口调用，从而不必烦恼如何与底层交互，开发框架为开发人员提供各种功能，以及Android应用工具的支持来便于创建和管理Android应用程序，最终达到让用户能高效开发Android应用的目的，以生活中的事务为例，Framework就像是一个配套完善的小区，有高效的物业，周边配套有学校、医院、商场，各类设施非常齐全，而用户就像是小区内的业主。 ​ 看一张经典的Android架构图。 ​ 从上图中可以看到Framewok的组成部分，它们的功能分别是： Activity Manager：用于管理和协调所有Android应用程序的活动和任务。 Content Providers：允许Android应用程序之间共享数据。 Package Manager：用于安装，升级和管理应用程序，以及处理应用程序的权限。 Resource Manager：管理应用程序使用的资源，例如图像，字符串，布局。 Notification Manager：处理Android系统的通知机制。 Telephony Manager：提供电话功能，例如拨打电话，接听电话等。 Location Manager：用于获取设备的位置信息。 View System：提供用户界面的基本组件或部件，例如按钮，文本框等。 Window Manager：处理屏幕上的窗口，例如在屏幕上绘制UI元素和管理窗口焦点。 Package Installer：用于在设备上安装应用程序的控制面板。 Resource Manager：管理所有允许应用程序访问的公共资源，例如铃声，照片和联系人信息。 Activity和Fragment：提供应用程序的用户界面和控制器。 ​ 可以看到前文中的各种系统服务就是属于Framework中的一部分，但是用户层并不能直接访问系统服务提供的功能，而是通过各服务对应的管理器来对系统服务进行调用。接下来开始跟踪，在开发应用中，当调用一个系统服务功能时发生了哪些调用，使用Android Studio创建一个项目，添加如下代码。 12345678910111213protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TelephonyManager tm = (TelephonyManager) this.getSystemService(TELEPHONY_SERVICE); /* * 电话状态： * 1.tm.CALL_STATE_IDLE=0 无活动 * 2.tm.CALL_STATE_RINGING=1 响铃 * 3.tm.CALL_STATE_OFFHOOK=2 摘机 */ int state= tm.getCallState();//int Log.i(&quot;MainActivity&quot;,&quot;phone state &quot;+state);} ​ 通过getSystemService函数提供了一个系统服务的名称，获取到了对应系统服务对应管理器，通过调用管理器的函数来触发对应系统服务的功能，看看具体是如何获取到系统服务的。找到Android源码中Activity.java文件。 1234567891011121314public Object getSystemService(@ServiceName @NonNull String name) { if (getBaseContext() == null) { throw new IllegalStateException( &quot;System services not available to Activities before onCreate()&quot;); } if (WINDOW_SERVICE.equals(name)) { return mWindowManager; } else if (SEARCH_SERVICE.equals(name)) { ensureSearchManager(); return mSearchManager; } return super.getSystemService(name);} ​ 如果是WINDOW_SERVICE或者SEARCH_SERVICE就快速的返回对应的管理器了，其他系统服务则继续调用父类的函数。Activity继承自ContextThemeWrapper，找到对应实现代码如下。 123456789public Object getSystemService(String name) { if (LAYOUT_INFLATER_SERVICE.equals(name)) { if (mInflater == null) { mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this); } return mInflater; } return getBaseContext().getSystemService(name);} ​ 找到ContextImpl中的对应实现 1234public Object getSystemService(String name) { ... return SystemServiceRegistry.getSystemService(this, name);} ​ 继续查看SystemServiceRegistry中的实现 123456789101112131415public static Object getSystemService(ContextImpl ctx, String name) { if (name == null) { return null; } final ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); if (fetcher == null) { if (sEnableServiceNotFoundWtf) { Slog.wtf(TAG, &quot;Unknown manager requested: &quot; + name); } return null; } final Object ret = fetcher.getService(ctx); ... return ret;} ​ 发现服务是从SYSTEM_SERVICE_FETCHERS中获取出来，然后返回的。看看这个对象的值是如何插进去的。搜索该对象的put函数调用处找到相关函数如下。 123456private static &lt;T&gt; void registerService(@NonNull String serviceName, @NonNull Class&lt;T&gt; serviceClass, @NonNull ServiceFetcher&lt;T&gt; serviceFetcher) { SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher); SYSTEM_SERVICE_CLASS_NAMES.put(serviceName, serviceClass.getSimpleName());} ​ 从名字就能看的出来，这是一个注册系统服务的函数，在该函数中对大多数系统服务进行注册，想要查找到一个系统服务，可以顺着registerService注册函数进行跟踪，如果添加一个自定义的系统服务，同样也是需要在这里进行系统服务的注册。 ​ 下面继续观察TelephonyManager中getCallState函数的实现。 123456789public @CallState int getCallState() { if (mContext != null) { TelecomManager telecomManager = mContext.getSystemService(TelecomManager.class); if (telecomManager != null) { return telecomManager.getCallState(); } } return CALL_STATE_IDLE;} ​ 这里又通过另一个管理器进行的函数调用，继续跟进去 123456789101112public @CallState int getCallState() { ITelecomService service = getTelecomService(); if (service != null) { try { return service.getCallStateUsingPackage(mContext.getPackageName(), mContext.getAttributionTag()); } catch (RemoteException e) { Log.d(TAG, &quot;RemoteException calling getCallState().&quot;, e); } } return TelephonyManager.CALL_STATE_IDLE;} ​ 上述代码可以看出，TelephonyManager管理器不负责业务相关的处理，主要是调用对应的系统服务来获取结果。继续查看getCallStateUsingPackage函数实现 1234567891011121314151617181920public int getCallStateUsingPackage(String callingPackage, String callingFeatureId) { try { Log.startSession(&quot;TSI.getCallStateUsingPackage&quot;); if (CompatChanges.isChangeEnabled( TelecomManager.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION, callingPackage, Binder.getCallingUserHandle())) { // Bypass canReadPhoneState check if this is being called from SHELL UID if (Binder.getCallingUid() != Process.SHELL_UID &amp;&amp; !canReadPhoneState( callingPackage, callingFeatureId, &quot;getCallState&quot;)) { throw new SecurityException(&quot;getCallState API requires READ_PHONE_STATE&quot; + &quot; for API version 31+&quot;); } } synchronized (mLock) { return mCallsManager.getCallState(); } } finally { Log.endSession(); }} ​ 在系统服务中就看到了管理状态相关的具体业务代码了，继续观察mCallsManager.getCallStae的实现 123int getCallState() { return mPhoneStateBroadcaster.getCallState();} ​ 最后是由PhoneStateBroadcaster对象维护着电话的状态信息了，PhoneStateBroadcaster是Android中的一个系统广播机制，它用于在电话状态发生变化时发出通知，以便其他组件和应用程序能够接收和处理这些变化。它可以发出包括新来电，挂断电话，拨号等状态变化的通知，以使系统中的其他组件能够更新和处理这些变化。PhoneStateBroadcaster还提供了一些其他的功能，例如电话状态监控，用于检测电话状态的变化，以便能够及时响应。简单的贴一下相关的代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061final class PhoneStateBroadcaster extends CallsManagerListenerBase { ... @Override public void onCallStateChanged(Call call, int oldState, int newState) { if (call.isExternalCall()) { return; } updateStates(call); } @Override public void onCallAdded(Call call) { if (call.isExternalCall()) { return; } updateStates(call); if (call.isEmergencyCall() &amp;&amp; !call.isIncoming()) { sendOutgoingEmergencyCallEvent(call); } } @Override public void onCallRemoved(Call call) { if (call.isExternalCall()) { return; } updateStates(call); } @Override public void onExternalCallChanged(Call call, boolean isExternalCall) { updateStates(call); } private void updateStates(Call call) { int callState = TelephonyManager.CALL_STATE_IDLE; if (mCallsManager.hasRingingOrSimulatedRingingCall()) { callState = TelephonyManager.CALL_STATE_RINGING; } else if (mCallsManager.getFirstCallWithState(CallState.DIALING, CallState.PULLING, CallState.ACTIVE, CallState.ON_HOLD) != null) { callState = TelephonyManager.CALL_STATE_OFFHOOK; } sendPhoneStateChangedBroadcast(call, callState); } int getCallState() { return mCurrentState; } private void sendPhoneStateChangedBroadcast(Call call, int phoneState) { if (phoneState == mCurrentState) { return; } mCurrentState = phoneState; ... } ...} 3.10 了解libcore​ libcore是Android平台下的Java核心库，主要提供与Java语言核心相关的类，如Object类、String类，Java集合类以及输入/输出流等。同时，libcore还包括了平台支持库，提供了一些用于Android平台特定功能的实现，如Socket、SSL、File、URI等类的平台特定实现。在Android应用程序开发中，libcore库是必不可少的一部分，其提供的类和实现对于开发和调试应用程序都具有非常重要的作用。 ​ 在libcore库中，luni是其中的一个子库，是指Java的基础类库（LUNI = LANG + UTIL + NET + IO），而ojluni是OpenJDK的代码在Android中的实现，其目录结构与luni子库类似，包含了Java语言核心类、Java集合类和I/O类等。ojluni是在Java标准库的基础上进行了一些定制化的修改，以便更好地适配Android系统。下面看看ojluni的目录结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113tree ./libcore/ojluni/src/main/java/ -d├── com│ └── sun│ ├── net│ │ └── ssl│ │ └── internal│ │ └── ssl│ ├── nio│ │ └── file│ └── security│ └── cert│ └── internal│ └── x509├── java│ ├── awt│ │ └── font│ ├── beans│ ├── io│ ├── lang│ │ ├── annotation│ │ ├── invoke│ │ ├── ref│ │ └── reflect│ ├── math│ ├── net│ ├── nio│ │ ├── channels│ │ │ └── spi│ │ ├── charset│ │ │ └── spi│ │ └── file│ │ ├── attribute│ │ └── spi│ ├── security│ │ ├── acl│ │ ├── cert│ │ ├── interfaces│ │ └── spec│ ├── sql│ ├── text│ ├── time│ │ ├── chrono│ │ ├── format│ │ ├── temporal│ │ └── zone│ └── util│ ├── concurrent│ │ ├── atomic│ │ └── locks│ ├── function│ ├── jar│ ├── logging│ ├── prefs│ ├── regex│ ├── stream│ └── zip├── javax│ ├── crypto│ │ ├── interfaces│ │ └── spec│ ├── net│ │ └── ssl│ ├── security│ │ ├── auth│ │ │ ├── callback│ │ │ ├── login│ │ │ └── x500│ │ └── cert│ └── sql│ └── rowset├── jdk│ ├── internal│ │ ├── util│ │ └── vm│ │ └── annotation│ └── net└── sun ├── invoke │ └── util ├── misc ├── net │ ├── ftp │ │ └── impl │ ├── spi │ │ └── nameservice │ ├── util │ └── www │ └── protocol │ ├── file │ ├── ftp │ └── jar ├── nio │ ├── ch │ ├── cs │ └── fs ├── reflect │ └── misc ├── security │ ├── action │ ├── jca │ ├── pkcs │ ├── provider │ │ └── certpath │ ├── timestamp │ ├── util │ └── x509 └── util ├── calendar ├── locale │ └── provider ├── logging └── resources 3.11 了解sepolicy​ sepolicy主要用来存放SELinux策略的目录，SELinux是一种强制访问控制机制，Android系统中实现访问控制的一种安全机制，它在Linux内核的基础上实现，用于保证手机安全。 ​ SELinux主要用于限制应用程序的权限，使其只能访问其所需的资源，并在需要时向用户请求权限。通过限制应用程序的权限，可以防止恶意软件和攻击者攻击系统。具体而言，sepolicy可以做到以下几点： 限制应用程序访问系统的资源，例如系统设置、网络接口等。 限制应用程序的使用权限，例如读取联系人、访问存储空间等。 保护系统文件和目录，防止应用程序和攻击者修改和删除系统关键文件。 ​ Type Enforcement是SELinux中的一个安全策略机制，用于对系统中每个对象和主体的访问进行强制访问控制。在Type Enforcement的模型中，每个对象和主体都被赋予了一个安全上下文（Security Context），该上下文由多个标签组成。 ​ Role-Based Access Control（RBAC）也是 SELinux 中的一种访问控制机制，用于对系统中多个用户、角色和对象的访问进行授权和限制。在RBAC模型中，每个用户都被分配了一个或多个角色，每个角色都有一组特定的权限和访问控制规则。与传统的访问控制方式不同，RBAC可以根据用户的职责和角色来授权和限制其访问，并且可以通过添加或删除角色等方式对访问控制进行动态管理。这种机制可以确保系统中不同用户之间的隔离和资源保护，并提高系统的安全性和可靠性。 ​ 在SELinux中，标签分为三种类型：用户标签（User ID）、角色标签（Role）和类型标签（Type）。每个安全上下文都包含了这三种标签的组合，如“u:r:system_app:s0”表示该上下文对应一个用户标签为“system_app”的进程，其角色标签和类型标签分别为“r”和“s0”。 ​ 通过安全上下文，SELinux可以对系统中的对象和主体进行细粒度控制，并限制它们之间的交互。例如，如果两个对象或主体的安全上下文不匹配，则它们不能相互通信或共享资源。这种机制可以有效地防止恶意应用程序或者攻击者对系统进行攻击或滥用。也可以通过修改 sepolicy 目录下的文件来调整安全策略，从而适应不同的应用程序和系统需求。 ​ 在ROM定制时，常会添加某些功能时由于权限问题导致系统输出警告信息提示错误，这种情况需要调整安全策略。调整策略的位置在Android源代码的 ./system/sepolicy/ 目录中，public、private目录下。 public：该目录包含Android系统与函数库等公共的sepolicy规则。这些规则是开发人员和厂商可以自由使用和修改的，因为这些规则涉及到的是公共区域的访问控制。 private：该目录包含硬编码到Android系统中的特定规则。这些规则用于控制既定的Android系统功能和应用程序，例如拨号应用程序、电源管理等，因此这些规则不能被修改或覆盖。 ​ 当修改Android系统的SELinux策略时，系统会使用prebuilts目录中的策略进行对比，这是因为prebuilts中包含了在 Android设备上预置的SELinux策略和规则。 ​ 对安全策略有一个大致的了解后，先看一个简单的例子，找到文件./system/sepolicy/public/adbd.te 12345# 定义类型type adbd, domain;# 允许adbd类型的进程，在类型shell_test_data_file中的目录内创建子目录allow adbd shell_test_data_file:dir create_dir_perms; ​ 这里使用了三个类型： adbd：指定进程的类型； domain：指定域的类型； shell_test_data_file：指定目录的类型。 ​ 规则使用了allow关键字，表示允许某些操作。具体来说，上述规则允许adbd类型的进程在shell_test_data_file类型的目录下创建目录，并且该目录将被赋予允许创建子目录的权限（由create_dir_perms定义）。 ​ 这个规则的实际意义是，当adbd进程需要在shell_test_data_file目录下创建子目录时，允许该操作，并为新创建的目录设置适当的权限。注意，这个规则只对该目录有效，不能用于其他目录。 ​ 通常情况下采用按需修改的方式调整安全策略，当添加的功能被安全策略拦住时，会输出警告提示。例如在文件com_android_internal_os_Zygote.cpp的SpecializeCommon函数中加入如下代码，访问data目录。 12std::string filepath=&quot;/data/app/demo&quot;;ReadFileToString(filepath,&amp;file_contents) ​ 然后就会被SELinux拦截并提示警告信息如下 1avc: denied { search } for name=&quot;app&quot; dev=&quot;dm-8&quot; ino=100 scontext=u:r:zygote:s0 tcontext=u:object_r:apk_data_file:s0 tclass=dir permissive=0 ​ 在SELinux中，avc: denied是出现最频繁的提示之一，根据提示可以知道，进程zygote对安全上下文为u:object_r:apk_data_file:s0的目录进行search操作，该行为被拒绝了。除此之外，还有其他拒绝访问的提示消息如下。 avc: denied {open} - 表示进程被禁止打开文件或设备。 avc: denied {read} - 表示进程被禁止读取一个文件、设备或目录。 avc: denied {write} - 表示进程被禁止写入一个文件、设备或目录。 avc: denied {getattr} - 表示进程被禁止读取一个文件或目录的元数据（例如，所有权、组、权限等）。 avc: denied {execute} - 表示进程被禁止执行一个文件或进程。 avc: denied {create} - 表示进程被禁止创建一个文件。 avc: denied {search} - 表示此进程被禁止在某目录中搜索文件的操作 ​ 除了 avc: denied之外，还有其他一些可能出现的提示信息。以下是一些常见提示信息以及它们的含义： avc: granted - 操作被允许。 avc: audit - 正在监视执行上下文之间的交互，并将相关信息记录到审计日志中。 avc: no audit - 没有记录此操作的详细信息，这通常是因为没有启用SELinux的审计功能。 avc: invalid - 操作请求的权限非法或无效。 avc: timeout - SELinux规则分析器超时无法确定操作是否应该允许。在这种情况下，操作通常会被拒绝。 avc: failed - SELinux规则分析器无法确定操作是否应该被允许或拒绝。 ​ 在SELinux中，scontext代表系统中的安全上下文，tcontext代表对象的安全上下文。每个具有权限要求的进程和对象都有一个安全上下文。SELinux使用这些安全上下文来进行访问控制决策。 scontext和tcontext中的“u”，“r”和“s0”是安全上下文标记的不同部分。含义如下： u - 代表selinux中定义的用户，tcontext中的u代表对象所属用户。 r - 代表进程的角色（role），tcontext中的r代表对象的角色。 s0 - 代表进程的安全策略范围（security level），tcontext中的s0代表对象的安全策略范围。s0通常表示为默认值。 ​ 可以通过命令ps -eZ来查看进程的scontext。 1234567ps -eZu:r:servicemanager:s0 system 672 1 10860740 3784 SyS_epoll+ 0 S servicemanageru:r:hwservicemanager:s0 system 673 1 10880928 4648 SyS_epoll+ 0 S hwservicemanageru:r:kernel:s0 root 674 2 0 0 worker_th+ 0 S [kworker/7:1H]u:r:vndservicemanager:s0 system 675 1 10813436 2884 SyS_epoll+ 0 S vndservicemanageru:r:kernel:s0 root 676 2 0 0 kthread_w+ 0 S [psimon] ​ 可以通过命令ls -Z来查看文件的scontext 12345cd /data/appls -Z -alldrwxrwxr-x 3 system system u:object_r:apk_data_file:s0 3488 2023-02-26 21:50:57.968696920 +0800 ~~QZ-rYHaywe6nr2ryYn3UoQ==drwxrwxr-x 3 system system u:object_r:apk_data_file:s0 3488 2023-03-02 22:12:29.802016689 +0800 ~~W9dmzmphiDsjJm79RiBwdg== ​ 重新对下面的这个提示进行一次解读。selinux拒绝搜索一个目录，目录名称为app，所在设备为dm-8，被拒绝的进程上下文特征是u:r:zygote:s0，角色是zygote，目标文件上下文特征是u:object_r:apk_data_file:s0，用户级别为object_r，文件的所属类型是apk_data_file，表示应用程序的数据文件。tclass表示请求对象的类型，dir为目录，file表示文件 1avc: denied { search } for name=&quot;app&quot; dev=&quot;dm-8&quot; ino=100 scontext=u:r:zygote:s0 tcontext=u:object_r:apk_data_file:s0 tclass=dir permissive=0 ​ 解读完成后，可以开始调整安全策略了，找到文件system/sepolicy/private/zygote.te，然后添加策略如下 1allow zygote apk_data_file:dir search; ​ 修改完成后编译时，会报错，提示diff对比文件时发现内容不一致。最后再将文件system/sepolicy/prebuilts/api/31.0/private/zygote.te下添加相同的策略即可成功编译。 ​ neverallow是SELinux策略语言中的一个规则，它用于指定某个操作永远不允许执行。neverallow规则用于设置一些强制访问控制规则，以在安全策略中明确禁止某些行为，从而提高其安全性。neverallow规则与allow规则在语法上非常相似，但在作用上截然不同。 ​ 有时按照警告信息提示，添加了对应策略后无法编译通过提示违反了neverallow。这种情况可以找到对应的neverallow，进行修改添加一个白名单来放过添加的规则。例如下面这个例子 1234567neverallow { coredomain -fsck -init -ueventd -zygote} device:{ blk_file file } no_rw_file_perms; ​ 这个规则禁止上述进程以可读可写权限读写 device 类型的文件，其中-zygote，这种前面带有-表示排除掉这种进程，如果被设置了永不允许，只要找到对应的设置处，添加上排除对应进程即可成功编译了。 3.12 了解Linker​ Linker是安卓中的一个系统组件，负责加载和链接系统动态库文件。 ​ 在Android源代码中，Linker源码的主要目录是bionic/linker。该目录包含Linker的核心实现，如动态加载、符号表管理、重定位、符号解析、SO文件搜索等。其中，linker.c是Linker的主要入口点，该文件中包含了大量的实现细节。linker_phdr.c是负责加载和处理ELF格式库文件的代码，linker_namespaces.cpp负责管理命名空间的代码，linker_relocs.cpp负责处理重定位的代码，linker_sleb128.cpp和linker_uleb128.cpp负责压缩和解压缩数据的实现等。除了bionic/linker目录外，Linker相关的代码还分散在其他系统组件中，例如系统服务和应用程序框架。 ​ linker提供的一些函数来操作动态库，相关函数如下。 ​ 1. dlopen：打开一个动态链接库并返回句柄。 ​ 2. dlsym：查找动态链接库中符号的地址。 ​ 3. dlclose：关闭先前打开的动态链接库。 ​ 4. dlerror：返回最近的动态链接库错误。 ​ 5. dladdr：根据一个内存地址，返回映射到该地址的函数或变量的信息。 ​ 6. dl_iterate_phdr：遍历进程的动态链接库模块，可以获取模块地址、同名模块列表等信息。 ​ 在开始了解Linker如何加载动态库so文件前，需要先对so文件有一个简单的了解。 3.12.1 ELF文件格式​ 在Android中，so（Shared Object）动态库是一种是一种基于ELF格式（Executable and Linkable Format）的可执行文件，它包含已编译的函数和数据，可以在运行时被加载到内存中，并被多个应用程序或共享库使用。 ​ 与静态库不同，动态库中的代码在可执行文件中并不存在，取而代之的是一些动态链接器（Linker）编译时不知道的外部引用符号。在运行时，Linker会根据动态库中的符号表来解析这些引用，并将动态库中的函数和数据链接到可执行程序中。 ​ 进程间共享动态库可以大大减少内存使用，提高代码重用性和可维护性。例如，如果多个应用程序都需要使用同一组件库，可以将其实现作为共享库提供。这样一来，每个应用程序都可以使用同一份库，而不必将代码重复添加到每个应用程序中。 ​ 在ELF文件结构中，包含以下三个部分： ELF Header，ELF文件头，包含了文件的基本信息，例如文件类型、程序入口地址、节表的位置和大小等。 Section Header，节头部分，描述了文件中各个节的大小、类型和位置等信息。ELF文件中的每个节都包含某种类型的信息，例如代码、数据、符号表、重定位表以及其他调试信息等。 Program Header，段头部分，描述了可执行文件在内存中的布局。由于ELF文件的节可以以任意顺序排列，因此Linker在加载前需要使用Program Header来释放并映射虚拟内存，创建进程虚拟内存段布局。Program Header也包含了动态链接器所需的信息，例如动态库的位置、依赖关系和符号表位置等。 ​ 使用Android Studio创建一个Native C++的项目，成功编译后来到output目录中，解压app-debug.apk文件，然后进入app-debug\\lib\\arm64-v8a\\目录，找到so文件将其拖入010 Editor编辑器工具中。 ​ 接着给010 Editor编辑器安装一个ELF格式解析的模板，在工具栏找到模板-&gt;模板存储库。搜索ELF，点击安装，操作见下图。 ​ 模板安装后，关闭文件，重新使用010 Editor打开后，将编辑方式切换为模板后，就能成功看到使用ELF格式解析so文件的结果了，如下图。 ​ ELF头部定义了ELF文件的基本属性和结构，也为后续的段表和节表等信息提供了重要的指导作用。加载ELF文件的第一步就是解析ELF头部后，再根据头部信息去解析其他部分的数据，ELF头部（elf_header）结构包含以下成员： e_ident：长度为 16 字节的数组，用于标识文件类型和文件版本等信息。 e_type：ELF文件类型，如可执行文件、共享库、目标文件等等。 e_machine：目标硬件架构。 e_version：ELF文件的版本，其一般为EV_CURRENT。 e_entry：程序入口点的虚拟地址。 e_phoff：程序头表（program header table）的偏移量（以字节为单位）。 e_shoff：节头表（section header table）的偏移量（以字节为单位）。 e_flags：表示一些标志，比如针对硬件进行微调的标志。 e_ehsize：ELF头部的长度（以字节为单位）。 e_phentsize：程序头表中一个入口的长度（以字节为单位）。 e_phnum：程序头表中入口的数量。 e_shentsize：节头表中一个入口的长度（以字节为单位）。 e_shnum：节头表中入口的数量。 e_shstrndx：节头表中节名称字符串表的索引。 ​ 下图是010 Edtior解析展示的结果图。 ​ program header table是一种用于描述可执行文件和共享库的各个段（section）在进程内存中的映射关系的结构，也称为段表。每个程序头表入口表示一个段。在Linux系统中，它是被操作系统用于将ELF文件加载到进程地址空间的重要数据结构之一。每个program header table具有相同的固定结构，相关字段如下： p_type：指定该段的类型，如可执行代码、只读数据、可读写数据、动态链接表、注释等等。 p_offset：该段在ELF文件中的偏移量（以字节为单位）。 p_vaddr：该段在进程虚拟地址空间中的起始地址。 p_paddr：该项通常与p_vaddr相等。用于操作系统在将ELF文件的一个段映射到进程地址空间前，进行虚拟地址和物理地址的转换等操作。 p_filesz：该段在文件中的长度（以字节为单位）。 p_memsz：该段在加到进程地址空间后的长度（以字节为单位）。 p_flags：用于描述该段的标志，如可读、可写、可执行、不可缓存等等。 p_align：对于某些类型的段，该字段用于指定段在地址空间中的对齐方式。 ​ 下图是编辑器中解析so看到的值 ​ section header table（节头表）是用于描述ELF文件中所有节（section）的元信息列表，也称为节表。它包含了每个节在文件中的位置、大小、类型、属性等信息。节头表的中相关字段如下： sh_name: 节的名字在.shstrtab节中的向偏移量。这个偏移量可以用于获取该节的名字。 sh_type：节的类型（type），如代码段、数据段、符号表等。 sh_flags：节的属性标志，如是否可读、可写、可执行等。 sh_addr：节的内存地址（virtual address），当这个地址为零时，表示这个节没有被加载到内存中。 sh_offset：节在ELF文件中的偏移量（offset）。 sh_size：节的长度（size）属性。 sh_link：节的连接节（linking section），可以帮助定位一些节，如符号表。 sh_info：与sh_link一起使用，具体含义与sh_link的值有关。 sh_addralign：节的对齐方式（alignment）。 sh_entsize：节的entry的大小。 ​ 通过这些信息，section header table可以为执行链接和动态加载提供必要的元数据信息。样例数据看下图 ​ ELF文件中有各种节用于存放对应的信息，几个常见的节点存放数据的描述如下。 .dynsym 节：该节包含动态链接符号表（dynamic symbol table），用于描述.so文件所包含的动态链接库中的符号。符号是程序中一些命名实体的名称，例如函数、变量、常量等等，描述了这些实体在程序中的地址和大小等信息。.dynsym 节可以协助动态加载器（Dynamic Linker）在程序运行时逐个查找符号。 .dynstr 节：用于存放符号表中的字符串，包括函数名、变量名、库名等等。 .plt 节：保存了远程函数调用实现的跳转代码。 .rodata 节：包含程序中只读数据的代码段，如字符串常量、全局常量等等。 .text 节：程序的主要代码存放在该节中。该节包含可执行代码的机器语言指令，例如函数代码、条件语句、循环语句等等。 .bss 节点（Block Started by Symbol）存储未初始化的全局变量和静态变量，其大小在编译时无法确定。因此，.bss节点在ELF文件中只占据一些空间，该空间称为bss段。而在运行时，操作系统会分配实际的内存空间给这些变量。.bss节点的大小在 ELF文件头的e_shsize字段中给出。 .shstrtab 节点（Section Header String Table）存储节名称字符串，即每个节的名称和节头表中的节名称偏移量。它包含了ELF文件中每个节的字符串名称，方便读取程序在加载时快速访问。在Android中，.shstrtab节点是一个特殊的节，它位于节头表的末尾，可以通过ELF文件头的e_shstrndx字段找到。 3.12.2 动态库加载流程​ Linker动态库加载是把代码（函数、变量、数据结构等）从动态链接库（so文件）中加载到内存中，并建立起代码之间的相互引用关系的过程。在Android等操作系统中，Linker动态加载主要用于模块化开发，将程序分为多个独立的模块，以便于代码的管理和维护。下面是Linker动态加载的主要步骤： 根据系统的运行时需求，将需要的库文件加载进内存中，实现代码重用和共享。此时，Linker会执行一些特定的逻辑，如依赖优化、so文件版本检查等。 在进行动态链接的过程中，Linker会为每个库和每个函数生成全局唯一的标识符，以确定代码所在的地址。这个标识符会在编译过程中嵌入到库文件的头部，并且保存到动态链接库的符号表中。 解析符号表。Linker会读取库文件的符号表，并把符号名和符号地址配对起来，以便于在程序运行期间在内存中动态地连接他们。 检查符号表中的函数的其他库依赖项。如果当前库依赖于其他库，Linker就会递归地对这些依赖库进行加载、解析和链接。 调整符号地址。Linker会修改符号表中的函数地址，将函数重定向到动态库中正确的位置，以确保函数调用能够正确地传递和接收数据。 执行初始化和清理代码。在所有库和函数都被解析、链接和装载之后，Linker会执行全局构造函数来初始化代码，以及执行全局析构函数来清理代码。 Linker动态加载过程中还会涉及到如动态追加、卸载等操作。 ​ 以上是Linker动态加载的主要步骤及涉及到的主要逻辑。接着从源码层面跟踪动态加载的具体过程。打开前面创建的样例app。 12345678public class MainActivity extends AppCompatActivity { // Used to load the 'linkertest' library on application startup. static { System.loadLibrary(&quot;linkertest&quot;); } ... public native String stringFromJNI();} ​ 在应用层直接通过调用loadLibrary就可以完成一系列的加载动态库的操作了，看看内部是如何实现的。首先是System下的loadLibrary函数，前文有介绍过libcore中存放着openjdk的核心库的实现，而java.lang.System就是其中，找到文件libcore/ojluni/src/main/java/java/lang/System.java查看函数实现如下。 123public static void loadLibrary(String libname) { Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);} ​ 继续在ojluni的目录中搜索loadLibrary0的函数实现 12345678910111213141516171819202122232425262728293031323334353637383940void loadLibrary0(Class&lt;?&gt; fromClass, String libname) { ClassLoader classLoader = ClassLoader.getClassLoader(fromClass); loadLibrary0(classLoader, fromClass, libname);}private synchronized void loadLibrary0(ClassLoader loader, Class&lt;?&gt; callerClass, String libname) { ... String libraryName = libname; // 如果classloader不是BootClassLoader if (loader != null &amp;&amp; !(loader instanceof BootClassLoader)) { String filename = loader.findLibrary(libraryName); if (filename == null &amp;&amp; (loader.getClass() == PathClassLoader.class || loader.getClass() == DelegateLastClassLoader.class)) { filename = System.mapLibraryName(libraryName); } ... String error = nativeLoad(filename, loader); if (error != null) { throw new UnsatisfiedLinkError(error); } return; } getLibPaths(); String filename = System.mapLibraryName(libraryName); String error = nativeLoad(filename, loader, callerClass); if (error != null) { throw new UnsatisfiedLinkError(error); }}// 看到不管是哪个Classloader都是调用的nativeLoad，只是重载不一样。但是两个参数的实际也是调用了三个参数重载的实现。private static String nativeLoad(String filename, ClassLoader loader) { return nativeLoad(filename, loader, null);}// 三个参数重载的是一个native函数private static native String nativeLoad(String filename, ClassLoader loader, Class&lt;?&gt; caller); ​ 继续搜索nativeLoad的相关实现如下 1234567// 调用了JVM_NativeLoadJNIEXPORT jstring JNICALLRuntime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename, jobject javaLoader, jclass caller){ return JVM_NativeLoad(env, javaFilename, javaLoader, caller);} ​ JVM_NativeLoad的代码在art目录中，继续查看相关实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104JNIEXPORT jstring JVM_NativeLoad(JNIEnv* env, jstring javaFilename, jobject javaLoader, jclass caller) { ScopedUtfChars filename(env, javaFilename); if (filename.c_str() == nullptr) { return nullptr; } std::string error_msg; { art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM(); bool success = vm-&gt;LoadNativeLibrary(env, filename.c_str(), javaLoader, caller, &amp;error_msg); if (success) { return nullptr; } } ...}// 继续找到相关实现bool JavaVMExt::LoadNativeLibrary(JNIEnv* env, const std::string&amp; path, jobject class_loader, jclass caller_class, std::string* error_msg) { error_msg-&gt;clear(); SharedLibrary* library; Thread* self = Thread::Current(); { MutexLock mu(self, *Locks::jni_libraries_lock_); library = libraries_-&gt;Get(path); } ... // 已经加载过的，存在则返回true了。 if (library != nullptr) { ... return true; } ScopedLocalRef&lt;jstring&gt; library_path(env, GetLibrarySearchPath(env, class_loader)); Locks::mutator_lock_-&gt;AssertNotHeld(self); const char* path_str = path.empty() ? nullptr : path.c_str(); bool needs_native_bridge = false; char* nativeloader_error_msg = nullptr; // 加载动态链接库 void* handle = android::OpenNativeLibrary( env, runtime_-&gt;GetTargetSdkVersion(), path_str, class_loader, (caller_location.empty() ? nullptr : caller_location.c_str()), library_path.get(), &amp;needs_native_bridge, &amp;nativeloader_error_msg); VLOG(jni) &lt;&lt; &quot;[Call to dlopen(\\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;, RTLD_NOW) returned &quot; &lt;&lt; handle &lt;&lt; &quot;]&quot;; ... bool created_library = false; { std::unique_ptr&lt;SharedLibrary&gt; new_library( new SharedLibrary(env, self, path, handle, needs_native_bridge, class_loader, class_loader_allocator)); MutexLock mu(self, *Locks::jni_libraries_lock_); library = libraries_-&gt;Get(path); // 将刚刚加载好的链接库保存起来 if (library == nullptr) { // We won race to get libraries_lock. library = new_library.release(); libraries_-&gt;Put(path, library); created_library = true; } } ... bool was_successful = false; // 查找符号JNI_OnLoad void* sym = library-&gt;FindSymbol(&quot;JNI_OnLoad&quot;, nullptr); if (sym == nullptr) { ... } else { ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride())); self-&gt;SetClassLoaderOverride(class_loader); VLOG(jni) &lt;&lt; &quot;[Calling JNI_OnLoad in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;; using JNI_OnLoadFn = int(*)(JavaVM*, void*); JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym); // 调用JNI_OnLoad int version = (*jni_on_load)(this, nullptr); ... } library-&gt;SetResult(was_successful); return was_successful;} ​ 在这个函数中，看到使用OpenNativeLibrary来加载一个动态库，然后将加载动态库的信息包装成SharedLibrary对象，存入libraries_中，下次再加载时，会在libraries_查看是否存在，存在则直接返回。接着又通过函数FindSymbol查找JNI_OnLoad的符号地址，然后进行调用。继续跟踪加载动态库的具体实现，最后再回头看查找符号的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void* OpenNativeLibrary(JNIEnv* env, int32_t target_sdk_version, const char* path, jobject class_loader, const char* caller_location, jstring library_path, bool* needs_native_bridge, char** error_msg) {#if defined(ART_TARGET_ANDROID) UNUSED(target_sdk_version); if (class_loader == nullptr) { ... void* handle = android_dlopen_ext(path, RTLD_NOW, &amp;dlextinfo); if (handle == nullptr) { *error_msg = strdup(dlerror()); } return handle; ... { Result&lt;void*&gt; handle = TryLoadNativeloaderExtraLib(path); if (!handle.ok()) { *error_msg = strdup(handle.error().message().c_str()); return nullptr; } if (handle.value() != nullptr) { return handle.value(); } } ... void* handle = OpenSystemLibrary(path, RTLD_NOW); if (handle == nullptr) { *error_msg = strdup(dlerror()); } return handle; } ...#else for (const std::string&amp; lib_path : library_paths) { ... void* handle = dlopen(path_arg, RTLD_NOW); if (handle != nullptr) { return handle; } if (NativeBridgeIsSupported(path_arg)) { *needs_native_bridge = true; handle = NativeBridgeLoadLibrary(path_arg, RTLD_NOW); if (handle != nullptr) { return handle; } *error_msg = strdup(NativeBridgeGetError()); } else { *error_msg = strdup(dlerror()); } } return nullptr;#endif} ​ 在这里函数看到，使用多种方式尝试进行动态加载，分别是android_dlopen_ext、TryLoadNativeloaderExtraLib、OpenSystemLibrary。它们都是在Android平台上用来加载动态库的方法，但是它们各自的使用场景略有不同： android_dlopen_ext：是一个供开发者使用的公开函数，它支持指定库的绝对路径和不同的标志（如RTLD_NOW、RTLD_LAZY等），并返回一个指向已加载库的指针，供后续调用函数的时候使用。 TryLoadNativeloaderExtraLib：是Android系统中的内部方法，用于加载额外的本地库。它被用于支持动态加载共享库的应用程序，例如使用反射实现的动态库加载方式。系统在应用程序启动时调用它，用于加载应用程序所需的额外本地库。使用该方法可以加载特定的本地库，并支持跨架构的执行。 OpenSystemLibrary：也是Android系统中的内部方法，用于加载Android系统的本地库。它不需要指定库的路径，而是使用系统库路径中的路径名来加载相应的库文件。该方法主要用于加载Android操作系统核心中的一些固定的系统库，例如 libz.so、liblog.so等。 ​ 总的来说，这三个方法都是用于加载动态库的方法，不同的是它们的使用场景略有不同。选一条路线分析即可，这里继续从android_dlopen_ext深入分析，该函数的相关代码在libdl.cpp中实现。 1234void* android_dlopen_ext(const char* filename, int flag, const android_dlextinfo* extinfo) { const void* caller_addr = __builtin_return_address(0); return __loader_android_dlopen_ext(filename, flag, extinfo, caller_addr);} ​ 继续跟踪文件dlfcn.cpp中的实现 123456789101112131415161718192021void* __loader_android_dlopen_ext(const char* filename, int flags, const android_dlextinfo* extinfo, const void* caller_addr) { return dlopen_ext(filename, flags, extinfo, caller_addr);}static void* dlopen_ext(const char* filename, int flags, const android_dlextinfo* extinfo, const void* caller_addr) { ScopedPthreadMutexLocker locker(&amp;g_dl_mutex); g_linker_logger.ResetState(); void* result = do_dlopen(filename, flags, extinfo, caller_addr); if (result == nullptr) { __bionic_format_dlerror(&quot;dlopen failed&quot;, linker_get_error_buffer()); return nullptr; } return result;} ​ 到这里do_dlopen则执行到了Linker部分的实现了，找到linker.cpp文件查看 12345678910111213141516171819202122void* do_dlopen(const char* name, int flags, const android_dlextinfo* extinfo, const void* caller_addr) { ... soinfo* si = find_library(ns, translated_name, flags, extinfo, caller); loading_trace.End(); if (si != nullptr) { void* handle = si-&gt;to_handle(); LD_LOG(kLogDlopen, &quot;... dlopen calling constructors: realpath=\\&quot;%s\\&quot;, soname=\\&quot;%s\\&quot;, handle=%p&quot;, si-&gt;get_realpath(), si-&gt;get_soname(), handle); si-&gt;call_constructors(); failure_guard.Disable(); LD_LOG(kLogDlopen, &quot;... dlopen successful: realpath=\\&quot;%s\\&quot;, soname=\\&quot;%s\\&quot;, handle=%p&quot;, si-&gt;get_realpath(), si-&gt;get_soname(), handle); return handle; } return nullptr;} ​ 这里看到通过find_library进行查找的，找到后又调用了call_constructors函数。先看看call_constructors函数的处理。 12345678910void soinfo::call_constructors() { if (constructors_called || g_is_ldd) { return; } ... call_function(&quot;DT_INIT&quot;, init_func_, get_realpath()); call_array(&quot;DT_INIT_ARRAY&quot;, init_array_, init_array_count_, false, get_realpath()); ...} ​ 根据上面代码发现这里就是.init和.initarray执行的地方，继续看加载的流程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134static soinfo* find_library(android_namespace_t* ns, const char* name, int rtld_flags, const android_dlextinfo* extinfo, soinfo* needed_by) { soinfo* si = nullptr; if (name == nullptr) { si = solist_get_somain(); } else if (!find_libraries(ns, needed_by, &amp;name, 1, &amp;si, nullptr, 0, rtld_flags, extinfo, false /* add_as_children */)) { if (si != nullptr) { soinfo_unload(si); } return nullptr; } si-&gt;increment_ref_count(); return si;}// 继续向下跟踪bool find_libraries(...) { ... ZipArchiveCache zip_archive_cache; soinfo_list_t new_global_group_members; for (size_t i = 0; i&lt;load_tasks.size(); ++i) { 。。。 if (!find_library_internal(const_cast&lt;android_namespace_t*&gt;(task-&gt;get_start_from()), task, &amp;zip_archive_cache, &amp;load_tasks, rtld_flags)) { return false; } soinfo* si = task-&gt;get_soinfo(); } ... return true;}//追踪find_library_internalstatic bool find_library_internal(android_namespace_t* ns, LoadTask* task, ZipArchiveCache* zip_archive_cache, LoadTaskList* load_tasks, int rtld_flags) { soinfo* candidate; ... if (load_library(ns, task, zip_archive_cache, load_tasks, rtld_flags, true /* search_linked_namespaces */)) { return true; } ... return false;}static bool load_library(android_namespace_t* ns, LoadTask* task, ZipArchiveCache* zip_archive_cache, LoadTaskList* load_tasks, int rtld_flags, bool search_linked_namespaces) { const char* name = task-&gt;get_name(); soinfo* needed_by = task-&gt;get_needed_by(); ... LD_LOG(kLogDlopen, &quot;load_library(ns=%s, task=%s, flags=0x%x, search_linked_namespaces=%d): calling &quot; &quot;open_library&quot;, ns-&gt;get_name(), name, rtld_flags, search_linked_namespaces); // Open the file. off64_t file_offset; std::string realpath; int fd = open_library(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath); ... return load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);}// open_library打开动态库文件将指定的共享库文件加载到当前进程的地址空间中，创建一个新的动态链接对象，并返回其的句柄。static int open_library(android_namespace_t* ns, ZipArchiveCache* zip_archive_cache, const char* name, soinfo *needed_by, off64_t* file_offset, std::string* realpath) { TRACE(&quot;[ opening %s from namespace %s ]&quot;, name, ns-&gt;get_name()); // If the name contains a slash, we should attempt to open it directly and not search the paths. if (strchr(name, '/') != nullptr) { return open_library_at_path(zip_archive_cache, name, file_offset, realpath); } ... return fd;}// load_library加载解析ELF格式并将其链接到进程的地址空间中，将动态链接对象中的符号解析为当前进程中的符号，从而创建动态链接的关系。static bool load_library(android_namespace_t* ns, LoadTask* task, LoadTaskList* load_tasks, int rtld_flags, const std::string&amp; realpath, bool search_linked_namespaces) { ... soinfo* si = soinfo_alloc(ns, realpath.c_str(), &amp;file_stat, file_offset, rtld_flags); task-&gt;set_soinfo(si); // 读取elf header if (!task-&gt;read(realpath.c_str(), file_stat.st_size)) { task-&gt;remove_cached_elf_reader(); task-&gt;set_soinfo(nullptr); soinfo_free(si); return false; } ... return true;}// 最后看看read函数，这个函数负责从elf文件格式的数据中读取内容bool read(const char* realpath, off64_t file_size) { ElfReader&amp; elf_reader = get_elf_reader(); return elf_reader.Read(realpath, fd_, file_offset_, file_size); } ​ ElfReader是Android源文件中的工具，位于系统核心库libcore中，代码主要由C++编写。它可以读取ELF文件的所有信息，并将其解析为指定格式。 ElfReader具备以下特点： 读取ELF文件的头信息，包括ELF版本、目标体系结构、程序入口地址、节表偏移量等。 读取ELF文件的节表信息，包括节表名称、大小、偏移量、属性等。 通过节表信息可以获取符号表、重定位表、动态链接表等关键信息，如函数、变量、链接库、导出函数等。 支持通过指定节表名称获取某个节表的信息，如根据”.rodata“获取只读数据节表的信息等。 小结系统定制无论做怎样的修改，都要明白其原理，本章内容作为系统开发的内功心法，需要读者花费一些时间来吸收，在后面的内容的展开过程中，也可以随时重温本章内容，加深印象。 从设备开机到系统启动完成，整个启动链上涉及到的核心组件都在本节中进行了介绍。本节中介绍的系统组件，都是定制系统可能需要修改的地方。其中，Service与Framework的修改是最常见的，美化与安全定制都离不开它，读者朋友们可以重点阅读它们的代码来深入研究。","link":"/2025/04/07/chapter-03/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/12/08/hello-world/"},{"title":"OkHttp源码分析","text":"OkHttp请求流程 高并发请求分发器与线程池 责任链模式请求与响应拦截 目录 OkHttp介绍 简单使用： 使用流程： 调用流程： 分发器： 异步请求工作流程： OkHttp线程池的特点： AsyncCall 同步请求 拦截器： 获取响应： 责任链模式： 拦截器责任链： 五大拦截器功能： 拦截器详情： 一、重试及重定向拦截器 重试 重定向 总结 二、桥接拦截器 总结 三、缓存拦截器 缓存策略 流程： 详细流程： PS：请求头与响应头 四、连接拦截器 连接流程： 连接池清理： 代理连接： 五、请求服务器拦截器 Expect: 100-continue 总结 自定义拦截器 OkHttp总结 补充: 代理 OkHttp介绍由Square公司贡献的一个处理网络请求的开源项目，是目前Android使用最广泛的网络框架，从Android4。4开始HttpURLConnection的底层实现采用的是OkHttp。 支持HTTP/2并允许对同一主机的所有请求共享一个套接字 通过连接池，减少了请求延迟 默认通过GZip压缩数据 响应缓存，以免了重复请求的网络 请求失败自动重试主机的其他ip，自动重定向 …… 简单使用：123456789101112131415161718192021OkHttpClient okHttpClient = new OkHttpClient();Request request = new Request.Builder().url(&quot;http://www.baidu.com&quot;).build();Call call = okHttpClient.newCall(request);try { //同步请求 Response execute = call.execute();} catch (IOException e) { e.printStackTrace();}//异步请求call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { }}); 使用流程： 调用流程：OkHttp请求过程中最少需要接触OkHttpClient、Request、Call、Response，但是框架内部进行大量的逻辑处理。 所有的逻辑大部分集中在拦截器中，但是在进入拦截器之前还需要依靠分发器来调配请求任务。 分发器：内部维护队列与线程池，完成请求调配；Dispatcher 拦截器：五大默认拦截器完成整个请求过程； Interceptors 分发器：异步请求工作流程： Q：如何决定将请求放入ready还是running? Q：从running移动到ready的条件是什么？ Q：分发器线程池的工作行为？ Dispatcher中 A: client.dispatcher().enqueue(new AsyncCall(responseCallback)); 1234567891011121314synchronized void enqueue(AsyncCall call) { //1.running队列数小于最大请求数64（正在请求的的数量是有限制的，自己配置分发器时可以修改） //2.同一域名正在请求的个数也是有限制的小于5 //PS:最大同时请求数64，与同一台服务器请求数5 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) { //添加到running队列 runningAsyncCalls.add(call); //将runnable（call）提交到线程池当中 executorService().execute(call); } else { //不符合上面请求就加入到等待队列 readyAsyncCalls.add(call); }} A:client.dispatcher().finished(this);-&gt; promoteCalls()移动队列（异步时才有移动队列） 123456789101112131415161718192021private void promoteCalls() { //正在执行队列数 if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. //等待队列数得不为空 if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) { AsyncCall call = i.next(); //如果拿到的等待请求host，在请求的列表中已经存在5个 if (runningCallsForHost(call) &lt; maxRequestsPerHost) { //等待移除 i.remove(); //加入running runningAsyncCalls.add(call); //加入线程池 executorService().execute(call); } //判断正在执行队列数 if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. }} A:ThreadPoolExecutor 当一个任务通过execute(Runnable)方法添加到线程池时： 线程数量小于corePoolSize，新建线程(核心)来处理被添加的任务； 线程数量大于等于 corePoolSize，存在空闲线程，使用空闲线程执行新任务；- 线程数量大于等于 corePoolSize，不存在空闲线程，新任务被添加到等待队列，添加成功则等待空闲线程，添加失败： 线程数量小于maximumPoolSize，新建线程执行新任务； 线程数量等于maximumPoolSize，拒绝此任务。 1234567891011121314public synchronized ExecutorService executorService() { if (executorService == null) { //corePoolSize:核心线程数 0 不缓存线程，（0和1的表现是一样的）不用时就不占用线程，闲置60就会回收掉 //maximumPoolSize最大线程数（包括核心） //keepAliveTime 缓存60秒 //workQueue 队列 //threadFactory 创建一个thread //PS:和Executors.newCachedThreadPool();创建的线程池一样 executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); } return executorService;} SynchronousQueue implements BlockingQueue 是个阻塞队列 PS:三种阻塞队列 ArrayBlockingQueue：基于数组的阻塞队列，初始化需要指定固定大小。 LinkedBlockingQueue：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。 SynchronousQueue : 无容量的队列。 往队列中添加元素一定是失败的。 OkHttp线程池的特点：OkHttp提交请求，一定是往队列里提交，往队列中添加是一定是失败的，马上新建线程（没有到最大线程数）， 不需要等待。获得最大的并发量 AsyncCall继承NamedRunnable类实现Runnable接口 12345678910111213141516171819202122public abstract class NamedRunnable implements Runnable { protected final String name; public NamedRunnable(String format, Object... args) { this.name = Util.format(format, args); } /** * run方法其实调用的AsyncCall的execute() */ @Override public final void run() { String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try { execute(); } finally { Thread.currentThread().setName(oldName); } } protected abstract void execute();} 同步请求加入队列，执行完移除队列 1234synchronized void executed(RealCall call) { //同步直接加入running队列，这里的running是同步队列不是异步的 runningSyncCalls.add(call);} 拦截器：默认五大拦截器：（责任链模式）重定向与重试，Header、Body处理，缓存处理，连接处理，服务器通讯 请求是顺序的，响应是逆序的 获取响应：无论同步还是异常都是通过getResponseWithInterceptorChain 获得请求结果：Response 123456789101112131415161718192021222324Response getResponseWithInterceptorChain() throws IOException { // 拦截器集合 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); //重定向与重试 interceptors.add(retryAndFollowUpInterceptor); //Header,Body处理 interceptors.add(new BridgeInterceptor(client.cookieJar())); //缓存处理 interceptors.add(new CacheInterceptor(client.internalCache())); //连接处理 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } //服务器通讯 interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);} 责任链模式：（一排，最后一位往前一个个传纸条[请求]，传到第一个又一个个往后传[响应]） 为请求创建了一个接收者对象的链，在处理请求的时候执行过滤(各司其职)。 责任链上的处理者负责处理请求，客户只需要将请求发送到责任链即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 拦截器责任链： 五大拦截器功能： 重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。 桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。 缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。 连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。 请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。 拦截器详情：一、重试及重定向拦截器第一个拦截器:RetryAndFollowUpInterceptor，主要就是完成两件事情：重试与重定向。 重试场景：请求超时；域名解析后多个IP，如果一个IP失败了，重试其他IP 设置是否允许重试 12//设置是否允许重试 默认是允许new OkHttpClient().newBuilder().retryOnConnectionFailure(true); 在RetryAndFollowUpInterceptor中失败时，进入recover方法 12345678910111213141516171819202122try { //todo 请求出现了异常，那么releaseConnection依旧为true。 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false;} catch (RouteException e) { //todo 路由异常，连接未成功，请求还没发出去 //The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), streamAllocation, false, request)) { throw e.getLastConnectException(); } releaseConnection = false; //重试 continue;} catch (IOException e) { //todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接) // ConnectionShutdownException只对HTTP2存在。假定它就是false //An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue;} 在recover中 获取是否允许重试，如果不允许就抛异常，结束。 123456789101112131415161718192021222324private boolean recover(IOException e, StreamAllocation streamAllocation, boolean requestSendStarted, Request userRequest) { streamAllocation.streamFailed(e); //todo 1、在配置OkhttpClient是设置了不允许重试（默认允许），则一旦发生请求失败就不再重试 //The application layer has forbidden retries. if (!client.retryOnConnectionFailure()) return false; //todo 2、由于requestSendStarted只在http2的io异常中为true，先不管http2 //We can't send the request body again. if (requestSendStarted &amp;&amp; userRequest.body() instanceof UnrepeatableRequestBody) return false; //todo 3、判断是不是属于重试的异常 //This exception is fatal. if (!isRecoverable(e, requestSendStarted)) return false; //todo 4、是不是存在更多的路线 （多个ip，多个代理） //No more routes to attempt. if (!streamAllocation.hasMoreRoutes()) return false; // For failure recovery, use the same route selector with a new connection. return true; } 重试的异常包括哪些： 在 todo 3的isRecoverable方法中 12345678910111213141516171819202122232425262728private boolean isRecoverable(IOException e, boolean requestSendStarted) { // 1.是不是协议异常（code为204,205代表没有响应体，同时响应数据长度还大于0两都冲突，参照CallServerInterceptor中 // if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0)） //：不重试 if (e instanceof ProtocolException) { return false; } //2.socket超时异常 返回true:重试 if (e instanceof InterruptedIOException) { return e instanceof SocketTimeoutException &amp;&amp; !requestSendStarted; } //3.//SSL证书不正确 可能证书格式损坏 有问题：不重试 if (e instanceof SSLHandshakeException) { // If the problem was a CertificateException from the X509TrustManager, // do not retry. if (e.getCause() instanceof CertificateException) { return false; } } //4.SSL证书校验 ：不重试 if (e instanceof SSLPeerUnverifiedException) { return false; } return true;} 所以在socket超时异常时会进行重试，其他异常不再进行重试 重定向场景：30X，资源改变 最大重定向次数为：20 12345678//todo 处理3和4xx的一些状态码，如301 302重定向Request followUp = followUpRequest(response, streamAllocation.route());if (followUp == null) { if (!forWebSocket) { streamAllocation.release(); } return response;} 1Request followUpRequest(Response userResponse, Route route) 在followUpRequest中响应码 407: 1234567891011//407 身份校验case HTTP_PROXY_AUTH: Proxy selectedProxy = route != null ? route.proxy() : client.proxy(); if (selectedProxy.type() != Proxy.Type.HTTP) { throw new ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not &quot; + &quot;using proxy&quot;); } //用户没有设置就返回null,重定向就结束了 return client.proxyAuthenticator().authenticate(route, userResponse); 用户设置身份校验 123456789101112131415//设置身份校验的代理new OkHttpClient.Builder().proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress( &quot;localhost&quot;, 8080)))//设置身份校验(默认不设置这个）.proxyAuthenticator(new Authenticator() { @Nullable @Override public Request authenticate(Route route, Response response) throws IOException { //参照Authenticator接口注释 return response.request().newBuilder() .header(&quot;Proxy-Authorization&quot;, Credentials.basic(&quot;用户名&quot;,&quot;密码&quot;)) .build(); }}).build(); 401: 1234// 401 需要身份验证 有些服务器接口需要验证使用者身份 在请求头中添加 “Authorization”case HTTP_UNAUTHORIZED: //类似407身份验证，设置authenticator() return client.authenticator().authenticate(route, userResponse); 重定向： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 308 永久重定向// 307 临时重定向case HTTP_PERM_REDIRECT:case HTTP_TEMP_REDIRECT: // 如果请求方式不是GET或者HEAD，框架不会自动重定向请求 if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) { return null; } // 300 301 302 303case HTTP_MULT_CHOICE:case HTTP_MOVED_PERM:case HTTP_MOVED_TEMP:case HTTP_SEE_OTHER: // 如果用户不允许重定向，那就返回null if (!client.followRedirects()) return null; // 从响应头取出location String location = userResponse.header(&quot;Location&quot;); if (location == null) return null; // 根据location 配置新的请求 url HttpUrl url = userResponse.request().url().resolve(location); // 如果为null，说明协议有问题，取不出来HttpUrl，那就返回null，不进行重定向 if (url == null) return null; // 如果重定向在http到https之间切换，需要检查用户是不是允许(默认允许) boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme()); if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null; Request.Builder requestBuilder = userResponse.request().newBuilder(); /** * 重定向请求中 只要不是 PROPFIND 请求，无论是POST还是其他的方法都要改为GET请求方式， * 即只有 PROPFIND 请求才能有请求体 */ //请求不是get与head if (HttpMethod.permitsRequestBody(method)) { final boolean maintainBody = HttpMethod.redirectsWithBody(method); // 除了 PROPFIND 请求之外都改成GET请求 if (HttpMethod.redirectsToGet(method)) { requestBuilder.method(&quot;GET&quot;, null); } else { RequestBody requestBody = maintainBody ? userResponse.request().body() : null; requestBuilder.method(method, requestBody); } // 不是 PROPFIND 的请求，把请求头中关于请求体的数据删掉 if (!maintainBody) { requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); requestBuilder.removeHeader(&quot;Content-Type&quot;); } } // 在跨主机重定向时，删除身份验证请求头 if (!sameConnection(userResponse, url)) { requestBuilder.removeHeader(&quot;Authorization&quot;); } return requestBuilder.url(url).build(); 408请求超时： 123456789101112131415161718192021// 408 客户端请求超时 case HTTP_CLIENT_TIMEOUT: // 408 算是连接失败了，所以判断用户是不是允许重试 if (!client.retryOnConnectionFailure()) { return null; } // UnrepeatableRequestBody实际并没发现有其他地方用到 if (userResponse.request().body() instanceof UnrepeatableRequestBody) { return null; } // 如果是本身这次的响应就是重新请求的产物同时上一次之所以重请求还是因为408，那我们这次不再重请求了 if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) { return null; } // 如果服务器告诉我们了 Retry-After 多久后重试，那框架不管了。 if (retryAfter(userResponse, 0) &gt; 0) { return null; } return userResponse.request(); 503: // 503 服务不可用 和408差不多，但是只在服务器告诉你 Retry-After：0（意思就是立即重试） 才重请求 12345678910case HTTP_UNAVAILABLE: if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) { return null; }if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) { return userResponse.request();}return null; 重定向总结：服务器返回300 301 302 303需要重定向，会获取返回头的Location中的新地址。 如果此方法followUpRequest返回空，那就表示不需要再重定向了，直接返回响应；但是如果返回非空，那就要重新请求返回的Request，但是需要注意的是，我们的followup在拦截器中定义的最大次数为20次。 总结本拦截器是整个责任链中的第一个，这意味着它会是首次接触到Request与最后接收到Response的角色，在这个拦截器中主要功能就是判断是否需要重试与重定向。 重试的前提是出现了RouteException或者IOException。一但在后续的拦截器执行过程中出现这两个异常，就会通过recover方法进行判断是否进行连接重试。 重定向发生在重试的判定之后，如果不满足重试的条件，还需要进一步调用followUpRequest根据Response 的响应码(当然，如果直接请求失败，Response都不存在就会抛出异常)。followup最大发生20次。 二、桥接拦截器两大作用：补全请求头，处理响应（保存cookie，GzipSource） 补全请求与响应后处理 请求头 说明 Content-Type 请求体类型,如：application/x-www-form-urlencoded Content-Length/Transfer-Encoding 请求体解析方式 Host 请求的主机站点 Connection: Keep-Alive 保持长连接 Accept-Encoding: gzip 接受响应支持gzip压缩 Cookie cookie身份辨别 User-Agent 请求的用户信息，如:操作系统、浏览器等 得到响应： 1、读取Set-Cookie响应头并调用接口告知用户，在下次请求则会读取对应的数据设置进入请求头，默认CookieJar无实现； ​ 2、响应头Content-Encoding为gzip，使用GzipSource包装便于解析。 总结桥接拦截器的执行逻辑主要就是以下几点 对用户构建的Request进行添加或者删除相关头部信息，以转化成能够真正进行网络请求的Request将符合网络请求规范的Request交给下一个拦截器处理，并获取Response如果响应体经过了GZIP压缩，那就需要解压，再构建成用户可用的Response并返回 三、缓存拦截器CacheInterceptor，在发出请求前，判断是否命中缓存。如果命中则可以不请求，直接使用缓存的响应。 (只会存在Get请求的缓存) 步骤为: 1、从缓存中获得对应请求的响应缓存 2、创建CacheStrategy ,创建时会判断是否能够使用缓存，在CacheStrategy 中存在两个成员:networkRequest与cacheResponse。他们的组合如下: networkRequest cacheResponse 说明 Null Not Null 直接使用缓存 Not Null Null 向服务器发起请求 Null Null 直接gg，okhttp直接返回504 Not Null Not Null 发起请求，若得到响应为304(无修改)，则更新缓存响应并返回 即：networkRequest存在则优先发起网络请求，否则使用cacheResponse缓存，若都不存在则请求失败！ 3、交给下一个责任链继续处理 4、后续工作，返回304则用缓存的响应；否则使用网络响应并缓存本次响应（只缓存Get请求的响应） 缓存拦截器的工作说起来比较简单，但是具体的实现，需要处理的内容很多。在缓存拦截器中判断是否可以使用缓存，或是请求服务器都是通过CacheStrategy判断。 缓存策略123//todo 缓存策略:根据各种条件(请求头)组成 请求与缓存CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); 12345678910public CacheStrategy get() { CacheStrategy candidate = getCandidate(); //todo 如果可以使用缓存，那networkRequest必定为null；指定了只使用缓存但是networkRequest又不为null，冲突。那就gg(拦截器返回504) if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) { // We're forbidden from using the network and the cache is insufficient. return new CacheStrategy(null, null); } return candidate;} 流程： 没有缓存，就进行网络请求 如果是Https请求，缓存中没有保存握手信息，发起网络请求 通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求（isCacheable方法）：不允许用 如果请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性（用户配置不进行缓存）：不想用 如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存 响应的缓存有效期 这一步为进一步根据缓存响应中的一些信息判定缓存是否处于有效期内。如果满足： 缓存存活时间 &lt; 缓存新鲜度 - 缓存最小新鲜度 + 过期后继续使用时长 代表可以使用缓存。其中新鲜度可以理解为有效时间，而这里的 “缓存新鲜度-缓存最小新鲜度” 就代表了缓存真正有效的时间。 缓存过期处理 如果继续执行，表示缓存已经过期无法使用。此时我们判定缓存的响应中如果存在Etag，则使用If-None-Match交给服务器进行验证；如果存在Last-Modified或者Data，则使用If-Modified-Since交给服务器验证。服务器如果无修改则会返回304，这时候注意： 由于是缓存过期而发起的请求(与第4个判断用户的主动设置不同)，如果服务器返回304，那框架会自动更新缓存，所以此时CacheStrategy既包含networkRequest也包含cacheResponse 详细流程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109private CacheStrategy getCandidate() { // No cached response. //todo 1、没有缓存,进行网络请求 if (cacheResponse == null) { return new CacheStrategy(request, null); } //todo 2、https请求，但是没有握手信息,进行网络请求 // OkHttp会保存ssl握手信息 handshake,如果这次发起了https请求， // 但是缓存的响应信息中没有握手信息，发起网络请求 //Drop the cached response if it's missing a required handshake. if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) { return new CacheStrategy(request, null); } //todo 3、主要是通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求 //If this response shouldn't have been stored, it should never be used //as a response source. This check should be redundant as long as the //persistence store is well-behaved and the rules are constant. if (!isCacheable(cacheResponse, request)) { return new CacheStrategy(request, null); } CacheControl requestCaching = request.cacheControl(); //todo 4、如果 请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性 // 或者请求头包含 If-Modified-Since：时间 值为lastModified或者data 如果服务器没有在该头部指定的时间之后修改了请求的数据，服务器返回304(无修改) // 或者请求头包含 If-None-Match：值就是Etag（资源标记）服务器将其与存在服务端的Etag值进行比较；如果匹配，返回304 // 请求头中只要存在三者中任意一个，进行网络请求 if (requestCaching.noCache() || hasConditions(request)) { return new CacheStrategy(request, null); } //todo 5、如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存 CacheControl responseCaching = cacheResponse.cacheControl(); if (responseCaching.immutable()) { return new CacheStrategy(null, cacheResponse); } //todo 6、根据 缓存响应的 控制缓存的响应头 判断是否允许使用缓存 // 6.1、获得缓存的响应从创建到现在的时间 long ageMillis = cacheResponseAge(); //todo // 6.2、获取这个响应有效缓存的时长 long freshMillis = computeFreshnessLifetime(); if (requestCaching.maxAgeSeconds() != -1) { //todo 如果请求中指定了 max-age 表示指定了能拿的缓存有效时长，就需要综合响应有效缓存时长与请求能拿缓存的时长，获得最小的能够使用响应缓存的时长 freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds())); } //todo // 6.3 请求包含 Cache-Control:min-fresh=[秒] 能够使用还未过指定时间的缓存 （请求认为的缓存有效时间） long minFreshMillis = 0; if (requestCaching.minFreshSeconds() != -1) { minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds()); } //todo // 6.4 // 6.4.1、Cache-Control:must-revalidate 可缓存但必须再向源服务器进行确认 // 6.4.2、Cache-Control:max-stale=[秒] 缓存过期后还能使用指定的时长 如果未指定多少秒，则表示无论过期多长时间都可以；如果指定了，则只要是指定时间内就能使用缓存 // 前者会忽略后者，所以判断了不必须向服务器确认，再获得请求头中的max-stale long maxStaleMillis = 0; if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) { maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds()); } //todo // 6.5 不需要与服务器验证有效性 &amp;&amp; 响应存在的时间+请求认为的缓存有效时间 小于 缓存有效时长+过期后还可以使用的时间 // 允许使用缓存 if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) { Response.Builder builder = cacheResponse.newBuilder(); //todo 如果已过期，但未超过 过期后继续使用时长，那还可以继续使用，只用添加相应的头部字段 if (ageMillis + minFreshMillis &gt;= freshMillis) { builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \\&quot;Response is stale\\&quot;&quot;); } //todo 如果缓存已超过一天并且响应中没有设置过期时间也需要添加警告 long oneDayMillis = 24 * 60 * 60 * 1000L; if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) { builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \\&quot;Heuristic expiration\\&quot;&quot;); } return new CacheStrategy(null, builder.build()); } // Find a condition to add to the request. If the condition is satisfied, the // response body // will not be transmitted. //todo 7、缓存过期了 String conditionName; String conditionValue; if (etag != null) { conditionName = &quot;If-None-Match&quot;; conditionValue = etag; } else if (lastModified != null) { conditionName = &quot;If-Modified-Since&quot;; conditionValue = lastModifiedString; } else if (servedDate != null) { conditionName = &quot;If-Modified-Since&quot;; conditionValue = servedDateString; } else { return new CacheStrategy(request, null); // No condition! Make a regular request. } //todo 如果设置了 If-None-Match/If-Modified-Since 服务器是可能返回304(无修改)的,使用缓存的响应体 Headers.Builder conditionalRequestHeaders = request.headers().newBuilder(); Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue); Request conditionalRequest = request.newBuilder() .headers(conditionalRequestHeaders.build()) .build(); return new CacheStrategy(conditionalRequest, cacheResponse);} PS：请求头与响应头 响应头 说明 例子 Date 消息发送的时间 Date: Sat, 18 Nov 2028 06:17:41 GMT Expires 资源过期的时间 Expires: Sat, 18 Nov 2028 06:17:41 GMT Last-Modified 资源最后修改时间 Last-Modified: Fri, 22 Jul 2016 02:57:17 GMT ETag 资源在服务器的唯一标识 ETag: “16df0-5383097a03d40” Age 服务器用缓存响应请求，该缓存从产生到现在经过多长时间(秒) Age: 3825683 Cache-Control - - 请求头 说明 例子 If-Modified-Since 服务器没有在指定的时间后修改请求对应资源,返回304(无修改) If-Modified-Since: Fri, 22 Jul 2016 02:57:17 GMT If-None-Match 服务器将其与请求对应资源的Etag值进行比较，匹配返回304 If-None-Match: “16df0-5383097a03d40” Cache-Control - - 其中Cache-Control可以在请求头存在，也能在响应头存在，对应的value可以设置多种组合： max-age=[秒] ：资源最大有效时间; public ：表明该资源可以被任何用户缓存，比如客户端，代理服务器等都可以缓存资源; private：表明该资源只能被单个用户缓存，默认是private。 no-store：资源不允许被缓存 no-cache：(请求)不使用缓存 immutable：(响应)资源不会改变 min-fresh=[秒]：(请求)缓存最小新鲜度(用户认为这个缓存有效的时长) must-revalidate：(响应)不允许使用过期缓存 max-stale=[秒]：(请求)缓存过期后多久内仍然有效 假设存在max-age=100，min-fresh=20。这代表了用户认为这个缓存的响应，从服务器创建响应 到 能够缓存使用的时间为100-20=80s。但是如果max-stale=100。这代表了缓存有效时间80s过后，仍然允许使用100s，可以看成缓存有效时长为180s。 四、连接拦截器连接流程： ConnectInterceptor，打开与目标服务器的连接，并执行下一个拦截器。它简短的可以直接完整贴在这里： 1234567891011121314151617181920public final class ConnectInterceptor implements Interceptor { public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) { this.client = client; } @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); }} 首先我们看到的StreamAllocation这个对象是在第一个拦截器：重定向拦截器创建的，但是真正使用的地方却在这里。 *”当一个请求发出，需要建立连接，连接建立后需要使用流用来读写数据”*；而这个StreamAllocation就是协调请求、连接与数据流三者之间的关系，它负责为一次请求寻找连接，然后获得流来实现网络通信。 这里使用的newStream方法实际上就是去查找或者建立一个与请求主机有效的连接，返回的HttpCodec中包含了输入输出流，并且封装了对HTTP请求报文的编码与解码，直接使用它就能够与请求主机完成HTTP通信。 123456789101112131415161718192021222324public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) { int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try { //todo 找到一个健康的连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); //todo 利用连接实例化流HttpCodec对象，如果是HTTP/2返回Http2Codec，否则返回Http1Codec HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) { codec = resultCodec; return resultCodec; } } catch (IOException e) { throw new RouteException(e); }} StreamAllocation中简单来说就是维护连接：RealConnection——封装了Socket与一个Socket连接池。可复用的RealConnection findHealthyConnection方法中 12345678910111213141516171819202122232425262728293031private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException { while (true) { //todo 找到一个连接 RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); //todo 如果这个连接是新建立的，那肯定是健康的，直接返回 //If this is a brand new connection, we can skip the extensive health checks. synchronized (connectionPool) { if (candidate.successCount == 0) { return candidate; } } //todo 如果不是新创建的，需要检查是否健康 //Do a (potentially slow) check to confirm that the pooled connection is still good. // If it // isn't, take it out of the pool and start again. if (!candidate.isHealthy(doExtensiveHealthChecks)) { //todo 不健康 关闭连接，释放Socket,从连接池移除 // 继续下次寻找连接操作 noNewStreams(); continue; } return candidate; }} findConnection方法中的 尝试从连接池获取连接，如果有可复用的连接,会给第三个参数 this的connection赋值 1Internal.instance.get(connectionPool, address, this, null); 调到了（ConnectionPool）connectionPool.get方法 12345678910@Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) { assert (Thread.holdsLock(this)); for (RealConnection connection : connections) { if (connection.isEligible(address, route)) { streamAllocation.acquire(connection, true); return connection; } } return null;} isEligible判断是否能够复用 使用http1.1就不能用 如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口 都相同那就可以复用 123456789101112131415161718192021222324252627282930313233343536373839404142434445public boolean isEligible(Address address, @Nullable Route route) { // If this connection is not accepting new streams, we're done. // TODO: 实际上就是在使用http1.1就不能用 if (allocations.size() &gt;= allocationLimit || noNewStreams) return false; // If the non-host fields of the address don't overlap, we're done. // TODO: 如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口（域名没有判断，所以下面马上判断） if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false; // If the host exactly matches, we're done: this connection can carry the address. //todo: 都相同那就可以复用了 if (address.url().host().equals(this.route().address().url().host())) { return true; // This connection is a perfect match. } // At this point we don't have a hostname match. But we still be able to carry the // request if // our connection coalescing requirements are met. See also: // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/ // 1. This connection must be HTTP/2. if (http2Connection == null) return false; // 2. The routes must share an IP address. This requires us to have a DNS address for both // hosts, which only happens after route planning. We can't coalesce connections that use a // proxy, since proxies don't tell us the origin server's IP address. if (route == null) return false; if (route.proxy().type() != Proxy.Type.DIRECT) return false; if (this.route.proxy().type() != Proxy.Type.DIRECT) return false; if (!this.route.socketAddress().equals(route.socketAddress())) return false; // 3. This connection's server certificate's must cover the new host. if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false; if (!supportsUrl(address.url())) return false; // 4. Certificate pinning must match the host. try { address.certificatePinner().check(address.url().host(), handshake().peerCertificates()); } catch (SSLPeerUnverifiedException e) { return false; } return true; // The caller's address can be carried by this connection.} 没找到，必须新建一个连接了 1234567891011121314 if (!foundPooledConnection) { if (selectedRoute == null) { selectedRoute = routeSelection.next(); } // Create a connection and assign it to this allocation immediately. This makes // it possible // for an asynchronous cancel() to interrupt the handshake we're about to do. route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); acquire(result, false); }} 连接池清理： findConnection方法中： 12//todo 将新创建的连接放到连接池中Internal.instance.put(connectionPool, result); 调的是ConnectionPool.put方法 123456789void put(RealConnection connection) { assert (Thread.holdsLock(this)); if (!cleanupRunning) { cleanupRunning = true; //启动清理 executor.execute(cleanupRunnable); } connections.add(connection);} 123456789101112131415161718192021private final Runnable cleanupRunnable = new Runnable() { @Override public void run() { while (true) { //todo:最快多久后需要清理 long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) { //todo:因为等待是纳秒级，wait方法可以接收纳秒级控制，但是把毫秒与纳秒分开 long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) { try { //todo:参数多一个纳秒，控制更加精确 ConnectionPool.this.wait(waitMillis, (int) waitNanos); } catch (InterruptedException ignored) { } } } } }}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647long cleanup(long now) { int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; // Find either a connection to evict, or the time that the next eviction is due. synchronized (this) { for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) { RealConnection connection = i.next(); // If the connection is in use, keep searching. if (pruneAndGetAllocationCount(connection, now) &gt; 0) { inUseConnectionCount++; continue; } idleConnectionCount++; // TODO: 获得这个连接闲置多久 // If the connection is ready to be evicted, we're done. long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) { longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; } } //超过保活时间（5分钟）或者池内数量超过了5个，马上移除，然后返回0，表示不等待，马上再次检查 if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) { // We've found a connection to evict. Remove it from the list, then close it below (outside // of the synchronized block). connections.remove(longestIdleConnection); } else if (idleConnectionCount &gt; 0) { // A connection will be ready to evict soon. // TODO: 池内存在闲置连接，就等待，保活时间（5分钟）-最长闲置时间=还能闲置多久 再检查 return keepAliveDurationNs - longestIdleDurationNs; } else if (inUseConnectionCount &gt; 0) { // All connections are in use. It'll be at least the keep alive duration 'til we run again. // TODO: 有使用中的连接就等待5分钟，再检查 return keepAliveDurationNs; } else { // No connections, idle or in use. // TODO: 都不满足，可能池内没任何连接，直接停止清理（put后再次启用） cleanupRunning = false; return -1; } } 代理连接： findConnection中 123//todo 实际上就是创建socket连接，但是要注意的是如果存在http代理的情况result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); RealConnection.connect 123456789101112if (route.requiresTunnel()) { //todo http隧道代理 connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) { // We were unable to connect the tunnel but properly closed down our // resources. break; }} else { //todo 创建socket连接 connectSocket(connectTimeout, readTimeout, call, eventListener);} 有http代理先设置代理头，最终都用调用connectSocket方法 1234567891011121314151617181920private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call, EventListener eventListener) throws IOException { Request tunnelRequest = createTunnelRequest(); HttpUrl url = tunnelRequest.url(); for (int i = 0; i &lt; MAX_TUNNEL_ATTEMPTS; i++) { connectSocket(connectTimeout, readTimeout, call, eventListener); tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url); if (tunnelRequest == null) break; // Tunnel successfully created. // The proxy decided to close the connection after an auth challenge. We need to // create a new // connection, but this time with the auth credentials. closeQuietly(rawSocket); rawSocket = null; sink = null; source = null; eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null); }} 12345678private Request createTunnelRequest() { return new Request.Builder() .url(route.address().url()) .header(&quot;Host&quot;, Util.hostHeader(route.address().url(), true)) .header(&quot;Proxy-Connection&quot;, &quot;Keep-Alive&quot;) // For HTTP/1.0 proxies like Squid. .header(&quot;User-Agent&quot;, Version.userAgent()) .build();} 1234567891011121314151617181920212223242526272829303132333435363738/** * todo:创建socket连接 * Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */private void connectSocket(int connectTimeout, int readTimeout, Call call, EventListener eventListener) throws IOException { Proxy proxy = route.proxy(); Address address = route.address(); //todo:没有代理直接new一个Socket（），有代理就创建一个带代理参数的socket rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy); eventListener.connectStart(call, route.socketAddress(), proxy); rawSocket.setSoTimeout(readTimeout); try { // TODO: socket.connect Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); } catch (ConnectException e) { ConnectException ce = new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress()); ce.initCause(e); throw ce; } // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0 // More details: // https://github.com/square/okhttp/issues/3245 // https://android-review.googlesource.com/#/c/271775/ try { source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); } catch (NullPointerException npe) { if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) { throw new IOException(npe); } }} 五、请求服务器拦截器Expect: 100-continue一般出现于上传大容量请求体或者需要验证。代表了先询问服务器是否原因接收发送请求体数据。（先只发送请求头） OkHttp的做法：如果服务器允许则返回100，客户端继续发送请求体；如果服务器不允许则直接返回给用户。 同时服务器也可能会忽略此请求头，一直无法读取应答，此时抛出超时异常。 CallServerInterceptor，利用HttpCodec发出请求到服务器并且解析生成Response。 首先调用httpCodec.writeRequestHeaders(request); 将请求头写入到缓存中(直到调用flushRequest()才真正发送给服务器)。然后马上进行第一个逻辑判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public final class CallServerInterceptor implements Interceptor { private final boolean forWebSocket; public CallServerInterceptor(boolean forWebSocket) { this.forWebSocket = forWebSocket; } @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); //todo:拼接请求的数据 httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; //todo:如果没有请求体或者不是post跳过 if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) { // If there's a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100 // Continue&quot; response before transmitting the request body. If we don't get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. // todo: 如果是post请求，并包含了100-continue,不发请求体，读服务器的响应 if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) { // todo: 发送请求头 httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); } //服务返回100，responseBuilder会置为null if (responseBuilder == null) { // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); //todo：写入请求体 request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); } else if (!connection.isMultiplexed()) { // If the &quot;Expect: 100-continue&quot; expectation wasn't met, prevent the HTTP/1 // connection // from being reused. Otherwise we're still obligated to transmit the request // body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); } } httpCodec.finishRequest(); // TODO: 读取服务器响应 if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false); } Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); // todo: 服务器允许继续发送响应体 if (code == 100) { // server sent a 100-continue even though we did not request one. // try again to read the actual response responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); } realChain.eventListener() .responseHeadersEnd(realChain.call(), response); if (forWebSocket &amp;&amp; code == 101) { // Connection is upgrading, but we need to ensure interceptors see a non-null // response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); } else { response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); } if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) { streamAllocation.noNewStreams(); } if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) { throw new ProtocolException( &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength()); } return response; } static final class CountingSink extends ForwardingSink { long successfulCount; CountingSink(Sink delegate) { super(delegate); } @Override public void write(Buffer source, long byteCount) throws IOException { super.write(source, byteCount); successfulCount += byteCount; } }} 整个if都和一个请求头有关： Expect: 100-continue。这个请求头代表了在发送请求体之前需要和服务器确定是否愿意接受客户端发送的请求体。所以permitsRequestBody判断为是否会携带请求体的方式(POST)，如果命中if，则会先给服务器发起一次查询是否愿意接收请求体，这时候如果服务器愿意会响应100(没有响应体，responseBuilder 即为nul)。这时候才能够继续发送剩余请求数据。 但是如果服务器不同意接受请求体，那么我们就需要标记该连接不能再被复用，调用noNewStreams()关闭相关的Socket。 123456789101112// TODO: 读取服务器响应if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false);}Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); 这时responseBuilder的情况即为： 1、POST方式请求，请求头中包含Expect，服务器允许接受请求体，并且已经发出了请求体，responseBuilder为null; 2、POST方式请求，请求头中包含Expect，服务器不允许接受请求体，responseBuilder不为null 3、POST方式请求，未包含Expect，直接发出请求体，responseBuilder为null; 4、POST方式请求，没有请求体，responseBuilder为null; 5、GET方式请求，responseBuilder为null; 对应上面的5种情况，读取响应头并且组成响应Response，注意：此Response没有响应体。同时需要注意的是，如果服务器接受 Expect: 100-continue这是不是意味着我们发起了两次Request？那此时的响应头是第一次查询服务器是否支持接受请求体的，而不是真正的请求对应的结果响应。 所以 如果响应是100，这代表了是请求Expect: 100-continue成功的响应，需要马上再次读取一份响应头，这才是真正的请求对应结果响应头。 最后： forWebSocket代表websocket的请求，我们直接进入else，这里就是读取响应体数据。然后判断请求和服务器是不是都希望长连接，一旦有一方指明close，那么就需要关闭socket。而如果服务器返回204/205，一般情况而言不会存在这些返回码，但是一旦出现这意味着没有响应体，但是解析到的响应头中包含Content-Lenght且不为0，这表响应体的数据字节长度。此时出现了冲突，直接抛出协议异常！ 总结在这个拦截器中就是完成HTTP协议报文的封装与解析。 自定义拦截器123456789new OkHttpClient().newBuilder().addInterceptor(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { // todo: ....... final Response response = chain.proceed(chain.request()); // todo: ....... return response; }}); 一定要调用chain.proceed,并将response返回。 不调用的话，会使责任链中断，后面其他就没法执行了。 OkHttp总结整个OkHttp功能的实现就在这五个默认的拦截器中，所以先理解拦截器模式的工作机制是先决条件。这五个拦截器分别为: 重试拦截器、桥接拦截器、缓存拦截器、连接拦截器、请求服务拦截器。每一个拦截器负责的工作不一样，就好像工厂流水线，最终经过这五道工序，就完成了最终的产品。 但是与流水线不同的是，OkHttp中的拦截器每次发起请求都会在交给下一个拦截器之前干一些事情，在获得了结果之后又干一些事情。整个过程在请求向是顺序的，而响应向则是逆序。 当用户发起一个请求后，会由任务分发起Dispatcher将请求包装并交给重试拦截器处理。 1、重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。 2、桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。 3、缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。 4、连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。 5、请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。 在经过了这一系列的流程后，就完成了一次HTTP请求！ 补充: 代理在使用OkHttp时，如果用户在创建OkHttpClient时，配置了proxy或者proxySelector，则会使用配置的代理，并且proxy优先级高于proxySelector。而如果未配置，则会获取机器配置的代理并使用。 123456789//JDK : ProxySelectortry { URI uri = new URI(&quot;http://restapi.amap.com&quot;); List&lt;Proxy&gt; proxyList = ProxySelector.getDefault().select(uri); System.out.println(proxyList.get(0).address()); System.out.println(proxyList.get(0).type());} catch (URISyntaxException e) { e.printStackTrace();} 因此，如果我们不需要自己的App中的请求走代理，则可以配置一个proxy(Proxy.NO_PROXY)，这样也可以避免被抓包。NO_PROXY的定义如下： 12345public static final Proxy NO_PROXY = new Proxy();private Proxy() { this.type = Proxy.Type.DIRECT; this.sa = null;} 代理在Java中对应的抽象类有三种类型: 1234567public static enum Type { DIRECT, HTTP, SOCKS; private Type() { }} DIRECT：无代理，HTTP：http代理，SOCKS：socks代理。第一种自然不用多说，而Http代理与Socks代理有什么区别？ 对于Socks代理，在HTTP的场景下，代理服务器完成TCP数据包的转发工作;而Http代理服务器，在转发数据之外，还会解析HTTP的请求及响应，并根据请求及响应的内容做一些处理。 RealConnection的connectSocket方法: 123456//如果是Socks代理则 new Socket(proxy); 否则相当于直接:new Socket()rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);//connect方法socket.connect(address); 设置了SOCKS代理的情况下，创建Socket时，为其传入proxy，连接时还是以HTTP服务器为目标地址；但是如果设置的是Http代理，创建Socket是与Http代理服务器建立连接。 在connect方法时传递的address来自于下面的集合inetSocketAddressesRouteSelector的resetNextInetSocketAddress方法： 123456789101112131415161718192021222324252627282930313233private void resetNextInetSocketAddress(Proxy proxy) throws IOException { // ...... if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) { //无代理和socks代理，使用http服务器域名与端口 socketHost = address.url().host(); socketPort = address.url().port(); } else { SocketAddress proxyAddress = proxy.address(); if (!(proxyAddress instanceof InetSocketAddress)) { throw new IllegalArgumentException( &quot;Proxy.address() is not an &quot; + &quot;InetSocketAddress: &quot; + proxyAddress.getClass()); } InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress; socketHost = getHostString(proxySocketAddress); socketPort = proxySocketAddress.getPort(); } // ...... if (proxy.type() == Proxy.Type.SOCKS) { //socks代理 connect http服务器 （DNS没用，由代理服务器解析域名） inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort)); } else { //无代理，dns解析http服务器 //http代理,dns解析http代理服务器 List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost); //...... for (int i = 0, size = addresses.size(); i &lt; size; i++) { InetAddress inetAddress = addresses.get(i); inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort)); } }} 设置代理时，Http服务器的域名解析会被交给代理服务器执行。但是如果是设置了Http代理，会对Http代理服务器的域名使用OkhttpClient配置的dns解析代理服务器，Http服务器的域名解析被交给代理服务器解析。 上述代码就是代理与DNS在OkHttp中的使用，但是还有一点需要注意，Http代理也分成两种类型：普通代理与隧道代理。 其中普通代理不需要额外的操作，扮演「中间人」的角色，在两端之间来回传递报文。这个“中间人”在收到客户端发送的请求报文时，需要正确的处理请求和连接状态，同时向服务器发送新的请求，在收到响应后，将响应结果包装成一个响应体返回给客户端。在普通代理的流程中，代理两端都是有可能察觉不到”中间人“的存在。 但是隧道代理不再作为中间人，无法改写客户端的请求，而仅仅是在建立连接后，将客户端的请求，通过建立好的隧道，无脑的转发给终端服务器。隧道代理需要发起Http CONNECT请求，这种请求方式没有请求体，仅供代理服务器使用，并不会传递给终端服务器。请求头 部分一旦结束，后面的所有数据，都被视为应该转发给终端服务器的数据，代理需要把他们无脑的直接转发，直到从客户端的 TCP 读通道关闭。CONNECT 的响应报文，在代理服务器和终端服务器建立连接后，可以向客户端返回一个 200 Connect established 的状态码，以此表示和终端服务器的连接，建立成功。 RealConnection的connect方法 1234567891011if (route.requiresTunnel()) { connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) { // We were unable to connect the tunnel but properly closed down our // resources. break; }} else { connectSocket(connectTimeout, readTimeout, call, eventListener);} requiresTunnel方法的判定为：当前请求为https并且存在http代理，这时候connectTunnel中会发起: 1234CONNECT xxxx HTTP/1.1Host: xxxxProxy-Connection: Keep-AliveUser-Agent: okhttp/${version} 的请求，连接成功代理服务器会返回200；如果返回407表示代理服务器需要鉴权(如：付费代理)，这时需要在请求头中加入Proxy-Authorization： 123456789101112131415 Authenticator authenticator = new Authenticator() { @Nullable @Override public Request authenticate(Route route, Response response) throws IOException { if(response.code == 407){ //代理鉴权 String credential = Credentials.basic(&quot;代理服务用户名&quot;, &quot;代理服务密码&quot;); return response.request().newBuilder() .header(&quot;Proxy-Authorization&quot;, credential) .build(); } return null; } };new OkHttpClient.Builder().proxyAuthenticator(authenticator);","link":"/2020/12/10/okhttp/"},{"title":"View基础","text":"Android自定义View概述 Android开发进阶的必经之路 为什么要自定义View 自定义View的基本方法 自定义控件分类 自定义View基础 View的分类 View类简介 AttributeSet与自定义属性 View视图结构 Android坐标系 View位置（坐标）描述 位置获取方式 Android中颜色相关内容 View树的绘制流程 View树的绘制流程是谁负责的？ view的添加 view的绘制流程 measure layout draw LayoutParams MarginLayoutParams LayoutParams与View如何建立联系 addView 自定义LayoutParams LayoutParams常见的子类 MeasureSpec 定义 MeasureSpecs 的意义 MeasureSpec值的确定 Android开发进阶的必经之路为什么要自定义View自定义View的基本方法自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。 测量：onMeasure()决定View的大小； 布局：onLayout()决定View在ViewGroup中的位置； 绘制：onDraw()决定绘制这个View。 自定义控件分类 自定义View: 只需要重写onMeasure()和onDraw() 自定义ViewGroup: 则只需要重写onMeasure()和onLayout() 自定义View基础View的分类视图View主要分为两类| 类别 | 解释 | 特点 || ——– | —————————————– | ———— || 单一视图 | 即一个View，如TextView | 不包含子View || 视图组 | 即多个View组成的ViewGroup，如LinearLayout | 包含子View | View类简介 View类是Android中各种组件的基类，如View是ViewGroup基类 View表现为显示在屏幕上的各种视图 Android中的UI组件都由View、ViewGroup组成。 View的构造函数：共有4个 12345678910111213141516171819202122232425// 如果View是在Java代码里面new的，则调用第一个构造函数 public CarsonView(Context context) { super(context); }// 如果View是在.xml里声明的，则调用第二个构造函数// 自定义属性是从AttributeSet参数传进来的 public CarsonView(Context context, AttributeSet attrs) { super(context, attrs); }// 不会自动调用// 一般是在第二个构造函数里主动调用// 如View有style属性时 public CarsonView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } //API21之后才使用 // 不会自动调用 // 一般是在第二个构造函数里主动调用 // 如View有style属性时 public CarsonView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); } AttributeSet与自定义属性 系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤： 通过&lt;declare-styleable&gt;为自定义View添加属性 在xml中为相应的属性声明属性值 在运行时（一般为构造函数）获取属性值 将获取到的属性值应用到View View视图结构 PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口 DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等 对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图： 一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。 Android坐标系Android的坐标系定义为： 屏幕的左上角为坐标原点 向右为x轴增大方向 向下为y轴增大方向 区别于一般的数学坐标系 View位置（坐标）描述View的位置由4个顶点决定的4个顶点的位置描述分别由4个值决定： 请记住：View的位置是相对于父控件而言的） Top：子View上边界到父view上边界的距离 Left：子View左边界到父view左边界的距离 Bottom：子View下边距到父View上边界的距离 Right：子View右边界到父view左边界的距离 位置获取方式View的位置是通过view.getxxx()函数进行获取：（以Top为例） 123456789// 获取Top位置public final int getTop() { return mTop; } // 其余如下： getLeft(); //获取子View左上角距父View左侧的距离 getBottom(); //获取子View右下角距父View顶部的距离 getRight(); //获取子View右下角距父View左侧的距离 与MotionEvent中 get()和getRaw()的区别 1234567//get() ：触摸点相对于其所在组件坐标系的坐标 event.getX(); event.getY();//getRaw() ：触摸点相对于屏幕默认坐标系的坐标 event.getRawX(); event.getRawY(); Android中颜色相关内容Android支持的颜色模式：以ARGB8888为例介绍颜色定义: View树的绘制流程View树的绘制流程是谁负责的？view树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的； view的添加 view的绘制流程 measure 系统为什么要有measure过程？ measure过程都干了点什么事？ 对于自适应的尺寸机制，如何合理的测量一颗View树？ 那么ViewGroup是如何向子View传递限制信息的？ ScrollView嵌套ListView问题？ layout 系统为什么要有layout过程？ layout过程都干了点什么事？ draw 系统为什么要有draw过程？ draw过程都干了点什么事？ LayoutParamsLayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。 事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类 MarginLayoutParamsMarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的 属性优先级问题MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级 margin &gt; horizontalMargin和verticalMargin &gt; leftMargin和RightMargin、topMargin和bottomMargin 属性覆盖问题优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释 Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value LayoutParams与View如何建立联系 在XML中定义View 在Java代码中直接生成View对应的实例对象 addView12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 重载方法1：添加一个子View * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams */public void addView(View child) { addView(child, -1);}/** * 重载方法2：在指定位置添加一个子View * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams * @param index View将在ViewGroup中被添加的位置（-1代表添加到末尾） */public void addView(View child, int index) { if (child == null) { throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;); } LayoutParams params = child.getLayoutParams(); if (params == null) { params = generateDefaultLayoutParams();// 生成当前ViewGroup默认的LayoutParams if (params == null) { throw new IllegalArgumentException(&quot;generateDefaultLayoutParams() cannot return null&quot;); } } addView(child, index, params);}/** * 重载方法3：添加一个子View * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height */public void addView(View child, int width, int height) { final LayoutParams params = generateDefaultLayoutParams(); // 生成当前ViewGroup默认的LayoutParams params.width = width; params.height = height; addView(child, -1, params);}/** * 重载方法4：添加一个子View，并使用传入的LayoutParams */@Overridepublic void addView(View child, LayoutParams params) { addView(child, -1, params);}/** * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams */public void addView(View child, int index, LayoutParams params) { if (child == null) { throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;); } // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false);}private void addViewInner(View child, int index, LayoutParams params, boolean preventRequestLayout) { ..... if (mTransition != null) { mTransition.addChild(this, child); } if (!checkLayoutParams(params)) { // ① 检查传入的LayoutParams是否合法 params = generateLayoutParams(params); // 如果传入的LayoutParams不合法，将进行转化操作 } if (preventRequestLayout) { // ② 是否需要阻止重新执行布局流程 child.mLayoutParams = params; // 这不会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw） } else { child.setLayoutParams(params); // 这会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw） } if (index &lt; 0) { index = mChildrenCount; } addInArray(child, index); // tell our children if (preventRequestLayout) { child.assignParent(this); } else { child.mParent = this; } .....} 自定义LayoutParams 创建自定义属性 12345678&lt;resources&gt; &lt;declare-styleable name=&quot;xxxViewGroup_Layout&quot;&gt; &lt;!-- 自定义的属性 --&gt; &lt;attr name=&quot;layout_simple_attr&quot; format=&quot;integer&quot;/&gt; &lt;!-- 使用系统预置的属性 --&gt; &lt;attr name=&quot;android:layout_gravity&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 继承MarginLayout 1234567891011121314151617181920212223242526public static class LayoutParams extends ViewGroup.MarginLayoutParams { public int simpleAttr; public int gravity; public LayoutParams(Context c, AttributeSet attrs) { super(c, attrs); // 解析布局属性 TypedArray typedArray = c.obtainStyledAttributes(attrs, R.styleable.SimpleViewGroup_Layout); simpleAttr = typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_layout_simple_attr, 0); gravity=typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_android_layout_gravity, -1); typedArray.recycle();//释放资源 } public LayoutParams(int width, int height) { super(width, height); } public LayoutParams(MarginLayoutParams source) { super(source); } public LayoutParams(ViewGroup.LayoutParams source) { super(source); }} 重写ViewGroup中几个与LayoutParams相关的方法 1234567891011121314151617181920212223// 检查LayoutParams是否合法@Overrideprotected boolean checkLayoutParams(ViewGroup.LayoutParams p) { return p instanceof SimpleViewGroup.LayoutParams;}// 生成默认的LayoutParams@Overrideprotected ViewGroup.LayoutParams generateDefaultLayoutParams() { return new SimpleViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);}// 对传入的LayoutParams进行转化@Overrideprotected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) { return new SimpleViewGroup.LayoutParams(p);}// 对传入的LayoutParams进行转化@Overridepublic ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) { return new SimpleViewGroup.LayoutParams(getContext(), attrs);} LayoutParams常见的子类在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类： ViewGroup.MarginLayoutParams FrameLayout.LayoutParams LinearLayout.LayoutParams RelativeLayout.LayoutParams RecyclerView.LayoutParams GridLayoutManager.LayoutParams StaggeredGridLayoutManager.LayoutParams ViewPager.LayoutParams WindowManager.LayoutParams MeasureSpec定义测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种： UNSPECIFIED父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大） EXACTLY父控件已经知道你所需的精确大小，你的最终大小应该就是这么大。 AT_MOST你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。 MeasureSpecs 的意义通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法 MeasureSpec值的确定MeasureSpec值到底是如何计算得来的呢?子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个 * 最可能符合条件的child view的测量规格。 * @param spec 父控件的测量规格 * @param padding 父控件里已经占用的大小 * @param childDimension child view布局LayoutParams里的尺寸 * @return child view 的测量规格 */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); //父控件的测量模式 int specSize = MeasureSpec.getSize(spec); //父控件的测量大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了 case MeasureSpec.EXACTLY: //如果child的布局参数有固定值，比如&quot;layout_width&quot; = &quot;100dp&quot; //那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } //如果child的布局参数是&quot;match_parent&quot;，也就是想要占满父控件 //而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了 else if (childDimension == LayoutParams.MATCH_PARENT) { resultSize = size; resultMode = MeasureSpec.EXACTLY; } //如果child的布局参数是&quot;wrap_content&quot;，也就是想要根据自己的逻辑决定自己大小， //比如TextView根据设置的字符串大小来决定自己的大小 //那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛 //所以测量模式就是AT_MOST，测量大小就是父控件的size else if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size case MeasureSpec.AT_MOST: //同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求 if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } //child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小 //但同样的，child的尺寸上限也是父控件的尺寸上限size else if (childDimension == LayoutParams.MATCH_PARENT) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } //child想要根据自己逻辑决定大小，那就自己决定呗 else if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; } break; } return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 针对上表，这里再做一下具体的说明 对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定 对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。1. 当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小； 2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间； 3. 当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。 4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。","link":"/2021/06/15/view/"},{"title":"泛型","text":"问题 123456781、为什么我们需要泛型？2、泛型类、泛型接口和泛型方法3、如何限定类型变量？4、泛型使用中的约束和局限性5、泛型类型能继承吗？6、泛型中通配符类型7、虚拟机是如何实现泛型的？8、反射获取泛型的真实类型 1、为什么需要泛型？ 多种数据类型执行相同的代码（增加代码复用性） 在编译时进行更强的类型检查。 使用泛型不需要强制转换类型 2、泛型类、泛型接口和泛型方法123456789101112131415161718192021222324252627282930313233--泛型类public class Genericity&lt;T&gt; { private T data; public void setData(T data) { this.data = data; } public T getData() { return data; } --泛型方法 public &lt;T&gt; T getInput(T input){ return input; } --泛型方法2 public &lt;E&gt; E getInput2(E input){ return input; } public static void main(String[] args) { //泛型类 Genericity&lt;String&gt; genericity=new Genericity&lt;&gt;(); genericity.setData(&quot;泛型&quot;); Genericity&lt;Integer&gt; genericityInteger=new Genericity&lt;&gt;(); genericityInteger.setData(1); //泛型方法 Genericity genericityMethod=new Genericity(); genericityMethod.getInput(&quot;11&quot;); genericityMethod.getInput(11); genericityMethod.getInput(1f); }} 123456789101112131415161718--泛型接口public interface Genertor&lt;T&gt; { public T next();}--实现1、不传入具体类型，返回值为Tpublic class GenertorImpl&lt;T&gt; implements Genertor&lt;T&gt; { @Override public T next() { return null; }}--实现2、传入具体类型String，返回值为Stringpublic class GenertorImpl2 implements Genertor&lt;String&gt; { @Override public String next() { return null; }} 泛型类只影响它的普通方法 泛型类的T和泛型方法的T毫无关系，换成其他也一样，例如E，但是方法名不能一样，因为泛型在Java编译时是Object 泛型接口实现时，不传入具体类型传入T时，接口的方法返回的也是T。当传入具体类型时，接口的方法返回的也是具体的类型。 泛型方法只有方法前面有的才是泛型方法 3、如何限定类型变量？ 限定类型是写在类上的 12345678public class GenertorClass&lt;T extends Comparable&gt; { public static void main(String[] args) { GenertorClass&lt;String&gt; genertorClass = new GenertorClass&lt;&gt;(); GenertorClass&lt;Object&gt; genertorClass2 = new GenertorClass&lt;&gt;(); //传入String是正常的，传入Object时报错： //Type parameter 'java.lang.Object' is not within its bound; should implement 'java.lang.Comparable' }} 上面代码传入String时是正常的，传入Object时报错：Type parameter 'java.lang.Object' is not within its bound; should implement 'java.lang.Comparable' 因为String继承了 Comparable接口，而Object没有继承该接口 限定类型写在方法上 12345678910public class GenertorClass&lt;T extends Comparable&gt; { public static &lt;T extends Comparable&gt; T min(T a, T b) { if (a.compareTo(b) &gt; 0) return a;else return b; } public static void main(String[] args) { GenertorClass.min(&quot;1&quot;,&quot;2&quot;); GenertorClass.min(&quot;1&quot;,new Object());//报reason: no instance(s) of type variable(s) exist so that Object conforms to Comparable }} GenertorClass.min(“1”,”2”);是正确的，因为String继承了Comparable接口，而Object没有继承该接口。 多个限定类型 12345678910111213--类1public class Fruit {}--类2public class Apple extends Fruit implements Serializable {}--类3public class GenertorClass&lt;T extends Fruit &amp; Serializable&gt; { public static void main(String[] args) { GenertorClass&lt;Apple&gt; genertorClass = new GenertorClass&lt;&gt;(); GenertorClass&lt;Fruit&gt; genertorClass2 = new GenertorClass&lt;&gt;(); }} GenertorClass是正常的，GenertorClass报错：Type parameter 'Fruit' is not within its bound; should implement 'java.io.Serializable'。 因为两个限定类型都要实现才行，而且类3中Fruit&amp;Serializable两个位置不能调换。 T extends B B可以是类也可以是接口。 泛型类和泛型方法都可以使用多个限定类型 B可以是多个对象：T extends Comparable&amp;Serializable。多个对象时，传入的对象必需要同时实现多个限定类型Comparable和Serializable B为类和接口混合时，类只能有一个（java里单继承，多实现），并且必需放在最前面 ,否则会报错。 4、泛型使用中的约束和局限性 不能实例化类型变量。 1T data = new T()//不允许 静态域或者静态方法里不能引用类型变量。 1private static T instance;//不允许 （因为在new对象时，才知道真实的类型，虚拟机运行时，先执行static对象、方法，再执行构造方法，所以静态中使用泛型，虚拟机是不知道泛型类型的） 静态方法本身是泛型方法是可行的。 1priavte static &lt;T&gt; T getInstance(){}//允许 基本类型是不行的。 1&lt;int&gt;,&lt;double&gt;//不允许 int,double(不是对象)，只允许其包装类Integer，Double 不能使用instanceof关键字判断变量类型。 12Test&lt;Double&gt; test=new Test&lt;&gt;();if(test instanceof Test&lt;Double&gt;){}//不允许 编译时的类型擦除 泛型能定义数据，但不能创建数组（new 对象） 12private T[] list;//允许private T[] list2=new T[2];//不允许 泛型类获取的一定是类的原生类型 123456789Test&lt;Integer&gt; test1 = new Test&lt;&gt;();Test&lt;String&gt; test2 = new Test&lt;&gt;();System.out.println(test1.getClass()==test2.getClass());System.out.println(test1.getClass().getName());System.out.println(test2.getClass().getName());out:========================================truecom.example.annotation.Testcom.example.annotation.Test 这里的原生类型是Test，和传的参数无关 泛型类不能继承Exception 12class Problem&lt;T&gt; extends Exception{}//不允许//报错：Generic class may not extend 'java.lang.Throwable' 不能捕获泛型类对象 12345678public &lt;T extends Throwable&gt; void doWork(T t) throws T { try { // do... } catch (T e) { //报错 //do something throw t; }} 不能捕获，但是可以抛出 1234567public &lt;T extends Throwable&gt; void doWork2(T x) throws T { try { //do... } catch (Throwable e) { throw x; //允许的 }} 5、泛型类型能继承吗？ 12345678//类 Worker extents Employee类public class Employee {}public class Worker extends Employee {}//泛型类Pairpublic class Pair&lt;T&gt; {} Pair和Pair 没有任何继承关系 1Pair&lt;Employee&gt; employeePair= new Pair&lt;Worker&gt;();//不允许，错误的 1234567891011121314public class Pair&lt;T&gt; { private T data; public T getData() { return data; } public void setData(T data) { this.data = data; } }public class ExtendPair&lt;T&gt; extends Pair&lt;T&gt;{} 泛型类可以继承或者扩展其他泛型类 //比如List和ArrayList 1Pair&lt;Employee&gt; employee = new ExtendPair&lt;&gt;; //允许的 6、泛型中通配符类型（?只能用在方法上）通配符主要用于安全的访问数据 12345678910public class Food {}public class Fruit extends Food{}public class Apple extends Fruit{}public class Orange extends Fruit{}public class HongFuShi extends Apple{} 表示Pair传进去的类型参数是Fruit的子类包括Fruit本身（Fruit,Apple,Orange,HongFuShi） extends决定了类型参数的上界：向下的范围，即泛型对象必需继承Fruit或Fruit本身–Food不可以。 1234567891011//限定类型Fruitpublic static void printClassName(Pair&lt;? extends Fruit&gt; data) { System.out.println(data.getClass().getSimpleName());}Pair&lt;Fruit&gt; fruitPair = new Pair&lt;&gt;();Pair&lt;Apple&gt; applePair = new Pair&lt;&gt;();Pair&lt;Food&gt; foodPair = new Pair&lt;&gt;();Pair.printClassName(fruitPair);//允许Pair.printClassName(applePair);//允许Pair.printClassName(foodPair);//不允许//错误: 不兼容的类型: Pair&lt;Food&gt;无法转换为Pair&lt;? extends Fruit&gt; 1234567//限定类型变量赋值时，也是只能使用传入Fruit子类或者本身的对象Pair&lt;Fruit&gt; fruitPair = new Pair&lt;&gt;();Pair&lt;Apple&gt; applePair = new Pair&lt;&gt;();Pair&lt;Food&gt; foodPair = new Pair&lt;&gt;();Pair&lt;? extends Fruit&gt; f = fruitPair;//允许Pair&lt;? extends Fruit&gt; f2 = applePair;//允许Pair&lt;? extends Fruit&gt; f3 = foodPair;//不允许 使用&lt;? extends Fruit&gt;给对象set，get值时：set是不允许的，get只能get到Fruit对象，即extends的上界类型。 123456789101112131415Pair&lt;Fruit&gt; fruitPair = new Pair&lt;&gt;();Pair&lt;Apple&gt; applePair = new Pair&lt;&gt;();Pair&lt;? extends Fruit&gt; data = fruitPair;或Pair&lt;? extends Fruit&gt; data = applePair;data.setData(new Apple());//不允许data.setData(new Fruit());//不允许//错误: 不兼容的类型: Fruit无法转换为CAP#1// data.setData(new Fruit());// ^// 其中, CAP#1是新类型变量:// CAP#1从? extends Fruit的捕获扩展FruitFruit fruit = data.getData();//允许，获取到Fruit对象Apple apple = (Apple) data.getData();//需要转型，如果类型不正确会报ClassCastException强转异常 get方法：不管我们传的是Fruit还是它的子类，对于编译器来说我们传的一定是个Fruit，所以获取到的对象一定是个Fruit（子类继承Fruit）。 set方法：对于编译器来说你传的是个Fruit,但是是具体的哪一个子类，编译器是不知道的。 &lt;? extends Fruit&gt;主要用于安全的访问数据–读数据 表示Pair传进去的类型参数是Apple的父类包括Apple本身。(Apple,Fruit,Food) super 决定了类型参数的下界：向上的范围，即泛型对象是Apple的超类或Apple本身–HongFuShi不可以。 12345678910111213141516171819202122232425262728293031323334public static void printSuper(Pair&lt;? super Apple&gt; data){ System.out.println(data.getClass().getSimpleName());}Pair&lt;Fruit&gt; fruitPair = new Pair&lt;&gt;();Pair&lt;Apple&gt; applePair = new Pair&lt;&gt;();Pair&lt;Orange&gt; orangePair = new Pair&lt;&gt;();Pair&lt;HongFuShi&gt; hongFuShiPair = new Pair&lt;&gt;();printSuper(fruitPair);//允许printSuper(applePair);//允许printSuper(orangePair);//不允许，平级类printSuper(hongFuShiPair);//不允许//错误: 不兼容的类型: Pair&lt;HongFuShi&gt;无法转换为Pair&lt;? super Apple&gt;// printSuper(hongFuShiPair);Pair&lt;? super Apple&gt; data = fruitPair; //允许Pair&lt;? super Apple&gt; data = applePair; //允许Pair&lt;? super Apple&gt; data = hongFuShiPair; //不允许//错误: 不兼容的类型: Pair&lt;HongFuShi&gt;无法转换为Pair&lt;? super Apple&gt;// Pair&lt;? super Apple&gt; data = hongFuShiPair;// ^但是在设值的时候只能设置Apple的子类和它本身data.setData(new Apple()); //允许data.setData(new HongFuShi()); //允许data.setData(new Fruit()); //不允许//错误: 不兼容的类型: Fruit无法转换为CAP#1// data.setData(new Fruit());// ^// 其中, CAP#1是新类型变量:// CAP#1从? super Apple的捕获扩展Object 超 Apple获取数据时获取到的是Object对象Object object = data.getData(); set方法：只能传Apple和其子类，（因为子类包含了Apple或者HongFuShi，子类可以安全的转换为 super Apple） get方法：获取的对象一定是Apple的超类，Java中Object一定是Apple的超类。所以返回的是Object &lt;? super Apple&gt;主要用于安全的写入数据，只能是其本身Apple和其子类 7、虚拟机是如何实现泛型的？我们定义了一个简单的泛型类 1234567891011public class GenertorASM&lt;E&gt; { private E data; public E getData() { return data; } public void setData(E data) { this.data = data; }} 通过字节码查看工具查看该类的字节码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// class version 52.0 (52)// access flags 0x21// signature &lt;E:Ljava/lang/Object;&gt;Ljava/lang/Object;// declaration: GenertorASM&lt;E&gt;public class GenertorASM { // compiled from: GenertorASM.java // access flags 0x2 // signature TE; // declaration: data extends E private Ljava/lang/Object; data // access flags 0x1 public &lt;init&gt;()V L0 LINENUMBER 8 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this LGenertorASM; L0 L1 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 // signature ()TE; // declaration: E getData() public getData()Ljava/lang/Object; L0 LINENUMBER 12 L0 ALOAD 0 GETFIELD GenertorASM.data : Ljava/lang/Object; ARETURN L1 LOCALVARIABLE this LGenertorASM; L0 L1 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 // signature (TE;)V // declaration: void setData(E) public setData(Ljava/lang/Object;)V L0 LINENUMBER 16 L0 ALOAD 0 ALOAD 1 PUTFIELD GenertorASM.data : Ljava/lang/Object; L1 LINENUMBER 17 L1 RETURN L2 LOCALVARIABLE this LGenertorASM; L0 L2 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; LOCALVARIABLE data Ljava/lang/Object; L0 L2 1 // signature TE; // declaration: data extends E MAXSTACK = 2 MAXLOCALS = 2} 或者使用javap命令反编译.class文件 123456789101112131415161718192021222324252627282930313233343536373839javap -c -l GenertorASM.class // -c对代码进行反汇编,-l输出行号和本地变量表 public class GenertorASM&lt;E&gt; { public GenertorASM(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 8: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this LGenertorASM; public E getData(); Code: 0: aload_0 1: getfield #2 // Field data:Ljava/lang/Object; 4: areturn LineNumberTable: line 12: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this LGenertorASM; public void setData(E); Code: 0: aload_0 1: aload_1 2: putfield #2 // Field data:Ljava/lang/Object; 5: return LineNumberTable: line 16: 0 line 17: 5 LocalVariableTable: Start Length Slot Name Signature 0 6 0 this LGenertorASM; 0 6 1 data Ljava/lang/Object;} 通过反编译后，可以看到泛型被擦除了，对应的是Object对象，但在的signature中记录了泛型。 泛型擦除的原因： 在Java1.5之前不存在泛型的，1.5之后才添加的泛型，为了向下兼容，所以在编译时使用了泛型擦除用Object代替。 使用泛型限定符时,java编译时会将泛型转成限定符的类 123456789public class GenertorASM&lt;E extends Fruit&gt; { private E data; public E getData() { return data; } public void setData(E data) { this.data = data; }} 字节码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// class version 52.0 (52)// access flags 0x21// signature &lt;E:LFruit;&gt;Ljava/lang/Object;// declaration: GenertorASM&lt;E extends Fruit&gt;public class GenertorASM { // compiled from: GenertorASM.java // access flags 0x2 // signature TE; // declaration: data extends E private LFruit; data // access flags 0x1 public &lt;init&gt;()V L0 LINENUMBER 8 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this LGenertorASM; L0 L1 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 // signature ()TE; // declaration: E getData() public getData()LFruit; L0 LINENUMBER 11 L0 ALOAD 0 GETFIELD GenertorASM.data : LFruit; ARETURN L1 LOCALVARIABLE this LGenertorASM; L0 L1 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 // signature (TE;)V // declaration: void setData(E) public setData(LFruit;)V L0 LINENUMBER 14 L0 ALOAD 0 ALOAD 1 PUTFIELD GenertorASM.data : LFruit; L1 LINENUMBER 15 L1 RETURN L2 LOCALVARIABLE this LGenertorASM; L0 L2 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; LOCALVARIABLE data LFruit; L0 L2 1 // signature TE; // declaration: data extends E MAXSTACK = 2 MAXLOCALS = 2} 如果限定符有多个时，字节码中泛型使用第一个限定的类型，在使用其他的类型时，会使用强转成对应的类型（所以多个限定符时要注意强转异常） 123456789101112131415public class GenertorASM&lt;E extends Fruit &amp; Comparable&gt; { private E data; public E getData() { return data; } public void setData(E data) { this.data = data; } public E compare(E data1, E data2) { return data1.compareTo(data2) &gt; 0 ? data1 : data2; }} 字节码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// class version 52.0 (52)// access flags 0x21// signature &lt;E:LFruit;:Ljava/lang/Comparable;&gt;Ljava/lang/Object;// declaration: GenertorASM&lt;E extends Fruit extends java.lang.Comparable&gt;public class GenertorASM { // compiled from: GenertorASM.java // access flags 0x2 // signature TE; // declaration: data extends E private LFruit; data // access flags 0x1 public &lt;init&gt;()V L0 LINENUMBER 8 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this LGenertorASM; L0 L1 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 // signature ()TE; // declaration: E getData() public getData()LFruit; L0 LINENUMBER 12 L0 ALOAD 0 GETFIELD GenertorASM.data : LFruit; ARETURN L1 LOCALVARIABLE this LGenertorASM; L0 L1 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 // signature (TE;)V // declaration: void setData(E) public setData(LFruit;)V L0 LINENUMBER 16 L0 ALOAD 0 ALOAD 1 PUTFIELD GenertorASM.data : LFruit; L1 LINENUMBER 17 L1 RETURN L2 LOCALVARIABLE this LGenertorASM; L0 L2 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; LOCALVARIABLE data LFruit; L0 L2 1 // signature TE; // declaration: data extends E MAXSTACK = 2 MAXLOCALS = 2 // access flags 0x1 // signature (TE;TE;)TE; // declaration: E compare(E, E) public compare(LFruit;LFruit;)LFruit; L0 LINENUMBER 20 L0 ALOAD 1 CHECKCAST java/lang/Comparable ALOAD 2 INVOKEINTERFACE java/lang/Comparable.compareTo (Ljava/lang/Object;)I (itf) IFLE L1 ALOAD 1 GOTO L2 L1 FRAME SAME ALOAD 2 L2 FRAME SAME1 Fruit ARETURN L3 LOCALVARIABLE this LGenertorASM; L0 L3 0 // signature LGenertorASM&lt;TE;&gt;; // declaration: this extends GenertorASM&lt;E&gt; LOCALVARIABLE data1 LFruit; L0 L3 1 // signature TE; // declaration: data1 extends E LOCALVARIABLE data2 LFruit; L0 L3 2 // signature TE; // declaration: data2 extends E MAXSTACK = 2 MAXLOCALS = 3} 在字节码中CHECKCAST java/lang/Comparable 将对象强转成Comparable类型 相同方法使用泛型，类型不同时报错-因为在编译时类型擦除后的对象都是Objects 1234567 public static void method (List&lt;String&gt; list){ }//报错：'method(List&lt;String&gt;)' clashes with 'method(List&lt;Integer&gt;)'; both methods have same erasure public static void method (List&lt;Integer&gt; list){ } 另外在jdk中如果返回值不同（一个返回String，一个返回Integer），编译是不会报错的，但是开发工具中是报上面错的（idea这种只比较方法名和参数没有比较返回值） 8、反射获取泛型的真实类型当我们对一个泛型类进行反射时，需要得到泛型中的真实数据类型，业完成如json反序列化的操作。此时需要通过Type体系来完成。Type接口包含了一个实现类(Class)和四个实现接口，他们分别是： TypeVariable 泛型类型变量。可以获得泛型上下限等信息。 ParameterizedType 具体的泛型类型，可以获得元数据中泛型签名类型（泛型真实类型）。 GenericArrayType 当需要描述的类型是泛型类的数组时，比如List[],Map[]，此接口会作为Type的实现。 WildcardType 通配符泛型，获得上下限信息。 Type是个接口,它的直接实现类就是Class 123456789package java.lang.reflect;/** * @since 1.5 */public interface Type { default String getTypeName() { return toString(); }} 123public final class Class&lt;T&gt; implements Type{ } 我们创建一个Response泛型类 1234567891011121314151617181920212223242526272829public class Response&lt;T&gt; { T data; int code; String message; public Response(T data, int code, String message) { this.data = data; this.code = code; this.message = message; } static class Data { String result; public Data(String result) { this.result = result; } } public static void main(String[] args) { Response&lt;Data&gt; response = new Response&lt;&gt;(new Data(&quot;数据&quot;), 0, &quot;成功&quot;); Gson gson = new Gson(); String json = gson.toJson(response); System.out.println(json); Response&lt;Data&gt; result = gson.fromJson(json,Response.class); System.out.println(result.data.getClass()); }} 我们创建一个response对象传入Data数据类型，打印序列化后的数据 {&quot;data&quot;:{&quot;result&quot;:&quot;数据&quot;},&quot;code&quot;:0,&quot;message&quot;:&quot;成功&quot;} 然后我们通过gson反序列化打印data类型 12//Exception in thread &quot;main&quot; java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.lis.wanjob.jol.Response$Data// at com.lis.wanjob.jol.Response.main(Response.java:35) gson解析时会把Data认为是LinkedTreeMap类型，所以在打印时强制转换时报错了。 正确的解析是通过Type 12345678Type type = new TypeToken&lt;Response&lt;Data&gt;&gt;() { }.getType();System.out.println(type);Response&lt;Data&gt; result = gson.fromJson(json, type);System.out.println(result.data.getClass());--打印结果为：com.lis.wanjob.jol.Response&lt;com.lis.wanjob.jol.Response$Data&gt;class com.lis.wanjob.jol.Response$Data 我们看一下TypeToken的源码： 1234567891011121314151617 protected TypeToken() { this.type = getSuperclassTypeParameter(this.getClass()); this.rawType = Types.getRawType(this.type); this.hashCode = this.type.hashCode(); } static Type getSuperclassTypeParameter(Class&lt;?&gt; subclass) { Type superclass = subclass.getGenericSuperclass(); if (superclass instanceof Class) { throw new RuntimeException(&quot;Missing type parameter.&quot;); } else { ParameterizedType parameterized = (ParameterizedType)superclass; return Types.canonicalize(parameterized.getActualTypeArguments()[0]); } }public final Type getType() { return this.type; } 这里我们调用的是TypeToken 受保护的构造函数，getType()就是返回的type. getSuperclassTypeParameter()方法中，如果TypeToken类的类型type是泛型类型的话，会被装载为Type的子接口ParameterizedType，可以让我们得到具体的泛型类型。 在实例化TypeToken时使用{}，实际上是匿名内部类。 我们自己创建个类来解析泛型的真实类型 123456789101112131415static class TypeReference&lt;T&gt; { Type actualTyep; Type getType() { return actualTyep; } public TypeReference() { Type superclass = getClass().getGenericSuperclass(); ParameterizedType type = (ParameterizedType) superclass; //这里是数组，因为泛型可以有多个&lt;T,E&gt; Type[] actualTypeArguments = type.getActualTypeArguments(); actualTyep = actualTypeArguments[0]; }} 不加{}12345//不加{}时，new TypeReference&lt;Response&lt;Data&gt;&gt;()代表一个对象Type type2 = new TypeReference&lt;Response&lt;Data&gt;&gt;().getType();System.out.println(type2);Response&lt;Data&gt; result = gson.fromJson(json, type2);System.out.println(result.data.getClass()); 我们在输出时，不加{}时报错 123Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.reflect.ParameterizedType at com.lis.wanjob.jol.Response$TypeReference.&lt;init&gt;(Response.java:41) at com.lis.wanjob.jol.Response.main(Response.java:62) 加{}12345//加{}时，new TypeReference&lt;Response&lt;Data&gt;&gt;(){}代表一个匿名内部类Type type2 = new TypeReference&lt;Response&lt;Data&gt;&gt;(){}.getType();System.out.println(type2);Response&lt;Data&gt; result = gson.fromJson(json, type2);System.out.println(result.data.getClass()); 我们输出时：能正常的打印泛型的真实类型 12com.lis.wanjob.jol.Response&lt;com.lis.wanjob.jol.Response$Data&gt;class com.lis.wanjob.jol.Response$Data 因为不加{}时，new TypeReference&lt;Response&gt;()只是一个对象，在TypeReference没有记录泛型真实类型的地方，此时的Type就是Class,所以强转ParameterizedType时会报错。编译文件Response$TypeReference.class，as中查看： 1234567891011121314class Response$TypeReference&lt;T&gt; { Type actualTyep; Type getType() { return this.actualTyep; } public Response$TypeReference() { Type superclass = this.getClass().getGenericSuperclass(); ParameterizedType type = (ParameterizedType)superclass; Type[] actualTypeArguments = type.getActualTypeArguments(); this.actualTyep = actualTypeArguments[0]; }} 加了{}时，new TypeReference&lt;Response&gt;(){}是匿名内部类，编译时，会为我们生成对应的内部类的文件Response$1.class，我们在as中打开看到如下代码 1234final class Response$1 extends TypeReference&lt;Response&lt;Data&gt;&gt; { Response$1() { }} 内部类中记录了泛型的真实类型。在getType()获取类型时，其实是获取的内部类的类型，所以我们可以得到泛型的真实类型。 PS：我们可以将解析泛型的真实类型的类定义为抽象或将构造方法改为受保护的（必需不同包下），这样在创建解析类时必需加{}成为匿名内部类，来获取泛型的真实类型。 123456static abstract class TypeReference&lt;T&gt;{}或static class TypeReference&lt;T&gt; { protected TypeReference() { }}","link":"/2021/11/28/%E6%B3%9B%E5%9E%8B/"},{"title":"注解与反射（上）","text":"注解一般是配合反射来一起用的，所以我们把这两个合在一起来分析。 注解 注解声明 声明一个注解 元注解 注解类型元素 注解应用场景 SOURCE IDE语法检查 APT注解处理器 注解处理器的实现 APT 核心原理 APT 的优缺点 APT 应用场景 APT 工作流程图 CLASS RUNTIME Java 注解（Annotation）又称 Java 标注，是 JDK1.5 引入的一种注释机制。 注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。 注解声明声明一个注解Java中所有的注解，默认实现 Annotation接口： 1234567891011package java.lang.annotation;public interface Annotation { boolean equals(Object obj); int hashCode(); String toString(); Class&lt;? extends Annotation&gt; annotationType();} 注解的声明使用 @interface 关键字。一个注解的声明如下： 12public @interface Test{} 元注解在定义注解时，注解类也能够使用其他的注解声明。对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解）。一般的，我们在定义自定义注解时，需要指定的元注解有两个 ： 另外还有@Documented 与 @Inherited 元注解，前者用于被javadoc工具提取成文档，后者表示允许子类继承父类中定义的注解。 @Target注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值： ElementType.ANNOTATION_TYPE 可以应用于注解类型。 ElementType.CONSTRUCTOR 可以应用于构造函数。 ElementType.FIELD 可以应用于字段或属性。 ElementType.LOCAL_VARIABLE 可以应用于局部变量。 ElementType.METHOD 可以应用于方法级注解。 ElementType.PACKAGE 可以应用于包声明。 ElementType.PARAMETER 可以应用于方法的参数。 ElementType.TYPE 可以应用于类的任何元素。 @Retention注解指定标记注解的存储方式： RetentionPolicy.SOURCE - 标记的注解仅保留在源级别中，并被编译器忽略。 RetentionPolicy.CLASS - 标记的注解在编译时由编译器保留，但 Java 虚拟机(JVM)会忽略。 RetentionPolicy.RUNTIME - 标记的注解由 JVM 保留，因此运行时环境可以使用它。 @Retention 三个值中 SOURCE &lt; CLASS &lt; RUNTIME，即CLASS包含了SOURCE，RUNTIME包含SOURCE、CLASS。下文会介绍他们不同的应用场景。 下面来看例子： 12345@Target({ElementType.TYPE,ElementType.FIELD}) // 允许在类与类属性上标记该注解 **作用目标**@Retention(RetentionPolicy.SOURCE) //注解保留在源码中 **保留时**public @interface Test { } 注解类型元素在上文元注解中，允许在使用注解时传递参数。我们也能让自定义注解的主体包含 annotation type element (注解类型元素) 声明，它们看起来很像方法，可以定义可选的默认值。 123456@Target({ElementType.TYPE,ElementType.FIELD})@Retention(RetentionPolicy.SOURCE)public @interface Test { String value(); //无默认值 int age() default 1; //有默认值} 注意：在使用注解时，如果定义的注解中的类型元素无默认值，则必须进行传值。 123@Test(&quot;帅&quot;) //如果只存在value元素需要传值的情况，则可以省略:元素名=@Test(value=&quot;帅&quot;,age = 2)int i; 注解应用场景按照@Retention 元注解定义的注解存储方式，注解可以被在三种场景下使用： SOURCERetentionPolicy.SOURCE ，作用于源码级别的注解，可提供给IDE语法检查、APT等场景使用。 在类中使用 SOURCE 级别的注解，其编译之后的class中会被丢弃。 12345--AnnotationTest.java@Testpublic class AnnotationTest{} 12345--AnnotationTest.class// 这里的注解被丢弃了public class AnnotationTest{} IDE语法检查在Android开发中， support-annotations 与 androidx.annotation中均有提供 @IntDef 注解，此注解的定义如下： 12345678910package androidx.annotation;@Retention(SOURCE) //源码级别的注解@Target({ANNOTATION_TYPE})public @interface IntDef { int[] value() default {}; boolean flag() default false; boolean open() default false;} Java中Enum(枚举)的实质是特殊单例的静态成员变量，在运行期所有枚举类作为单例，全部加载到内存中。比常量多5到10倍的内存占用。 而现在为了进行内存优化，我们现在不再使用枚举，则方法定义为： 12345678910public static final int SUNDAY = 1;public static final int MONDAY = 2;public static void setCurrentDay(int currentDay) {}public void test() { setCurrentDay(1);} 然而此时，调用 setCurrentDay方法由于采用基本数据类型int，将无法进行类型限定。此时使用@IntDef增加自定义注解： 123456789@IntDef({IntDefTest.MONDAY,IntDefTest.SUNDAY}) //限定为 MONDAY，SUNDAY@Target(ElementType.PARAMETER) //作用于参数的注解@Retention(RetentionPolicy.SOURCE) //源码级别注解public @interface WeekDayAnn {}public static void setCurrentDay(@WeekDayAnn int currentDay) {} 此时，我们再去调用 setCurrentDay方法，如果传递的参数不是 MONDAY或者 SUNDAY则会显示 Inspection 警告(编译不会报错)。 以上注解均为 SOURCE 级别，本身IDEA/AS 就是由Java开发的，工具实现了对Java语法的检查，借助注解能对被注解的特定语法进行额外检查。 APT注解处理器APT全称为：”Anotation Processor Tools”，意为注解处理器。顾名思义，其用于处理注解。编写好的Java源文件，需要经过 javac 的编译，翻译为虚拟机能够加载解析的字节码Class文件。注解处理器是 javac 自带的一个工具，用来在编译时期扫描处理注解信息。你可以为某些注解注册自己的注解处理器。 注册的注解处理器由 javac调起，并将注解信息传递给注解处理器进行处理。 注解处理器是对注解应用最为广泛的场景。在Glide、EventBus3、Butterknifer、Tinker、ARouter等等常用框架中都有注解处理器的身影。但是你可能会发现，这些框架中对注解的定义并不是 SOURCE 级别，更多的是 CLASS 级别，别忘了：CLASS包含了SOURCE，RUNTIME包含SOURCE、CLASS。 注解处理器的实现首先在程序中添加一个Java Module annotation 用于专门写注解,创建一个注解MyClass 1234@Retention(RetentionPolicy.SOURCE)@Target(ElementType.TYPE)public @interface MyClass {} 单独创建annotation模块，能够给其他子模块进行依赖 然后再添加一个Java Module compiler 用于注解处理器的编写 在app和compiler中build.gradle中添加annotation的依赖 123dependencies{ implementation project(':annotation')} 在compiler中添加注解处理器继承AbstractProcessor 123456789package com.lis.compiler;public class Processor extends AbstractProcessor { @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { return false; }} 注册注解处理器 在compiler main目录下创建以下目录及文件resources\\META-INF\\services\\javax.annotation.processing.Processor 这此文件里添加注解处理器的实现类com.lis.compiler.Processor （每个注解处理器占一行） 另外一种是使用AutoService自动完成注册 @AutoService(Processor.class) //固定写法 compileOnly ‘com.google.auto.service:auto-service:1.0’annotationProcessor ‘com.google.auto.service:auto-service:1.0’ @AutoService(Processor.class) //固定写法@SupportedAnnotationTypes({“com.lis.annotation.MyClass”})public class Processor extends AbstractProcessor { } 设置处理器要处理的注解 有两种方式 1.重写getSupportedAnnotationTypes方法 12345678/** * 允许此注解处理器处理的注解 * @return */@Overridepublic Set&lt;String&gt; getSupportedAnnotationTypes() { return Collections.singleton(&quot;com.lis.annotation.MyClass&quot;);} 2.在class上添加注解SupportedAnnotationTypes 12345678910111213141516@SupportedAnnotationTypes({&quot;com.lis.annotation.MyClass&quot;})public class Processor extends AbstractProcessor { @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { return false; } /** * 允许此注解处理器处理的注解 * @return */// @Override// public Set&lt;String&gt; getSupportedAnnotationTypes() {// return Collections.singleton(&quot;com.lis.annotation.MyClass&quot;);// }} 在app中使用此注解处理器（build文件中引用此注解处理器） 12implementation project(':annotation')annotationProcessor project(':compiler') //kotlin使用kapt 使用kotlin时 12345plugins { id 'kotlin-kapt' //引入kapt插件}kapt project(':compiler') //使用kapt引入注解处理器 在app中使用注解 1234@MyClassclass MainActivity : AppCompatActivity(){ } apt: 不会打包进APK，只会在编译时参与编译 在注解处理器中输出一个日志=======================&gt;,然后编译项目可以看到以下日志输出 1234&gt; Task :app:kaptDebugKotlin警告: No SupportedSourceVersion annotation found on com.lis.compiler.Processor, returning RELEASE_6.警告: 来自注释处理程序 'org.jetbrains.kotlin.kapt3.base.ProcessorWrapper' 的受支持 source 版本 'RELEASE_6' 低于 -source '1.8'注: =======================&gt;注: =======================&gt; 问题：注解处理器为什么会执行多次？ 因为java编译过程：词法分析、语法分析、填充符号表、注解处理器处理注解、语义分析、解语法糖、生成字节码。 注解处理器可以增删改抽象语法树的任意元素。执行到注解处理器，都会重新执行 语法分析、填充符号表 步，直到注解处理器不再对语法树进行修改为止，第一次的循环过程都称为一次Roud。 process第一个参数set集合是要处理的注解集合，如果这个集合为null了，就不需要处理了。 123if(!annotations.isEmpty()){ //todo} APT 核心原理 编译时触发： 当 Java 编译器（javac）开始工作时，APT 自动启动。 扫描注解： 遍历所有源码和 Class 文件，找到被目标注解标记的元素（如字段、方法）。 生成代码： 根据注解信息，用 JavaPoet 等工具生成新的 Java 文件。 多轮处理： 生成的代码可能包含新注解，APT 会多次循环处理，直到无新代码生成。 APT 的优缺点 优点 缺点 编译时处理，不拖慢运行速度 学习成本高，需要理解注解处理器API 减少手写重复代码（如 findViewById） 生成的代码调试困难 代码更干净，维护方便 配置稍繁琐（注册处理器） APT 应用场景 View 绑定： 如 ButterKnife，自动生成 findViewById 代码。 依赖注入： 如 Dagger2，生成依赖注入逻辑。 路由框架： 如 ARouter，生成 Activity 路由表。 序列化/反序列化： 如 Gson TypeAdapter 自动生成。 APT 工作流程图写注解 → 编译 → APT 扫描 → 生成代码 → 二次编译 → 最终 APK CLASS定义为 CLASS 的注解，会保留在class文件中，但是会被虚拟机忽略(即无法在运行期反射获取注解)。此时完全符合此种注解的应用场景为字节码操作。如：AspectJ、热修复Roubust中应用此场景。所谓字节码操作即为，直接修改字节码Class文件以达到修改代码执行逻辑的目的。在程序中有多处需要进行是否登录的判断。 如果我们使用普通的编程方式，需要在代码中进行 if-else 的判断，也许存在十个判断点，则需要在每个判断点加入此项判断。此时，我们可以借助AOP(面向切面)编程思想，将程序中所有功能点划分为： 需要登录 与 无需登录两种类型，即两个切面。对于切面的区分即可采用注解。 12345678910111213//Java源码@Target(ElementType.METHOD)@Retention(RetentionPolicy.CLASS)public @interface Login {}@Loginpublic void jumpA(){ startActivity(new Intent(this,AActivity.class));}public void jumpB(){ startActivity(new Intent(this,BActivity.class));} 在上诉代码中， jumpA 方法需要具备登录身份。而 Login 注解的定义被设置为 CLASS 。因此我们能够在该类所编译的字节码中获得到方法注解 Login 。在操作字节码时，就能够根据方法是否具备该注解来修改class中该方法的内容加入 if-else 的代码段： 12345678910111213//Class字节码@Loginpublic void jumpA() { if (this.isLogin) { this.startActivity(new Intent(this, LoginActivity.class)); } else { this.startActivity(new Intent(this, AActivity.class)); }}public void jumpB() { startActivity(new Intent(this,BActivity.class));} 注解能够设置类型元素(参数)，结合参数能实现更为丰富的场景，如：运行期权限判定等 RUNTIME注解保留至运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。","link":"/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"}],"tags":[{"name":"activity","slug":"activity","link":"/tags/activity/"},{"name":"Android源码","slug":"Android源码","link":"/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"dispatch","slug":"dispatch","link":"/tags/dispatch/"},{"name":"OkHttp","slug":"OkHttp","link":"/tags/OkHttp/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"泛型","slug":"泛型","link":"/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"注解","slug":"注解","link":"/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"反射","slug":"反射","link":"/tags/%E5%8F%8D%E5%B0%84/"},{"name":"动态代理","slug":"动态代理","link":"/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}],"categories":[{"name":"Android源码","slug":"Android源码","link":"/categories/Android%E6%BA%90%E7%A0%81/"},{"name":"Android三方库源码分析","slug":"Android三方库源码分析","link":"/categories/Android%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Java基础与进阶","slug":"Java基础与进阶","link":"/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"}]}