<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lis</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-06-04T02:52:44.725Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM</title>
    <link href="http://example.com/2025/05/28/JVM/"/>
    <id>http://example.com/2025/05/28/JVM/</id>
    <published>2025-05-28T09:16:56.000Z</published>
    <updated>2025-06-04T02:52:44.725Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#jvm%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">JVM的内存管理</a><ul><li><a href="#java%E4%BB%8E%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C">Java从编译到执行</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA">运行时数据区</a></li><li><a href="#java%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java方法的运行与虚拟机栈</a></li><li><a href="#%E6%A0%88%E5%B8%A7%E6%89%A7%E8%A1%8C%E5%AF%B9%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%BD%B1%E5%93%8D">栈帧执行对内存区域的影响</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E5%8C%BA%E5%9F%9F">运行时数据区中的其他区域</a></li><li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">深入理解JVM内存区域</a></li></ul></li><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">对象的分配及垃圾回收机制</a><ul><li><a href="#jvm%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B">JVM中对象的创建过程</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">对象的内存布局</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D">对象的访问定位</a></li><li><a href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E6%B4%BB">判断对象的存活</a><ul><li><a href="#class%E5%9B%9E%E6%94%B6%E6%9D%A1%E4%BB%B6-%E8%8B%9B%E5%88%BB%E6%BB%A1%E8%B6%B3%E6%89%80%E6%9C%89">Class回收条件 （苛刻，满足所有）</a></li></ul></li><li><a href="#%E5%90%84%E7%A7%8D%E5%BC%95%E7%94%A8">各种引用</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">对象的分配策略</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E5%8E%9F%E5%88%99">对象的分配原则</a></li></ul></li><li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF">虚拟机的优化技术</a><ul><li><a href="#%E6%A0%88%E4%B8%AD%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1">栈中分配对象</a></li><li><a href="#%E5%A0%86%E4%B8%AD%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF">堆中优化技术</a></li></ul></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">垃圾回收基础知识</a><ul><li><a href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">回收算法</a></li></ul></li></ul></li><li><a href="#jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98">JVM垃圾回收器及性能调优</a><ul><li><a href="#jvm%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8">JVM中常见的垃圾回收器</a></li><li><a href="#cms">CMS</a><ul><li><a href="#cms%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82">CMS中的细节</a></li><li><a href="#cms%E7%9A%84%E9%97%AE%E9%A2%98">CMS的问题</a></li></ul></li><li><a href="#jvm%E8%B0%83%E4%BC%98">JVM调优</a><ul><li><a href="#jvm%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E4%BB%A3%E5%88%92%E5%88%86">JVM内存的分代划分</a></li><li><a href="#%E6%89%A9%E5%AE%B9%E6%96%B0%E7%94%9F%E4%BB%A3%E6%8F%90%E9%AB%98gc%E6%95%88%E7%8E%87">扩容新生代提高GC效率</a></li><li><a href="#jvm%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dminorgc%E6%97%B6%E6%89%AB%E6%8F%8F%E5%85%A8%E5%A0%86%E7%9A%84">JVM是如何避免MinorGC时扫描全堆的</a></li></ul></li><li><a href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%96%B9%E6%B3%95%E5%8C%BA">常量池（方法区）</a></li><li><a href="#java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2">Java的发展历史</a></li></ul></li></ul><!-- tocstop --><a id="more"></a><h2><span id="jvm的内存管理">JVM的内存管理</span></h2><p><img src="/2025/05/28/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt="JVM内存模型.jpg"></p><h3><span id="java从编译到执行">Java从编译到执行</span></h3><p><img src="/2025/05/28/JVM/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java程序运行过程.png"></p><ul><li><p>解释执行</p><p>要经过JVM翻译，速度慢一点</p></li><li><p>JIT执行（Java代码 翻译成 汇编码（放在codecache内存））</p><p>速度比较快，编译时间比较长</p></li></ul><p>JVM是一种规范</p><ul><li>JVM的跨平台</li><li>JVM的语言无关性</li></ul><p><img src="/2025/05/28/JVM/JVM%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0.png" alt="JVM的跨平台.png"></p><h3><span id="运行时数据区">运行时数据区</span></h3><p>定义：Java虚拟机在执行Java程序的过程中会把它所管理的<code>内存</code>划分为若干个不同的数据区域</p><p>类型：线程私有与线程共享</p><ul><li>共享区：方法区，堆</li><li>私有区：虚拟机栈，本地方法栈（HotSpot 合二为一了），程序计数器</li></ul><p><img src="/2025/05/28/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="运行时数据区.png"></p><h3><span id="java方法的运行与虚拟机栈">Java方法的运行与虚拟机栈</span></h3><p><img src="/2025/05/28/JVM/%E8%BF%90%E8%A1%8C%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="运行的内存区域.png"></p><p><strong>程序计数器</strong></p><p>指向当前线程正在执行的字节码指令的地址（只记录虚拟机栈的，本地方法栈值始终为null）</p><p><strong>虚拟机栈</strong></p><p>存储当前线程运行Java方法所需要的数据，指令，返回地址</p><ul><li><p>大小限制 -Xss</p><p>创建一个线程就会创建一个虚拟机栈，基本上是1M</p><p>-Xss1m,-Xss1024K,-Xss1048576(没有单位默认bit)</p><p>调优：内存吃紧的情况可以调小虚拟机栈的大小</p></li><li><p>栈溢出</p><p>一个方法一个栈帧，死递归导致内存大小超过1m</p></li></ul><p><strong>栈帧</strong></p><ul><li>局部变量表  //记录方法运行时的偏移量</li><li>操作数栈</li><li>动态连接</li><li>完成出口    //方法结束后返回的地方</li></ul><h3><span id="栈帧执行对内存区域的影响">栈帧执行对内存区域的影响</span></h3><p><img src="/2025/05/28/JVM/%E6%A0%88%E5%B8%A7%E6%89%A7%E8%A1%8C.png" alt="1748336726316"></p><p>使用反汇编工具输出字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">// 一个方法对应一个栈帧</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// iconst_1 、istore_1</span></span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">2</span>; <span class="comment">// iconst_2 、istore_2</span></span><br><span class="line">        <span class="keyword">int</span> z = (x + y) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.work();</span><br><span class="line">        p.hashCode(); <span class="comment">//方法属于本地方法 --- 本地方法栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap -v Person.class</p><p><img src="/2025/05/28/JVM/%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="反汇编.png"></p><p>没有8的原因是7的操作 字节码偏移量大，占两个计数</p><h3><span id="运行时数据区中的其他区域">运行时数据区中的其他区域</span></h3><p><img src="/2025/05/28/JVM/%E5%85%B6%E4%BB%96%E5%8C%BA%E5%9F%9F.png" alt="其他区域.png"></p><p>直接内存申请：<code>ByteBuffer.allocateDirect(128 * 1024*1024)</code> //分配128M的直接内存</p><h3><span id="深入理解jvm内存区域">深入理解JVM内存区域</span></h3><p>JVM内存处理全流程</p><ol><li>JVM申请内存</li><li>初始化运行时数据区</li><li>类加载</li><li>执行方法</li><li>创建对象</li></ol><p>内存溢出</p><ul><li>栈溢出（死递归）</li><li>堆溢出（设置堆的大小，然后创建一个超过堆大小的对象）</li><li>方法区溢出（设置方法区大小，不断的加载xx.class）</li><li>本机直接内存溢出（设置直接内存大小，然后申请超的对象）</li></ul><h2><span id="对象的分配及垃圾回收机制">对象的分配及垃圾回收机制</span></h2><h3><span id="jvm中对象的创建过程">JVM中对象的创建过程</span></h3><p><img src="/2025/05/28/JVM/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="对象创建过程"></p><ul><li><p>检查加载</p><p>检查类有没有加载过，没有加载使用类加载器加载（常量池中的符号引用转换为直接引用）</p></li><li><p>分配内存</p><p>划分内存方式</p><ul><li><p>指针碰撞</p><p><img src="/2025/05/28/JVM/%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E.png" alt="指针碰撞"></p></li><li><p>空闲列表</p><p><img src="/2025/05/28/JVM/%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8.png" alt="空闲列表.png"></p></li></ul><p>并发安全问题</p><ul><li><p>CAS加载重试</p><p><img src="/2025/05/28/JVM/CAS%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E.png" alt="CAS指针碰撞"></p></li><li><p>本地线程分配缓冲（<code>默认</code>）</p><p><img src="/2025/05/28/JVM/%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B%E7%BC%93%E5%86%B2.png" alt="本地线程缓冲"></p></li></ul></li><li><p>初始化</p><p>“<code>零</code>”值</p></li><li><p>设置</p><p>对象头</p></li><li><p>对象初始化</p><p>构造方法</p></li></ul><h3><span id="对象的内存布局">对象的内存布局</span></h3><p><img src="/2025/05/28/JVM/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="对象的内存布局"></p><ul><li>对象头<ul><li>Mark Word</li><li>类型指针    （指向方法区xxx.class）</li><li>若为对象数组，记录数组长度数据</li></ul></li><li>实例数据</li><li>对齐填充（非必须，对齐8字节整数倍）</li></ul><h3><span id="对象的访问定位">对象的访问定位</span></h3><ul><li>使用句柄</li><li><img src="/2025/05/28/JVM/%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt="使用句柄"></li><li>直接指针（HotSpot）</li></ul><p><img src="/2025/05/28/JVM/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="直接指针"></p><h3><span id="判断对象的存活">判断对象的存活</span></h3><p><img src="/2025/05/28/JVM/%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB.png" alt="对象存活"></p><ul><li><p>引用计数算法</p></li><li><p>可达性分析（根可达）</p><p><code>GC roots (Root Set)：静态变量，线程栈变量（局部变量），常量池，JNI（指针）</code></p><ol start="5"><li><p>内存引用：class对象，异常对象Exception，类加载器</p></li><li><p>同步锁：synchronized对象</p></li><li><p>内部对象：JMXBean，JVMTI中注册的回调、本地代码缓存等</p></li><li><p>临时对象：跨代引用 </p></li></ol></li></ul><h4><span id="class回收条件-苛刻满足所有">Class回收条件 （苛刻，满足所有）</span></h4><ol><li>class new出的所有对象都要回收掉了。</li><li>对应的类加载器也要被回收掉。</li><li>该类对应的java.lang.Class对象没有被引用<ol><li>任何地方没有被引用，并且无法通过反射调用这个类的方法。</li></ol></li><li>参数控制。-Xnoclassgc 关闭才行</li></ol><h3><span id="各种引用">各种引用</span></h3><ul><li><p>强引用  </p><p>=</p></li><li><p>软引用 SoftReference </p><p>马上OOM的时候回收 。（图片缓存）</p></li><li><p>弱引用 WeakReference</p><p>一旦发生GC时就会被回收   （空间不够，才会GC）ThreadLocal，HashMap</p></li><li><p>虚引用 PhantomReference</p><p>监控垃圾回收器是否执行  <code>NIO中DirectByteBuffer中的Cleaner</code></p></li></ul><h3><span id="对象的分配策略">对象的分配策略</span></h3><p>几乎所有的对象都在堆上分配</p><p>栈上分配  ：逃逸分析</p><p>新生代：老年代=1：2（默认）</p><p>新生代 Eden：From：To=8：1：1（默认）</p><p><img src="/2025/05/28/JVM/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" alt="对象分配策略"></p><h4><span id="对象的分配原则">对象的分配原则</span></h4><ul><li><p>对象优化在Eden分配</p></li><li><p>空间分配担保</p><p>JVM担保老年代能放下，失败后发生一次fullgc</p><p>（统计历次老年代回收释放的空间，晋级老年代时小于这个值就直接放）</p></li><li><p>大对象直接进入老年代</p><p>只有Serial和ParNew回收器才会有效， 大小超过-XX:PretenureSizeThreshold参数的设置值</p></li><li><p>长期存活的对象进入老年代</p><p>From,To区进行复制回收算法， GC计数 15次以后进入老年代</p></li><li><p>动态对象年龄判定</p><p>多个对象计算年龄和，大于survivor 期望值直接进入老年代</p></li></ul><p><code>header中Gc为4位2进制，最大是15，达到15后进入老年代，默认15，在CMS垃圾回收器中是6</code></p><h3><span id="虚拟机的优化技术">虚拟机的优化技术</span></h3><h4><span id="栈中分配对象">栈中分配对象</span></h4><p>逃逸分析+触发JIT（热点数据）</p><p>开启逃逸分析，并且栈里分配缓冲（TLAB），并且打开标量替换，才会在栈上分配对象（对象只在方法里用，外部没有用到。逃逸不掉）</p><p>栈不需要回收，线程执行完，栈就没了</p><p><code>-XX:DoEscapeAnalysis</code>  默认开启逃逸分析 <code>-XX:-DoEscapeAnalysis</code>：关掉</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>PS:逃逸分析有方法逃逸和线程逃逸：如果一个方法不会被其他方法调用就是方法逃逸，如果一个方法不会被其他线程访问就是线程逃逸</p><h4><span id="堆中优化技术">堆中优化技术</span></h4><p>本地线程分配缓冲（TLAB）</p><h3><span id="垃圾回收基础知识">垃圾回收基础知识</span></h3><p><img src="/2025/05/28/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80.png" alt="垃圾回收基础"></p><p>回收新生代：minor GC </p><p>回收老年代：major GC ,OldGC</p><p>回收老年代是肯定会触发FullGC</p><h4><span id="回收算法">回收算法</span></h4><ul><li><p>复制算法    （主要是新生代）</p><ul><li>实现简单、运行高效</li><li>没有内存碎片</li><li>复用率只有一半</li></ul><p>Eden区的来源（Appel式的复制回收算法）</p><ul><li>Appel式回收</li><li>提高空间复用率和空间分配担保</li></ul></li><li><p>标记清除算法 （CMS使用）</p><ul><li>位置不连接，产生碎片（导致提前GC）</li><li>可以做到不暂停</li></ul></li><li><p>标记整理算法 （标记-&gt;整理-&gt;清除）</p><ul><li>没有内存碎片</li><li>指针需要移动</li></ul></li></ul><h2><span id="jvm垃圾回收器及性能调优">JVM垃圾回收器及性能调优</span></h2><h3><span id="jvm中常见的垃圾回收器">JVM中常见的垃圾回收器</span></h3><p><img src="/2025/05/28/JVM/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="常见的垃圾回收器"></p><p>jdk1.8默认是Parallel Scavenge 和 Parallel Old：最大吞吐量（PS组合，自适应大小）</p><p>单线程收集</p><p><img src="/2025/05/28/JVM/%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%94%B6%E9%9B%86.png" alt="单线程收集"></p><p>多线程收集</p><p><img src="/2025/05/28/JVM/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%B6%E9%9B%86.png" alt="多线程收集"></p><h3><span id="cms">CMS</span></h3><p>CMS 针对老年代的垃圾回收器（响应优先）</p><p><img src="/2025/05/28/JVM/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="CMS垃圾回收器.png"></p><ol><li><p>初始标记 ：根直接相连的对象   （STW，暂停时间短 ）</p></li><li><p>并发标记：标记除根直接相连的其他对象（并发标记）</p></li><li><p>重新标记：有变动的对象（STW，暂停所有用户线程，时间短）</p></li><li><p>并发清理：用户和GC同时进行   时间长</p></li><li><p>重置线程：</p></li></ol><h4><span id="cms中的细节">CMS中的细节</span></h4><ul><li><p>预清理</p><ul><li><p>新生代Eden区A对象又指向了老年代的标记为垃圾的对象B，将B标记为非垃圾对象 ‘粉色’。</p></li><li><p>老年代的引用发生了变化， 记录类似卡表的结构</p></li></ul></li><li><p>并发可中断预清理</p><p>触发条件：Eden区已有2M（配置参数）以上</p><ul><li><p>From或To区对象到老年代可达，导致老年代的并发标记中的引用发生变化。</p></li><li><p>老年代的引用发生了变化， 记录类似卡表的结构</p></li></ul><p>中断：</p><ol><li>循环次数（配置参数）</li><li>时间5秒（配置参数）</li><li>Eden区内存使用达到50%</li></ol></li></ul><blockquote><p>在并发标记和重新标记这间，<strong>节约缩短重新标记时间</strong></p></blockquote><p><img src="/2025/05/28/JVM/CMS%E4%B8%AD%E7%BB%86%E8%8A%82.png" alt="CMS中细节"></p><p>CMS垃圾回收日志</p><p><img src="/2025/05/28/JVM/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%97%A5%E5%BF%97.png" alt="CMS垃圾回收日志"></p><h4><span id="cms的问题">CMS的问题</span></h4><ul><li><p>CPU敏感（核数&lt;4基本上没法用）</p></li><li><p>浮动垃圾（在并发清理时，还有新的垃圾产生）</p></li><li><p>内存碎片（对象分配不下去，导致垃圾回收器退化CMS-&gt;Serial Old）<code>重启</code></p></li></ul><h3><span id="jvm调优">JVM调优</span></h3><h4><span id="jvm内存的分代划分">JVM内存的分代划分</span></h4><p><img src="/2025/05/28/JVM/JVM%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3%E5%88%92%E5%88%86.png" alt="JVM内存分代划分.png"></p><p>总堆：活跃数据的3~4倍</p><p>总堆： 300M*4 = 1.2G    新生代 = 450M，老年代=750M</p><h4><span id="扩容新生代提高gc效率">扩容新生代提高GC效率</span></h4><p><img src="/2025/05/28/JVM/%E6%89%A9%E5%AE%B9%E6%96%B0%E7%94%9F%E4%BB%A3.png" alt="扩容新生代"></p><p>扫描时间T1， 复制所用时间T2 。往往T1时间短，T2时间长</p><p>新生代容量：R<br>A存活时间750ms<br>MinorGC间隔500ms<br>所用时长：T1+ T2</p><p>扩容新生代：2R<br>A存活时间750ms<br>MinorGC间隔1000ms（空间增大一倍，时间拉长）<br>GC时，A已经不存活<br>所用时长：T1，没有T2了</p><table><thead><tr><th>新生代容量R</th><th>扩容新生代2R</th></tr></thead><tbody><tr><td>A存活时间750ms</td><td>A存活时间750ms</td></tr><tr><td>MinorGC间隔500ms</td><td>MinorGC间隔1000ms</td></tr><tr><td>所用时长：T1+ T2</td><td>所用时长：T1</td></tr></tbody></table><h4><span id="jvm是如何避免minorgc时扫描全堆的">JVM是如何避免MinorGC时扫描全堆的</span></h4><p>使用卡表记录跨代引用，避免全堆扫描</p><p><img src="/2025/05/28/JVM/%E5%8D%A1%E8%A1%A8.png" alt="卡表"></p><h3><span id="常量池方法区">常量池（方法区）</span></h3><ul><li>Class常量池 </li><li>运行时常量池</li><li>字符串常量池</li></ul><p><strong>Class常量池（静态常量池）</strong>在class文件中，记录Class,Methodref，编译时的字面量以及符号引用</p><p>字面量 ：String i=”king”  king就字面量</p><p>符号引用： String 这个类，java.lang.String </p><p>类，方法的信息</p><p><img src="/2025/05/28/JVM/%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="静态常量池"></p><p><strong>运行时常量池</strong>：通过类加载，将类放在方法区 Person.class</p><p>只有在运行的时候才会把符号引用转换成直接引用</p><p><img src="/2025/05/28/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="运行时常量池.png"></p><p><strong>字符串常量池</strong></p><p><code>String str = &quot;abc&quot;</code></p><p><img src="/2025/05/28/JVM/String1.png" alt="string1"></p><p>“abc”创建以后就不可改变了并且会复用，String str2=”abc”就不会再创建了。</p><p><code>String str = new String(&quot;abc&quot;)</code></p><p><img src="/2025/05/28/JVM/String2.png" alt="String2.png"></p><p>会有2个对象，一个字符串常量池里”abc”,一个是堆里的String对象（abc的引用）</p><p><code>Class中的局部变量String</code></p><p><img src="/2025/05/28/JVM/String3.png" alt="String3"></p><p><del>在运行时，创建的String对象会在堆中直接创建，不会再在常量池中创建。</del></p><p><code>intern()</code></p><p>intern()首先在常量池中查找是否有等于该字符串的对象引用，有就返回引用。</p><p>所以a和b指向的是同一个</p><p><img src="/2025/05/28/JVM/intern.png" alt="intern"></p><h3><span id="java的发展历史">Java的发展历史</span></h3><p><img src="/2025/05/28/JVM/Java%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="Java发展史"></p><p>Java7：try catch , NIO的api</p><p>Java8：lambda,Stream,HashMap性能，并发安全工具类，元空间取代永久代</p><p>Java9：CMS废弃倒计时，G1默认回收器</p><p>Java10：JIT graal 编译器</p><p>Java11：-ZGC</p><p>Java13: -ZGC 4TB-&gt;16TB</p><p>Java14：移除CMS</p>]]></content>
    
    
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jvm%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&quot;&gt;JVM的内存管理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#java%E4%BB%8E%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C&quot;&gt;Java从编译到执行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA&quot;&gt;运行时数据区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#java%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88&quot;&gt;Java方法的运行与虚拟机栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A0%88%E5%B8%A7%E6%89%A7%E8%A1%8C%E5%AF%B9%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%BD%B1%E5%93%8D&quot;&gt;栈帧执行对内存区域的影响&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E5%8C%BA%E5%9F%9F&quot;&gt;运行时数据区中的其他区域&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F&quot;&gt;深入理解JVM内存区域&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6&quot;&gt;对象的分配及垃圾回收机制&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jvm%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B&quot;&gt;JVM中对象的创建过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80&quot;&gt;对象的内存布局&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D&quot;&gt;对象的访问定位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E6%B4%BB&quot;&gt;判断对象的存活&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#class%E5%9B%9E%E6%94%B6%E6%9D%A1%E4%BB%B6-%E8%8B%9B%E5%88%BB%E6%BB%A1%E8%B6%B3%E6%89%80%E6%9C%89&quot;&gt;Class回收条件 （苛刻，满足所有）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%90%84%E7%A7%8D%E5%BC%95%E7%94%A8&quot;&gt;各种引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5&quot;&gt;对象的分配策略&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E5%8E%9F%E5%88%99&quot;&gt;对象的分配原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF&quot;&gt;虚拟机的优化技术&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A0%88%E4%B8%AD%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1&quot;&gt;栈中分配对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A0%86%E4%B8%AD%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF&quot;&gt;堆中优化技术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&quot;&gt;垃圾回收基础知识&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95&quot;&gt;回收算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98&quot;&gt;JVM垃圾回收器及性能调优&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jvm%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8&quot;&gt;JVM中常见的垃圾回收器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cms&quot;&gt;CMS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#cms%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82&quot;&gt;CMS中的细节&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cms%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;CMS的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm%E8%B0%83%E4%BC%98&quot;&gt;JVM调优&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jvm%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E4%BB%A3%E5%88%92%E5%88%86&quot;&gt;JVM内存的分代划分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%89%A9%E5%AE%B9%E6%96%B0%E7%94%9F%E4%BB%A3%E6%8F%90%E9%AB%98gc%E6%95%88%E7%8E%87&quot;&gt;扩容新生代提高GC效率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dminorgc%E6%97%B6%E6%89%AB%E6%8F%8F%E5%85%A8%E5%A0%86%E7%9A%84&quot;&gt;JVM是如何避免MinorGC时扫描全堆的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%96%B9%E6%B3%95%E5%8C%BA&quot;&gt;常量池（方法区）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2&quot;&gt;Java的发展历史&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;</summary>
    
    
    
    <category term="Java基础与进阶" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>注解与反射（上）</title>
    <link href="http://example.com/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</id>
    <published>2025-05-15T08:51:54.000Z</published>
    <updated>2025-05-19T07:48:30.728Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="注解">注解</span></h2><p>Java 注解（Annotation）又称 Java 标注，是 JDK1.5 引入的一种注释机制。 注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。</p><p>注解一般是配合反射来一起用的，所以我们把这两个合在一起来分析。</p><!-- toc --><ul><li><a href="#%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E"><strong>注解声明</strong></a><ul><li><a href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3"><strong>声明一个注解</strong></a></li><li><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><strong>元注解</strong></a></li><li><a href="#%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B%E5%85%83%E7%B4%A0"><strong>注解类型元素</strong></a></li></ul></li><li><a href="#%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>注解应用场景</strong></a><ul><li><a href="#source"><strong>SOURCE</strong></a><ul><li><a href="#ide%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5"><strong>IDE语法检查</strong></a></li><li><a href="#apt%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8"><strong>APT注解处理器</strong></a></li><li><a href="#%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><strong>注解处理器的实现</strong></a></li><li><a href="#apt-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><strong>APT 核心原理</strong></a></li><li><a href="#apt-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><strong>APT 的优缺点</strong></a></li><li><a href="#apt-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>APT 应用场景</strong></a></li><li><a href="#apt-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE"><strong>APT 工作流程图</strong></a></li></ul></li><li><a href="#class"><strong>CLASS</strong></a></li><li><a href="#runtime"><strong>RUNTIME</strong></a></li></ul></li></ul><!-- tocstop --><a id="more"></a><h3><span id="注解声明"><strong>注解声明</strong></span></h3><h4><span id="声明一个注解"><strong>声明一个注解</strong></span></h4><p>Java中所有的注解，默认实现 <code>Annotation</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的声明使用 <code>@interface</code> 关键字。一个注解的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="元注解"><strong>元注解</strong></span></h4><p>在定义注解时，注解类也能够使用其他的注解声明。对注解类型进行注解的注解类，我们称之为 meta-<br>annotation（元注解）。一般的，我们在定义自定义注解时，需要指定的元注解有两个 ：</p><blockquote><p>另外还有@Documented 与 @Inherited 元注解，前者用于被javadoc工具提取成文档，后者表示允许子类<br>继承父类中定义的注解。</p></blockquote><p><strong>@Target</strong><br>注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值：</p><ul><li>ElementType.ANNOTATION_TYPE 可以应用于注解类型。</li><li>ElementType.CONSTRUCTOR 可以应用于构造函数。</li><li>ElementType.FIELD 可以应用于字段或属性。</li><li>ElementType.LOCAL_VARIABLE 可以应用于局部变量。</li><li>ElementType.METHOD 可以应用于方法级注解。</li><li>ElementType.PACKAGE 可以应用于包声明。</li><li>ElementType.PARAMETER 可以应用于方法的参数。</li><li>ElementType.TYPE 可以应用于类的任何元素。</li></ul><p><strong>@Retention</strong><br>注解指定标记注解的存储方式：</p><ul><li><p>RetentionPolicy.SOURCE - 标记的注解仅保留在源级别中，并被编译器忽略。</p></li><li><p>RetentionPolicy.CLASS - 标记的注解在编译时由编译器保留，但 Java 虚拟机(JVM)会忽略。</p></li><li><p>RetentionPolicy.RUNTIME - 标记的注解由 JVM 保留，因此运行时环境可以使用它。</p><blockquote><p>@Retention 三个值中 SOURCE &lt; CLASS &lt; RUNTIME，即CLASS包含了SOURCE，RUNTIME包含SOURCE、CLASS。下文会介绍他们不同的应用场景。</p></blockquote></li></ul><p>下面来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.FIELD&#125;)</span> <span class="comment">// 允许在类与类属性上标记该注解  **作用目标**</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">//注解保留在源码中    **保留时**</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="注解类型元素"><strong>注解类型元素</strong></span></h4><p>在上文元注解中，允许在使用注解时传递参数。我们也能让自定义注解的主体包含 annotation type element (注解类型元素) 声明，它们看起来很像方法，可以定义可选的默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>; <span class="comment">//无默认值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 1</span>; <span class="comment">//有默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在使用注解时，如果定义的注解中的类型元素无默认值，则必须进行传值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(&quot;帅&quot;)</span> <span class="comment">//如果只存在value元素需要传值的情况，则可以省略:元素名=</span></span><br><span class="line"><span class="meta">@Test(value=&quot;帅&quot;,age = 2)</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure><h3><span id="注解应用场景"><strong>注解应用场景</strong></span></h3><p>按照@Retention 元注解定义的注解存储方式，注解可以被在三种场景下使用：</p><p> <img src="/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="应用场景"></p><h4><span id="source"><strong>SOURCE</strong></span></h4><p><code>RetentionPolicy.SOURCE</code> ，作用于源码级别的注解，可提供给IDE语法检查、APT等场景使用。</p><p>在类中使用 SOURCE 级别的注解，其编译之后的class中会被丢弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--AnnotationTest.java</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--AnnotationTest.class</span><br><span class="line"><span class="comment">// 这里的注解被丢弃了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="ide语法检查"><strong>IDE语法检查</strong></span></h5><p>在Android开发中， <code>support-annotations</code> 与 <code>androidx.annotation</code>中均有提供 @IntDef 注解，此注解的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> androidx.annotation;</span><br><span class="line"><span class="meta">@Retention(SOURCE)</span> <span class="comment">//源码级别的注解</span></span><br><span class="line"><span class="meta">@Target(&#123;ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IntDef &#123;</span><br><span class="line">    <span class="keyword">int</span>[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">flag</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java中Enum(枚举)的实质是特殊单例的静态成员变量，在运行期所有枚举类作为单例，全部加载到内存中。<br>比常量多5到10倍的内存占用。</p></blockquote><p>而现在为了进行内存优化，我们现在不再使用枚举，则方法定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCurrentDay</span><span class="params">(<span class="keyword">int</span> currentDay)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setCurrentDay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而此时，调用 <code>setCurrentDay</code>方法由于采用基本数据类型int，将无法进行类型限定。此时使用@IntDef增加自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntDef(&#123;IntDefTest.MONDAY,IntDefTest.SUNDAY&#125;)</span> <span class="comment">//限定为 MONDAY，SUNDAY</span></span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span> <span class="comment">//作用于参数的注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">//源码级别注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WeekDayAnn &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCurrentDay</span><span class="params">(<span class="meta">@WeekDayAnn</span> <span class="keyword">int</span> currentDay)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们再去调用 <code>setCurrentDay</code>方法，如果传递的参数不是 MONDAY或者 SUNDAY则会显示 Inspection 警告(编译不会报错)。</p><p><img src="/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5.png" alt="语法检查"></p><p>以上注解均为 SOURCE 级别，本身IDEA/AS 就是由Java开发的，工具实现了对Java语法的检查，借助注解能对被注解的特定语法进行额外检查。</p><h5><span id="apt注解处理器"><strong>APT注解处理器</strong></span></h5><p>APT全称为：”Anotation Processor Tools”，意为注解处理器。顾名思义，其用于处理注解。编写好的Java源文<br>件，需要经过 javac 的编译，翻译为虚拟机能够加载解析的字节码Class文件。注解处理器是 javac 自带的一个工<br>具，用来在编译时期扫描处理注解信息。你可以为某些注解注册自己的注解处理器。 注册的注解处理器由 javac<br>调起，并将注解信息传递给注解处理器进行处理。</p><blockquote><p>注解处理器是对注解应用最为广泛的场景。在Glide、EventBus3、Butterknifer、Tinker、ARouter等等常用<br>框架中都有注解处理器的身影。但是你可能会发现，这些框架中对注解的定义并不是 SOURCE 级别，更多的<br>是 CLASS 级别，别忘了：CLASS包含了SOURCE，RUNTIME包含SOURCE、CLASS。</p></blockquote><h5><span id="注解处理器的实现"><strong>注解处理器的实现</strong></span></h5><p>首先在程序中添加一个Java Module <code>annotation</code> 用于专门写注解,创建一个注解MyClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyClass &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单独创建annotation模块，能够给其他子模块进行依赖</p></blockquote><p>然后再添加一个Java Module <code>compiler</code> 用于注解处理器的编写</p><p>在app和compiler中build.gradle中添加annotation的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    <span class="function">implementation <span class="title">project</span><span class="params">(<span class="string">&#x27;:annotation&#x27;</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>compiler</code>中添加注解处理器继承AbstractProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lis.compiler;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册注解处理器</strong></p><p>在<code>compiler</code> main目录下创建以下目录及文件<code>resources\META-INF\services\javax.annotation.processing.Processor</code>  这此文件里添加注解处理器的实现类<code>com.lis.compiler.Processor</code> （每个注解处理器占一行）</p><blockquote><p>另外一种是使用AutoService自动完成注册 @AutoService(Processor.class) <em>//固定写法</em></p><p>compileOnly ‘com.google.auto.service:auto-service:1.0’<br>annotationProcessor ‘com.google.auto.service:auto-service:1.0’</p><p>@AutoService(Processor.class) //固定写法<br>@SupportedAnnotationTypes({“com.lis.annotation.MyClass”})<br>public class Processor extends AbstractProcessor {</p><p>}</p></blockquote><p><strong>设置处理器要处理的注解</strong></p><p>有两种方式</p><p>1.重写getSupportedAnnotationTypes方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许此注解处理器处理的注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.singleton(<span class="string">&quot;com.lis.annotation.MyClass&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在class上添加注解SupportedAnnotationTypes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&#123;&quot;com.lis.annotation.MyClass&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许此注解处理器处理的注解 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span></span><br><span class="line"><span class="comment">//        return Collections.singleton(&quot;com.lis.annotation.MyClass&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app中使用此注解处理器（build文件中引用此注解处理器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">implementation <span class="title">project</span><span class="params">(<span class="string">&#x27;:annotation&#x27;</span>)</span></span></span><br><span class="line"><span class="function">annotationProcessor <span class="title">project</span><span class="params">(<span class="string">&#x27;:compiler&#x27;</span>)</span> <span class="comment">//kotlin使用kapt</span></span></span><br></pre></td></tr></table></figure><p>使用kotlin时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span> <span class="comment">//引入kapt插件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">kapt <span class="title">project</span><span class="params">(<span class="string">&#x27;:compiler&#x27;</span>)</span> <span class="comment">//使用kapt引入注解处理器</span></span></span><br></pre></td></tr></table></figure><p>在<code>app</code>中使用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyClass</span></span><br><span class="line">class MainActivity : AppCompatActivity()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>apt: 不会打包进APK，只会在编译时参与编译</strong></p><p>在注解处理器中输出一个日志<code>=======================&gt;</code>,然后编译项目可以看到以下日志输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :app:kaptDebugKotlin</span><br><span class="line">警告: No SupportedSourceVersion annotation found on com.lis.compiler.Processor, returning RELEASE_6.警告: 来自注释处理程序 <span class="string">&#x27;org.jetbrains.kotlin.kapt3.base.ProcessorWrapper&#x27;</span> 的受支持 source 版本 <span class="string">&#x27;RELEASE_6&#x27;</span> 低于 -source <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">注: =======================&gt;</span><br><span class="line">注: =======================&gt;</span><br></pre></td></tr></table></figure><blockquote><p>问题：注解处理器为什么会执行多次？</p></blockquote><p><img src="/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/java%E7%BC%96%E8%AF%91.png" alt="java编译"></p><p>因为java编译过程：词法分析、语法分析、填充符号表、注解处理器处理注解、语义分析、解语法糖、生成字节码。</p><p>注解处理器可以增删改抽象语法树的任意元素。执行到注解处理器，都会重新执行 语法分析、填充符号表 步，直到注解处理器不再对语法树进行修改为止，第一次的循环过程都称为一次Roud。</p><p>process第一个参数set集合是要处理的注解集合，如果这个集合为null了，就不需要处理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!annotations.isEmpty())&#123;</span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="apt-核心原理"><strong>APT 核心原理</strong></span></h5><ol><li><strong>编译时触发：</strong>  当 Java 编译器（javac）开始工作时，APT 自动启动。</li><li><strong>扫描注解：</strong>  遍历所有源码和 Class 文件，找到被目标注解标记的元素（如字段、方法）。</li><li><strong>生成代码：</strong>  根据注解信息，用 JavaPoet 等工具生成新的 Java 文件。</li><li><strong>多轮处理：</strong>  生成的代码可能包含新注解，APT 会多次循环处理，直到无新代码生成。</li></ol><h5><span id="apt-的优缺点"><strong>APT 的优缺点</strong></span></h5><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>编译时处理</strong>，不拖慢运行速度</td><td>学习成本高，需要理解注解处理器API</td></tr><tr><td><strong>减少手写重复代码</strong>（如 findViewById）</td><td>生成的代码调试困难</td></tr><tr><td><strong>代码更干净</strong>，维护方便</td><td>配置稍繁琐（注册处理器）</td></tr></tbody></table><h5><span id="apt-应用场景"><strong>APT 应用场景</strong></span></h5><ol><li><strong>View 绑定：</strong>  如 ButterKnife，自动生成 findViewById 代码。</li><li><strong>依赖注入：</strong>  如 Dagger2，生成依赖注入逻辑。</li><li><strong>路由框架：</strong>  如 ARouter，生成 Activity 路由表。</li><li><strong>序列化/反序列化：</strong>  如 Gson TypeAdapter 自动生成。</li></ol><h5><span id="apt-工作流程图"><strong>APT 工作流程图</strong></span></h5><p>写注解 → 编译 → APT 扫描 → 生成代码 → 二次编译 → 最终 APK  </p><h4><span id="class"><strong>CLASS</strong></span></h4><p>定义为 <code>CLASS</code> 的注解，会保留在class文件中，但是会被虚拟机忽略(即无法在运行期反射获取注解)。此时完全符合此种注解的应用场景为字节码操作。如：AspectJ、热修复Roubust中应用此场景。<br>所谓字节码操作即为，直接修改字节码Class文件以达到修改代码执行逻辑的目的。在程序中有多处需要进行是否<br>登录的判断。</p><p>如果我们使用普通的编程方式，需要在代码中进行 <code>if-else</code> 的判断，也许存在十个判断点，则需要在每个判断点加<br>入此项判断。此时，我们可以借助AOP(面向切面)编程思想，将程序中所有功能点划分为： 需要登录 与 无需登录<br>两种类型，即两个切面。对于切面的区分即可采用注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java源码</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Login &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Login</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jumpA</span><span class="params">()</span></span>&#123;</span><br><span class="line">startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>,AActivity.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jumpB</span><span class="params">()</span></span>&#123;</span><br><span class="line">startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>,BActivity.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上诉代码中， <code>jumpA</code> 方法需要具备登录身份。而 <code>Login</code> 注解的定义被设置为 <code>CLASS</code> 。因此我们能够在该类所编译的字节码中获得到方法注解 <code>Login</code> 。在操作字节码时，就能够根据方法是否具备该注解来修改class中该方法的<br>内容加入 <code>if-else</code> 的代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class字节码</span></span><br><span class="line"><span class="meta">@Login</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jumpA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isLogin) &#123;</span><br><span class="line">        <span class="keyword">this</span>.startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, LoginActivity.class));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, AActivity.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jumpB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>,BActivity.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解能够设置类型元素(参数)，结合参数能实现更为丰富的场景，如：运行期权限判定等</p><h4><span id="runtime"><strong>RUNTIME</strong></span></h4><p>注解保留至运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h2&gt;&lt;p&gt;Java 注解（Annotation）又称 Java 标注，是 JDK1.5 引入的一种注释机制。 注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。&lt;/p&gt;
&lt;p&gt;注解一般是配合反射来一起用的，所以我们把这两个合在一起来分析。&lt;/p&gt;
&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E&quot;&gt;&lt;strong&gt;注解声明&lt;/strong&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3&quot;&gt;&lt;strong&gt;声明一个注解&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%83%E6%B3%A8%E8%A7%A3&quot;&gt;&lt;strong&gt;元注解&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B%E5%85%83%E7%B4%A0&quot;&gt;&lt;strong&gt;注解类型元素&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF&quot;&gt;&lt;strong&gt;注解应用场景&lt;/strong&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#source&quot;&gt;&lt;strong&gt;SOURCE&lt;/strong&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ide%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5&quot;&gt;&lt;strong&gt;IDE语法检查&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#apt%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8&quot;&gt;&lt;strong&gt;APT注解处理器&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0&quot;&gt;&lt;strong&gt;注解处理器的实现&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#apt-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86&quot;&gt;&lt;strong&gt;APT 核心原理&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#apt-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9&quot;&gt;&lt;strong&gt;APT 的优缺点&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#apt-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF&quot;&gt;&lt;strong&gt;APT 应用场景&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#apt-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE&quot;&gt;&lt;strong&gt;APT 工作流程图&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#class&quot;&gt;&lt;strong&gt;CLASS&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#runtime&quot;&gt;&lt;strong&gt;RUNTIME&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;</summary>
    
    
    
    <category term="Java基础与进阶" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="反射" scheme="http://example.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
    <category term="动态代理" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>注解与反射（下）</title>
    <link href="http://example.com/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%B8%8B/"/>
    <id>http://example.com/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%B8%8B/</id>
    <published>2025-05-15T08:51:54.000Z</published>
    <updated>2025-05-19T07:49:34.697Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="反射">反射</span></h2><p><strong>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。</strong>反射被视为动态语言的关键。</p><!-- toc --><ul><li><a href="#class"><strong>Class</strong></a></li><li><a href="#%E8%8E%B7%E5%BE%97-class-%E5%AF%B9%E8%B1%A1"><strong>获得 Class 对象</strong></a></li><li><a href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><strong>判断是否为某个类的实例</strong></a></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><strong>创建实例</strong></a></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E4%BF%A1%E6%81%AF"><strong>获取构造器信息</strong></a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF"><strong>获取类的成员变量（字段）信息</strong></a></li><li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><strong>获取类的调用方法</strong></a></li><li><a href="#%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><strong>利用反射创建数组</strong></a></li><li><a href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%9C%9F%E5%AE%9E%E7%B1%BB%E5%9E%8B"><strong>反射获取泛型真实类型</strong></a></li><li><a href="#%E5%8F%8D%E5%B0%84%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9final%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><strong>反射是否可以修改final类型变量</strong></a></li><li><a href="#%E5%8F%8D%E5%B0%84%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2"><strong>反射为什么慢</strong></a></li><li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><strong>动态代理</strong></a></li></ul><!-- tocstop --><a id="more"></a><p>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的，并且能够获得此类的引用。于是我们直接<br>对这个类进行实例化，之后使用这个类对象进行操作。<br>反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。这时候，我们<br>使用 JDK 提供的反射 API 进行反射调用。</p><p><strong>Java反射机制主要提供了以下功能：</strong></p><ul><li>在运行时构造任意一个类的对象</li><li>在运行时获取或者修改任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法（属性）</li></ul><h3><span id="class"><strong>Class</strong></span></h3><p>反射始于Class，<strong>Class是一个类，封装了当前对象所对应的类的信息。</strong>一个类中有属性，方法，构造器等，比如说有一个Person类，一个Order类，一个Book类，这些都是不同的类，现在需要一个类，用来描述类，这就是<br>Class，它应该有类名，属性，方法，构造器等。Class是用来描述类的类。</p><p>Class类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等。对于每<br>个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 对象只<br>能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个Class实例。</p><p>对象Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="获得-class-对象"><strong>获得 Class 对象</strong></span></h3><p>获取Class对象的三种方式</p><ol><li>通过类名获取 <code>类名.class</code></li><li>通过对象获取 <code>对象名.getClass()</code></li><li>通过全类名获取 <code>Class.forName(全类名)</code> <code>classLoader.loadClass(全类名)</code></li></ol><ul><li>使用 Class 类的  <code>forName</code> 静态方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line"></span><br><span class="line">例:</span><br><span class="line">Class&lt;?&gt; person = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line"><span class="comment">//这方法必需要有空的构造方法才行，不然报 NoSuchMethodException: Person.&lt;init&gt;()</span></span><br><span class="line">Person o = (Person) person.newInstance();</span><br></pre></td></tr></table></figure><ul><li>直接获取某一个对象的 class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure><ul><li>调用某个对象的  getClass() 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure><h3><span id="判断是否为某个类的实例"><strong>判断是否为某个类的实例</strong></span></h3><p>一般地，我们用  <code>instanceof</code> 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的<br><code>isInstance()</code> 方法来判断是否为某个类的实例，它是一个 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">Class&lt;?&gt; person = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">Object o = person.newInstance();</span><br><span class="line">System.out.println(person.isInstance(o));</span><br></pre></td></tr></table></figure><p>判断是否为某个类的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAssignableFrom</span><span class="params">(Class&lt;?&gt; cls)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">例：</span></span><br><span class="line"><span class="function">Class&lt;?&gt; person </span>= Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">System.out.println(person.isAssignableFrom(Person.class)); <span class="comment">//当前类型，父类也会报错Object</span></span><br></pre></td></tr></table></figure><h3><span id="创建实例"><strong>创建实例</strong></span></h3><p>通过反射来生成对象主要有两种方式。</p><ul><li><p>使用Class对象的newInstance()方法来创建Class对象对应类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance(); <span class="comment">//只能是空构造函数的</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这<br>种方法可以用指定的构造器构造类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Person所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; person = Person.class;</span><br><span class="line"><span class="comment">//无参数的构造器</span></span><br><span class="line">Constructor&lt;?&gt; constructor = person.getConstructor();</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Person person1 = (Person) constructor.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参数的构造器</span></span><br><span class="line">Constructor&lt;?&gt; constructor2 = person.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">//传参 必需传入对应的参数</span></span><br><span class="line">Person person2 = (Person) constructor2.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">12</span>); </span><br></pre></td></tr></table></figure></li></ul><h3><span id="获取构造器信息"><strong>获取构造器信息</strong></span></h3><p>得到构造器的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Constructor <span class="title">getConstructor</span><span class="params">(Class[] params)</span> -- 获得使用特殊的参数类型的<span class="keyword">public</span>构造函数<span class="params">(包括父类）</span></span></span><br><span class="line"><span class="function"><span class="params">Constructor[] getConstructors()</span> -- 获得类的所有公共构造函数</span></span><br><span class="line"><span class="function">Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class[] params)</span> -- 获得使用特定参数类型的构造函数<span class="params">(包括私有)</span></span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span> -- 获得类的所有构造函数<span class="params">(与接入级别无关)</span></span></span><br></pre></td></tr></table></figure><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的<br>一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br></pre></td></tr></table></figure><h3><span id="获取类的成员变量字段信息"><strong>获取类的成员变量（字段）信息</strong></span></h3><p>获得字段信息的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> -- 获得命名的公共字段</span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span> -- 获得类的所有公共字段</span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> -- 获得类声明的命名的字段</span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span> -- 获得类声明的所有字段</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">例：</span></span><br><span class="line"><span class="function">Person p</span>=<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">12</span>);</span><br><span class="line">Class&lt;?&gt; person = Person.class;</span><br><span class="line">Field field=person.getDeclaredField(<span class="string">&quot;name&quot;</span>);  <span class="comment">//获取指定字段</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);  <span class="comment">//不管是读值还是写值。私有字段都 必须先调用setAccessible(true)方法。</span></span><br><span class="line">Object o = field.get(p); <span class="comment">//获取指定字段的值（张三）</span></span><br><span class="line">System.out.println(o);</span><br><span class="line">field.set(p,<span class="string">&quot;李四&quot;</span>); <span class="comment">//设置指定字段的值</span></span><br><span class="line">System.out.println(p.getName());</span><br></pre></td></tr></table></figure><h3><span id="获取类的调用方法"><strong>获取类的调用方法</strong></span></h3><p>获得方法信息的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特定的参数类型，获得命名的公共方法</span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> -- 获得类的所有公共方法</span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特写的参数类型，获得类声明的命名的方法</span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> -- 获得类声明的所有方法</span></span><br></pre></td></tr></table></figure><p>当我们从类中获取了一个方法后，我们就可以用  invoke() 方法来调用这个方法。 invoke 方法的原型为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">例：</span></span><br><span class="line"><span class="function">Person p</span>=<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">12</span>);</span><br><span class="line">Class&lt;?&gt; person = Person.class;</span><br><span class="line">Method method=person.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>,String.class); <span class="comment">//获取指定方法</span></span><br><span class="line">method.setAccessible(<span class="keyword">true</span>);   <span class="comment">//访问私有域时，也需要设置</span></span><br><span class="line">method.invoke(p,<span class="string">&quot;李四&quot;</span>); <span class="comment">//调用方法（一是对象实例，2是参数</span></span><br><span class="line">System.out.println(p.getName());</span><br></pre></td></tr></table></figure><h3><span id="利用反射创建数组"><strong>利用反射创建数组</strong></span></h3><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference 其中的Array类为<br>java.lang.reflect.Array类。我们通过<code>Array.newInstance()</code>创建数组对象，它的原型是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">Class&lt;?&gt; person = Person.class;</span><br><span class="line">Person p=<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">12</span>);</span><br><span class="line">Person[] o = (Person[]) Array.newInstance(person, <span class="number">3</span>);</span><br><span class="line">Array.set(o,<span class="number">0</span>,p);</span><br></pre></td></tr></table></figure><h3><span id="反射获取泛型真实类型"><strong>反射获取泛型真实类型</strong></span></h3><p>参考<a href="/2021/11/28/%E6%B3%9B%E5%9E%8B/" title="[泛型] [8、反射获取泛型的真实类型]">[泛型] [8、反射获取泛型的真实类型]</a></p><h3><span id="反射是否可以修改final类型变量"><strong>反射是否可以修改final类型变量</strong></span></h3><p>反射是可以修改final变量的，但是如果是基本数据类型或者String类型的时候，无法通过对象获取修改后的值，因为JVM对其进行了内联优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        ReflectTest t = <span class="keyword">new</span> ReflectTest();</span><br><span class="line">        Field field = ReflectTest.class.getDeclaredField(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(t,<span class="number">2</span>);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只能使用反射获取修改后的值</span></span><br><span class="line">        System.out.println(field.get(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="反射为什么慢"><strong>反射为什么慢</strong></span></h3><ol><li><p><strong>Method#invoke 需要进行自动拆装箱</strong></p><p>invoke方法的参数是Object[]类型，如果基本数据int类型会转为Integer装箱，同时再包装成Object数组。在执行时候又会把数组拆解开来，并拆箱为基本数据类型。</p></li><li><p><strong>反射需要按名检索类和方法</strong></p><p>遍历整个类中的所有方法</p></li><li><p><strong>需要检查方法</strong></p><p>反射时需要检查方法可见性以及每个实际参数与形式参数的类型匹配性</p></li><li><p><strong>编译器无法对动态调用的代码做优化，比如内联</strong></p><p>反射涉及到动态解析的类型，影响内联判断并且无法进行JIT</p></li></ol><blockquote><p>反射带来的影响现在已经微乎其微，真正影响程序性能的是编码质量。</p></blockquote><h3><span id="动态代理"><strong>动态代理</strong></span></h3><p>动态代理也是使用了反射来创建代理对象，调用对象方法来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(Integer code)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个接口实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现动态代理的调用</span></span><br><span class="line">Service re = <span class="keyword">new</span> ReflectTest();</span><br><span class="line">Service o = (Service) Proxy.newProxyInstance(ReflectTest.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Service.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(re,args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(o.getData(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//结果输出 返回值</span></span><br></pre></td></tr></table></figure><p><code>Proxy.newProxyInstance</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">    <span class="comment">//关键代码</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs </span>= interfaces.clone();</span><br><span class="line"><span class="comment">//在内存中生成一个代理类</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"><span class="comment">//通过构造函数创建代理类的实例</span></span><br><span class="line"><span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line"><span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line"><span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过调用java的实现方法将代理类给输出出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clzss=Service.class;</span><br><span class="line"><span class="comment">//将动态代理类写成文件</span></span><br><span class="line">String name = clzss.getName() + <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = ProxyGenerator.generateProxyClass(name, <span class="keyword">new</span> Class[]&#123;clzss&#125;);</span><br><span class="line"><span class="keyword">try</span> (FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./&quot;</span> + name + <span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">    fos.write(bytes);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到一个Service$Proxy.class文件，在idea中查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span>$<span class="title">Proxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Service$Proxy(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getData</span><span class="params">(Integer var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;Service&quot;</span>).getMethod(<span class="string">&quot;getData&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Integer&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现所有的方法都是通过反射进行的回调。</p><p>调用o.getData(1)时就相当于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method m=Class.forName(<span class="string">&quot;Service&quot;</span>).getMethod(<span class="string">&quot;getData&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Integer&quot;</span>));</span><br><span class="line"><span class="number">1.</span>调用Service$Proxy对象的getData(<span class="number">1</span>)</span><br><span class="line"><span class="number">2.</span>调用InvocationHandler的invoke(Service$Proxy,m,<span class="keyword">new</span> Object[]&#123;<span class="number">1</span>&#125;)</span><br><span class="line"><span class="number">3.</span>最后调用method.invoke(re,args)，即 m.invoke(Service的实现re,参数<span class="number">1</span>)</span><br><span class="line"><span class="number">4.</span>返回即为 <span class="string">&quot;返回值&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。&lt;/strong&gt;反射被视为动态语言的关键。&lt;/p&gt;
&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#class&quot;&gt;&lt;strong&gt;Class&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%8E%B7%E5%BE%97-class-%E5%AF%B9%E8%B1%A1&quot;&gt;&lt;strong&gt;获得 Class 对象&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B&quot;&gt;&lt;strong&gt;判断是否为某个类的实例&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B&quot;&gt;&lt;strong&gt;创建实例&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E4%BF%A1%E6%81%AF&quot;&gt;&lt;strong&gt;获取构造器信息&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF&quot;&gt;&lt;strong&gt;获取类的成员变量（字段）信息&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95&quot;&gt;&lt;strong&gt;获取类的调用方法&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84&quot;&gt;&lt;strong&gt;利用反射创建数组&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%9C%9F%E5%AE%9E%E7%B1%BB%E5%9E%8B&quot;&gt;&lt;strong&gt;反射获取泛型真实类型&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%8D%E5%B0%84%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9final%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F&quot;&gt;&lt;strong&gt;反射是否可以修改final类型变量&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%8D%E5%B0%84%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2&quot;&gt;&lt;strong&gt;反射为什么慢&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86&quot;&gt;&lt;strong&gt;动态代理&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;</summary>
    
    
    
    <category term="Java基础与进阶" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="反射" scheme="http://example.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
    <category term="动态代理" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第七章 类加载和函数调用</title>
    <link href="http://example.com/2025/04/07/chapter-07/"/>
    <id>http://example.com/2025/04/07/chapter-07/</id>
    <published>2025-04-07T03:45:54.000Z</published>
    <updated>2025-04-07T03:46:33.447Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[转]安卓系统定制：从入门到实践</strong></p><!-- toc --><ul><li><a href="#71-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">7.1 双亲委派机制</a></li><li><a href="#72-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B">7.2 类的加载流程</a></li><li><a href="#73-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B">7.3 函数调用流程</a></li><li><a href="#74-executemterpimpl">7.4 ExecuteMterpImpl</a></li><li><a href="#75-executeswitch">7.5 ExecuteSwitch</a></li><li><a href="#76-%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93">7.6 本章小结</a></li></ul><!-- tocstop --><p>在上一章中，我们学习了分析Android运行的执行流程，并找到合适的时机来插入业务逻辑代码，以实现特定功能。例如，在应用启动流程中，我们可以通过注入DEX文件或动态库文件来实现某些功能。通过native函数的注册流程，我们可以对静态注册和动态注册信息进行打桩输出。而通过解析AndroidManifest.xml文件的过程，则可以额外添加默认权限。</p><p>在本章中，将详细介绍Android源码中加载类的执行流程。了解Android中类加载机制以及函数调用流程是非常重要的基础知识。通过学习这些执行流程原理，在定制功能时能为我们提供更多方向和思路。</p><a id="more"></a><h2><span id="71-双亲委派机制">7.1 双亲委派机制</span></h2><p>在Android系统中，应用程序运行在Dalvik或ART虚拟机上。当应用启动时，Android系统会根据应用程序包中的AndroidManifest.xml文件确定需要启动哪些组件，并在启动过程中加载所需的类。</p><p>Android中的类加载器遵循双亲委派模型。即每个类加载器在尝试加载一个类之前，都会先委托其父类加载器去加载该类。只有当父类加载器无法完成任务时，子类加载器才会尝试自己来进行加载。这个模型保证了不同的类只会被加载一次，并且保护了核心Java API不被恶意代码篡改。</p><p>在Android应用程序中，每个类都分配到一个特定的DEX文件（即Dalvik Executable）中。DEX文件包含该类所有方法和属性的字节码。当应用程序启动时，它的DEX文件将被加载到内存并由虚拟机执行其中的代码。</p><p>在函数调用流程中，当一个函数被调用时，虚拟机会保存当前线程状态，并跳转到被调函数入口地址开始执行该函数。虚拟机对函数指令进行执行，并维护执行过程所需数据结构（如栈帧）。当函数执行完毕后，虚拟机将结果返回给调用方并恢复之前保存的线程状态。</p><p>深入学习Android的类加载机制和函数执行调用流程可以更好地理解应用程序的运行机制。</p><p>在Android中，类通常保存在DEX文件中，而ClassLoader则负责加载DEX文件。每个应用程序包（APK）都包含一个或多个DEX文件，这些DEX文件包含应用程序的所有类信息。当需要使用某个类时，ClassLoader会从相应的DEX文件中加载该类，并将其转换为可执行的Java类。因此，ClassLoader和DEX密切相关，ClassLoader是DEX文件的载体和管理者。</p><p>Android 中的 ClassLoader 类型分为两种：</p><ol><li><p>系统类加载器。系统类加载器主要包括BootClassLoader、PathClassLoader和DexClassLoader。</p></li><li><p>自定义加载器。</p></li></ol><p>一些常见的加载器的用途如下：</p><ol><li><p><code>BootClassLoader</code>：位于 <code>ClassLoader </code>层次结构中的最顶层。负责加载系统级别的类，如<code> Java</code> 核心库和一些基础库。</p></li><li><p><code>PathClassLoader</code>：从应用程序的<code> APK</code> 文件中加载类和资源。继承自<code>BaseDexClassLoader</code>类，它能够加载已经被优化的 <code>Dex</code> 文件和未经过优化的 <code>Dex</code> 文件。<code>PathClassLoader</code> 主要用于加载已经打包在 <code>APK </code>文件中的代码和资源。</p></li><li><p><code>DexClassLoader</code>：从<code> .dex</code> 或<code> .odex</code> 文件中加载类。继承自<code>BaseDexClassLoader</code>类，它支持动态加载 <code>Dex </code>文件，并且可以在运行时进行优化操作。<code>DexClassLoader </code>主要用于加载未安装的 <code>APK</code> 文件中的代码。</p></li><li><p><code>InMemoryDexClassLoader</code>：用于从内存中加载已经存在于内存中的<code>dex</code>文件。继承自 <code>BaseDexClassLoader</code>，并且可以处理多个<code>dex</code>文件。<code>InMemoryDexClassLoader </code>可以在运行时动态加载 <code>dex</code> 文件，并且不需要将文件保存到磁盘上，从而提高应用程序的性能。</p></li><li><p><code>BaseDexClassLoader</code>：<code>DexClassLoader</code>、<code>InMemoryDexClassLoader</code> 和 <code>PathClassLoader</code> 的基类，封装了加载 <code>dex</code> 文件的基本逻辑，包括创建<code> DexPathList</code> 对象、打开 <code>dex </code>文件、查找类等操作。<code>BaseDexClassLoader </code>实现了双亲委派模型，即在自身无法加载类时，会委派给父类加载器进行查找。<code>BaseDexClassLoader</code> 还支持多个 <code>dex </code>文件的加载，并且可以在运行时进行优化操作。</p></li><li><p>SecureClassLoader：继承自ClassLoader抽象类，该类主要实现了一些权限相关的功能。</p></li><li><p>URLClassLoader：SecureClassLoader的子类，其可以使用url路径加载JAR文件中的类。</p></li></ol><p>整个类加载器的继承结构如下图所示：</p><p><img src="/2025/04/07/chapter-07/classloader.png" alt="ClassLoader 继承结构"></p><p>类加载器采用了双亲委派机制（Parent Delegation Model），这是一种经典的Java类加载机制。</p><p>双亲委派机制是指当一个类加载器收到请求去加载一个类时，它并不会自己去加载，而是把这个任务委托给父类加载器去完成。如果父类加载器还存在父类加载器，这个请求就会向上递归，直到达到最顶层的BootClassLoader为止。也就是说，最先调用加载的ClassLoader是最顶层的，最后尝试加载的是当前的ClassLoader。</p><p>采用双亲委派机制可以有效地避免类的重复加载，并保证核心API的安全性。具体表现为：</p><ul><li>在类加载时，首先从当前加载器的缓存中查找是否已经加在了该类，如果已经加在，则直接返回；</li><li>如果没有在缓存中找到该累，则将加在任务委派给父累加，在者完成；</li><li>父累加如果也没有找道该累，则将会递归向上委派, 直道BootClassLoader;</li><li>BootCLassLoader无法代理添加和发生错误之前所做过得努力, 则会让子类加载器自行加载。</li></ul><h2><span id="72-类的加载流程">7.2 类的加载流程</span></h2><p>在<code>Android</code>中，<code>ClassLoader</code>类是双亲委派机制的主要实现者。该类提供了<code>findClass</code>和<code>loadClass</code>方法，其中<code>findClass</code>是<code>ClassLoader</code>的抽象方法，需要由子类实现。接下来将跟踪源码实现，详细了解<code>ClassLoader</code>是如何进行类加载流程的。</p><p>在前文中曾经介绍过如何使用<code>DexClassLoader</code>加载一个类，并调用其中的函数，下面是当时的加载样例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        String dexPath = <span class="string">&quot;/system/framework/kjar.jar&quot;</span>;</span><br><span class="line">        String dexOutputDir = getApplicationInfo().dataDir;</span><br><span class="line">        ClassLoader classLoader = <span class="keyword">new</span> DexClassLoader(dexPath, dexOutputDir, <span class="keyword">null</span>,</span><br><span class="line">                getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz2 = classLoader.loadClass(<span class="string">&quot;cn.rom.myjar.MyCommon&quot;</span>);</span><br><span class="line">            Method addMethod = clazz2.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, <span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</span><br><span class="line">            Object result = addMethod.invoke(<span class="keyword">null</span>, <span class="number">12</span>,<span class="number">25</span>);</span><br><span class="line">            Log.i(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;getMyJarVer:&quot;</span>+result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>ClassLoader </code>加载类时，<code>loadClass</code> 和<code> findClass</code>都可以完成对类的加载工作，它们在加载类时有着不同的作用和执行流程。</p><p>​    首先看看<code>loadClass</code>的特征，它的方法签名如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass( <span class="keyword">final</span> String class_name, <span class="keyword">final</span> <span class="keyword">boolean</span> resolve ) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure><p>​    其中<code>name</code> 参数表示要加载的类的全名；<code>resolve</code> 参数表示是否需要在加载完成后进行链接操作。如果 <code>resolve</code> 参数为<code> true</code>，则会尝试在加载完成后对该类进行链接操作，包括验证、准备和解析等步骤。如果 <code>resolve</code> 参数为<code> false</code>，则不会进行链接操作。</p><p>​    在执行<code>loadClass</code>方法时，<code>ClassLoader </code>会先检查自身是否已经加载过该类，如果已经加载过，则直接返回该类的<code> Class</code> 对象。如果没有加载过，则将任务委托给父类加载器进行处理，如果父类加载器无法加载该类，则再次调用自身的<code> findClass</code> 方法进行加载。如果<code> findClass</code> 方法仍然无法找到该类，则抛出 <code>ClassNotFoundException</code> 异常。</p><p>​    接下来再了解下<code>findClass</code> 方法，它 是 <code>BaseClassLoader </code>类中定义的一个抽象方法，用于在特定的数据源（如文件、内存等）中查找指定名称的类，并返回对应的<code> Class</code> 对象。下面是方法签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure><p>​    与<code> loadClass</code> 不同，<code>findClass</code> 方法并不会先委派给父类加载器进行处理，而是直接在当前 <code>ClassLoader </code>中进行查找。如果能够找到指定的类，则通过 <code>defineClass </code>方法将其转换成<code>Class</code>对象，并返回该对象；否则，抛出 <code>ClassNotFoundException </code>异常。</p><p>​    明白了两者的区别后，接下来开始跟踪源码，了解在<code>AOSP</code>具体是如何加载类的。首先找到<code>DexClassLoader</code>中<code>loadClass</code>的实现代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    发现内部并没有任何代码，说明该实现来自于父类中，接着来查看父类<code>BaseDexClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Package <span class="title">getPackage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    同样没有找到<code>loadClass</code>的实现，继续看它的父类<code>ClassLoader</code>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用了另外一个重载，resolve参数不传的情况默认为false</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// 尝试在已经加载过的里面查找</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有父类的情况，就让父类来加载</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 到达父类顶端后，则使用这个函数查找，通常来查找引导类和扩展类</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 父类没有找到的情况，再通过findClass查找</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    通过这里的代码，能够很清晰的看到前文中<code>ClassLoader</code>的双亲委派机制，接着继续跟踪<code>findClass</code>分析当前<code>ClassLoader</code>是如何加载类的，由于<code>ClassLoader</code>是一个抽象类，而<code>findClass</code>在该类中并未实现具体代码，所以该方法是在子类中实现，上面在<code>BaseDexClassLoader</code>的类中，就已经看到的<code>findClass</code>的函数，下面是具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 首先检查当前ClassLoader是否有共享库，如果有则遍历每个共享库的ClassLoader去尝试加载该类</span></span><br><span class="line">        <span class="keyword">if</span> (sharedLibraryLoaders != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ClassLoader loader : sharedLibraryLoaders) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> loader.loadClass(name);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">        <span class="comment">// 当前ClassLoader操作的dex文件中查找该类</span></span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(</span><br><span class="line">                    <span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    <code>pathList</code>是一个<code>DexPathList</code>对象，表示当前<code>ClassLoader</code>所管理的一组<code>dex</code>文件的路径列表。<code>findClass()</code>方法通过调用<code>DexPathList.findClass()</code>方法来查找指定名称的类。继续跟进查看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> Element[] dexElements;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>dexElements</code>的数组存放着所有已经加载的<code>dex</code>文件中的类信息。具体来说，每个<code>dex</code>文件都被解析为一个<code>DexFile</code>对象，而<code>dexElements</code>数组中的每个元素实际上就是一个<code>Element</code>对象，代表了一个<code>dex</code>文件和其中包含的类信息。这些<code>Element</code>对象按照优先级顺序排列，以便<code>ClassLoader</code>可以根据它们的顺序来查找类定义。继续查看<code>Element</code>的<code>findClass</code>方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// 管理着一个dex文件</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">getDexPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> path.isDirectory() ? <span class="keyword">null</span> : path.getAbsolutePath();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dexFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// DexFile.getName() returns the path of the dex file.</span></span><br><span class="line">                <span class="keyword">return</span> dexFile.getName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (dexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> (pathIsDirectory ? <span class="string">&quot;directory \&quot;&quot;</span> : <span class="string">&quot;zip file \&quot;&quot;</span>) + path + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;dex file \&quot;&quot;</span> + dexFile + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;zip file \&quot;&quot;</span> + path + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; findClass(String name, ClassLoader definingContext,</span><br><span class="line">                List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">            <span class="keyword">return</span> dexFile != <span class="keyword">null</span> ? dexFile.loadClassBinaryName(name, definingContext, suppressed)</span><br><span class="line">                    : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    可以看到这里实际就是管理一个对应的<code>DexFile</code>对象，该对象关联着一个对应的<code>dex</code>文件，这里通过调用<code>DexFile</code>对象的<code>loadClassBinaryName</code>去加载这个类，继续跟踪它的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loader, mCookie, <span class="keyword">this</span>, suppressed);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, Object cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     DexFile dexFile, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        Class result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = defineClassNative(name, loader, cookie, dexFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title">defineClassNative</span><span class="params">(String name, ClassLoader loader, Object cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  DexFile dexFile)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ClassNotFoundException, NoClassDefFoundError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里看到经过几层调用后，进入了<code>native</code>实现了，根据<code>AOSP</code>中<code>native</code>注册的命名规则，直接搜索<code>DexFile_defineClassNative</code>找到对应的实现代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jclass <span class="title">DexFile_defineClassNative</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jstring javaName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject dexFile)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">const</span> DexFile*&gt; dex_files;</span><br><span class="line">  <span class="keyword">const</span> OatFile* oat_file;</span><br><span class="line">  <span class="comment">// cookie转换成一组c++中的DexFile对象以及OatFile</span></span><br><span class="line">  <span class="keyword">if</span> (!ConvertJavaArrayToDexFiles(env, cookie, <span class="comment">/*out*/</span> dex_files, <span class="comment">/*out*/</span> oat_file)) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_file&quot;</span>;</span><br><span class="line">    DCHECK(env-&gt;ExceptionCheck());</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 将类名转换为c++的string存放在了descriptor中</span></span><br><span class="line">  <span class="comment">// 这里会将java中的类描述符转换为c++使用的类描述符，例如类中的.转换为\</span></span><br><span class="line">  <span class="keyword">const</span> std::<span class="function">string <span class="title">descriptor</span><span class="params">(DotToDescriptor(class_name.c_str()</span>))</span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> size_t <span class="title">hash</span><span class="params">(ComputeModifiedUtf8Hash(descriptor.c_str()</span>))</span>;</span><br><span class="line">  <span class="keyword">for</span> (auto&amp; dex_file : dex_files) &#123;</span><br><span class="line">    <span class="comment">// 根据类描述符找到对应的类</span></span><br><span class="line">    <span class="keyword">const</span> dex::ClassDef* dex_class_def =</span><br><span class="line">        OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash);</span><br><span class="line">    <span class="keyword">if</span> (dex_class_def != nullptr) &#123;</span><br><span class="line">      <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">      ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 使用类加载器和 DEX 文件定义一个新的 Java 类，并返回一个描述该类的 Class 对象指针</span></span><br><span class="line">      ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(),</span><br><span class="line">                                                               descriptor.c_str(),</span><br><span class="line">                                                               hash,</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               *dex_file,</span><br><span class="line">                                                               *dex_class_def);</span><br><span class="line">      <span class="comment">// 将DexFile插入到ClassLoader中。</span></span><br><span class="line">      class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile),</span><br><span class="line">                                                 class_loader.Get());</span><br><span class="line">      <span class="keyword">if</span> (result != nullptr) &#123;</span><br><span class="line">        VLOG(class_linker) &lt;&lt; <span class="string">&quot;DexFile_defineClassNative returning &quot;</span> &lt;&lt; result</span><br><span class="line">                           &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; class_name.c_str();</span><br><span class="line">        <span class="keyword">return</span> soa.AddLocalReference&lt;jclass&gt;(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_class_def &quot;</span> &lt;&lt; class_name.c_str();</span><br><span class="line">  <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    代码中看到<code>cookie</code>中能拿到所有<code>DexFile</code>，最终的<code>Class</code>对象是由<code>DefineClass</code>方法定义后返回的。继续看其实现过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjPtr&lt;mirror::Class&gt; ClassLinker::DefineClass(Thread* self,</span><br><span class="line">                                               <span class="keyword">const</span> <span class="keyword">char</span>* descriptor,</span><br><span class="line">                                               size_t hash,</span><br><span class="line">                                               Handle&lt;mirror::ClassLoader&gt; class_loader,</span><br><span class="line">                                               <span class="keyword">const</span> DexFile&amp; dex_file,</span><br><span class="line">                                               <span class="keyword">const</span> dex::ClassDef&amp; dex_class_def) &#123;</span><br><span class="line">  ...</span><br><span class="line">  DexFile <span class="keyword">const</span>* new_dex_file = nullptr;</span><br><span class="line">  dex::ClassDef <span class="keyword">const</span>* new_class_def = nullptr;</span><br><span class="line">  <span class="comment">// 类被加载前的预处理</span></span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassPreDefine(descriptor,</span><br><span class="line">                                                            klass,</span><br><span class="line">                                                            class_loader,</span><br><span class="line">                                                            dex_file,</span><br><span class="line">                                                            dex_class_def,</span><br><span class="line">                                                            &amp;new_dex_file,</span><br><span class="line">                                                            &amp;new_class_def);</span><br><span class="line">  <span class="comment">// 将dex文件加载到内存中</span></span><br><span class="line">  ObjPtr&lt;mirror::DexCache&gt; dex_cache = RegisterDexFile(*new_dex_file, class_loader.Get());</span><br><span class="line">  <span class="keyword">if</span> (dex_cache == nullptr) &#123;</span><br><span class="line">    self-&gt;AssertPendingException();</span><br><span class="line">    <span class="keyword">return</span> sdc.Finish(nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">  klass-&gt;SetDexCache(dex_cache);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化类</span></span><br><span class="line">  SetupClass(*new_dex_file, *new_class_def, klass, class_loader.Get());</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向类表中插入类对象</span></span><br><span class="line">  ObjPtr&lt;mirror::Class&gt; existing = InsertClass(descriptor, klass.Get(), hash);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载并初始化类，在必要时创建新的类对象</span></span><br><span class="line">  LoadClass(self, *new_dex_file, *new_class_def, klass);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  MutableHandle&lt;mirror::Class&gt; h_new_class = hs.NewHandle&lt;mirror::Class&gt;(nullptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链接类及其相关信息</span></span><br><span class="line">  <span class="keyword">if</span> (!LinkClass(self, descriptor, klass, interfaces, &amp;h_new_class)) &#123;</span><br><span class="line">    <span class="comment">// Linking failed.</span></span><br><span class="line">    <span class="keyword">if</span> (!klass-&gt;IsErroneous()) &#123;</span><br><span class="line">      mirror::Class::SetStatus(klass, ClassStatus::kErrorUnresolved, self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sdc.Finish(nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sdc.Finish(h_new_class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>ClassPreDefine</code>是一个回调函数，它在类被加载之前被调用，用于进行一些预处理工作。具体来说，<code>ClassPreDefin</code>会被调用以执行以下任务：</p><ul><li><p>对新定义的类进行验证和解析，以确保类结构的正确性。</p></li><li><p>为新定义的类分配内存空间，并构造新对象的实例。</p></li><li><p>设置类的访问控制权限并更新关联的缓存信息。</p></li></ul><p>​    <code>RegisterDexFile</code>用于注册 <code>DEX</code> 文件。该函数负责将 <code>DEX </code>文件加载到内存中，并将其中包含的类和相关信息注册到运行时环境中，以供后续的程序使用。该函数的主要负责：</p><ul><li><p>将 <code>DEX </code>文件加载到内存中，并为其分配一段连续的内存空间。</p></li><li><p>在运行时环境中创建<code>mirror::DexFile</code>对象，该对象包含了<code> DEX</code>文件的元数据信息，例如文件名、<code>MD5 </code>哈希值等。</p></li><li><p>为<code>DEX</code>文件中包含的每个类创建相应的<code> mirror::Class</code> 对象，并将其添加到类表中进行管理。</p></li><li><p>为新创建的<code> mirror::Class</code> 对象设置其访问权限和其他属性，例如类标志、字段、方法等。</p></li><li><p>创建并返回一个 <code>mirror::DexCache </code>对象，该对象表示已注册的<code>DEX</code>文件的缓存信息。</p></li></ul><p>​    <code>SetupClass</code> 函数用于初始化类。该函数的主要作用：</p><ul><li><p>解析类定义，并为其分配内存空间。</p></li><li><p>为新创建的类对象设置相关信息，例如类名、超类、接口信息等。</p></li><li><p>设置类对象的访问修饰符和标志。</p></li><li><p>将类对象添加到运行时环境中进行管理。</p></li><li><p>在必要的情况下，执行与类加载生命周期有关的回调函数。</p></li></ul><p>​    <code>InsertClass</code>函数用于向类表中插入新的类对象，并确保在插入之前对其进行必要的验证和初始化工作。该函数的主要作用：</p><ul><li><p>根据类描述符和哈希值查找类表中是否已经存在相同的类对象。</p></li><li><p>如果已经存在相同的类对象，则返回其指针，否则将新的类对象插入到类表中，并返回其指针。</p></li><li><p>在插入新的类对象之前，会先进行一些验证工作，例如检查类的访问权限，以及确保类的结构和超类的继承关系正确等。</p></li><li><p>在需要时，执行与类加载生命周期有关的回调函数。</p></li></ul><p>​    <code>LoadClass</code> 函数用于加载并初始化类。并将其插入到类表中进行管理。主要作用：</p><ul><li><p>根据类描述符查找类表中是否已经存在相同的类对象，如存在则直接返回其指针。</p></li><li><p>如果类表中不存在相同的类对象，则先使用 <code>SetupClass()</code> 函数创建新的类对象，并将其插入到类表中。此处调用了 <code>InsertClass()</code> 函数。</p></li><li><p>加载并初始化类的超类及接口信息，以确保类的继承关系正确。</p></li><li><p>执行与类加载生命周期有关的回调函数。</p></li></ul><p>​    <code>    LinkClass</code> 函数是在用于链接类，该函数会返回一个新的类对象指针，以供调用者使用。主要作用：</p><ul><li><p>链接类的超类，并执行与超类有关的初始化工作。</p></li><li><p>链接类实现的接口，并执行与接口有关的初始化工作。</p></li><li><p>链接类的字段，并执行与字段有关的初始化工作。</p></li><li><p>链接类的方法，并执行与方法有关的初始化工作。</p></li><li><p>在必要时创建新的类对象，并将其返回给调用者。</p></li></ul><p>​    将加载类的过程中几个关键的步骤搞清楚后，继续深入查看<code>LoadClass</code>是如何实现的，重点关注最后一个参数<code>kclass</code>做了些什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadClass</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> dex::ClassDef&amp; dex_class_def,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Runtime* <span class="keyword">const</span> runtime = Runtime::Current();</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取类加载器的线性内存分配器</span></span><br><span class="line">    LinearAlloc* <span class="keyword">const</span> allocator = GetAllocatorForClassLoader(klass-&gt;GetClassLoader());</span><br><span class="line">    <span class="comment">// 为类中的静态字段分配内存空间</span></span><br><span class="line">    LengthPrefixedArray&lt;ArtField&gt;* sfields = AllocArtFieldArray(self,</span><br><span class="line">                                                                allocator,</span><br><span class="line">                                                                accessor.NumStaticFields());</span><br><span class="line">    <span class="comment">// 为类中的实例字段分配内存空间</span></span><br><span class="line">    LengthPrefixedArray&lt;ArtField&gt;* ifields = AllocArtFieldArray(self,</span><br><span class="line">                                                                allocator,</span><br><span class="line">                                                                accessor.NumInstanceFields());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置类的方法列表指针</span></span><br><span class="line">    klass-&gt;SetMethodsPtr(</span><br><span class="line">        AllocArtMethodArray(self, allocator, accessor.NumMethods()),</span><br><span class="line">        accessor.NumDirectMethods(),</span><br><span class="line">        accessor.NumVirtualMethods());</span><br><span class="line">    <span class="keyword">size_t</span> class_def_method_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> last_dex_method_index = dex::kDexNoIndex;</span><br><span class="line">    <span class="keyword">size_t</span> last_class_def_method_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历类的所有方法和字段</span></span><br><span class="line">    accessor.VisitFieldsAndMethods([&amp;](</span><br><span class="line">        <span class="keyword">const</span> ClassAccessor::Field&amp; field) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">// 遍历所有字段，由last_static_field_idx判断是否正在处理的是静态字段</span></span><br><span class="line">          <span class="keyword">if</span> (num_sfields == <span class="number">0</span> || LIKELY(field_idx &gt; last_static_field_idx)) &#123;</span><br><span class="line">            <span class="comment">// 加载字段信息</span></span><br><span class="line">            LoadField(field, klass, &amp;sfields-&gt;At(num_sfields));</span><br><span class="line">            ++num_sfields;</span><br><span class="line">            last_static_field_idx = field_idx;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, [&amp;](<span class="keyword">const</span> ClassAccessor::Field&amp; field) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">// 加载实例字段信息</span></span><br><span class="line">          <span class="keyword">if</span> (num_ifields == <span class="number">0</span> || LIKELY(field_idx &gt; last_instance_field_idx)) &#123;</span><br><span class="line">            LoadField(field, klass, &amp;ifields-&gt;At(num_ifields));</span><br><span class="line">            ++num_ifields;</span><br><span class="line">            last_instance_field_idx = field_idx;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, [&amp;](<span class="keyword">const</span> ClassAccessor::Method&amp; method) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">          <span class="comment">// 获取实例方法</span></span><br><span class="line">          ArtMethod* art_method = klass-&gt;GetDirectMethodUnchecked(class_def_method_index,</span><br><span class="line">              image_pointer_size_);</span><br><span class="line">          <span class="comment">// 将dex_file参数中指向Java方法字节码的指针(method)解析为机器码，并将它存储到art_method参数对应的内存区域中，完成对Java方法实现代码的加载</span></span><br><span class="line">          LoadMethod(dex_file, method, klass, art_method);</span><br><span class="line">          <span class="comment">// 将art_method参数对应的实现代码链接到oat_class_ptr参数对应的oat文件中</span></span><br><span class="line">          LinkCode(<span class="keyword">this</span>, art_method, oat_class_ptr, class_def_method_index);</span><br><span class="line">          ...</span><br><span class="line">        &#125;, [&amp;](<span class="keyword">const</span> ClassAccessor::Method&amp; method) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 和上面差不多的，不过这里处理的是虚方法</span></span><br><span class="line">          ArtMethod* art_method = klass-&gt;GetVirtualMethodUnchecked(</span><br><span class="line">              class_def_method_index - accessor.NumDirectMethods(),</span><br><span class="line">              image_pointer_size_);</span><br><span class="line">          LoadMethod(dex_file, method, klass, art_method);</span><br><span class="line">          LinkCode(<span class="keyword">this</span>, art_method, oat_class_ptr, class_def_method_index);</span><br><span class="line">          ++class_def_method_index;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将加载好的字段保存到kclass</span></span><br><span class="line">    klass-&gt;SetSFieldsPtr(sfields);</span><br><span class="line">    DCHECK_EQ(klass-&gt;NumStaticFields(), num_sfields);</span><br><span class="line">    klass-&gt;SetIFieldsPtr(ifields);</span><br><span class="line">    DCHECK_EQ(klass-&gt;NumInstanceFields(), num_ifields);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Ensure that the card is marked so that remembered sets pick up native roots.</span></span><br><span class="line">  WriteBarrier::ForEveryFieldWrite(klass.Get());</span><br><span class="line">  self-&gt;AllowThreadSuspension();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    然后再了解一下<code>LoadField</code>和<code>LoadMethod</code>是如何加载的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadField</span><span class="params">(<span class="keyword">const</span> ClassAccessor::Field&amp; field,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Handle&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ArtField* dst)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可以看到实际就是将值填充给了dst</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> field_idx = field.GetIndex();</span><br><span class="line">  dst-&gt;SetDexFieldIndex(field_idx);</span><br><span class="line">  dst-&gt;SetDeclaringClass(klass.Get());</span><br><span class="line">  dst-&gt;SetAccessFlags(field.GetAccessFlags() | hiddenapi::CreateRuntimeFlags(field));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadMethod</span><span class="params">(<span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> ClassAccessor::Method&amp; method,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Handle&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ArtMethod* dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> dex_method_idx = method.GetIndex();</span><br><span class="line">  <span class="keyword">const</span> dex::MethodId&amp; method_id = dex_file.GetMethodId(dex_method_idx);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* method_name = dex_file.StringDataByIdx(method_id.name_idx_);</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedAssertNoThreadSuspension <span class="title">ants</span><span class="params">(<span class="string">&quot;LoadMethod&quot;</span>)</span></span>;</span><br><span class="line">  dst-&gt;SetDexMethodIndex(dex_method_idx);</span><br><span class="line">  dst-&gt;SetDeclaringClass(klass.Get());</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 如果加载的是finalize方法</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(<span class="built_in">strcmp</span>(<span class="string">&quot;finalize&quot;</span>, method_name) == <span class="number">0</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method_name[<span class="number">0</span>] == <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理构造函数</span></span><br><span class="line">    <span class="keyword">bool</span> is_init = (<span class="built_in">strcmp</span>(<span class="string">&quot;&lt;init&gt;&quot;</span>, method_name) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">bool</span> is_clinit = !is_init &amp;&amp; (<span class="built_in">strcmp</span>(<span class="string">&quot;&lt;clinit&gt;&quot;</span>, method_name) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(!is_init &amp;&amp; !is_clinit)) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">&quot;Unexpected &#x27;&lt;&#x27; at start of method name &quot;</span> &lt;&lt; method_name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY((access_flags &amp; kAccConstructor) == <span class="number">0</span>)) &#123;</span><br><span class="line">        LOG(WARNING) &lt;&lt; method_name &lt;&lt; <span class="string">&quot; didn&#x27;t have expected constructor access flag in class &quot;</span></span><br><span class="line">            &lt;&lt; klass-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot; in dex file &quot;</span> &lt;&lt; dex_file.GetLocation();</span><br><span class="line">        <span class="comment">// access_flags存储了Java方法的访问标志，如public、private、static等。kAccConstructor是一个常量，表示Java构造函数的访问标志</span></span><br><span class="line">        access_flags |= kAccConstructor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否为native函数</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY((access_flags &amp; kAccNative) != <span class="number">0u</span>)) &#123;</span><br><span class="line">    <span class="comment">// Check if the native method is annotated with @FastNative or @CriticalNative.</span></span><br><span class="line">    access_flags |= annotations::GetNativeMethodAnnotationAccessFlags(</span><br><span class="line">        dex_file, dst-&gt;GetClassDef(), dex_method_idx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置该方法的访问标志</span></span><br><span class="line">  dst-&gt;SetAccessFlags(access_flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为接口类的抽象方法</span></span><br><span class="line">  <span class="keyword">if</span> (klass-&gt;IsInterface() &amp;&amp; dst-&gt;IsAbstract()) &#123;</span><br><span class="line"><span class="comment">// 计算并设置抽象方法的IMT索引。IMT(Interface Method Table)是一个虚拟表，用于存储接口类中的所有方法索引。</span></span><br><span class="line">    dst-&gt;CalculateAndSetImtIndex();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个java方法是否有可执行代码，也就是java字节码，方法的具体执行指令集</span></span><br><span class="line">  <span class="keyword">if</span> (dst-&gt;HasCodeItem()) &#123;</span><br><span class="line">    DCHECK_NE(method.GetCodeItemOffset(), <span class="number">0u</span>);</span><br><span class="line">    <span class="comment">// 根据当前是否采用AOT编译器来进行不同的方式填充可执行代码。</span></span><br><span class="line">    <span class="keyword">if</span> (Runtime::Current()-&gt;IsAotCompiler()) &#123;</span><br><span class="line">      dst-&gt;SetDataPtrSize(reinterpret_cast32&lt;<span class="keyword">void</span>*&gt;(method.GetCodeItemOffset()), image_pointer_size_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dst-&gt;SetCodeItem(dst-&gt;GetDexFile()-&gt;GetCodeItem(method.GetCodeItemOffset()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dst-&gt;SetDataPtrSize(<span class="literal">nullptr</span>, image_pointer_size_);</span><br><span class="line">    DCHECK_EQ(method.GetCodeItemOffset(), <span class="number">0u</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查该方法的参数类型和返回值类型是否符合要求</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* shorty = dst-&gt;GetShorty();</span><br><span class="line">  <span class="keyword">bool</span> all_parameters_are_reference = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">bool</span> all_parameters_are_reference_or_int = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">bool</span> return_type_is_fp = (shorty[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> || shorty[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>, e = <span class="built_in">strlen</span>(shorty); i &lt; e; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shorty[i] != <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">      all_parameters_are_reference = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (shorty[i] == <span class="string">&#x27;F&#x27;</span> || shorty[i] == <span class="string">&#x27;D&#x27;</span> || shorty[i] == <span class="string">&#x27;J&#x27;</span>) &#123;</span><br><span class="line">        all_parameters_are_reference_or_int = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Java方法设置是否启用Nterp快速路径，如果该函数非native的，并且参数全部为引用类型，则设置该方法的entry_point_from_interpreter_为Nterp快速路径</span></span><br><span class="line">  <span class="keyword">if</span> (!dst-&gt;IsNative() &amp;&amp; all_parameters_are_reference) &#123;</span><br><span class="line">    dst-&gt;SetNterpEntryPointFastPathFlag();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回值类型非浮点型，并且所有参数类型都是引用类型或整型，则设置该方法的invocation_count_为Nterp快速路径</span></span><br><span class="line">  <span class="keyword">if</span> (!return_type_is_fp &amp;&amp; all_parameters_are_reference_or_int) &#123;</span><br><span class="line">    dst-&gt;SetNterpInvokeFastPathFlag();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>finalize</code>是<code>Java</code>中的一个方法，定义在<code>Object</code>类中，用于执行垃圾回收前的资源清理工作。当某个对象不再被引用时，垃圾回收器会调用该对象的<code>finalize</code>方法来完成一些特定的清理操作，如释放非托管资源等。</p><p>​    <code>Nterp</code>快速路径<code>（Nterp Fast Path）</code>是<code>ART</code>虚拟机的一种执行模式，可以在不进行线程切换的情况下快速执行<code>Java</code>方法。具体来说，<code>Nterp</code>快速路径使用一种特殊的、基于指令计数器的执行模式来处理<code>Java</code>方法，以实现更高效的性能。</p><p>​    <code>Nterp</code>快速路径的作用是提高<code>Java</code>方法的执行速度和效率，特别是在热点代码部分，可以获得更高的吞吐量和更低的延迟。另外，由于采用了一些特殊的优化技术，如参数传递方式改变、返回值处理流程优化等，<code>Nterp</code>快速路径还可以减少<code>JNI</code>开销，从而提升整个应用程序的性能表现。</p><p>​    在前文介绍<code>native</code>的动态注册时，曾经简单的讲解<code>LinkCode</code>，这里再次对这个重点函数进行详细的了解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClassLinker::ShouldUseInterpreterEntrypoint</span><span class="params">(ArtMethod* method, <span class="keyword">const</span> <span class="keyword">void</span>* quick_code)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (quick_code == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ..</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LinkCode</span><span class="params">(ClassLinker* class_linker,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ArtMethod* method,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> OatFile::OatClass* oat_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">uint32_t</span> class_def_method_index)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* quick_code = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (oat_class != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> OatFile::OatMethod oat_method = oat_class-&gt;GetOatMethod(class_def_method_index);</span><br><span class="line">    <span class="comment">// 获取一个方法的快速代码（Quick Code），用于设置该方法的入口点地址</span></span><br><span class="line">    quick_code = oat_method.GetQuickCode();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有方法的快速代码，否则使用解释器执行，在下一节的函数调用中会详细讲到</span></span><br><span class="line">  <span class="keyword">bool</span> enter_interpreter = class_linker-&gt;ShouldUseInterpreterEntrypoint(method, quick_code);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (quick_code == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置一个方法的入口点位置，可以是编译成机器码的快速执行入口、解释器入口，或者native函数的入口地址</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(</span><br><span class="line">        method-&gt;IsNative() ? GetQuickGenericJniStub() : GetQuickToInterpreterBridge());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enter_interpreter) &#123;</span><br><span class="line">    <span class="comment">// 设置解释器入口为该方法的入口点位置</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickToInterpreterBridge());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NeedsClinitCheckBeforeCall(method)) &#123;</span><br><span class="line">    DCHECK(!method-&gt;GetDeclaringClass()-&gt;IsVisiblyInitialized());</span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickResolutionStub());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 已经编译好的机器码所在的快速执行入口</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(quick_code);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给native设置入口地址的，在第六章动态注册中讲到。</span></span><br><span class="line">  <span class="keyword">if</span> (method-&gt;IsNative()) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    快速代码是指一种优化后的本地机器代码，它可以直接执行<code>Java</code>字节码对应的指令，从而实现更快的函数调用和执行。快速代码通常是通过即时编译器<code>（JIT）</code>或预编译技术生成的，并保存在<code>Oat</code>文件中。在运行时，如果一个方法已经被编译为快速代码，则<code>LinkCode</code>函数可以直接使用<code>Oat</code>文件中的方法描述符获取快速代码的地址，并将其设置为该方法的入口点地址。</p><p>​    接下来看看设置的解释器入口是什么，跟踪方法<code>GetQuickToInterpreterBridge</code>的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">GetQuickToInterpreterBridge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(art_quick_to_interpreter_bridge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里和<code>native</code>动态注册分析时看到入口设置非常类似，<code>GetQuickToInterpreterBridge</code>是一个静态内联函数，它将全局变量<code>art_quick_to_interpreter_bridge</code>的地址强制转换为<code>const void*</code>类型，然后返回该地址。<code>art_quick_to_interpreter_bridge</code>是一个指向解释器入口点的函数指针，它在链接器启动时被初始化，是由汇编进行实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ENTRY art_quick_to_interpreter_bridge</span><br><span class="line">    SETUP_SAVE_REFS_AND_ARGS_FRAME         &#x2F;&#x2F; Set up frame and save arguments.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  x0 will contain mirror::ArtMethod* method.</span><br><span class="line">    mov x1, xSELF                          &#x2F;&#x2F; How to get Thread::Current() ???</span><br><span class="line">    mov x2, sp</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; uint64_t artQuickToInterpreterBridge(mirror::ArtMethod* method, Thread* self,</span><br><span class="line">    &#x2F;&#x2F;                                      mirror::ArtMethod** sp)</span><br><span class="line">    bl   artQuickToInterpreterBridge</span><br><span class="line"></span><br><span class="line">    RESTORE_SAVE_REFS_AND_ARGS_FRAME</span><br><span class="line">    REFRESH_MARKING_REGISTER</span><br><span class="line"></span><br><span class="line">    fmov d0, x0</span><br><span class="line"></span><br><span class="line">    RETURN_OR_DELIVER_PENDING_EXCEPTION</span><br><span class="line">END art_quick_to_interpreter_bridge</span><br></pre></td></tr></table></figure><p>查看汇编代码时，可以注意到关键是使用<code>bl</code>指令调用<code>artQuickToInterpreterBridge</code>函数。这个函数就是解释器的入口函数。</p><p>解释器（Interpreter）是一种Java字节码执行引擎，它能够直接解释和执行Java字节码指令。与预编译的本地机器代码不同，解释器以Java字节码为基础，通过逐条解释执行来完成函数的执行过程。</p><p>当应用程序需要执行一个Java方法时，链接器会将该方法的字节码读入内存，并利用解释器逐条指令执行。解释器会根据Java字节码类型进行相应的操作，包括创建对象、读取/写入局部变量和操作数栈、跳转操作等。同时，解释器还会处理异常、垃圾回收、线程同步等方面的操作，从而保证Java程序的正确性和稳定性。</p><p>尽管解释器的执行速度比本地机器代码要慢一些，但它具有许多优点。例如，解释器可以实现更快的程序启动时间、更小的内存占用和更好的灵活性；同时，它还可以避免因硬件平台差异、编译器优化等问题导致代码执行异常和安全隐患。</p><p>当一个方法第一次被调用时，在进行初步解释和执行之后，解释器会生成相应的Profile数据。后续调用将根据Profile数据决定是否使用JIT编译器或AOT编译器进行优化。这种混合的执行方式可以有效地平衡运行效率和内存开销之间的关系，提高Java程序的整体性能和响应速度。</p><p>当类加载完成后，对应的类数据将会存储在相应的DexFile中。在后续使用中，可以通过DexFile来访问类中的成员和函数。下面简单了解一下DexFile结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// dex文件魔数的字节数。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kDexMagicSize = <span class="number">4</span>;</span><br><span class="line">  <span class="comment">// dex文件版本号的字节数。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kDexVersionLen = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kClassDefinitionOrderEnforcedVersion = <span class="number">37</span>;</span><br><span class="line">  <span class="comment">// SHA-1消息摘要的长度</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kSha1DigestSize = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// dex文件的大小端标志</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kDexEndianConstant = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无效索引的值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint16_t</span> kDexNoIndex16 = <span class="number">0xFFFF</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kDexNoIndex32 = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示dex文件头结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> magic_[<span class="number">8</span>] = &#123;&#125;;<span class="comment">// 魔数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> checksum_ = <span class="number">0</span>;    <span class="comment">// 校验和</span></span><br><span class="line">    <span class="keyword">uint8_t</span> signature_[kSha1DigestSize] = &#123;&#125;;<span class="comment">// SHA-1签名</span></span><br><span class="line">    <span class="keyword">uint32_t</span> file_size_ = <span class="number">0</span>;  <span class="comment">// 文件总大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size_ = <span class="number">0</span>;  <span class="comment">// 偏移量到下一部分的起始位置</span></span><br><span class="line">    <span class="keyword">uint32_t</span> endian_tag_ = <span class="number">0</span>;<span class="comment">// 大小端标志</span></span><br><span class="line">    <span class="keyword">uint32_t</span> link_size_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> link_off_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> map_off_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> string_ids_size_ = <span class="number">0</span>;  <span class="comment">// 字符串ID的数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> string_ids_off_ = <span class="number">0</span>;  <span class="comment">// 字符串ID数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> type_ids_size_ = <span class="number">0</span>;  <span class="comment">// 类型ID数，不支持超过65535个</span></span><br><span class="line">    <span class="keyword">uint32_t</span> type_ids_off_ = <span class="number">0</span>;  <span class="comment">// 类型ID数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> proto_ids_size_ = <span class="number">0</span>;  <span class="comment">// ProtoId的数量，不支持超过65535个</span></span><br><span class="line">    <span class="keyword">uint32_t</span> proto_ids_off_ = <span class="number">0</span>;  <span class="comment">// ProtoId数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> field_ids_size_ = <span class="number">0</span>;  <span class="comment">// FieldIds的数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> field_ids_off_ = <span class="number">0</span>;  <span class="comment">// FieldIds数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> method_ids_size_ = <span class="number">0</span>;  <span class="comment">// MethodIds的数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> method_ids_off_ = <span class="number">0</span>;  <span class="comment">// MethodIds数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> class_defs_size_ = <span class="number">0</span>;  <span class="comment">// ClassDefs的数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> class_defs_off_ = <span class="number">0</span>;  <span class="comment">// ClassDef数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> data_size_ = <span class="number">0</span>;  <span class="comment">// 数据部分的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> data_off_ = <span class="number">0</span>;  <span class="comment">// 数据部分的文件偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码dex文件版本号。</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">GetVersion</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 支持默认方法的第一个Dex格式版本。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kDefaultMethodsVersion = <span class="number">37</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// dex文件数据起始位置</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> begin_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内存分配的字节数。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> size_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据节的基地址（对于标准dex，与Begin()相同）。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> data_begin_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据节的大小。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> data_size_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> location_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> location_checksum_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dex文件头的指针</span></span><br><span class="line">  <span class="keyword">const</span> Header* <span class="keyword">const</span> header_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::StringId* <span class="keyword">const</span> string_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::TypeId* <span class="keyword">const</span> type_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字段标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::FieldId* <span class="keyword">const</span> field_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::MethodId* <span class="keyword">const</span> method_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原型标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::ProtoId* <span class="keyword">const</span> proto_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类定义列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::ClassDef* <span class="keyword">const</span> class_defs_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法句柄列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::MethodHandleItem* method_handles_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法句柄列表中元素的数量</span></span><br><span class="line">  <span class="keyword">size_t</span> num_method_handles_;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    接着查看<code>DexFile</code>的构造函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">DexFile::DexFile(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* base,</span><br><span class="line">                 <span class="keyword">size_t</span> size,</span><br><span class="line">                 <span class="keyword">const</span> <span class="keyword">uint8_t</span>* data_begin,</span><br><span class="line">                 <span class="keyword">size_t</span> data_size,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; location,</span><br><span class="line">                 <span class="keyword">uint32_t</span> location_checksum,</span><br><span class="line">                 <span class="keyword">const</span> OatDexFile* oat_dex_file,</span><br><span class="line">                 <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DexFileContainer&gt; container,</span><br><span class="line">                 <span class="keyword">bool</span> is_compact_dex)</span><br><span class="line">    : begin_(base),</span><br><span class="line">      size_(size),</span><br><span class="line">      data_begin_(data_begin),</span><br><span class="line">      data_size_(data_size),</span><br><span class="line">      location_(location),</span><br><span class="line">      location_checksum_(location_checksum),</span><br><span class="line">      header_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> Header*&gt;(base)),</span><br><span class="line">      string_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> StringId*&gt;(base + header_-&gt;string_ids_off_)),</span><br><span class="line">      type_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> TypeId*&gt;(base + header_-&gt;type_ids_off_)),</span><br><span class="line">      field_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> FieldId*&gt;(base + header_-&gt;field_ids_off_)),</span><br><span class="line">      method_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> MethodId*&gt;(base + header_-&gt;method_ids_off_)),</span><br><span class="line">      proto_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> ProtoId*&gt;(base + header_-&gt;proto_ids_off_)),</span><br><span class="line">      class_defs_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> ClassDef*&gt;(base + header_-&gt;class_defs_off_)),</span><br><span class="line">      method_handles_(<span class="literal">nullptr</span>),</span><br><span class="line">      num_method_handles_(<span class="number">0</span>),</span><br><span class="line">      call_site_ids_(<span class="literal">nullptr</span>),</span><br><span class="line">      num_call_site_ids_(<span class="number">0</span>),</span><br><span class="line">      hiddenapi_class_data_(<span class="literal">nullptr</span>),</span><br><span class="line">      oat_dex_file_(oat_dex_file),</span><br><span class="line">      container_(<span class="built_in">std</span>::move(container)),</span><br><span class="line">      is_compact_dex_(is_compact_dex),</span><br><span class="line">      hiddenapi_domain_(hiddenapi::Domain::kApplication) &#123;</span><br><span class="line">  CHECK(begin_ != <span class="literal">nullptr</span>) &lt;&lt; GetLocation();</span><br><span class="line">  CHECK_GT(size_, <span class="number">0U</span>) &lt;&lt; GetLocation();</span><br><span class="line">  <span class="comment">// Check base (=header) alignment.</span></span><br><span class="line">  <span class="comment">// Must be 4-byte aligned to avoid undefined behavior when accessing</span></span><br><span class="line">  <span class="comment">// any of the sections via a pointer.</span></span><br><span class="line">  CHECK_ALIGNED(begin_, <span class="keyword">alignof</span>(Header));</span><br><span class="line"></span><br><span class="line">  InitializeSectionsFromMapList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看出<code>header_</code>这个<code>dex</code>文件头的结构体中存储着最重要的信息，初始化时先是填充了<code>header_</code>中的数据，然后再根据<code>header_</code>文件头，将其他重要信息初始化。当需要对这个<code>Dex</code>进行访问时，只需要通过文件头信息，就可以为我们索引找到任何一段信息了。它提供了整个文件的索引。</p><p>​    使用<code>010 Editor</code>工具，通过模板库在线安装<code>DEX.bt</code>模板，然后打开之前的样例文件，查看在例子中<code>header_</code>的真实数据。</p><p><img src="/2025/04/07/chapter-07/dex_header.png" alt="image-20230325190621427"></p><h2><span id="73-函数调用流程">7.3 函数调用流程</span></h2><p>在Android中，<strong>Java</strong>函数和<strong>native</strong>函数的调用方式略有不同。</p><p>对于<strong>Java</strong>函数，它们的执行是由<em>Android Runtime</em>虚拟机完成的。具体来说，当应用程序需要调用一个<strong>Java</strong>函数时，<em>Android Runtime</em>会根据该函数的状态和类型进行相应的处理，包括解释器执行、JIT编译器动态生成机器码等；当函数执行完毕后，结果会被传递回应用程序。</p><p>而对于<strong>native</strong>函数，则是由操作系统内核直接执行的。应用程序需要通过JNI（Java Native Interface）来调用<code>native</code> 函数。首先将<strong>Java数据结构转换为C/C++类型</strong>, 然后将参数传递给 <code>native</code> 函数, 最终再将结果转换为<strong>Java数据结构并返回给应用程序。</strong></p><p>在这个过程中, JNI提供了一系列的函数和接口来实现Java与本地代码/数据之间的交互和转换。</p><p>下面使用反编译工具<code>jadx</code>打开前文中的样例程序，样例程序的代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMyJarVer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;v1.0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    切换为展示<code>smali</code>指令，并右键选择显示<code>Dalvik</code>字节码，看到如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="keyword">static</span> <span class="title">add</span><span class="params">(II)</span>I</span></span><br><span class="line"><span class="function">    .registers 3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    .param p0, &quot;a&quot;:I</span></span><br><span class="line"><span class="function">    .param p1, &quot;b&quot;:I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                              .line 11</span></span><br><span class="line"><span class="function">    002bf89c: 9000 0102               0000: add-<span class="keyword">int</span>             v0, p0, p1</span></span><br><span class="line"><span class="function">                         .end local v1 # &quot;a&quot;:I</span></span><br><span class="line"><span class="function">                         .end local v2 # &quot;b&quot;:I</span></span><br><span class="line"><span class="function">    002bf8a0: 0f00                    0002: return              v0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.end method</span></span><br></pre></td></tr></table></figure><p>​    <code>.registers 3</code>表示该函数中使用到了3个寄存器，分别为两个参数和返回值。</p><p>​    <code>002bf89c</code> 表示的是当前指令的偏移地址。</p><p>​    <code>9000 0102</code> 就是该函数中的<code>java</code>字节码，其中前两个字节<code>9000</code>表示的是操作码，由于字节码是大端序存储的，所以这里实际操作码解读为<code>0x0090</code>，下面在<code>AOSP</code>中对<code>Opcodes</code>的定义中也能看到<code>0x90</code>操作码对应的操作是<code>add-int</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">int</span> OP_ADD_INT                      = <span class="number">0x0090</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用<code>010 Editor</code>工具，将样例程序解压后获得的<code>classes.dex</code>拖入<code>010 Editor</code>打开。看到结果如下。</p><p><img src="/2025/04/07/chapter-07/dex%E6%A8%A1%E6%9D%BF.png" alt="image-20230325133550347"></p><p>​    接下来在<code>dex_class_defs</code>中寻找刚刚分析的目标类<code>MyCommon</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct class_def_item class_def[2205]public cn.rom.myjar.MyCommon1243C4h20hFg: Bg:0xE0E0E0Class ID</span><br></pre></td></tr></table></figure><p>​    将其展开后，能看到该<code>class</code>的详细信息，在上一节的类加载中，当<code>DEX</code>被解析后，加载的类在内存中就是以这样的结构存储着数据。</p><p><img src="/2025/04/07/chapter-07/def_class.png" alt="image-20230325134213390"></p><p>​    在其中的函数结构体下面的<code>code_item</code>类型的数据，就存储着该函数要执行的<code>java</code>字节码，继续展开该结构。</p><p><img src="/2025/04/07/chapter-07/codeitem1.png" alt="image-20230325134632085"></p><p>​    这里就能看到对该函数结构的描述了，<code>insns</code>中则存储着函数要执行的指令。每个指令的单位是<code>ushort</code>，即两个字节存储，将这里的三个指令转换为16进制表示则是。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">144  &#x3D;  00 90 -&gt; 大端序 -&gt; 9000</span><br><span class="line"></span><br><span class="line">513  &#x3D;  02 01 -&gt; 大端序 -&gt; 0102</span><br><span class="line"></span><br><span class="line">15   &#x3D;  00 0F -&gt; 大端序 -&gt; 0f00</span><br></pre></td></tr></table></figure><p>​    结果和上面<code>smali</code>展示中的一致。这就是<code>java</code>字节码，在调用过程中，系统会经过层层的转换和解析，最终通过对函数中的指令进行执行来完成函数的调用。</p><p>​    接下来根据之前的例子，开始对函数调用流程的代码进行跟踪分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Object result = addMethod.invoke(<span class="keyword">null</span>, <span class="number">12</span>,<span class="number">25</span>);</span><br><span class="line">    Log.i(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;getMyJarVer:&quot;</span>+result);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    找到<code>Method</code>的<code>invoke</code>的实现，这是一个<code>native</code>函数，所以继续找对应的<code>Method_invoke</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FastNative</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">Method_invoke</span><span class="params">(JNIEnv* env, jobject javaMethod, jobject javaReceiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray javaArgs)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> InvokeMethod&lt;kRuntimePointerSize&gt;(soa, javaMethod, javaReceiver, javaArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">InvokeMethod</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa, jobject javaMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                     jobject javaReceiver, jobject javaArgs, size_t num_frames)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java方法和ArtMethod之间存在映射关系，SOA提供了一种方便的方式来将Java对象转换为Art虚拟机中的数据对象</span></span><br><span class="line">  ObjPtr&lt;mirror::Executable&gt; executable = soa.Decode&lt;mirror::Executable&gt;(javaMethod);</span><br><span class="line">  <span class="keyword">const</span> bool accessible = executable-&gt;IsAccessible();</span><br><span class="line">  ArtMethod* m = executable-&gt;GetArtMethod();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!m-&gt;IsStatic()) &#123;</span><br><span class="line">    <span class="comment">// Replace calls to String.&lt;init&gt; with equivalent StringFactory call.</span></span><br><span class="line">    <span class="keyword">if</span> (declaring_class-&gt;IsStringClass() &amp;&amp; m-&gt;IsConstructor()) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 查找虚方法的真实实现</span></span><br><span class="line">      m = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtualOrInterface(m, kPointerSize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对java方法的参数进行转换</span></span><br><span class="line">  ObjPtr&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt; objects =</span><br><span class="line">      soa.Decode&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt;(javaArgs);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  JValue result;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* shorty;</span><br><span class="line">  <span class="keyword">if</span> (!InvokeMethodImpl(soa, m, np_method, receiver, objects, &amp;shorty, &amp;result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> soa.AddLocalReference&lt;jobject&gt;(BoxPrimitive(Primitive::GetType(shorty[<span class="number">0</span>]), result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个函数中，主要使用<code>SOA</code>将<code>Java</code>函数以及函数的参数转换为<code>C++</code>对象。</p><p><code>Structured Object Access（SOA）</code>用于优化<code>Java</code>对象在<code>Native</code>代码和<code>Art</code>虚拟机之间的传递和处理。<code>SOA</code>技术提供了一种高效的方式，将<code>Java</code>对象转换为基于指针的本地<code>C++</code>对象，从而避免了频繁的对象复制和<code>GC</code>操作，提高了程序的性能和执行效率。</p><p>在<code>SOA</code>技术中使用<code>Handle</code>和<code>ObjPtr</code>等类型的指针来管理<code>Java</code>对象和本地<code>C++</code>对象之间的映射关系。<code>Handle</code>是一种包装器，用于管理<code>Java</code>对象的生命周期，并确保其在被访问时不会被<code>GC</code>回收。<code>ObjPtr</code>则是一种智能指针，用于管理本地<code>C++</code>对象的生命周期，并确保其正确释放和销毁。</p><p>通过<code>SOA</code>可以在<code>Native</code>代码中高效地访问和操作<code>Java</code>对象，例如调用<code>Java</code>方法、读取<code>Java</code>字段等。在执行过程中，<code>SOA</code>技术会自动进行对象的内存分配和管理，以确保程序的正确性和性能表现。</p><p>接下来继续了解<code>InvokeMethodImpl</code>函数的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InvokeMethodImpl</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ArtMethod* m,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ArtMethod* np_method,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ObjPtr&lt;mirror::Object&gt; receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ObjPtr&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt; objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">char</span>** shorty,</span></span></span><br><span class="line"><span class="function"><span class="params">                      JValue* result)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将函数的参数转换后，存放到arg_array中。</span></span><br><span class="line">  <span class="keyword">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">  *shorty = np_method-&gt;GetShorty(&amp;shorty_len);</span><br><span class="line">  <span class="function">ArgArray <span class="title">arg_array</span><span class="params">(*shorty, shorty_len)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!arg_array.BuildArgArrayFromObjectArray(receiver, objects, np_method, soa.Self())) &#123;</span><br><span class="line">    CHECK(soa.Self()-&gt;IsExceptionPending());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数调用</span></span><br><span class="line">  InvokeWithArgArray(soa, m, &amp;arg_array, result, *shorty);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>ArgArray</code>主要用于管理<code>Java</code>方法参数列表的类。<code>ArgArray</code>和<code>Java</code>中的类型对应如下：</p><p>​    1.基本类型：<code>ArgArray</code>中的基本类型分别对应<code>Java</code>中的八种基本类型</p><ul><li><code>boolean：&#39;Z&#39;</code></li><li><code>byte：&#39;B&#39;</code></li><li><code>short：&#39;S&#39;</code></li><li><code>char：&#39;C&#39;</code></li><li><code>int：&#39;I&#39;</code></li><li><code>long：&#39;J&#39;</code></li><li><code>float：&#39;F&#39;</code></li><li><code>double：&#39;D&#39;</code></li></ul><p>​    2.引用类型：<code>ArgArray</code>中的引用类型对应<code>Java</code>中的对象类型，包括<code>String、Object、</code>数组等。在<code>ArgArray</code>中，引用类型用字符<code>&#39;L&#39;</code>开头，并紧跟着完整类名和结尾的分号<code>&#39;;&#39;</code>表示，例如<code>&#39;Landroid/content/Context;&#39;</code>表示<code>android.content.Context</code>类。</p><p>​    3.可变参数：可变参数在<code>Java</code>中使用<code>“...”</code>符号表示，而在<code>ArgArray</code>中，则需要将所有可变参数打包为一个数组，并使用<code>‘[’</code>和<code>‘]’</code>符号表示。例如，如果<code>Java</code>方法声明为<code>“public void foo(int a, String... args)”</code>，则在<code>ArgArray</code>中，参数列表的短类型描述符为<code>“ILjava/lang/String;[”</code>。</p><p>​    理解了<code>C++</code>如何存放参数数据后，继续看下一层的函数调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvokeWithArgArray</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ArtMethod* method, ArgArray* arg_array, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取java参数的数组指针</span></span><br><span class="line">  <span class="keyword">uint32_t</span>* args = arg_array-&gt;GetArray();</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(soa.Env()-&gt;IsCheckJniEnabled())) &#123;</span><br><span class="line">    CheckMethodArguments(soa.Vm(), method-&gt;GetInterfaceMethodIfProxy(kRuntimePointerSize), args);</span><br><span class="line">  &#125;</span><br><span class="line">  method-&gt;Invoke(soa.Self(), args, arg_array-&gt;GetNumBytes(), result, shorty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到了<code>ArtMethod</code>的<code>Invoke</code>函数，这里将参数的数组指针，参数数组大小，返回值指针，调用函数的描述符号传递了过去。在开始进入关键函数前，先对返回值指针<code>JValue* result</code>进行简单介绍。</p><p><code>JValue</code>是用于存储和传递<code>Java</code>方法返回值的联合体。包含了各种基本类型和引用类型的成员变量。下面是该联合体的定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">union</span> <span class="title">PACKED</span><span class="params">(<span class="keyword">alignof</span>(mirror::Object*))</span> JValue </span>&#123;</span><br><span class="line">  <span class="comment">// We default initialize JValue instances to all-zeros.</span></span><br><span class="line">  JValue() : j(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; ALWAYS_INLINE <span class="keyword">static</span> JValue <span class="title">FromPrimitive</span><span class="params">(T v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int8_t</span> <span class="title">GetB</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> b; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetB</span><span class="params">(<span class="keyword">int8_t</span> new_b)</span> </span>&#123;</span><br><span class="line">    j = ((<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_b) &lt;&lt; <span class="number">56</span>) &gt;&gt; <span class="number">56</span>);  <span class="comment">// Sign-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint16_t</span> <span class="title">GetC</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetC</span><span class="params">(<span class="keyword">uint16_t</span> new_c)</span> </span>&#123;</span><br><span class="line">    j = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_c);  <span class="comment">// Zero-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">GetD</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetD</span><span class="params">(<span class="keyword">double</span> new_d)</span> </span>&#123; d = new_d; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">float</span> <span class="title">GetF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetF</span><span class="params">(<span class="keyword">float</span> new_f)</span> </span>&#123; f = new_f; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int32_t</span> <span class="title">GetI</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetI</span><span class="params">(<span class="keyword">int32_t</span> new_i)</span> </span>&#123;</span><br><span class="line">    j = ((<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_i) &lt;&lt; <span class="number">32</span>) &gt;&gt; <span class="number">32</span>);  <span class="comment">// Sign-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int64_t</span> <span class="title">GetJ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> j; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetJ</span><span class="params">(<span class="keyword">int64_t</span> new_j)</span> </span>&#123; j = new_j; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">mirror::Object* <span class="title">GetL</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line">  ALWAYS_INLINE</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetL</span><span class="params">(ObjPtr&lt;mirror::Object&gt; new_l)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int16_t</span> <span class="title">GetS</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetS</span><span class="params">(<span class="keyword">int16_t</span> new_s)</span> </span>&#123;</span><br><span class="line">    j = ((<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_s) &lt;&lt; <span class="number">48</span>) &gt;&gt; <span class="number">48</span>);  <span class="comment">// Sign-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint8_t</span> <span class="title">GetZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetZ</span><span class="params">(<span class="keyword">uint8_t</span> new_z)</span> </span>&#123;</span><br><span class="line">    j = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_z);  <span class="comment">// Zero-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">mirror::Object** <span class="title">GetGCRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;l; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint8_t</span> z;</span><br><span class="line">  <span class="keyword">int8_t</span> b;</span><br><span class="line">  <span class="keyword">uint16_t</span> c;</span><br><span class="line">  <span class="keyword">int16_t</span> s;</span><br><span class="line">  <span class="keyword">int32_t</span> i;</span><br><span class="line">  <span class="keyword">int64_t</span> j;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  mirror::Object* l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>JValue</code>结构体的大小为8个字节对齐，结构体提供了一些成员函数，例如<code>GetXXX</code>和<code>SetXXX</code>等函数，用于获取和设置不同类型的返回值。<code>alignof(mirror::Object*)</code>的具体值取决于编译器和操作系统的不同，一般为4或8。</p><p>对参数以及返回值的在<code>C++</code>中的表示有了初步的了解后，开始继续查看函数调用过程中的关键函数<code>ArtMethod::Invoke</code>，下面是具体实现代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread* self, <span class="keyword">uint32_t</span>* args, <span class="keyword">uint32_t</span> args_size, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前的环境（也就是函数调用时的程序计数器、堆栈指针等信息）保存到一个栈帧中。这个栈帧通常会被分配在堆上，并且由垃圾回收器来管理。在函数返回时，这个栈帧会被弹出，恢复之前的环境。</span></span><br><span class="line">  ManagedStack fragment;</span><br><span class="line">  self-&gt;PushManagedStackFragment(&amp;fragment);</span><br><span class="line"></span><br><span class="line">  Runtime* runtime = Runtime::Current();</span><br><span class="line">  <span class="comment">// IsForceInterpreter为true表示强制使用解释器执行函数</span></span><br><span class="line">  <span class="comment">// 这里的条件是，如果设置了强制走解释器执行，并且非native函数，并且非代理函数，并且可执行的函数，则符合条件</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(!runtime-&gt;IsStarted() ||</span><br><span class="line">               (self-&gt;IsForceInterpreter() &amp;&amp; !IsNative() &amp;&amp; !IsProxyMethod() &amp;&amp; IsInvokable()))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (IsStatic()) &#123;</span><br><span class="line">      <span class="comment">// 静态函数调用</span></span><br><span class="line">      art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">          self, <span class="keyword">this</span>, <span class="literal">nullptr</span>, args, result, <span class="comment">/*stay_in_interpreter=*/</span> <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非静态函数调用</span></span><br><span class="line">      mirror::Object* receiver =</span><br><span class="line">          <span class="keyword">reinterpret_cast</span>&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[<span class="number">0</span>])-&gt;AsMirrorPtr();</span><br><span class="line">      art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">          self, <span class="keyword">this</span>, receiver, args + <span class="number">1</span>, result, <span class="comment">/*stay_in_interpreter=*/</span> <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 是否有已编译的快速执行代码的入口点</span></span><br><span class="line">    <span class="keyword">bool</span> have_quick_code = GetEntryPointFromQuickCompiledCode() != <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (LIKELY(have_quick_code)) &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 走快速调用方式，比解释器执行的性能高。</span></span><br><span class="line">      <span class="keyword">if</span> (!IsStatic()) &#123;</span><br><span class="line">        (*art_quick_invoke_stub)(<span class="keyword">this</span>, args, args_size, self, result, shorty);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*art_quick_invoke_static_stub)(<span class="keyword">this</span>, args, args_size, self, result, shorty);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; <span class="string">&quot;Not invoking &#x27;&quot;</span> &lt;&lt; PrettyMethod() &lt;&lt; <span class="string">&quot;&#x27; code=null&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        result-&gt;SetJ(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从栈帧中还原当前环境</span></span><br><span class="line">  self-&gt;PopManagedStackFragment(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上代码得到的结论是，函数执行的路线有两条，<code>EnterInterpreterFromInvoke</code>由解释器执行和<code>art_quick_invoke_stub</code>快速执行通道。</p><p><code>art_quick_invoke_stub</code>是由一段汇编完成对函数的执行，该函数充分利用寄存器并尽可能地减少堆栈访问次数，以提高<code>Java</code>方法的执行效率。虽然快速执行通道的效率会更加高，但是可读性差，但是对于学习执行过程和修改执行流程来说，解释器执行会更加简单易改。所以接下来跟进解释器执行，了解执行的细节。继续跟踪<code>EnterInterpreterFromInvoke</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnterInterpreterFromInvoke</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ArtMethod* method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ObjPtr&lt;mirror::Object&gt; receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">uint32_t</span>* args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">bool</span> stay_in_interpreter)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取函数中的指令信息</span></span><br><span class="line">  <span class="function">CodeItemDataAccessor <span class="title">accessor</span><span class="params">(method-&gt;DexInstructionData())</span></span>;</span><br><span class="line">  <span class="keyword">uint16_t</span> num_regs;</span><br><span class="line">  <span class="keyword">uint16_t</span> num_ins;</span><br><span class="line">  <span class="keyword">if</span> (accessor.HasCodeItem()) &#123;</span><br><span class="line">    <span class="comment">// 获取寄存器的数量和参数的数量</span></span><br><span class="line">    num_regs =  accessor.RegistersSize();</span><br><span class="line">    num_ins = accessor.InsSize();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!method-&gt;IsInvokable()) &#123;</span><br><span class="line">    self-&gt;EndAssertNoThreadSuspension(old_cause);</span><br><span class="line">    method-&gt;ThrowInvocationTimeError();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DCHECK(method-&gt;IsNative()) &lt;&lt; method-&gt;PrettyMethod();</span><br><span class="line">    <span class="comment">// 从函数描述符中计算出寄存器数量和参数数量</span></span><br><span class="line">    <span class="comment">// 这里将num_regs和num_ins都赋值的原因是，方法的前几个参数通常会存储在寄存器中，而不是堆栈中。因此，num_regs和num_ins的值应该是相同的，都代表了当前方法使用的寄存器数量，也就是用于存储参数和局部变量等数据的寄存器数量。</span></span><br><span class="line">    num_regs = num_ins = ArtMethod::NumArgRegisters(method-&gt;GetShorty());</span><br><span class="line">    <span class="comment">// 非静态函数的情况，会多一个this参数，所以寄存器数量和参数数量+1</span></span><br><span class="line">    <span class="keyword">if</span> (!method-&gt;IsStatic()) &#123;</span><br><span class="line">      num_regs++;</span><br><span class="line">      num_ins++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的ShadowFrame作为当前栈，将当前环境保存在其中，并且推入栈帧，供当前线程调用方法时使用</span></span><br><span class="line">  ShadowFrame* last_shadow_frame = self-&gt;GetManagedStack()-&gt;GetTopShadowFrame();</span><br><span class="line">  ShadowFrameAllocaUniquePtr shadow_frame_unique_ptr =</span><br><span class="line">      CREATE_SHADOW_FRAME(num_regs, last_shadow_frame, method, <span class="comment">/* dex pc */</span> <span class="number">0</span>);</span><br><span class="line">  ShadowFrame* shadow_frame = shadow_frame_unique_ptr.get();</span><br><span class="line">  self-&gt;PushShadowFrame(shadow_frame);</span><br><span class="line">  <span class="comment">// 计算出将要使用的第一个寄存器</span></span><br><span class="line">  <span class="keyword">size_t</span> cur_reg = num_regs - num_ins;</span><br><span class="line">  <span class="comment">// 非静态函数的情况，第一个寄存器的值为this，所以设置其为引用类型</span></span><br><span class="line">  <span class="keyword">if</span> (!method-&gt;IsStatic()) &#123;</span><br><span class="line">    <span class="comment">// receiver变量表示方法调用的第一个参数</span></span><br><span class="line">    CHECK(receiver != <span class="literal">nullptr</span>);</span><br><span class="line">    shadow_frame-&gt;SetVRegReference(cur_reg, receiver);</span><br><span class="line">    ++cur_reg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* shorty = method-&gt;GetShorty(&amp;shorty_len);</span><br><span class="line">  <span class="comment">// 遍历所有参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> shorty_pos = <span class="number">0</span>, arg_pos = <span class="number">0</span>; cur_reg &lt; num_regs; ++shorty_pos, ++arg_pos, cur_reg++) &#123;</span><br><span class="line">    DCHECK_LT(shorty_pos + <span class="number">1</span>, shorty_len);</span><br><span class="line">    <span class="keyword">switch</span> (shorty[shorty_pos + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">//L 表示这个参数是个引用类型，比如Ljava/lang/String;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: &#123;</span><br><span class="line">        ObjPtr&lt;mirror::Object&gt; o =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[arg_pos])-&gt;AsMirrorPtr();</span><br><span class="line">        <span class="comment">// 将转换好的数据设置到当前栈中</span></span><br><span class="line">        shadow_frame-&gt;SetVRegReference(cur_reg, o);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// J或者D的数据类型要占用两个寄存器存放。</span></span><br><span class="line">        <span class="keyword">uint64_t</span> wide_value = (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(args[arg_pos + <span class="number">1</span>]) &lt;&lt; <span class="number">32</span>) | args[arg_pos];</span><br><span class="line">        <span class="comment">// 合并后的数据设置到栈中</span></span><br><span class="line">        shadow_frame-&gt;SetVRegLong(cur_reg, wide_value);</span><br><span class="line">        cur_reg++;</span><br><span class="line">        arg_pos++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 普通的整型数据设置到栈中</span></span><br><span class="line">        shadow_frame-&gt;SetVReg(cur_reg, args[arg_pos]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  self-&gt;EndAssertNoThreadSuspension(old_cause);</span><br><span class="line">  <span class="comment">// 静态函数的情况需要检查所在的类是否已经正常初始化。</span></span><br><span class="line">  <span class="keyword">if</span> (method-&gt;IsStatic()) &#123;</span><br><span class="line">    ObjPtr&lt;mirror::Class&gt; declaring_class = method-&gt;GetDeclaringClass();</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(!declaring_class-&gt;IsVisiblyInitialized())) &#123;</span><br><span class="line">      <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(self)</span></span>;</span><br><span class="line">      <span class="function">Handle&lt;mirror::Class&gt; <span class="title">h_class</span><span class="params">(hs.NewHandle(declaring_class))</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(!Runtime::Current()-&gt;GetClassLinker()-&gt;EnsureInitialized(</span><br><span class="line">                        self, h_class, <span class="comment">/*can_init_fields=*/</span> <span class="literal">true</span>, <span class="comment">/*can_init_parents=*/</span> <span class="literal">true</span>))) &#123;</span><br><span class="line">        CHECK(self-&gt;IsExceptionPending());</span><br><span class="line">        self-&gt;PopShadowFrame();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      DCHECK(h_class-&gt;IsInitializing());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非native函数执行</span></span><br><span class="line">  <span class="keyword">if</span> (LIKELY(!method-&gt;IsNative())) &#123;</span><br><span class="line"><span class="comment">// 解释执行的关键函数</span></span><br><span class="line">    JValue r = Execute(self, accessor, *shadow_frame, JValue(), stay_in_interpreter);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *result = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// native函数的解释执行</span></span><br><span class="line">    args = shadow_frame-&gt;GetVRegArgs(method-&gt;IsStatic() ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Runtime::Current()-&gt;IsStarted()) &#123;</span><br><span class="line">      UnstartedRuntime::Jni(self, method, receiver.Ptr(), args, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      InterpreterJni(self, method, shorty, receiver, args, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 弹出栈帧，还原到执行后的栈环境</span></span><br><span class="line">  self-&gt;PopShadowFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在这个函数中，为即将执行的函数准备好了栈帧环境，将参数填入了<code>shadow_frame</code>栈帧中。并且获取出了函数要执行的指令信息<code>accessor</code>。最后通过<code>Execute</code>执行该函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline JValue <span class="title">Execute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CodeItemDataAccessor&amp; accessor,</span></span></span><br><span class="line"><span class="function"><span class="params">    ShadowFrame&amp; shadow_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">    JValue result_register,</span></span></span><br><span class="line"><span class="function"><span class="params">    bool stay_in_interpreter = <span class="keyword">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    bool from_deoptimize = <span class="keyword">false</span>)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否需要从解释器模式切换到编译模式。</span></span><br><span class="line">  <span class="keyword">if</span> (LIKELY(!from_deoptimize)) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    instrumentation::Instrumentation* instrumentation = Runtime::Current()-&gt;GetInstrumentation();</span><br><span class="line">    <span class="comment">// 从当前线程栈帧中获取要执行的函数</span></span><br><span class="line">    ArtMethod *method = shadow_frame.GetMethod();</span><br><span class="line"><span class="comment">// 是否有注册Method Entry 监听器</span></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(instrumentation-&gt;HasMethodEntryListeners())) &#123;</span><br><span class="line">      <span class="comment">// 触发 Method Entry 监听器，并传递相应的参数</span></span><br><span class="line">      instrumentation-&gt;MethodEnterEvent(self,</span><br><span class="line">                                        shadow_frame.GetThisObject(accessor.InsSize()),</span><br><span class="line">                                        method,</span><br><span class="line">                                        <span class="number">0</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 是否有未处理的异常</span></span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(self-&gt;IsExceptionPending())) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// stay_in_interpreter 表示是否需要停留在解释器模式，self-&gt;IsForceInterpreter() 表示是否强制使用解释器模式。所以内部是不走解释器执行的处理，走编译模式执行</span></span><br><span class="line">    <span class="keyword">if</span> (!stay_in_interpreter &amp;&amp; !self-&gt;IsForceInterpreter()) &#123;</span><br><span class="line">      jit::Jit* jit = Runtime::Current()-&gt;GetJit();</span><br><span class="line">      <span class="keyword">if</span> (jit != nullptr) &#123;</span><br><span class="line">        <span class="comment">// 判断当前方法是否可以使用 JIT 编译后的机器码执行</span></span><br><span class="line">        jit-&gt;MethodEntered(self, shadow_frame.GetMethod());</span><br><span class="line">        <span class="keyword">if</span> (jit-&gt;CanInvokeCompiledCode(method)) &#123;</span><br><span class="line">          JValue result;</span><br><span class="line">  <span class="comment">// 直接栈帧推出</span></span><br><span class="line">          self-&gt;PopShadowFrame();</span><br><span class="line"></span><br><span class="line">          uint16_t arg_offset = accessor.RegistersSize() - accessor.InsSize();</span><br><span class="line">          <span class="comment">// 调用该函数的机器码实现</span></span><br><span class="line">          ArtInterpreterToCompiledCodeBridge(self, nullptr, &amp;shadow_frame, arg_offset, &amp;result);</span><br><span class="line">          <span class="comment">// 重新推入栈帧</span></span><br><span class="line">          self-&gt;PushShadowFrame(&amp;shadow_frame);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从栈帧中获取要执行的当前函数</span></span><br><span class="line">  ArtMethod* method = shadow_frame.GetMethod();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// kSwitchImplKind：表示当前实现是否使用基于 switch 语句的解释器实现。</span></span><br><span class="line">  <span class="keyword">if</span> (kInterpreterImplKind == kSwitchImplKind ||</span><br><span class="line">      UNLIKELY(!Runtime::Current()-&gt;IsStarted()) ||</span><br><span class="line">      !method-&gt;IsCompilable() ||</span><br><span class="line">      method-&gt;MustCountLocks() ||</span><br><span class="line">      Runtime::Current()-&gt;IsActiveTransaction()) &#123;</span><br><span class="line">    <span class="comment">// 使用switch解释器执行</span></span><br><span class="line">    <span class="keyword">return</span> ExecuteSwitch(</span><br><span class="line">        self, accessor, shadow_frame, result_register, <span class="comment">/*interpret_one_instruction=*/</span> <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CHECK_EQ(kInterpreterImplKind, kMterpImplKind);</span><br><span class="line">  <span class="comment">// 编译执行函数</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 是否支持Mterp解释器执行</span></span><br><span class="line">    <span class="keyword">if</span> (!self-&gt;UseMterp()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitch(</span><br><span class="line">          self, accessor, shadow_frame, result_register, <span class="comment">/*interpret_one_instruction=*/</span> <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行目标函数</span></span><br><span class="line">    bool returned = ExecuteMterpImpl(self,</span><br><span class="line">                                     accessor.Insns(),</span><br><span class="line">                                     &amp;shadow_frame,</span><br><span class="line">                                     &amp;result_register);</span><br><span class="line">    <span class="keyword">if</span> (returned) &#123;</span><br><span class="line">      <span class="keyword">return</span> result_register;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 失败的情况继续采用switch解释器执行</span></span><br><span class="line">      result_register = ExecuteSwitch(</span><br><span class="line">          self, accessor, shadow_frame, result_register, <span class="comment">/*interpret_one_instruction=*/</span> <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">if</span> (shadow_frame.GetDexPC() == dex::kDexNoIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> result_register;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完该函数后，在继续深入前，先将其中的几个知识点进行介绍。</p><p>编译模式<code>（Compiled Mode）</code>是一种执行方式，它将应用程序代码编译成机器码后再执行。相较于解释器模式，编译模式具有更高的执行效率和更好的性能表现。</p><p>在<code>Android</code>应用程序中，编译模式采用的是 <code>Just-In-Time（JIT）</code>编译技术。当一个方法被多次调用时，系统会自动将其编译成本地机器码，并缓存起来以备下次使用。</p><p>当一个方法被编译成本地机器码后，其执行速度将显著提高。因为与解释器模式相比，编译模式不需要逐条解释代码，而是直接执行编译好的机器码。</p><p>由于编译过程需要一定的时间，因此在程序启动或者第一次运行新方法时，可能会出现一些额外的延迟。所以，在实际应用中，系统通常会采用一些策略，如预热机制等，来优化编译模式的性能表现。编译模式是一种性能更高、效率更好的执行方式，可以帮助应用程序在运行时获得更好的响应速度和用户体验。</p><p><code>Method Entry</code> 监听器是<code>Android</code>系统中的一种监听器，它可以用来监听应用程序的方法入口。当一个方法被调用时，系统会触发<code>Method Entry</code>监听器，并将当前线程、当前方法和调用栈信息等相关数据传递给监听器。</p><p><code>Android Studio</code>在调试模式下会自动为每个线程启动一个监听器，并在方法进入和退出时触发相应的事件。这些事件包括 <code>Method Entry</code>（方法入口）、<code>Method Exit</code>（方法出口）等。</p><p>​    下面将分别介绍<code>ExecuteMterpImpl</code>和<code>ExecuteSwitch</code>是如何实现指令流的执行。</p><h2><span id="74-executemterpimpl">7.4 ExecuteMterpImpl</span></h2><p><code>ExecuteMterpImpl</code>是基于<code>Mterp（Method Interpreter）</code>技术实现。<code>Mterp</code>技术使用指令集解释器来执行应用程序的代码，相比于<code>JIT</code>编译模式可以更快地启动和执行短小精悍的方法，同时也可以避免<code>JIT</code>编译带来的额外开销。</p><p>在<code>Mterp</code>模式下，<code>Dex </code>指令集被转化成了一组<code>C++</code>的函数，这些函数对应<code>Dex</code>指令集中的每一条指令。<code>ExecuteMterpImpl</code>实际上就是调用这些函数来逐条解释执行当前方法的指令集。</p><p>​    在<code>Android 4.4</code>中，系统首次引入了 <code>Mterp</code> 技术来加速应用程序的解释执行。在此之后的 <code>Android</code>版本中，<code>Mterp </code>技术得到了不断优化和完善，并逐渐成为<code>Android</code>平台的主要方法执行方式之一。</p><p>​    从<code>Android 6.0</code>开始，<code>Dalvik </code>运行时环境被弃用，取而代之的是<code>ART</code>运行时环境。<code>ART</code> 运行时环境可以通过<code>JIT</code>编译、<code>AOT </code>编译和<code>Mterp</code>等多种方式来执行应用程序的代码，其中<code>Mterp</code>技术被广泛使用于 <code>Android</code> 应用程序的解释执行过程中。但是对于某些特定的场景和应用程序，系统可能还是会选择其他的执行方式来获得更好的性能和效率。</p><p>​    <code>ExecuteMterpImpl</code>使用了汇编语言和<code> C++</code>语言混合编写，需要有一定的汇编和<code>C++</code>编程经验才能理解其含义和功能。该代码主要实现了以下功能：</p><p>​    1.保存当前方法的返回值寄存器和指令集</p><p>​    2.设置方法执行的环境和参数，包括<code>vregs</code>数组、<code>dex_pc </code>寄存器等</p><p>​    3.为当前方法设置热度倒计时，并根据热度值来判断是否需要启用<code>Mterp</code>技术</p><p>​    4.执行当前方法的指令集，逐条解释执行 <code>Dex </code>指令</p><p>​    下面看<code>ExecuteMterpImpl</code>实现代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从xPC寄存器中获取一条指令</span><br><span class="line">.macro FETCH_INST</span><br><span class="line">    ldrh    wINST, [xPC]</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从指令中获取操作码，指令最顶部2个字节就是操作码，所以这里拿操作码是 &amp; 0xff的意思</span><br><span class="line">.macro GET_INST_OPCODE reg</span><br><span class="line">    and     \reg, xINST, #255</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 跳转到操作码处理逻辑</span><br><span class="line">.macro GOTO_OPCODE reg</span><br><span class="line">    add     \reg, xIBASE, \reg, lsl #$&#123;handler_size_bits&#125;</span><br><span class="line">    br      \reg</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">ENTRY ExecuteMterpImpl</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    &#x2F;&#x2F; 保存寄存器信息</span><br><span class="line">    SAVE_TWO_REGS_INCREASE_FRAME xPROFILE, x27, 80</span><br><span class="line">    SAVE_TWO_REGS                xIBASE, xREFS, 16</span><br><span class="line">    SAVE_TWO_REGS                xSELF, xINST, 32</span><br><span class="line">    SAVE_TWO_REGS                xPC, xFP, 48</span><br><span class="line">    SAVE_TWO_REGS                fp, lr, 64</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fp寄存器指向栈顶</span><br><span class="line">    add     fp, sp, #64</span><br><span class="line"></span><br><span class="line">    &#x2F;* 记录对应返回值的寄存器 *&#x2F;</span><br><span class="line">    str     x3, [x2, #SHADOWFRAME_RESULT_REGISTER_OFFSET]</span><br><span class="line"></span><br><span class="line">    &#x2F;* 记录dex文件中的指令的指针 *&#x2F;</span><br><span class="line">    str     x1, [x2, #SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET]</span><br><span class="line"></span><br><span class="line">    mov     xSELF, x0</span><br><span class="line">    ldr     w0, [x2, #SHADOWFRAME_NUMBER_OF_VREGS_OFFSET]</span><br><span class="line">    add     xFP, x2, #SHADOWFRAME_VREGS_OFFSET     &#x2F;&#x2F; 计算局部变量表的偏移地址</span><br><span class="line">    add     xREFS, xFP, w0, uxtw #2                &#x2F;&#x2F; 计算局部变量引用表的偏移地址</span><br><span class="line">    ldr     w0, [x2, #SHADOWFRAME_DEX_PC_OFFSET]   &#x2F;&#x2F; 获取当前Dex中的PC</span><br><span class="line">    add     xPC, x1, w0, uxtw #1                   &#x2F;&#x2F; 将Dex PC转换为地址，并保存到寄存器xPC中</span><br><span class="line">    CFI_DEFINE_DEX_PC_WITH_OFFSET(CFI_TMP, CFI_DEX, 0)</span><br><span class="line">    EXPORT_PC&#x2F;&#x2F; 将Dex PC导出</span><br><span class="line"></span><br><span class="line">    &#x2F;* Starting ibase *&#x2F;</span><br><span class="line">    ldr     xIBASE, [xSELF, #THREAD_CURRENT_IBASE_OFFSET]</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set up for backwards branches &amp; osr profiling *&#x2F;</span><br><span class="line">    ldr     x0, [xFP, #OFF_FP_METHOD]&#x2F;&#x2F; 获取当前方法的方法指针</span><br><span class="line">    add     x1, xFP, #OFF_FP_SHADOWFRAME&#x2F;&#x2F; 计算拿到当前线程的栈帧</span><br><span class="line">    mov     x2, xSELF&#x2F;&#x2F; 将当前线程对象保存到寄存器x2中</span><br><span class="line">    bl      MterpSetUpHotnessCountdown &#x2F;&#x2F; 热度计数器调整</span><br><span class="line">    mov     wPROFILE, w0                &#x2F;&#x2F; 将热度计数器的宽度赋值给寄存器wPROFILE</span><br><span class="line"></span><br><span class="line">    &#x2F;* start executing the instruction at rPC *&#x2F;</span><br><span class="line">    FETCH_INST                          &#x2F;&#x2F; 获取下一条指令</span><br><span class="line">    GET_INST_OPCODE ip                  &#x2F;&#x2F; 从指令中获取操作码</span><br><span class="line">    GOTO_OPCODE ip                      &#x2F;&#x2F; 跳转到操作码处理逻辑</span><br><span class="line">    &#x2F;* NOTE: no fallthrough *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; cfi info continues, and covers the whole mterp implementation.</span><br><span class="line">    END ExecuteMterpImpl</span><br></pre></td></tr></table></figure><p>​    这些操作码可以通过<code>Opcodes</code>找到其对应的对应，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> OP_IPUT_CHAR                    = <span class="number">0x005e</span>;</span><br><span class="line">    <span class="keyword">int</span> OP_IPUT_SHORT                   = <span class="number">0x005f</span>;</span><br><span class="line">    <span class="keyword">int</span> OP_SGET                         = <span class="number">0x0060</span>;</span><br><span class="line">    <span class="keyword">int</span> OP_SGET_WIDE                    = <span class="number">0x0061</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    而在在汇编文件中，会有其对应操作码的具体实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%def field(helper&#x3D;&quot;&quot;):</span><br><span class="line">    .extern $helper</span><br><span class="line">    mov      x0, xPC                       &#x2F;&#x2F; arg0: 指令的地址</span><br><span class="line">    mov      x1, xINST                     &#x2F;&#x2F; arg1: 指令对应的16位数值</span><br><span class="line">    add      x2, xFP, #OFF_FP_SHADOWFRAME  &#x2F;&#x2F; arg2: ShadowFrame* sf</span><br><span class="line">    mov      x3, xSELF                     &#x2F;&#x2F; arg3: Thread* self</span><br><span class="line">    PREFETCH_INST 2                        &#x2F;&#x2F; 预备取下一条指令</span><br><span class="line">    bl       $helper   &#x2F;&#x2F; 调用 $helper 函数</span><br><span class="line">    cbz      x0, MterpPossibleException</span><br><span class="line">    ADVANCE 2</span><br><span class="line">    GET_INST_OPCODE ip                     &#x2F;&#x2F; 从指令中获取操作码</span><br><span class="line">    GOTO_OPCODE ip                         &#x2F;&#x2F; 跳转到操作码处理逻辑</span><br><span class="line"></span><br><span class="line">%def op_iput(helper&#x3D;&quot;MterpIPutU32&quot;):</span><br><span class="line">%  field(helper&#x3D;helper)</span><br><span class="line"></span><br><span class="line">%def op_sget(helper&#x3D;&quot;MterpSGetU32&quot;):</span><br><span class="line">%  field(helper&#x3D;helper)</span><br><span class="line"></span><br><span class="line">%def op_iput_char():</span><br><span class="line">%  op_iput(helper&#x3D;&quot;MterpIPutU16&quot;)</span><br><span class="line"></span><br><span class="line">%def op_iput_short():</span><br><span class="line">%  op_iput(helper&#x3D;&quot;MterpIPutI16&quot;)</span><br><span class="line"></span><br><span class="line">%def op_sget_wide():</span><br><span class="line">%  op_sget(helper&#x3D;&quot;MterpSGetU64&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    到这里，就找到对应的执行<code>C++</code>函数将<code>Dex</code>的指令逐一进行执行处理，其对应的<code>C++</code>执行部分则在文件<code>mterp.cc</code>文件中找到。<code>Mterp</code>的执行流程到这里就非常清晰了。</p><h2><span id="75-executeswitch">7.5 ExecuteSwitch</span></h2><p>​    <code>ExecuteSwitch</code>是基于 <code>switch </code>语句实现的一种解释器，用于执行当前方法的指令集。在 <code>Android</code> 应用程序中，每个方法都会对应一组指令集，用于描述该方法的具体实现。当该方法被调用时，系统需要按照指令集来执行相应的操作，从而实现该方法的功能并计算出结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> JValue <span class="title">ExecuteSwitch</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> CodeItemDataAccessor&amp; accessor,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ShadowFrame&amp; shadow_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                            JValue result_register,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">bool</span> interpret_one_instruction)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是否处于事务中</span></span><br><span class="line">  <span class="keyword">if</span> (Runtime::Current()-&gt;IsActiveTransaction()) &#123;</span><br><span class="line">    <span class="comment">// 是否跳过访问检查</span></span><br><span class="line">    <span class="keyword">if</span> (shadow_frame.GetMethod()-&gt;SkipAccessChecks()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">true</span>&gt;(</span><br><span class="line">          self, accessor, shadow_frame, result_register, interpret_one_instruction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">true</span>, <span class="literal">true</span>&gt;(</span><br><span class="line">          self, accessor, shadow_frame, result_register, interpret_one_instruction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shadow_frame.GetMethod()-&gt;SkipAccessChecks()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">false</span>&gt;(</span><br><span class="line">          self, accessor, shadow_frame, result_register, interpret_one_instruction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">true</span>, <span class="literal">false</span>&gt;(</span><br><span class="line">          self, accessor, shadow_frame, result_register, interpret_one_instruction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在这个函数中，根据条件调整参数，最终都是调用<code>ExecuteSwitchImpl</code>，下面继续看解释器的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> do_access_check, <span class="keyword">bool</span> transaction_active&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteSwitchImplCpp</span><span class="params">(SwitchImplContext* ctx)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 获取到当前正在执行的Dex指令在CodeItem中的索引位置</span></span><br><span class="line">  <span class="keyword">uint32_t</span> dex_pc = shadow_frame.GetDexPC();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>* <span class="keyword">const</span> instrumentation = Runtime::Current()-&gt;GetInstrumentation();</span><br><span class="line">  <span class="comment">// 获取指令流</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint16_t</span>* <span class="keyword">const</span> insns = accessor.Insns();</span><br><span class="line">  <span class="comment">// 将当前指令转换为专门用来操作指令的Instruction类</span></span><br><span class="line">  <span class="keyword">const</span> Instruction* next = Instruction::At(insns + dex_pc);</span><br><span class="line"></span><br><span class="line">  DCHECK(!shadow_frame.GetForceRetryInstruction())</span><br><span class="line">      &lt;&lt; <span class="string">&quot;Entered interpreter from invoke without retry instruction being handled!&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">const</span> interpret_one_instruction = ctx-&gt;interpret_one_instruction;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取下一条待执行的指令</span></span><br><span class="line">    <span class="keyword">const</span> Instruction* <span class="keyword">const</span> inst = next;</span><br><span class="line">    dex_pc = inst-&gt;GetDexPc(insns);</span><br><span class="line">    <span class="comment">// 更新pc位置</span></span><br><span class="line">    shadow_frame.SetDexPC(dex_pc);</span><br><span class="line">    TraceExecution(shadow_frame, inst, dex_pc);</span><br><span class="line">    <span class="comment">// 从指令中获取到操作码</span></span><br><span class="line">    <span class="keyword">uint16_t</span> inst_data = inst-&gt;Fetch16(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">exit</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> success;  <span class="comment">// Moved outside to keep frames small under asan.</span></span><br><span class="line">    <span class="comment">// 执行指令前的预处理</span></span><br><span class="line">    <span class="keyword">if</span> (InstructionHandler&lt;do_access_check, transaction_active, Instruction::kInvalidFormat&gt;(</span><br><span class="line">            ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, <span class="built_in">exit</span>).</span><br><span class="line">            Preamble()) &#123;</span><br><span class="line">      DCHECK_EQ(self-&gt;IsExceptionPending(), inst-&gt;Opcode(inst_data) == Instruction::MOVE_EXCEPTION);</span><br><span class="line">      <span class="comment">// 这是一个超大的switch，根据操作码来选择如何执行</span></span><br><span class="line">      <span class="keyword">switch</span> (inst-&gt;Opcode(inst_data)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_CASE(OPCODE, OPCODE_NAME, NAME, FORMAT, i, a, e, v)                                \</span></span><br><span class="line">        <span class="keyword">case</span> OPCODE: &#123;                                                                            \</span><br><span class="line">          next = inst-&gt;RelativeAt(Instruction::SizeInCodeUnits(Instruction::FORMAT));             \</span><br><span class="line">          success = OP_##OPCODE_NAME&lt;do_access_check, transaction_active&gt;(                        \</span><br><span class="line">              ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, <span class="built_in">exit</span>);     \</span><br><span class="line">          <span class="keyword">if</span> (success &amp;&amp; LIKELY(!interpret_one_instruction)) &#123;                                    \</span><br><span class="line">            <span class="keyword">continue</span>;                                                                             \</span><br><span class="line">          &#125;                                                                                       \</span><br><span class="line">          <span class="keyword">break</span>;                                                                                  \</span><br><span class="line">        &#125;</span><br><span class="line">  DEX_INSTRUCTION_LIST(OPCODE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OPCODE_CASE</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>switch</code>解释器，就是指的这个函数中，使用<code>switch</code>来对不同的所有操作码进行对应的处理，但是这里并没有看到非常大的<code>case</code>条件，这是因为代码都在<code>OPCODE_CASE</code>定义中，找到这个定义的实现如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_CASE(OPCODE, OPCODE_NAME, NAME, FORMAT, i, a, e, v)                                \</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> do_access_check, <span class="keyword">bool</span> transaction_active&gt;                                           \</span><br><span class="line">ASAN_NO_INLINE <span class="keyword">static</span> <span class="keyword">bool</span> OP_##OPCODE_NAME(                                                      \</span><br><span class="line">    SwitchImplContext* ctx,                                                                       \</span><br><span class="line">    <span class="keyword">const</span> instrumentation::Instrumentation* instrumentation,                                      \</span><br><span class="line">    Thread* self,                                                                                 \</span><br><span class="line">    ShadowFrame&amp; shadow_frame,                                                                    \</span><br><span class="line">    <span class="keyword">uint16_t</span> dex_pc,                                                                              \</span><br><span class="line">    <span class="keyword">const</span> Instruction* inst,                                                                      \</span><br><span class="line">    <span class="keyword">uint16_t</span> inst_data,                                                                           \</span><br><span class="line">    <span class="keyword">const</span> Instruction*&amp; next,                                                                     \</span><br><span class="line">    <span class="keyword">bool</span>&amp; <span class="built_in">exit</span>) REQUIRES_SHARED(Locks::mutator_lock_) &#123;                                           \</span><br><span class="line">  InstructionHandler&lt;do_access_check, transaction_active, Instruction::FORMAT&gt; handler(           \</span><br><span class="line">      ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, <span class="built_in">exit</span>);             \</span><br><span class="line">  <span class="keyword">return</span> LIKELY(handler.OPCODE_NAME());                                                           \</span><br><span class="line">&#125;</span><br><span class="line">DEX_INSTRUCTION_LIST(OPCODE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OPCODE_CASE</span></span><br></pre></td></tr></table></figure><p>​    可以看到内部是调用了初始化了一个<code>InstructionHandler</code>对象，然后<code>handler.OPCODE_NAME()</code>调用了对应的操作码函数。最后看看其实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstructionHandler</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="function">ALWAYS_INLINE <span class="title">InstructionHandler</span><span class="params">(SwitchImplContext* ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> instrumentation::Instrumentation* instrumentation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ShadowFrame&amp; shadow_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint16_t</span> dex_pc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> Instruction* inst,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint16_t</span> inst_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> Instruction*&amp; next,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">bool</span>&amp; exit_interpreter_loop)</span></span></span><br><span class="line">    : ctx_(ctx),</span><br><span class="line">      instrumentation_(instrumentation),</span><br><span class="line">      self_(self),</span><br><span class="line">      shadow_frame_(shadow_frame),</span><br><span class="line">      dex_pc_(dex_pc),</span><br><span class="line">      inst_(inst),</span><br><span class="line">      inst_data_(inst_data),</span><br><span class="line">      next_(next),</span><br><span class="line">      exit_interpreter_loop_(exit_interpreter_loop) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">HANDLER_ATTRIBUTES <span class="keyword">bool</span> <span class="title">INVOKE_STATIC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HandleInvoke&lt;kStatic, <span class="comment">/*is_range=*/</span> <span class="literal">false</span>&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">HANDLER_ATTRIBUTES <span class="keyword">bool</span> <span class="title">INVOKE_STATIC_RANGE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HandleInvoke&lt;kStatic, <span class="comment">/*is_range=*/</span> <span class="literal">true</span>&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有操作码对应的实现都是在<code>InstructionHandler</code>中进行实现，<code>switch</code>解释器的做法非常简单粗暴，尽量性能较差，但是可读性高，当需求是对调用流程进行打桩，或者定制修改时，可以选择强制其走<code>switch</code>解释器来执行该函数。</p><p>需要注意的是，在执行的优化中，当强制走解释器流程调用后，它会交给<code>JIT</code>编译器进行编译，生成本地机器码。在生成机器码的同时，<code>JIT</code>编译器会将该函数的入口地址设置为生成的机器码的地址。在下一次调用该函数时，虚拟机就会跳过解释器阶段，直接执行机器码，从而提高程序的执行效率。</p><h2><span id="76-本章小结">7.6 本章小结</span></h2><p>本章主要介绍了安卓系统中DEX文件的类的加载机制与细节。相比于实际操作动手修改代码，本章介绍的内容显示更加枯燥乏味，但是深入了解系统内部的运行机制，有助于更宏观视角的去理解的程序执行。掌握这一部分内容，在代码修改点的选择上，尤其是系统组件的部分代码，将会更加精准。而且，本章内容同样适合于二进制安全对抗研究领域，是研究软件加密与解密必不可少的基础知识。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[转]安卓系统定制：从入门到实践&lt;/strong&gt;&lt;/p&gt;
&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#71-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6&quot;&gt;7.1 双亲委派机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#72-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B&quot;&gt;7.2 类的加载流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#73-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B&quot;&gt;7.3 函数调用流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#74-executemterpimpl&quot;&gt;7.4 ExecuteMterpImpl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#75-executeswitch&quot;&gt;7.5 ExecuteSwitch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#76-%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93&quot;&gt;7.6 本章小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;

&lt;p&gt;在上一章中，我们学习了分析Android运行的执行流程，并找到合适的时机来插入业务逻辑代码，以实现特定功能。例如，在应用启动流程中，我们可以通过注入DEX文件或动态库文件来实现某些功能。通过native函数的注册流程，我们可以对静态注册和动态注册信息进行打桩输出。而通过解析AndroidManifest.xml文件的过程，则可以额外添加默认权限。&lt;/p&gt;
&lt;p&gt;在本章中，将详细介绍Android源码中加载类的执行流程。了解Android中类加载机制以及函数调用流程是非常重要的基础知识。通过学习这些执行流程原理，在定制功能时能为我们提供更多方向和思路。&lt;/p&gt;</summary>
    
    
    
    <category term="Android源码" scheme="http://example.com/categories/Android%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Android源码" scheme="http://example.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>第三章 认识系统组件</title>
    <link href="http://example.com/2025/04/07/chapter-03/"/>
    <id>http://example.com/2025/04/07/chapter-03/</id>
    <published>2025-04-07T03:45:54.000Z</published>
    <updated>2025-04-07T03:45:52.429Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[转]安卓系统定制：从入门到实践</strong></p><!-- toc --><ul><li><a href="#31-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D">3.1 源码结构介绍</a></li><li><a href="#32-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">3.2 Android系统启动流程</a></li><li><a href="#33-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8">3.3 内核启动</a></li><li><a href="#34-init%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8">3.4 Init进程启动</a></li><li><a href="#35-initrc">3.5 init.rc</a></li><li><a href="#36-zygote%E5%90%AF%E5%8A%A8">3.6 Zygote启动</a></li><li><a href="#37-android-app%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8">3.7 Android app应用启动</a></li><li><a href="#38-%E4%BA%86%E8%A7%A3service">3.8 了解Service</a></li><li><a href="#39-%E4%BA%86%E8%A7%A3framework">3.9 了解Framework</a></li><li><a href="#310-%E4%BA%86%E8%A7%A3libcore">3.10 了解libcore</a></li><li><a href="#311-%E4%BA%86%E8%A7%A3sepolicy">3.11 了解sepolicy</a></li><li><a href="#312-%E4%BA%86%E8%A7%A3linker">3.12 了解Linker</a><ul><li><a href="#3121-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">3.12.1 ELF文件格式</a></li><li><a href="#3122-%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B">3.12.2 动态库加载流程</a></li></ul></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li></ul><!-- tocstop --><p>在上一章的学习中，我们成功编译了<code>Android</code>12，以及对应的系统内核，并且通过多种方式刷入手机。接下来需要先对<code>Android</code>源码的根结构有一定的了解，了解结构有助于更快地定位和分析源码，同时能让开发人员更好地理解<code>Android</code>系统。在修改系统时，有些简单的功能（例如<code>native</code>中的文件读写、<code>java</code>类型的转换<code>c++</code>类型等）并不需要我们重新实现，因为这些需求大多数在<code>Android</code>系统源码中都有类似的实现，熟练掌握<code>Android</code>系统源码，了解系统中常用的那些功能性函数，可以大大提高定制系统的效率。</p><p><strong>在学习系统源码时，碰到问题，要学会暂时记录并跳过，经历过一遍遍学习和实践后，之前遇到的问题可能简单思考便会明白，这不仅节省了时间，也不会在学习过程中逐渐失去信心。</strong></p><a id="more"></a><h2><span id="31-源码结构介绍">3.1 源码结构介绍</span></h2><p>​    首先看看<code>Android</code>源码根目录下，各个目录的简单介绍。</p><ol><li><code>art</code>：该目录是在<code>Android</code> 5.0中新增加的，主要是实现<code>Android RunTime（ART）</code>的目录，它作为<code>Android</code> 4.4中的<code>Dalvik</code>虚拟机的替代，主要处理<code>Java</code>字节码执行。</li><li><code>bionic</code>：<code>Android</code>的<code>C</code>库，包含了很多标准的<code>C</code>库函数和头文件，还有一些<code>Android</code>特有的函数和头文件。</li><li><code>build</code>：该目录包含了编译<code>Android</code>源代码所需要的脚本，包括<code>makefile</code>文件和一些构建工具。</li><li><code>compatibility</code>：<code>Android</code>设备的兼容性测试套件<code>（CTS）</code>和兼容性实现<code>（Compatibility Implementation）</code>。</li><li><code>cts</code>：<code>Android</code>设备兼容性测试套件<code>（CTS）</code>，主要用来测试设备是否符合<code>Android</code>标准。</li><li><code>dalvik</code>：<code>Dalvik</code>虚拟机，它是<code>Android 2.3</code>版本之前的主要虚拟机，它主要处理<code>Java</code>字节码执行。</li><li><code>developers</code>：<code>Android</code>开发者文档和样例代码。</li><li><code>development</code>：调试工具，如<code>systrace、monkey、ddms</code>等。</li><li><code>device</code>：特定的<code>Android</code>设备的驱动程序。</li><li><code>external</code>：第三方库，如<code>WebKit、OpenGL</code>等。</li><li><code>frameworks</code>：<code>Android</code>应用程序调用底层服务的<code>API</code>。</li><li><code>hardware</code>：<code>Android</code>设备硬件相关的驱动代码，如摄像头驱动、蓝牙驱动等。</li><li><code>kernel</code>：<code>Android</code>系统内核的源代码，它是<code>Android</code>系统的核心部分。</li><li><code>libcore</code>：<code>Android</code>底层库，它提供了一些基本的<code>API</code>，如文件系统操作、网络操作等。</li><li><code>packages</code>：<code>Android</code>系统中的系统应用程序的源码，例如短信、电话、浏览器、相机等</li><li><code>pdk</code>：<code>Android</code>平台开发套件，它包含了一些工具和<code>API</code>，以便开发者快速开发Android应用程序。</li><li><code>platform_testing</code>：测试工具，用于测试<code>Android</code>平台的稳定性和性能。</li><li><code>prebuilts</code>：预先编译的文件，如编译工具、驱动程序等。</li><li><code>sdk</code>：<code>Android SDK</code>的源代码，<code>Android SDK</code>的<code>API</code>文档、代码示例、工具等。</li><li><code>system</code>：<code>Android</code>系统的核心部分，如系统服务、应用程序、内存管理机制、文件系统、网络协议等。</li><li><code>test</code>：测试代码，用于测试<code>Android</code>系统的各个组件。</li><li><code>toolchain</code>：编译器和工具链，如<code>GCC、Clang</code>等，用于编译<code>Android</code>源代码。</li><li><code>tools</code>：开发工具，如<code>Android SDK</code>工具、<code>Android Studio、Eclipse</code>等。</li><li><code>vendor</code>：硬件厂商提供的驱动程序，如摄像头驱动、蓝牙驱动等。</li></ol><p>​    在上述目录中，并不需要全部记下，只需要记住几个重点即可，例如<code>art、framework、libcore、system、build</code>。在实践时，为了实现功能，查阅翻读源码时，就会不断加深你对这些目录划分的了解。</p><h2><span id="32-android系统启动流程">3.2 Android系统启动流程</span></h2><p>​    <code>Android</code>系统启动主要分为四个阶段：<code>Bootloader</code>阶段、<code>Kernel</code>阶段、<code>Init</code>进程阶段和<code>System Server</code>启动阶段，下面看一下这几个阶段的启动流程。</p><ol><li><code>Bootloader</code>阶段： 当手机或平板电脑开机时，首先会执行引导加载程序（<code>Bootloader</code>），它会在手机的<code>ROM</code>中寻找启动内核（<code>Kernel</code>）的镜像文件，并将其加载进<code>RAM</code>。在这个阶段，<code>Android</code>系统并没有完全启动，只是建立了基本的硬件和内核环境。</li><li><code>Kernel</code>阶段： <code>Kernel</code>阶段是<code>Android</code>启动的第二阶段，它主要负责初始化硬件设备、加载驱动程序、设置内存管理等。此外，<code>Kernel</code>还会加载<code>initramfs</code>，它是一个临时文件系统，包含了<code>init</code>程序和一些设备文件。</li><li><code>Init</code>进程阶段： <code>Kernel</code>会启动<code>init</code>进程，它是<code>Android</code>系统中的第一个用户空间进程。<code>Init</code>进程的主要任务是读取<code>init.rc</code>文件，并根据该文件中的配置信息启动和配置<code>Android</code>系统的各个组件。在这个阶段中，系统会依次启动各个服务和进程，包括启动<code>Zygote</code>进程和创建<code>System Server</code>进程。</li><li><code>System Server</code>启动阶段： <code>System Server</code>是<code>Android</code>系统的核心服务进程，它会启动所有的系统服务。其中包括<code>Activity Manager、Package Manager、Window Manager、Location Manager、Telephony Manager、Wi-Fi Service、Bluetooth Service</code>等。<code>System Server</code>启动后，<code>Android</code>系统就完全启动了，用户可以进入桌面，开始使用各种应用程序。</li></ol><p>​    在开始启动流程代码追踪前，最重要的是不要试图了解所有细节过程，分析代码时要抓住需求重点，然后围绕着需求点来进行深入分析。尽管<code>Android</code>源码是一个非常庞大的体系，选择一个方向来熟悉代码，这样就能快速的达成目标，避免深陷代码泥沼。</p><h2><span id="33-内核启动">3.3 内核启动</span></h2><p>​    <code>Bootloader</code>其实是一段程序，这个程序的主要功能就是用来引导系统启动，也称之为引导程序，而这个引导程序是存放在一个只读的寄存器中，从物理地址0开始的一段空间分配给了这个只读存储器来存放引导程序。</p><p>​    <code>Bootloader</code>会初始化硬件设备并准备内存空间映射，为启动内核准备环境。然后寻找内核的镜像文件，验证<code>boot</code>分区和<code>recovery</code>分区的完整性，然后将其加载到内存中，最后开始执行内核。可以通过命令<code>adb reboot bootloader</code>直接重启进入引导程序。</p><p>​    <code>Bootloader</code>初始化完成后，会在特定的物理地址处查找<code>EFI</code>引导头（<code>efi_head</code>）。如果查找到<code>EFI</code>引导头，<code>bootloader</code>就会加载<code>EFI</code>引导头指定的<code>EFI</code>引导程序，然后开始执行<code>EFI</code>引导程序，以进行后续的<code>EFI</code>引导流程。而这个<code>efi_head</code>就是<code>linux</code>内核最早的入口了。</p><p>​    不做系统引导开发的朋友，并不需要完全看懂内核中的汇编部分代码，了解其执行的流程即可，因此不需要读者有汇编的功底，只需要能看懂简单的几个指令即可。打开编译内核源码时的目录，找到文件<code>android-kernel/private/msm-google/arch/arm64/kernel/head.S</code>，查看其汇编代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__HEAD</span><br><span class="line">_head:</span><br><span class="line">&#x2F;*</span><br><span class="line"> * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">&#x2F;*</span><br><span class="line"> * This add instruction has no meaningful effect except that</span><br><span class="line"> * its opcode forms the magic &quot;MZ&quot; signature required by UEFI.</span><br><span class="line"> *&#x2F;</span><br><span class="line">addx13, x18, #0x16</span><br><span class="line">bstext</span><br><span class="line">#else</span><br><span class="line">bstext&#x2F;&#x2F; branch to kernel start, magic</span><br></pre></td></tr></table></figure><p>​    在<code>arm</code>指令集中，指令<code>b</code>表示跳转，所以，继续找到<code>stext</code>的定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * The following callee saved general purpose registers are used on the</span><br><span class="line"> * primary lowlevel boot path:</span><br><span class="line"> *</span><br><span class="line"> *  Register   Scope                      Purpose</span><br><span class="line"> *  x21        stext() .. start_kernel()  FDT pointer passed at boot in x0</span><br><span class="line"> *  x23        stext() .. start_kernel()  physical misalignment&#x2F;KASLR offset</span><br><span class="line"> *  x28        __create_page_tables()     callee preserved temp register</span><br><span class="line"> *  x19&#x2F;x20    __primary_switch()         callee preserved temp registers</span><br><span class="line"> *&#x2F;</span><br><span class="line">ENTRY(stext)</span><br><span class="line">blpreserve_boot_args&#x2F;&#x2F; 把引导程序传的4个参数保存在全局数组boot_args</span><br><span class="line">blel2_setup&#x2F;&#x2F; Drop to EL1, w0&#x3D;cpu_boot_mode</span><br><span class="line">adrpx23, __PHYS_OFFSET</span><br><span class="line">andx23, x23, MIN_KIMG_ALIGN - 1&#x2F;&#x2F; KASLR offset, defaults to 0</span><br><span class="line">blset_cpu_boot_mode_flag</span><br><span class="line">bl__create_page_tables&#x2F;&#x2F; 创建页表映射 x25&#x3D;TTBR0, x26&#x3D;TTBR1</span><br><span class="line">&#x2F;*</span><br><span class="line"> * The following calls CPU setup code, see arch&#x2F;arm64&#x2F;mm&#x2F;proc.S for</span><br><span class="line"> * details.</span><br><span class="line"> * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class="line"> * the TCR will have been set.</span><br><span class="line"> *&#x2F;</span><br><span class="line">bl__cpu_setup&#x2F;&#x2F; &#x2F;&#x2F; 初始化处理器 initialise processor</span><br><span class="line">b__primary_switch</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure><p>​    能看到最后一行是跳转到<code>__primary_switch</code>，接下来继续看它的实现代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__primary_switch:</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">movx19, x0&#x2F;&#x2F; preserve new SCTLR_EL1 value</span><br><span class="line">mrsx20, sctlr_el1&#x2F;&#x2F; preserve old SCTLR_EL1 value</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">bl__enable_mmu</span><br><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">ldrx8, &#x3D;__primary_switched&#x2F;&#x2F;将x8设置成__primary_switched的地址</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">blrx8&#x2F;&#x2F;调用__primary_switched</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * If we return here, we have a KASLR displacement in x23 which we need</span><br><span class="line"> * to take into account by discarding the current kernel mapping and</span><br><span class="line"> * creating a new one.</span><br><span class="line"> *&#x2F;</span><br><span class="line">msrsctlr_el1, x20&#x2F;&#x2F; disable the MMU</span><br><span class="line">isb</span><br><span class="line">bl__create_page_tables&#x2F;&#x2F; recreate kernel mapping</span><br><span class="line"></span><br><span class="line">tlbivmalle1&#x2F;&#x2F; Remove any stale TLB entries</span><br><span class="line">dsbnsh</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">msrsctlr_el1, x19&#x2F;&#x2F; re-enable the MMU</span><br><span class="line">isb</span><br><span class="line">iciallu&#x2F;&#x2F; flush instructions fetched</span><br><span class="line">dsbnsh&#x2F;&#x2F; via old mapping</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">ldrx8, &#x3D;__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">brx8</span><br><span class="line">ENDPROC(__primary_switch)</span><br></pre></td></tr></table></figure><p>​    继续跟踪<code>__primary_switched</code>函数，就能看到调用重点函数<code>start_kernel</code>了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">__primary_switched:</span><br><span class="line">adrpx4, init_thread_union</span><br><span class="line">addsp, x4, #THREAD_SIZE</span><br><span class="line">adr_lx5, init_task</span><br><span class="line">msrsp_el0, x5&#x2F;&#x2F; Save thread_info</span><br><span class="line"></span><br><span class="line">adr_lx8, vectors&#x2F;&#x2F; load VBAR_EL1 with virtual</span><br><span class="line">msrvbar_el1, x8&#x2F;&#x2F; vector table address</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">stpxzr, x30, [sp, #-16]!</span><br><span class="line">movx29, sp</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SHADOW_CALL_STACK</span><br><span class="line">adr_lx18, init_shadow_call_stack&#x2F;&#x2F; Set shadow call stack</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">str_lx21, __fdt_pointer, x5&#x2F;&#x2F; Save FDT pointer</span><br><span class="line"></span><br><span class="line">ldr_lx4, kimage_vaddr&#x2F;&#x2F; Save the offset between</span><br><span class="line">subx4, x4, x0&#x2F;&#x2F; the kernel virtual and</span><br><span class="line">str_lx4, kimage_voffset, x5&#x2F;&#x2F; physical mappings</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Clear BSS</span><br><span class="line">adr_lx0, __bss_start</span><br><span class="line">movx1, xzr</span><br><span class="line">adr_lx2, __bss_stop</span><br><span class="line">subx2, x2, x0</span><br><span class="line">bl__pi_memset</span><br><span class="line">dsbishst&#x2F;&#x2F; Make zero page visible to PTW</span><br><span class="line">#ifdef CONFIG_KASAN</span><br><span class="line">blkasan_early_init</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">tstx23, ~(MIN_KIMG_ALIGN - 1)&#x2F;&#x2F; already running randomized?</span><br><span class="line">b.ne0f</span><br><span class="line">movx0, x21&#x2F;&#x2F; pass FDT address in x0</span><br><span class="line">movx1, x23&#x2F;&#x2F; pass modulo offset in x1</span><br><span class="line">blkaslr_early_init&#x2F;&#x2F; parse FDT for KASLR options</span><br><span class="line">cbzx0, 0f&#x2F;&#x2F; KASLR disabled? just proceed</span><br><span class="line">orrx23, x23, x0&#x2F;&#x2F; record KASLR offset</span><br><span class="line">ldpx29, x30, [sp], #16&#x2F;&#x2F; we must enable KASLR, return</span><br><span class="line">ret&#x2F;&#x2F; to __primary_switch()</span><br><span class="line">0:</span><br><span class="line">#endif</span><br><span class="line">bstart_kernel&#x2F;&#x2F; 内核的入口函数</span><br><span class="line">ENDPROC(__primary_switched)</span><br></pre></td></tr></table></figure><p>​    上面能看到最后一个指令就是调用<code>start_kernel</code>了，这个函数是内核的入口函数，同时也是<code>C</code>语言部分的入口函数。接下来，查看文件<code>android-kernel/private/msm-google/init/main.c</code>，可以看到其中大量的<code>init</code>初始化各种子系统的函数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加载各种子系统</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">rest_init();</span><br><span class="line"></span><br><span class="line">prevent_tail_call_optimization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    继续追踪关键的函数<code>rest_init</code>，在这里开启的内核初始化线程以及创建内核线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">void</span> __ref <span class="title">rest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">numa_default_policy();</span><br><span class="line">pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    继续看看<code>kernel_init</code>内核初始化线程的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __ref <span class="title">kernel_init</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">ret = run_init_process(ramdisk_execute_command);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">       ramdisk_execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在这里，看到了原来<code>init</code>进程是用<code>run_init_process</code>启动的，<code>ramdisk_execute_command</code>被初始化为了”/init”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_run_init_process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = run_init_process(init_filename);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; ret != -ENOENT) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;Starting init: %s exists but couldn&#x27;t execute it (error %d)\n&quot;</span>,</span><br><span class="line">       init_filename, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单包装调用的<code>run_init_process</code>，继续看下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run_init_process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">argv_init[<span class="number">0</span>] = init_filename;</span><br><span class="line"><span class="keyword">return</span> do_execve(getname_kernel(init_filename),</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)argv_init,</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)envp_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里能看到最后是通过<code>execve</code>拉起来了系统的第一个进程，<code>init</code>进程。总结内核启动的简单流程图如下。</p><p><img src="/2025/04/07/chapter-03/startkernel.png" alt="startkernel"></p><h2><span id="34-init进程启动">3.4 Init进程启动</span></h2><p>​    <code>init</code>进程是<code>Android</code>系统的第一个进程，它在系统启动之后就被启动，并且一直运行到系统关闭，它是<code>Android</code>系统的核心进程，隶属于系统进程，具有最高的权限，所有的其他进程都是它的子进程，它的主要功能有以下几点：</p><p>​     1、启动<code>Android</code>系统的基础服务：<code>init</code>进程负责启动<code>Android</code>系统的基础服务。</p><p>​     2、管理系统进程：<code>init</code>进程管理系统进程，比如启动和关闭系统进程。</p><p>​     3、加载设备驱动：<code>init</code>进程会加载设备的驱动，使设备可以正常使用。</p><p>​     4、加载系统环境变量：<code>init</code>进程会加载系统所需要的环境变量，如<code>PATH、LD_LIBRARY_PATH</code>等。</p><p>​     5、加载系统配置文件：<code>init</code>进程会加载系统所需要的配置文件。</p><p>​     6、启动用户进程：<code>init</code>进程会启动用户进程，如桌面程序、默认浏览器等。</p><p>​    <code>init</code>进程的入口是在<code>Android</code>源码的<code>system/core/init/main.cpp</code>。下面，看看入口函数的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(address_sanitizer)</span></span><br><span class="line">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// Boost prio which will be restored later</span></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, <span class="number">-20</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">&quot;ueventd&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;subcontext&quot;</span>)) &#123;</span><br><span class="line">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 第二步 装载selinux策略</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SetupSelinux(argv);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;second_stage&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SecondStageMain(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 第一步 挂载设备节点，初次进入没有参数将执行这里</span></span><br><span class="line">    <span class="keyword">return</span> FirstStageMain(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    根据上一章的启动<code>init</code>的参数，可以判断第一次启动时执行的是<code>FirstStageMain</code>函数，继续看看这个函数的实现，可以看到初始化了一些基础系统支持的目录，以及使用<code>mount</code>进行挂载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    CHECKCALL(clearenv());</span><br><span class="line">    CHECKCALL(setenv(<span class="string">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line">    <span class="comment">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="string">&quot;mode=0755&quot;</span>));</span><br><span class="line">    CHECKCALL(mkdir(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mkdir(<span class="string">&quot;/dev/socket&quot;</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mkdir(<span class="string">&quot;/dev/dm-user&quot;</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="string">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAKE_STR</span></span><br><span class="line">    <span class="comment">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class="line">    CHECKCALL(chmod(<span class="string">&quot;/proc/cmdline&quot;</span>, <span class="number">0440</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cmdline;</span><br><span class="line">    android::base::ReadFileToString(<span class="string">&quot;/proc/cmdline&quot;</span>, &amp;cmdline);</span><br><span class="line">    <span class="comment">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class="line">    chmod(<span class="string">&quot;/proc/bootconfig&quot;</span>, <span class="number">0440</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootconfig;</span><br><span class="line">    android::base::ReadFileToString(<span class="string">&quot;/proc/bootconfig&quot;</span>, &amp;bootconfig);</span><br><span class="line">    <span class="keyword">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class="line">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;selinuxfs&quot;</span>, <span class="string">&quot;/sys/fs/selinux&quot;</span>, <span class="string">&quot;selinuxfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class="number">0600</span>, makedev(<span class="number">1</span>, <span class="number">11</span>)));</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 重新调用拉起init进程，并且参数设置为selinux_setup</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;/system/bin/init&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">&quot;selinux_setup&quot;</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> fd = open(<span class="string">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">// 使用execv再次调用init进程</span></span><br><span class="line">    execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">    <span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">    PLOG(FATAL) &lt;&lt; <span class="string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;) failed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在目录初始化完成后又拉起了一个<code>init</code>进程，并且传入参数<code>selinux_setup</code>，接下来，直接看前面<code>main</code>入口函数中判断出现该参数时调用的<code>SetupSelinux</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetupSelinux</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">&quot;Opening SELinux policy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the policy before potentially killing snapuserd.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> policy;</span><br><span class="line">    ReadPolicy(&amp;policy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> snapuserd_helper = SnapuserdSelinuxHelper::CreateIfNeeded();</span><br><span class="line">    <span class="keyword">if</span> (snapuserd_helper) &#123;</span><br><span class="line">        <span class="comment">// Kill the old snapused to avoid audit messages. After this we cannot</span></span><br><span class="line">        <span class="comment">// read from /system (or other dynamic partitions) until we call</span></span><br><span class="line">        <span class="comment">// FinishTransition().</span></span><br><span class="line">        snapuserd_helper-&gt;StartTransition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LoadSelinuxPolicy(policy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snapuserd_helper) &#123;</span><br><span class="line">        <span class="comment">// Before enforcing, finish the pending snapuserd transition.</span></span><br><span class="line">        snapuserd_helper-&gt;FinishTransition();</span><br><span class="line">        snapuserd_helper = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SelinuxSetEnforcement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;re in the kernel domain and want to transition to the init domain.  File systems that</span></span><br><span class="line">    <span class="comment">// store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,</span></span><br><span class="line">    <span class="comment">// but other file systems do.  In particular, this is needed for ramdisks such as the</span></span><br><span class="line">    <span class="comment">// recovery image for A/B devices.</span></span><br><span class="line">    <span class="keyword">if</span> (selinux_android_restorecon(<span class="string">&quot;/system/bin/init&quot;</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">&quot;restorecon failed of /system/bin/init failed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setenv(kEnvSelinuxStartedAt, <span class="built_in">std</span>::to_string(start_time.time_since_epoch().count()).c_str(), <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 继续再拉起一个init进程,参数设置second_stage</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;/system/bin/init&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">&quot;second_stage&quot;</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">    <span class="comment">// panic and never return from this function.</span></span><br><span class="line">    PLOG(FATAL) &lt;&lt; <span class="string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;) failed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面的代码可以看到，在完成<code>selinux</code>的加载处理后，又拉起了一个<code>init</code>进程，并且传入参数<code>second_stage</code>。接下来，看第三步<code>SecondStageMain</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 初始化属性系统</span></span><br><span class="line">    PropertyInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启属性服务</span></span><br><span class="line">    StartPropertyService(&amp;property_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析init.rc 以及启动其他相关进程</span></span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    继续跟踪<code>LoadBootScripts</code>函数，了解它是如何解析执行<code>init.rc</code>文件的。（修改的意思是否正确？）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootscript = GetProperty(<span class="string">&quot;ro.boot.init_rc&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootscript.empty()) &#123;</span><br><span class="line">        <span class="comment">// 解析各目录中的init.rc</span></span><br><span class="line">        parser.ParseConfig(<span class="string">&quot;/system/etc/init/hw/init.rc&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">&quot;/system/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// late_import is available only in Q and earlier release. As we don&#x27;t</span></span><br><span class="line">        <span class="comment">// have system_ext in those versions, skip late_import for system_ext.</span></span><br><span class="line">        parser.ParseConfig(<span class="string">&quot;/system_ext/etc/init&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">&quot;/vendor/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">&quot;/odm/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">&quot;/product/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    继续看看解析的逻辑，可以看到参数可以是目录或者文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfig</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;</span><br><span class="line">        <span class="keyword">return</span> ParseConfigDir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ParseConfigFile(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果是目录，则遍历所有文件再调用解析文件，所以直接看<code>ParseConfigFile</code>就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ParseData(path, &amp;config_contents.value());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后看看<code>ParseData</code>是如何解析数据的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::ParseData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="built_in">std</span>::<span class="built_in">string</span>* data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">            <span class="keyword">case</span> T_EOF:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> T_NEWLINE: &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line">                    <span class="comment">// 从section_parsers_中获取出来的</span></span><br><span class="line">                    section_parser = section_parsers_[args[<span class="number">0</span>]].get();</span><br><span class="line">                    section_start_line = state.line;</span><br><span class="line">                    <span class="comment">// 使用了ParseSection进行解析</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                                section_parser-&gt;ParseSection(<span class="built_in">std</span>::move(args), filename, state.line);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; state.line &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; result.error();</span><br><span class="line">                        section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">                        bad_section_found = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                    <span class="comment">// 使用了ParseLineSection进行解析</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result = section_parser-&gt;ParseLineSection(<span class="built_in">std</span>::move(args), state.line);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; state.line &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> T_TEXT:</span><br><span class="line">                args.emplace_back(state.text);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    简单解读一下这里的代码，首先这里看到从<code>section_parsers_</code>中取出对应的节点解析对象<code>section_parser</code>，通过<code>section_parser</code>执行<code>ParseSection</code>或者<code>ParseLineSection</code>函数解析<code>.rc</code>文件中的数据。所以需要了解<code>section_parsers_</code>中存储的是什么，查看函数<code>CreateParser</code>就明白了。所谓的节点解析对象，就是<code>ServiceParser、ActionParser、ImportParser</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::AddSectionParser</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SectionParser&gt; parser)</span> </span>&#123;</span><br><span class="line">    section_parsers_[name] = <span class="built_in">std</span>::move(parser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Parser <span class="title">CreateParser</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser;</span><br><span class="line"></span><br><span class="line">    parser.AddSectionParser(<span class="string">&quot;service&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;(</span><br><span class="line">                                               &amp;service_list, GetSubcontext(), <span class="built_in">std</span>::nullopt));</span><br><span class="line">    parser.AddSectionParser(<span class="string">&quot;on&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;(&amp;action_manager, GetSubcontext()));</span><br><span class="line">    parser.AddSectionParser(<span class="string">&quot;import&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;(&amp;parser));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果了解过<code>init.rc</code>文件格式的，看到这里就很眼熟了，这就是<code>.rc</code>文件中配置时使用的节点名称了。它们的功能的简单描述如下。</p><ol><li><p><code>service</code>    定义一个服务</p></li><li><p><code>on</code>                触发某个<code>action</code>时，执行对应的指令</p></li><li><p><code>import</code>      表示导入另外一个<code>rc</code>文件</p></li></ol><p>​    再解读上面的代码就是，根据<code>rc</code>文件的配置不同，使用<code>ServiceParser</code>、<code>ActionParser</code>、<code>ImportParser</code>这三种节点解析对象的<code>ParseSection</code>或者<code>ParseLineSection</code>函数来处理（这句不完整？）。继续看看这三个对象的解析函数实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service节点的解析处理</span></span><br><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">ServiceParser::ParseSection</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.size() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;services must have a name and a program&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!IsValidName(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;invalid service name &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filename_ = filename;</span><br><span class="line"></span><br><span class="line">    Subcontext* restart_action_subcontext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (subcontext_ &amp;&amp; subcontext_-&gt;PathMatchesSubcontext(filename)) &#123;</span><br><span class="line">        restart_action_subcontext = subcontext_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">str_args</span><span class="params">(args.begin() + <span class="number">2</span>, args.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SelinuxGetVendorAndroidVersion() &lt;= __ANDROID_API_P__) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str_args[<span class="number">0</span>] == <span class="string">&quot;/sbin/watchdogd&quot;</span>) &#123;</span><br><span class="line">            str_args[<span class="number">0</span>] = <span class="string">&quot;/system/bin/watchdogd&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (SelinuxGetVendorAndroidVersion() &lt;= __ANDROID_API_Q__) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str_args[<span class="number">0</span>] == <span class="string">&quot;/charger&quot;</span>) &#123;</span><br><span class="line">            str_args[<span class="number">0</span>] = <span class="string">&quot;/system/bin/charger&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    service_ = <span class="built_in">std</span>::make_unique&lt;Service&gt;(name, restart_action_subcontext, str_args, from_apex_);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// on 节点的解析处理</span></span><br><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">ActionParser::ParseSection</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">triggers</span><span class="params">(args.begin() + <span class="number">1</span>, args.end())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (triggers.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;Actions must have a trigger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Subcontext* action_subcontext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (subcontext_ &amp;&amp; subcontext_-&gt;PathMatchesSubcontext(filename)) &#123;</span><br><span class="line">        action_subcontext = subcontext_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> event_trigger;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; property_triggers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                ParseTriggers(triggers, action_subcontext, &amp;event_trigger, &amp;property_triggers);</span><br><span class="line">        !result.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;ParseTriggers() failed: &quot;</span> &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> action = <span class="built_in">std</span>::make_unique&lt;Action&gt;(<span class="literal">false</span>, action_subcontext, filename, line, event_trigger,</span><br><span class="line">                                           property_triggers);</span><br><span class="line"></span><br><span class="line">    action_ = <span class="built_in">std</span>::move(action);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import节点的解析处理</span></span><br><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">ImportParser::ParseSection</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.size() != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;single argument needed for import\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> conf_file = ExpandProps(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!conf_file.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;Could not expand import: &quot;</span> &lt;&lt; conf_file.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">&quot;Added &#x27;&quot;</span> &lt;&lt; *conf_file &lt;&lt; <span class="string">&quot;&#x27; to import list&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (filename_.empty()) filename_ = filename;</span><br><span class="line">    imports_.emplace_back(<span class="built_in">std</span>::move(*conf_file), line);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    到这里大致的<code>init</code>进程的启动流程相信大家已经有了一定了解。明白<code>init</code>的原理后，对于<code>init.rc</code>相信大家已经有了简单的印象，接下来将详细展开讲解<code>init.rc</code>文件。</p><h2><span id="35-initrc">3.5 init.rc</span></h2><p>​    <code>init.rc</code>是<code>Android</code>系统中的一个脚本文件而并非配置文件，是一种名为<code>Android Init Language</code>的脚本语言写成的文件，当然也可以简单当作配置文件来理解，主要用于启动和管理<code>Android</code>上的其他进程以对系统进行初始化工作。</p><p>​    将<code>init.rc</code>看作是<code>init</code>进程功能的动态延申，一些可能需要改动的初始化系统任务就放在配置文件中，然后读取配置解析后再进行初始化执行，如此可以提高一定的灵活性，相信很多开发人员在工作中都有做过类似的封装。而<code>init.rc</code>就是配置文件的入口，在<code>init.rc</code>中通过<code>import</code>节点来导入其他的配置文件，所以这些文件都可以算是<code>init.rc</code>的一部分。在上一章（确定是章？），通过了解<code>init</code>进程的工作流程，明白了解析<code>init.rc</code>文件的过程。</p><p>​    <code>init.rc</code>是由多个<code>section</code>节点组成的，而节点的类型分别主要是<code>service、on、import</code>三种。上一节中，有简单的介绍，它们的作用分别是定义服务、事件触发、导入其他<code>rc</code>文件。下面，来看<code>init.rc</code>文件中的几个例子，查看文件<code>system/core/rootdir/init.rc</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入另一个rc文件</span><br><span class="line">import &#x2F;init.environ.rc</span><br><span class="line">import &#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.usb.rc</span><br><span class="line">import &#x2F;init.$&#123;ro.hardware&#125;.rc</span><br><span class="line">import &#x2F;vendor&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.$&#123;ro.hardware&#125;.rc</span><br><span class="line">import &#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.usb.configfs.rc</span><br><span class="line">import &#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.$&#123;ro.zygote&#125;.rc</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 当初始化触发时,执行section下的命令</span><br><span class="line">on init</span><br><span class="line">    sysclktz 0</span><br><span class="line"></span><br><span class="line">    # Mix device-specific information into the entropy pool</span><br><span class="line">    copy &#x2F;proc&#x2F;cmdline &#x2F;dev&#x2F;urandom</span><br><span class="line">    copy &#x2F;system&#x2F;etc&#x2F;prop.default &#x2F;dev&#x2F;urandom</span><br><span class="line"></span><br><span class="line">    symlink &#x2F;proc&#x2F;self&#x2F;fd&#x2F;0 &#x2F;dev&#x2F;stdin</span><br><span class="line">    symlink &#x2F;proc&#x2F;self&#x2F;fd&#x2F;1 &#x2F;dev&#x2F;stdout</span><br><span class="line">    symlink &#x2F;proc&#x2F;self&#x2F;fd&#x2F;2 &#x2F;dev&#x2F;stderr</span><br><span class="line"></span><br><span class="line">    # Create energy-aware scheduler tuning nodes</span><br><span class="line">    mkdir &#x2F;dev&#x2F;stune&#x2F;foreground</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当属性ro.debuggable变更为1时触发section内的命令</span><br><span class="line">on property:ro.debuggable&#x3D;1</span><br><span class="line">    # Give writes to anyone for the trace folder on debug builds.</span><br><span class="line">    # The folder is used to store method traces.</span><br><span class="line">    chmod 0773 &#x2F;data&#x2F;misc&#x2F;trace</span><br><span class="line">    # Give reads to anyone for the window trace folder on debug builds.</span><br><span class="line">    chmod 0775 &#x2F;data&#x2F;misc&#x2F;wmtrace</span><br><span class="line">    # Give reads to anyone for the accessibility trace folder on debug builds.</span><br><span class="line">    chmod 0775 &#x2F;data&#x2F;misc&#x2F;a11ytrace</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义系统服务 服务名称ueventd  服务路径&#x2F;system&#x2F;bin&#x2F;ueventd</span><br><span class="line">&#x2F;&#x2F; 服务类型core，关机行为critical，安全标签u:r:ueventd:s0</span><br><span class="line">service ueventd &#x2F;system&#x2F;bin&#x2F;ueventd</span><br><span class="line">    class core</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br><span class="line">    shutdown critical</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义系统服务 服务名称console 服务路径&#x2F;system&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;&#x2F; 服务类型core 服务状态disabled 服务所属用户shell 服务所属组shell log readproc</span><br><span class="line">&#x2F;&#x2F; 安全标签u:r:shell:s0 设置环境变量HOSTNAME console</span><br><span class="line">service console &#x2F;system&#x2F;bin&#x2F;sh</span><br><span class="line">    class core</span><br><span class="line">    console</span><br><span class="line">    disabled</span><br><span class="line">    user shell</span><br><span class="line">    group shell log readproc</span><br><span class="line">    seclabel u:r:shell:s0</span><br><span class="line">    setenv HOSTNAME console</span><br></pre></td></tr></table></figure><p>​    看完各种节点的样例后，大概了解<code>init.rc</code>中应该如何添加一个<code>section</code>了。<code>import</code>非常简单，只需要指定一个<code>rc</code>文件的路径即可。<code>on</code>节点在源码中，看到对应的处理是<code>ActionParser</code>，这个节点就是当触发了一个<code>Action</code>的事件后就自上而下，依次执行节点下的所有命令，所以，就得了解一下一共有哪些<code>Action</code>事件提供使用。详细介绍参考自<code>http://www.gaohaiyan.com/4047.html</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">on boot                     #系统启动触发</span><br><span class="line">on early-init               #在初始化之前触发</span><br><span class="line">on init                     #在初始化时触发（在启动配置文件&#x2F;init.conf被装载之后）</span><br><span class="line">on late-init                #在初始化晚期阶段触发</span><br><span class="line">on charger                  #当充电时触发</span><br><span class="line">on property:&lt;key&gt;&#x3D;&lt;value&gt;   #当属性值满足条件时触发</span><br><span class="line">on post-fs                  #挂载文件系统</span><br><span class="line">on post-fs-data             #挂载data</span><br><span class="line">on device-added-&lt;path&gt;      #在指定设备被添加时触发</span><br><span class="line">on device-removed-&lt;path&gt;    #在指定设备被移除时触发</span><br><span class="line">on service-exited-&lt;name&gt;    #在指定service退出时触发</span><br><span class="line">on &lt;name&gt;&#x3D;&lt;value&gt;           #当属性&lt;name&gt;等于&lt;value&gt;时触发</span><br></pre></td></tr></table></figure><p>​    在触发<code>Action</code>事件后可以执行的命令如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">chdir &lt;dirc&gt;                                  更改工作目录为&lt;dirc&gt;</span><br><span class="line">chmod &lt;octal-mode&gt; &lt;path&gt;                     更改文件访问权限</span><br><span class="line">chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;                  更改文件所有者和组群</span><br><span class="line">chroot &lt;direc&gt;                                更改根目录位置</span><br><span class="line">class_start &lt;serviceclass&gt;                    如果它们不在运行状态的话，启动由&lt;serviceclass&gt;类名指定的所有相关服务</span><br><span class="line">class_stop &lt;serviceclass&gt;                     如果它们在运行状态的话，停止</span><br><span class="line">domainname &lt;name&gt;                             设置域名</span><br><span class="line">exec &lt;path&gt; [ &lt;argument&gt; ]*                   fork并执行一个程序，其路径为&lt;path&gt;，这条命令将阻塞直到该程序启动完成，因此它有可能造成init程序在某个节点不停地等待</span><br><span class="line">export &lt;name&gt; &lt;value&gt;                         设置某个环境变量&lt;name&gt;的值为&lt;value&gt;，这是对全局有效的，即其后所有进程都将继承这个变量</span><br><span class="line">hostname &lt;name&gt;                               设置主机名</span><br><span class="line">ifup &lt;interface&gt;                              使网络接口&lt;interface&gt;成功连接</span><br><span class="line">import &lt;filename&gt;                             引入一个名为&lt;filename&gt;的文件</span><br><span class="line">insmod &lt;path&gt;                                 在&lt;path&gt;路径上安装一个模块</span><br><span class="line">mkdir &lt;path&gt; [mode] [owner] [group]           在&lt;path&gt;路径上新建一个目录</span><br><span class="line">mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [&lt;mountoption&gt;]*  尝试在指定路径上挂载一个设备</span><br><span class="line">setprop &lt;name&gt; &lt;value&gt;                        设置系统属性&lt;name&gt;的值为&lt;value&gt;</span><br><span class="line">setrlinit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;              设置一种资源的使用限制。这个概念亦存在于Linux系统中，&lt;cur&gt;表示软限制，&lt;max&gt;表示硬限制</span><br><span class="line">start &lt;service&gt;                               启动一个服务</span><br><span class="line">stop &lt;service&gt;                                停止一个服务</span><br><span class="line">symlink &lt;target&gt; &lt;path&gt;                       创建一个&lt;path&gt;路径的软链接，目标为&lt;target&gt;</span><br><span class="line">sysclk &lt;mins_west_of_gmt&gt;                     设置基准时间，如果当前时间时GMT，这个值是0</span><br><span class="line">trigger &lt;event&gt;                               触发一个事件</span><br><span class="line">write &lt;path&gt; &lt;string&gt; [&lt;string&gt;]*             打开一个文件，并写入字符串</span><br></pre></td></tr></table></figure><p>​    而<code>service</code>节点主要是将可执行程序作为服务启动，上面的例子，看到节点下面有一系列的参数，下面是这些参数的详细描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class &lt;name&gt;                                       为该服务指定一个class名，同一个class的所有服务必须同时启动或者停止。</span><br><span class="line">                                                   默认情况下服务的class名是“default”。另外还有core(其它服务依赖的基础性核心服务)、main(java须要的基本服务)、late_start(厂商定制的服务)</span><br><span class="line">critical                                           表示这是一个对设备至关重要的一个服务，如果它在四分钟内退出超过四次，则设备将重启进入恢复模式</span><br><span class="line">disabled                                           此服务不会自动启动，而是需要通过显式调用服务名来启动</span><br><span class="line">group &lt;groupname&gt; [&lt;groupname&gt;]*                   在启动服务前将用户组切换为&lt;groupname&gt;</span><br><span class="line">oneshot                                            只启动一次，当此服务退出时，不要主动去重启它</span><br><span class="line">onrestart                                          当此服务重启时，执行某些命令</span><br><span class="line">setenv &lt;name&gt; &lt;value&gt;                              设置环境变量&lt;name&gt;为某个值&lt;value&gt;</span><br><span class="line">socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [&lt;group&gt;]]    创建一个名为&#x2F;dev&#x2F;socket&#x2F;&lt;name&gt;的unix domain socket，然后将它的fd值传给启动它的进程，有效的&lt;type&gt;值包括dgram，stream和seqacket，而user和group的默认值是0</span><br><span class="line">user &lt;username&gt;                                    在启动服务前将用户组切换为&lt;username&gt;，默认情况下用户都是root</span><br></pre></td></tr></table></figure><p>​    到这里，相信大家应该能够看懂<code>init.rc</code>中的大多数<code>section</code>的含义了。下面的例子将组合使用，定义一个自己的服务，并且启动它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service kservice &#x2F;system&#x2F;bin&#x2F;app_process -Djava.class.path&#x3D;&#x2F;system&#x2F;framework&#x2F;ksvr.jar &#x2F;system&#x2F;bin cn.ksvr.kSystemSvr svr</span><br><span class="line">    class main</span><br><span class="line">    user root</span><br><span class="line">    group root</span><br><span class="line">    oneshot</span><br><span class="line">    seclabel u:r:su:s0</span><br><span class="line"></span><br><span class="line">on property:sys.boot_completed&#x3D;1</span><br><span class="line">    bootchart stop</span><br><span class="line">    start kservice</span><br></pre></td></tr></table></figure><p>​    上面的案例中，我定义了一个<code>kservice</code>的服务，使用<code>/system/bin/app_process</code>作为进程启动，并设置目标<code>jar</code>作为应用的<code>classpath</code>，最后设置<code>jar</code>文件的入口类<code>cn.ksvr.kSystemSvr</code>，最后的<code>svr</code>是做为参数传递给<code>kSystemSvr</code>中的<code>main</code>函数。接下来是当属性<code>sys.boot_completed</code>变更为1时表示手机完成引导，执行节点下的命令启动刚刚定义的服务。</p><h2><span id="36-zygote启动">3.6 Zygote启动</span></h2><p>​    了解<code>init.rc</code>定义的原理后，就可以继续阅读<code>init.rc</code>追踪后续的启动流程了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 导入含有zygote服务定义的rc文件，这个会根据系统所支持的对应架构导入</span><br><span class="line">import &#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.$&#123;ro.zygote&#125;.rc</span><br><span class="line"></span><br><span class="line"># init完成后触发zygote-start事件</span><br><span class="line">on late-init</span><br><span class="line">    ...</span><br><span class="line">    # Now we can start zygote for devices with file based encryption</span><br><span class="line">    trigger zygote-start</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"># zygote-start事件触发时执行的节点。最后启动了zygote和zygote_secondary</span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class="line">    wait_for_prop odsign.verification.done 1</span><br><span class="line">    # A&#x2F;B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start statsd</span><br><span class="line">    start netd</span><br><span class="line">    start zygote</span><br><span class="line">    start zygote_secondary</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    <code>zygote</code>服务定义的<code>rc</code>文件在路径<code>system/core/rootdir/</code>中。分别是<code>init.zygote32.rc</code>、<code>init.zygote64.rc</code>、<code>init.zygote32_64.rc</code>、<code>init.zygote64_32.rc</code>，下面查看<code>zygote64</code>的是如何定义的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; --zygote 传递给app_process程序的参数,表示这是启动一个孵化器。</span><br><span class="line">&#x2F;&#x2F; --start-system-server 传递给app_process程序的参数，表示进程启动后需要启动system_server进程</span><br><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br><span class="line">    critical window&#x3D;$&#123;zygote.critical_window.minute:-off&#125; target&#x3D;zygote-fatal</span><br></pre></td></tr></table></figure><p>​    从定义中可以看到<code>zygote</code>进程实际启动的就是<code>app_process</code>进程。</p><p>​    <code>app_process</code>是<code>Android</code>系统的主要进程，它是其他所有应用程序的容器，它负责创建新的进程，并启动它们。此外，它还管理应用程序的生命周期，防止任何一个应用程序占用资源过多，或者做出不良影响。<code>app_process</code>还负责在应用运行时为它们提供上下文，以及管理应用进程之间的通信。</p><p>​    跟踪<code>app_process</code>的实现，它的入口是在目录<code>frameworks/base/cmds/app_process/app_main.cpp</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> ABI_LIST_PROPERTY[] = <span class="string">&quot;ro.product.cpu.abilist64&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> ZYGOTE_NICE_NAME[] = <span class="string">&quot;zygote64&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> ABI_LIST_PROPERTY[] = <span class="string">&quot;ro.product.cpu.abilist32&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> ZYGOTE_NICE_NAME[] = <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused &quot;parent dir&quot; argument.</span></span><br><span class="line">    <span class="comment">// 参数的处理</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果启动时设置--zygote，则启动ZygoteInit，否则启动RuntimeInit</span></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* zygoteName=<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>;</span><br><span class="line">        runtime.start(zygoteName, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* zygoteName=<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>;</span><br><span class="line">        runtime.start(zygoteName, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    从代码中可以看到主要是对参数进行处理包装后，然后根据是否携带<code>--zygote</code>选择启动<code>ZygoteInit</code>或者是<code>RuntimeInit</code>。</p><p>​    <code>ZygoteInit</code>负责加载和初始化<code>Android</code>运行时环境，例如应用程序运行器、垃圾收集器等，并且它启动<code>Android</code>系统中的所有核心服务。</p><p>​     <code>RuntimeInit</code>负责联系应用程序的执行环境与系统的运行环境，然后将应用程序的主类加载到运行时，最后将应用程序的控制权交给应用程序的主类。</p><p>​    下面继续看看<code>runtime.start</code>的实现，查看对应文件<code>frameworks/base/core/jni/AndroidRuntime.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);</span></span><br><span class="line">    <span class="comment">//ALOGD(&quot;Found LD_ASSUME_KERNEL=&#x27;%s&#x27;\n&quot;, kernelHack);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动vm虚拟机 */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注册框架使用的JNI调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里调用ZygoteInit或者是RuntimeInit的main函数</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">&quot;Shutting down VM\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(<span class="string">&quot;Warning: unable to detach main thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">        ALOGW(<span class="string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    通过<code>JNI</code>函数<code>CallStaticVoidMethod</code>调用了<code>ZygoteInit</code>的<code>main</code>入口函数，现在就来到了<code>java</code>层中，查看文件代码<code>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        ZygoteServer zygoteServer = <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">                bootTimingsTraceLog.traceBegin(<span class="string">&quot;ZygotePreload&quot;</span>);</span><br><span class="line">                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">                        SystemClock.uptimeMillis());</span><br><span class="line">                <span class="comment">// 预加载资源，比如类、主题资源、字体资源等等</span></span><br><span class="line">                preload(bootTimingsTraceLog);</span><br><span class="line">                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class="line">                        SystemClock.uptimeMillis());</span><br><span class="line">                bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygotePreload</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            Zygote.initNativeState(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">            ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"><span class="comment">// 创建socket服务端</span></span><br><span class="line">            zygoteServer = <span class="keyword">new</span> ZygoteServer(isPrimaryZygote);</span><br><span class="line"><span class="comment">// 前面在init.rc中有配置--start-system-server的进程则会进入fork启动SystemServer</span></span><br><span class="line">            <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">                Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">                <span class="comment">// child (system_server) process.</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Accepting command socket connections&quot;</span>);</span><br><span class="line">            <span class="comment">// socket服务端等待AMS的请求，收到请求后就会由Zygote服务端来通过fork创建应用程序的进程</span></span><br><span class="line">            caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;System zygote died with fatal exception&quot;</span>, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (zygoteServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                zygoteServer.closeServerSocket();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We&#x27;re in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">        <span class="comment">// command.</span></span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    这里的重点是创建了<code>zygoteServer</code>，然后根据参数决定是否<code>forkSystemServer</code>，最后<code>runSelectLoop</code>等待<code>AMS</code>发送消息创建应用程序的进程。依次从代码观察它们的本质。首先是<code>ZygoteServer</code>的构造函数，可以看到，主要是创建<code>Socket</code>套接字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ZygoteServer(<span class="keyword">boolean</span> isPrimaryZygote) &#123;</span><br><span class="line">        mUsapPoolEventFD = Zygote.getUsapPoolEventFD();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isPrimaryZygote) &#123;</span><br><span class="line">            mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line">            mUsapPoolSocket =</span><br><span class="line">                    Zygote.createManagedSocketFromInitSocket(</span><br><span class="line">                            Zygote.USAP_POOL_PRIMARY_SOCKET_NAME);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME);</span><br><span class="line">            mUsapPoolSocket =</span><br><span class="line">                    Zygote.createManagedSocketFromInitSocket(</span><br><span class="line">                            Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mUsapPoolSupported = <span class="keyword">true</span>;</span><br><span class="line">        fetchUsapPoolPolicyProps();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    接着分析<code>forkSystemServer</code>，目的是了解返回值到底是什么，返回值的<code>r.run()</code>会调用到哪里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 服务启动的相关参数，这里注意到类名是com.android.server.SystemServer</span></span><br><span class="line">        String[] args = &#123;</span><br><span class="line">                <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,&quot;</span></span><br><span class="line">                        + <span class="string">&quot;1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--capabilities=&quot;</span> + capabilities + <span class="string">&quot;,&quot;</span> + capabilities,</span><br><span class="line">                <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--runtime-args&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--target-sdk-version=&quot;</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">                <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        ZygoteArguments parsedArgs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 使用fork创建一个SystemServer进程</span></span><br><span class="line">            <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">            pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.mUid, parsedArgs.mGid,</span><br><span class="line">                    parsedArgs.mGids,</span><br><span class="line">                    parsedArgs.mRuntimeFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.mPermittedCapabilities,</span><br><span class="line">                    parsedArgs.mEffectiveCapabilities);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For child process */</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            <span class="comment">// pid为0的部分，就是由这里fork出来的SystemServer执行的了。</span></span><br><span class="line">            <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteArguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ClassLoader cl = getOrCreateSystemServerClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 初始化SystemServer</span></span><br><span class="line">    <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                                 parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                                 parsedArgs.mRemainingArgs, cl);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// 继续跟进去</span></span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">                classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 反射获取com.android.server.SystemServer的入口函数并返回</span></span><br><span class="line">    <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到就是通过反射，获取到对应类的main函数，最后封装到MethodAndArgsCaller返回</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Missing class when invoking static main &quot;</span> + className,</span><br><span class="line">            ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Missing static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Problem getting static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Main method is not public and static on &quot;</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">         * by invoking the exception&#x27;s run() method. This arrangement</span></span><br><span class="line"><span class="comment">         * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">         * up the process.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forkSystemServer最终返回的就是MethodAndArgsCaller对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** method to call */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** argument array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    <code>forkSystemServer</code>函数走到最后是通过反射获取<code>com.android.server.SystemServer</code>的入口函数<code>main</code>，并封装到<code>MethodAndArgsCaller</code>对象中返回。最后的返回结果调用<code>run</code>时，就会执行到<code>SystemServer</code>中的<code>main</code>函数。继续看看<code>main</code>函数的实现，查看文件<code>frameworks/base/services/java/com/android/server/SystemServer.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 创建主线程Looper</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化系统Context上下文</span></span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建SystemServiceManager，由它管理系统的所有服务</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">        mSystemServiceManager.setStartInfo(mRuntimeRestart,</span><br><span class="line">                                           mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">        mDumper.addDumpable(mSystemServiceManager);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动各种服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t.traceBegin(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动引导服务</span></span><br><span class="line">        startBootstrapServices(t);</span><br><span class="line">        <span class="comment">// 启动核心服务</span></span><br><span class="line">        startCoreServices(t);</span><br><span class="line">        <span class="comment">// 启动其他服务</span></span><br><span class="line">        startOtherServices(t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        t.traceEnd(); <span class="comment">// StartServices</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动负责引导的服务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    t.traceBegin(<span class="string">&quot;startBootstrapServices&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 启动ActivityManagerService</span></span><br><span class="line">    t.traceBegin(<span class="string">&quot;StartActivityManager&quot;</span>);</span><br><span class="line">    ActivityTaskManagerService atm = mSystemServiceManager.startService(</span><br><span class="line">        ActivityTaskManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">        mSystemServiceManager, atm);</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    mWindowManagerGlobalLock = atm.getGlobalLock();</span><br><span class="line">    t.traceEnd();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    t.traceBegin(<span class="string">&quot;startOtherServices&quot;</span>);</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 从systemReady开始可以启动第三方应用</span></span><br><span class="line">    mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;, t);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后看看systemReady的处理</span></span><br><span class="line"><span class="comment">// frameworks/base/services/java/com/android/server/am/ActivitymanagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback, <span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;System now ready&quot;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 启动多用户下的Home Activity，最终会开启系统应用Luncher桌面显示</span></span><br><span class="line">        <span class="keyword">if</span> (bootingSystemUser) &#123;</span><br><span class="line">            t.traceBegin(<span class="string">&quot;startHomeOnAllDisplays&quot;</span>);</span><br><span class="line">            mAtmInternal.startHomeOnAllDisplays(currentUserId, <span class="string">&quot;systemReady&quot;</span>);</span><br><span class="line">            t.traceEnd();</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    到这里大致的服务启动流程就清楚了，最后成功抵达了<code>Luncher</code>的启动，重新回到流程中，继续看看<code>runSelectLoop</code>函数是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        socketFDs.add(mZygoteSocket.getFileDescriptor());</span><br><span class="line">        peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        mUsapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            fetchUsapPoolPolicyPropsWithMinInterval();</span><br><span class="line">            mUsapPoolRefillAction = UsapPoolRefillAction.NONE;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] usapPipeFDs = <span class="keyword">null</span>;</span><br><span class="line">            StructPollfd[] pollFDs;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pollReturnValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pollReturnValue = Os.poll(pollFDs, pollTimeoutMs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;poll failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (mUsapPoolRefillAction != UsapPoolRefillAction.NONE) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] sessionSocketRawFDs =</span><br><span class="line">                        socketFDs.subList(<span class="number">1</span>, socketFDs.size())</span><br><span class="line">                                .stream()</span><br><span class="line">                                .mapToInt(FileDescriptor::getInt$)</span><br><span class="line">                                .toArray();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> isPriorityRefill =</span><br><span class="line">                        mUsapPoolRefillAction == UsapPoolRefillAction.IMMEDIATE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Runnable command =</span><br><span class="line">                        fillUsapPool(sessionSocketRawFDs, isPriorityRefill);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> command;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPriorityRefill) &#123;</span><br><span class="line">                    <span class="comment">// Schedule a delayed refill to finish refilling the pool.</span></span><br><span class="line">                    mUsapPoolRefillTriggerTimestamp = System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    重点主要放在返回值的跟踪上，直接看<code>fillUsapPool</code>函数做了些什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">fillUsapPool</span><span class="params">(<span class="keyword">int</span>[] sessionSocketRawFDs, <span class="keyword">boolean</span> isPriorityRefill)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (--numUsapsToSpawn &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Runnable caller =</span><br><span class="line">                    Zygote.forkUsap(mUsapPoolSocket, sessionSocketRawFDs, isPriorityRefill);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> caller;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续追踪关键返回值的函数forkUsap</span></span><br><span class="line"><span class="comment">// 对应文件frameworks/base/core/java/com/android/internal/os/Zygote.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Runnable <span class="title">forkUsap</span><span class="params">(LocalServerSocket usapPoolSocket,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span>[] sessionSocketRawFDs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> isPriorityFork)</span> </span>&#123;</span><br><span class="line">        FileDescriptor readFD;</span><br><span class="line">        FileDescriptor writeFD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileDescriptor[] pipeFDs = Os.pipe2(O_CLOEXEC);</span><br><span class="line">            readFD = pipeFDs[<span class="number">0</span>];</span><br><span class="line">            writeFD = pipeFDs[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException errnoEx) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable to create USAP pipe.&quot;</span>, errnoEx);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 这里fork出一个子进程并初始化信息，最后返回pid</span></span><br><span class="line">        <span class="keyword">int</span> pid = nativeForkApp(readFD.getInt$(), writeFD.getInt$(),</span><br><span class="line">                                sessionSocketRawFDs, <span class="comment">/*argsKnown=*/</span> <span class="keyword">false</span>, isPriorityFork);</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            IoUtils.closeQuietly(readFD);</span><br><span class="line">            <span class="comment">// 如果是子进程就调用childMain获取返回值</span></span><br><span class="line">            <span class="keyword">return</span> childMain(<span class="keyword">null</span>, usapPoolSocket, writeFD);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Fork failed.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// readFD will be closed by the native code. See removeUsapTableEntry();</span></span><br><span class="line">            IoUtils.closeQuietly(writeFD);</span><br><span class="line">            nativeAddUsapTableEntry(pid, readFD.getInt$());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续看childMain的实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">childMain</span><span class="params">(<span class="meta">@Nullable</span> ZygoteCommandBuffer argBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="meta">@Nullable</span> LocalServerSocket usapPoolSocket,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      FileDescriptor writePipe)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 初始化应用程序环境，设置应用程序上下文，初始化应用程序线程等等</span></span><br><span class="line">        specializeAppProcess(args.mUid, args.mGid, args.mGids,</span><br><span class="line">                             args.mRuntimeFlags, rlimits, args.mMountExternal,</span><br><span class="line">                             args.mSeInfo, args.mNiceName, args.mStartChildZygote,</span><br><span class="line">                             args.mInstructionSet, args.mAppDataDir, args.mIsTopApp,</span><br><span class="line">                             args.mPkgDataInfoList, args.mAllowlistedDataInfoList,</span><br><span class="line">                             args.mBindMountAppDataDirs, args.mBindMountAppStorageDirs);</span><br><span class="line"></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"><span class="comment">// 又看到这个了，在SystemServer的启动中，之前追踪过</span></span><br><span class="line">    <span class="comment">// 这里最后是反射获取某个java类的main函数封装后返回</span></span><br><span class="line">        <span class="keyword">return</span> ZygoteInit.zygoteInit(args.mTargetSdkVersion,</span><br><span class="line">                                     args.mDisabledCompatChanges,</span><br><span class="line">                                     args.mRemainingArgs,</span><br><span class="line">                                     <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    前面分析过了<code>zygoteInit</code>函数，所以这里就不需要再继续进去看了，看看孵化器进程是如何初始化应用程序环境的，追踪<code>specializeAppProcess</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">specializeAppProcess</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> startChildZygote, String instructionSet, String appDataDir, <span class="keyword">boolean</span> isTopApp,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] pkgDataInfoList, String[] allowlistedDataInfoList,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> bindMountAppDataDirs, <span class="keyword">boolean</span> bindMountAppStorageDirs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数传递到了native层进行初始化处理了。</span></span><br><span class="line">        nativeSpecializeAppProcess(uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo,</span><br><span class="line">                niceName, startChildZygote, instructionSet, appDataDir, isTopApp,</span><br><span class="line">                pkgDataInfoList, allowlistedDataInfoList,</span><br><span class="line">                bindMountAppDataDirs, bindMountAppStorageDirs);</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续查看nativeSpecializeAppProcess</span></span><br><span class="line"><span class="comment">// 文件所在frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_Zygote_nativeSpecializeAppProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids, jint runtime_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean is_top_app, jobjectArray pkg_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobjectArray allowlisted_data_info_list, jboolean mount_data_dirs,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">    jlong capabilities = CalculateCapabilities(env, uid, gid, gids, is_child_zygote);</span><br><span class="line"></span><br><span class="line">    SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits, capabilities, capabilities,</span><br><span class="line">                     mount_external, se_info, nice_name, <span class="keyword">false</span>, is_child_zygote == JNI_TRUE,</span><br><span class="line">                     instruction_set, app_data_dir, is_top_app == JNI_TRUE, pkg_data_info_list,</span><br><span class="line">                     allowlisted_data_info_list, mount_data_dirs == JNI_TRUE,</span><br><span class="line">                     mount_storage_dirs == JNI_TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续查看SpecializeCommon实现</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecializeCommon</span><span class="params">(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray rlimits, jlong permitted_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jlong effective_capabilities, jint mount_external,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_se_info, jstring managed_nice_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool is_system_server, bool is_child_zygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_instruction_set, jstring managed_app_data_dir,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool is_top_app, jobjectArray pkg_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray allowlisted_data_info_list, bool mount_data_dirs,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* process_name = is_system_server ? <span class="string">&quot;system_server&quot;</span> : <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line">    auto fail_fn = std::bind(ZygoteFailure, env, process_name, managed_nice_name, _1);</span><br><span class="line">    auto extract_fn = std::bind(ExtractJString, env, process_name, managed_nice_name, _1);</span><br><span class="line"></span><br><span class="line">    auto se_info = extract_fn(managed_se_info);</span><br><span class="line">    auto nice_name = extract_fn(managed_nice_name);</span><br><span class="line">    auto instruction_set = extract_fn(managed_instruction_set);</span><br><span class="line">    auto app_data_dir = extract_fn(managed_app_data_dir);</span><br><span class="line">    <span class="comment">// 在这里的nick_name就是应用的包名了</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* nice_name_ptr = nice_name.has_value() ? nice_name.value().c_str() : nullptr;</span><br><span class="line"><span class="comment">// 如果是系统服务，就初始化系统服务的classloader</span></span><br><span class="line">    <span class="keyword">if</span> (is_system_server) &#123;</span><br><span class="line">        <span class="comment">// Prefetch the classloader for the system server. This is done early to</span></span><br><span class="line">        <span class="comment">// allow a tie-down of the proper system server selinux domain.</span></span><br><span class="line">        env-&gt;CallStaticObjectMethod(gZygoteInitClass, gGetOrCreateSystemServerClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">            <span class="comment">// Be robust here. The Java code will attempt to create the classloader</span></span><br><span class="line">            <span class="comment">// at a later point (but may not have rights to use AoT artifacts).</span></span><br><span class="line">            env-&gt;ExceptionClear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (selinux_android_setcontext(uid, is_system_server, se_info_ptr, nice_name_ptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">        fail_fn(CREATE_ERROR(<span class="string">&quot;selinux_android_setcontext(%d, %d, \&quot;%s\&quot;, \&quot;%s\&quot;) failed&quot;</span>, uid,</span><br><span class="line">                             is_system_server, se_info_ptr, nice_name_ptr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make it easier to debug audit logs by setting the main thread&#x27;s name to the</span></span><br><span class="line">    <span class="comment">// nice name rather than &quot;app_process&quot;.</span></span><br><span class="line">    <span class="keyword">if</span> (nice_name.has_value()) &#123;</span><br><span class="line">        SetThreadName(nice_name.value());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_system_server) &#123;</span><br><span class="line">        SetThreadName(<span class="string">&quot;system_server&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用java层的callPostForkChildHooks函数</span></span><br><span class="line">    <span class="comment">// 这个函数主要用来在新创建的子进程中调用回调函数进行初始化。</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                              is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以在这里插入一个日志，看看在<code>android</code>启动完成时，孵化出了哪些进程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                              is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line">ALOGW(<span class="string">&quot;start CallStaticVoidMethod current process:%s&quot;</span>, nice_name_ptr);</span><br></pre></td></tr></table></figure><p>​    然后编译aosp后刷入手机中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行脚本初始化编译环境</span><br><span class="line">source .&#x2F;build&#x2F;envsetup.sh</span><br><span class="line">&#x2F;&#x2F; 选择要编译的版本</span><br><span class="line">lunch aosp_blueline-userdebug</span><br><span class="line">&#x2F;&#x2F; 多线程编译</span><br><span class="line">make -j$(nproc --all)</span><br><span class="line">&#x2F;&#x2F; 设置刷机目录</span><br><span class="line">export ANDROID_PRODUCT_OUT&#x3D;~&#x2F;android_src&#x2F;out&#x2F;target&#x2F;product&#x2F;blueline</span><br><span class="line">&#x2F;&#x2F; 手机重启进入bootloader</span><br><span class="line">adb reboot bootloader</span><br><span class="line">&#x2F;&#x2F; 查看手机是否已经进入bootloader了</span><br><span class="line">fastboot devices</span><br><span class="line">&#x2F;&#x2F; 将刚刚编译的系统刷入手机</span><br><span class="line">fastboot flashall -w</span><br></pre></td></tr></table></figure><p>使用<code>android studio</code>的<code>logcat</code>查看日志，或者直接使用命令<code>adb logcat &gt; tmp.log</code>将日志输出到文件中，再进行观察。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">system_process                       W  start CallStaticVoidMethod current process:(null)</span><br><span class="line">com.android.bluetooth                W  start CallStaticVoidMethod current process:com.android.bluetooth</span><br><span class="line">com.android.systemui                 W  start CallStaticVoidMethod current process:com.android.systemui</span><br><span class="line">pid-2292                             W  start CallStaticVoidMethod current process:WebViewLoader-armeabi-v7a</span><br><span class="line">pid-2293                             W  start CallStaticVoidMethod current process:WebViewLoader-arm64-v8a</span><br><span class="line">com.android.networkstack             W  start CallStaticVoidMethod current process:com.android.networkstack.process</span><br><span class="line">com.qualcomm.qti.telephonyservice    W  start CallStaticVoidMethod current process:com.qualcomm.qti.telephonyservice</span><br><span class="line">pid-2401                             W  start CallStaticVoidMethod current process:webview_zygote</span><br><span class="line">com.android.se                       W  start CallStaticVoidMethod current process:com.android.se</span><br><span class="line">com.android.phone                    W  start CallStaticVoidMethod current process:com.android.phone</span><br><span class="line">com.android.settings                 W  start CallStaticVoidMethod current process:com.android.settings</span><br><span class="line">android.ext.services                 W  start CallStaticVoidMethod current process:android.ext.services</span><br><span class="line">com.android.launcher3                W  start CallStaticVoidMethod current process:com.android.launcher3</span><br><span class="line">com....cellbroadcastreceiver.module  W  start CallStaticVoidMethod current process:com.android.cellbroadcastreceiver.module</span><br><span class="line">com.android.carrierconfig            W  start CallStaticVoidMethod current process:com.android.carrierconfig</span><br><span class="line">com.android.providers.blockednumber  W  start CallStaticVoidMethod current process:android.process.acore</span><br><span class="line">pid-2859                             W  start CallStaticVoidMethod current process:com.android.deskclock</span><br><span class="line">pid-2899                             W  start CallStaticVoidMethod current process:com.android.nfc</span><br><span class="line">pid-2927                             W  start CallStaticVoidMethod current process:com.android.keychain</span><br><span class="line">pid-2944                             W  start CallStaticVoidMethod current process:com.android.providers.media.module</span><br><span class="line">pid-3028                             W  start CallStaticVoidMethod current process:com.android.quicksearchbox</span><br><span class="line">pid-3059                             W  start CallStaticVoidMethod current process:com.android.printspooler</span><br><span class="line">pid-3077                             W  start CallStaticVoidMethod current process:com.android.music</span><br><span class="line">pid-3112                             W  start CallStaticVoidMethod current process:com.android.traceur</span><br><span class="line">pid-3145                             W  start CallStaticVoidMethod current process:com.android.dialer</span><br><span class="line">pid-3151                             W  start CallStaticVoidMethod current process:android.process.media</span><br><span class="line">pid-3213                             W  start CallStaticVoidMethod current process:com.android.calendar</span><br><span class="line">pid-3230                             W  start CallStaticVoidMethod current process:com.android.imsserviceentitlement</span><br><span class="line">pid-3256                             W  start CallStaticVoidMethod current process:com.android.camera2</span><br><span class="line">pid-3277                             W  start CallStaticVoidMethod current process:com.android.contacts</span><br><span class="line">pid-3302                             W  start CallStaticVoidMethod current process:com.android.dynsystem</span><br><span class="line">pid-3322                             W  start CallStaticVoidMethod current process:com.android.dynsystem:dynsystem</span><br><span class="line">pid-3337                             W  start CallStaticVoidMethod current process:com.android.inputmethod.latin</span><br><span class="line">pid-3359                             W  start CallStaticVoidMethod current process:com.android.managedprovisioning</span><br><span class="line">pid-3380                             W  start CallStaticVoidMethod current process:com.android.messaging</span><br><span class="line">pid-3413                             W  start CallStaticVoidMethod current process:com.android.onetimeinitializer</span><br><span class="line">pid-3436                             W  start CallStaticVoidMethod current process:com.android.packageinstaller</span><br><span class="line">pid-3455                             W  start CallStaticVoidMethod current process:com.android.permissioncontroller</span><br><span class="line">pid-3480                             W  start CallStaticVoidMethod current process:com.android.providers.calendar</span><br><span class="line">pid-3503                             W  start CallStaticVoidMethod current process:com.android.settings</span><br><span class="line">pid-3504                             W  start CallStaticVoidMethod current process:com.android.localtransport</span><br><span class="line">pid-3545                             W  start CallStaticVoidMethod current process:com.android.shell</span><br><span class="line">pid-3568                             W  start CallStaticVoidMethod current process:com.android.statementservice</span><br><span class="line">pid-3595                             W  start CallStaticVoidMethod current process:com.android.quicksearchbox</span><br><span class="line">pid-3615                             W  start CallStaticVoidMethod current process:com.android.cellbroadcastreceiver.module</span><br><span class="line">pid-3638                             W  start CallStaticVoidMethod current process:com.android.externalstorage</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    从日志中可以看到<code>system_process</code>进程是孵化出来的第一个进程，接着孵化了一堆系统相关的进程，包括<code>launcher</code>桌面应用管理的系统应用。</p><p>​    根据前文看到的一系列的源码，分析后得出以下几个结论</p><ol><li><code>zygote</code>启动实际是启动<code>app_process</code>进程。</li><li>由<code>init</code>进程解析<code>init.rc</code>时启动了第一个<code>zygote</code>进程。</li><li>在第一个<code>zygote</code>进程中创建的<code>ZygoteServer</code>，并开始监听消息。</li><li>其他<code>zygote</code>进程是在<code>ZygoteServer</code>这个服务中收到消息后，再去<code>fork</code>出的新进程。</li><li>所有进程均来自于<code>zygote</code>进程的<code>fork</code>而来，所以<code>zygote</code>是进程的始祖。</li></ol><p>​    结合观测到的代码流程，再看下面的一个汇总图。不需要完全理解启动过程中的所有的处理，重点是在这里留下一个大致的印象以及简单的整理。</p><p><img src="/2025/04/07/chapter-03/android-boot.jpg" alt="image"></p><h2><span id="37-android-app应用启动">3.7 Android app应用启动</span></h2><p>​    经过一系列的代码跟踪，学习了<code>android</code>是如何启动的，系统服务是如何启动的，进程是如何启动。相信大家也好奇，当点击打开一个应用后，系统做了一系列的什么工作，最终打开了这个<code>app</code>，调用到<code>MainActivity</code>的<code>onCreate</code>的呢。</p><p>​    当<code>Android</code>成功进入系统后，在主界面中显示的桌面是一个叫做<code>Launcher</code>的系统应用，它是用来显示系统中已经安装的应用程序，并将这些信息的图标作为快捷方式显示在屏幕上，当用户点击图标时，<code>Launcher</code>就会启动对应的应用。在前文中，从<code>forkSystemServer</code>的流程中，最后能看到系统启动准备就绪后拉起了<code>Launcher</code>的应用。</p><p>​    <code>Launcher</code>是如何打开一个应用的呢？其实<code>Launcher</code>本身就是作为第一个应用在系统启动后首先打开的，既然<code>Launcher</code>就是应用。那么在手机上看到各种应用的图标，就是它读取到需要展示的数据，然后布局展示出来的，点击后打开应用，就是给每个<code>item</code>设置的点击事件进行处理的。接着，来看看这个<code>Launcher</code>应用的源码。</p><p>​    查看代码<code>frameworks/base/core/java/android/app/LauncherActivity.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LauncherActivity</span> <span class="keyword">extends</span> <span class="title">ListActivity</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        Intent intent = intentForPosition(position);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果你是一名<code>android</code>开发人员，相信你对<code>startActivity</code>这个函数非常熟悉了，但是<code>startActivity</code>是如何打开一个应用的呢，很多人不会深入了解，有了前文中的一系列基础铺垫，这时你已经能尝试追踪调用链了。现在，继续深入挖掘<code>startActivity</code>的原理。</p><p>​    查看代码<code>frameworks/base/core/java/android/app/Activity.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, <span class="meta">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">            <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    继续追踪<code>startActivityForResult</code>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 继续追踪startActivityForResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String who, Intent intent, <span class="keyword">int</span> requestCode, <span class="meta">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class="line">        Uri referrer = onProvideReferrer();</span><br><span class="line">        <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">        &#125;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">    <span class="comment">// 运行Activity</span></span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, who,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, who, requestCode,</span><br><span class="line">                ar.getResultCode(), ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    接下来的关键函数是<code>execStartActivity</code>，继续深入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继续追踪execStartActivity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData(who);</span><br><span class="line">            intent.prepareToLeaveProcess(who);</span><br><span class="line">            <span class="comment">// 启动Activity</span></span><br><span class="line">            <span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">                    who.getOpPackageName(), who.getAttributionTag(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">                    target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    <code>ActivityTaskManager</code>下的<code>service</code>调用的<code>startActivity</code>。</p><p>​    查看代码<code>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">                               String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">                               String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">                               resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">                               UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> String callingFeatureId, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">&quot;startActivityAsUser&quot;</span>)</span><br><span class="line">                .setCaller(caller)</span><br><span class="line">                .setCallingPackage(callingPackage)</span><br><span class="line">                .setCallingFeatureId(callingFeatureId)</span><br><span class="line">                .setResolvedType(resolvedType)</span><br><span class="line">                .setResultTo(resultTo)</span><br><span class="line">                .setResultWho(resultWho)</span><br><span class="line">                .setRequestCode(requestCode)</span><br><span class="line">                .setStartFlags(startFlags)</span><br><span class="line">                .setProfilerInfo(profilerInfo)</span><br><span class="line">                .setActivityOptions(bOptions)</span><br><span class="line">                .setUserId(userId)</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    先看看<code>obtainStarter</code>返回的对象类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityStarter <span class="title">obtainStarter</span><span class="params">(Intent intent, String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFactory.obtain().setIntent(intent).setReason(reason);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    看到返回的是<code>ActivityStarter</code>类型，接着找到对应的<code>excute</code>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理 Activity 启动请求的接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        res = executeRequest(mRequest);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种权限检查，合法的请求则继续</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">                request.voiceInteractor, startFlags, <span class="keyword">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask,</span><br><span class="line">                restrictedBgActivity, intentGrants);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;startActivityInner&quot;</span>);</span><br><span class="line">       result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">       startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 判断是否需要为 Activity 创建新的 Task</span></span><br><span class="line">        mTargetRootTask.startActivityLocked(mStartActivity,</span><br><span class="line">                topRootTask != <span class="keyword">null</span> ? topRootTask.getTopNonFinishingActivity() : <span class="keyword">null</span>, newTask,</span><br><span class="line">                mKeepCurTransition, mOptions, sourceRecord);</span><br><span class="line">    <span class="comment">// 如果需要恢复 Activity</span></span><br><span class="line">        <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                    mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">            <span class="comment">// 判断当前 Activity 是否可见以及是否需要暂停后台 Activity</span></span><br><span class="line">            <span class="keyword">if</span> (!mTargetRootTask.isTopActivityFocusable()</span><br><span class="line">                    || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.isTaskOverlay()</span><br><span class="line">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前 Activity 可见，则将其移动到前台</span></span><br><span class="line">                <span class="keyword">if</span> (mTargetRootTask.isTopActivityFocusable()</span><br><span class="line">                        &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedRootTask(mTargetRootTask)) &#123;</span><br><span class="line">                    mTargetRootTask.moveToFront(<span class="string">&quot;startActivityInner&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 恢复处于焦点状态的 Activity 的顶部 Activity</span></span><br><span class="line">                mRootWindowContainer.resumeFocusedTasksTopActivities(</span><br><span class="line">                        mTargetRootTask, mStartActivity, mOptions, mTransientLaunch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复处于焦点状态的 Activity 的顶部 Activity。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedTasksTopActivities</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Task targetRootTask, ActivityRecord target, ActivityOptions targetOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> deferPause)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 遍历所有显示器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 获取当前焦点所在的任务根节点</span></span><br><span class="line">            <span class="keyword">final</span> Task focusedRoot = display.getFocusedRootTask();</span><br><span class="line">            <span class="comment">// 如果有任务根节点，则恢复任务根节点中顶部的 Activity</span></span><br><span class="line">            <span class="keyword">if</span> (focusedRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= focusedRoot.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetRootTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有焦点任务根节点，并且目标任务根节点为空，则恢复 Home Activity</span></span><br><span class="line">                result |= resumeHomeActivity(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="string">&quot;no-focusable-task&quot;</span>,</span><br><span class="line">                                             display.getDefaultTaskDisplayArea());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复位于任务根节点顶部的 Activity</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> deferPause)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        someActivityResumed = resumeTopActivityInnerLocked(prev, options, deferPause);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复位于任务根节点顶部的 Activity。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> deferPause)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mTaskSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    <code>startSpecificActivity</code>将启动指定的<code>Activity</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivity</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否已经有进程在运行这个应用程序?</span></span><br><span class="line">        <span class="keyword">final</span> WindowProcessController wpc =</span><br><span class="line">                mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> knownToBeDead = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果应用程序正在运行，则直接启动 Activity</span></span><br><span class="line">        <span class="keyword">if</span> (wpc != <span class="keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Exception when starting activity &quot;</span></span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">            knownToBeDead = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 通知 Keyguard 正在启动一个不确定的 Activity（仅在 Keyguard 转换期间使用）</span></span><br><span class="line">        r.notifyUnknownVisibilityLaunchedForKeyguardTransition();</span><br><span class="line"><span class="comment">// 如果应用程序未运行，则异步启动新进程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isTop = andResume &amp;&amp; r.isTopRunningActivity();</span><br><span class="line">        mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? <span class="string">&quot;top-activity&quot;</span> : <span class="string">&quot;activity&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    主要关注开启一个新应用的流程，所以这里只追踪<code>startProcessAsync</code>调用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startProcessAsync</span><span class="params">(ActivityRecord activity, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">boolean</span> isTop,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) &#123;</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;dispatchingStartProcess:&quot;</span></span><br><span class="line">                        + activity.processName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Post message to start process to avoid possible deadlock of calling into AMS with the</span></span><br><span class="line">            <span class="comment">// ATMS lock held.</span></span><br><span class="line">            <span class="keyword">final</span> Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,</span><br><span class="line">                    mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,</span><br><span class="line">                    isTop, hostingType, activity.intent.getComponent());</span><br><span class="line">            mH.sendMessage(m);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    上面开启新进程的代码是异步发送消息给了<code>ActivityManagerService</code>。找到<code>AMS</code>中对应的<code>startProcess</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcess</span><span class="params">(String processName, ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> isTop, String hostingType, ComponentName hostingName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;startProcess:&quot;</span></span><br><span class="line">                             + processName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// If the process is known as top app, set a hint so when the process is</span></span><br><span class="line">            <span class="comment">// started, the top priority can be applied immediately to avoid cpu being</span></span><br><span class="line">            <span class="comment">// preempted by other processes before attaching the process of top app.</span></span><br><span class="line">            startProcessLocked(processName, info, knownToBeDead, <span class="number">0</span> <span class="comment">/* intentFlags */</span>,</span><br><span class="line">                               <span class="keyword">new</span> HostingRecord(hostingType, hostingName, isTop),</span><br><span class="line">                               ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, <span class="keyword">false</span> <span class="comment">/* allowWhileBooting */</span>,</span><br><span class="line">                               <span class="keyword">false</span> <span class="comment">/* isolated */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续追踪startProcessLocked</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       HostingRecord hostingRecord, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> isolated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,</span><br><span class="line">                                           hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>,</span><br><span class="line">                                           <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>,</span><br><span class="line">                                           <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>, <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里初始化了一堆进程信息，然后调用了另一个重载</span></span><br><span class="line"><span class="comment">// 并且注意entryPoint赋值android.app.ActivityThread</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> disableHiddenApiChecks, <span class="keyword">boolean</span> disableTestApiChecks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String abiOverride)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line">        <span class="keyword">final</span> String entryPoint = <span class="string">&quot;android.app.ActivityThread&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids,</span><br><span class="line">                              runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi,</span><br><span class="line">                              instructionSet, invokeWith, startTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(HostingRecord hostingRecord, String entryPoint, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">final</span> Process.ProcessStartResult startResult = startProcess(hostingRecord,</span><br><span class="line">                                                                    entryPoint, app,</span><br><span class="line">                                                                    uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo,</span><br><span class="line">                                                                    requiredAbi, instructionSet, invokeWith, startTime);</span><br><span class="line">    handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                               startSeq, <span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> app.getPid() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续查看startProcess</span></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startProcess</span><span class="params">(HostingRecord hostingRecord, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">int</span> mountExternal, String seInfo, String requiredAbi, String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                String invokeWith, <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">final</span> Process.ProcessStartResult startResult;</span><br><span class="line">    <span class="keyword">boolean</span> regularZygote = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 这里根据应用情况使用不同类型的zygote来启动进程</span></span><br><span class="line">    <span class="keyword">if</span> (hostingRecord.usesWebviewZygote()) &#123;</span><br><span class="line">        startResult = startWebView(entryPoint,</span><br><span class="line">                                   app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                                   app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                                   app.info.dataDir, <span class="keyword">null</span>, app.info.packageName,</span><br><span class="line">                                   app.getDisabledCompatChanges(),</span><br><span class="line">                                   <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.getStartSeq()&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hostingRecord.usesAppZygote()) &#123;</span><br><span class="line">        <span class="keyword">final</span> AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can&#x27;t isolate app data and storage data as parent zygote already did that.</span></span><br><span class="line">        startResult = appZygote.getProcess().start(entryPoint,</span><br><span class="line">                                                   app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                                                   app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                                                   app.info.dataDir, <span class="keyword">null</span>, app.info.packageName,</span><br><span class="line">                                                   <span class="comment">/*zygotePolicyFlags=*/</span> ZYGOTE_POLICY_FLAG_EMPTY, isTopApp,</span><br><span class="line">                                                   app.getDisabledCompatChanges(), pkgDataInfoMap, allowlistedAppDataInfoMap,</span><br><span class="line">                                                   <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                                                   <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.getStartSeq()&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        regularZygote = <span class="keyword">true</span>;</span><br><span class="line">        startResult = Process.start(entryPoint,</span><br><span class="line">                                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                                    app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags,</span><br><span class="line">                                    isTopApp, app.getDisabledCompatChanges(), pkgDataInfoMap,</span><br><span class="line">                                    allowlistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs,</span><br><span class="line">                                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.getStartSeq()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!regularZygote) &#123;</span><br><span class="line">        <span class="comment">// webview and app zygote don&#x27;t have the permission to create the nodes</span></span><br><span class="line">        <span class="keyword">if</span> (Process.createProcessGroup(uid, startResult.pid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.e(ActivityManagerService.TAG, <span class="string">&quot;Unable to create process group for &quot;</span></span><br><span class="line">                   + app.processName + <span class="string">&quot; (&quot;</span> + startResult.pid + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    这里，看到了<code>zygote</code>有三种类型，根据启动的应用信息使用不同类型的<code>zygote</code>来启动。</p><ol><li><p><code>regularZygote</code>常规进程，<code>zygote32/zygote64</code>进程，是所有<code>Android Java</code>应用的父进程</p></li><li><p><code>appZygote</code>应用进程，比常规进程多一些限制。</p></li><li><p><code>webviewZygote</code>辅助<code>zygote</code>进程，渲染不可信的<code>web</code>内容，最严格的安全限制</p></li></ol><p>​    三种<code>zygote</code>类型的启动流程差不多的，看常规进程启动即可。首先看<code>getProcess</code>返回的是什么类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChildZygoteProcess <span class="title">getProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mZygote != <span class="keyword">null</span>) <span class="keyword">return</span> mZygote;</span><br><span class="line"></span><br><span class="line">            connectToZygoteIfNeededLocked();</span><br><span class="line">            <span class="keyword">return</span> mZygote;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    应该找<code>ChildZygoteProcess</code>的<code>start</code>函数，然后找到类定义后，发现没有<code>start</code>，那么应该就是父类中的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildZygoteProcess</span> <span class="keyword">extends</span> <span class="title">ZygoteProcess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mPid;</span><br><span class="line"></span><br><span class="line">    ChildZygoteProcess(LocalSocketAddress socketAddress, <span class="keyword">int</span> pid) &#123;</span><br><span class="line">        <span class="keyword">super</span>(socketAddress, <span class="keyword">null</span>);</span><br><span class="line">        mPid = pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mPid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    继续找到父类<code>ZygoteProcess</code>的<code>start</code>函数，参数太长，这里省略掉参数的描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, <span class="comment">/*startChildZygote=*/</span> <span class="keyword">false</span>,</span><br><span class="line">                    packageName, zygotePolicyFlags, isTopApp, disabledCompatChanges,</span><br><span class="line">                    pkgDataInfoMap, allowlistedDataInfoList, bindMountAppsData,</span><br><span class="line">                    bindMountAppStorageDirs, zygoteArgs);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 前面是将前面准备的参数填充好</span></span><br><span class="line">        <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">        <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">        argsForZygote.add(<span class="string">&quot;--runtime-args&quot;</span>);</span><br><span class="line">        argsForZygote.add(<span class="string">&quot;--setuid=&quot;</span> + uid);</span><br><span class="line">        argsForZygote.add(<span class="string">&quot;--setgid=&quot;</span> + gid);</span><br><span class="line">        argsForZygote.add(<span class="string">&quot;--runtime-flags=&quot;</span> + runtimeFlags);</span><br><span class="line">        <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">&quot;--mount-external-default&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_INSTALLER) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">&quot;--mount-external-installer&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_PASS_THROUGH) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">&quot;--mount-external-pass-through&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_ANDROID_WRITABLE) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">&quot;--mount-external-android-writable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="comment">// The USAP pool can not be used if the application will not use the systems graphics</span></span><br><span class="line">            <span class="comment">// driver.  If that driver is requested use the Zygote application start path.</span></span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),</span><br><span class="line">                                              zygotePolicyFlags,</span><br><span class="line">                                              argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteState zygoteState, <span class="keyword">int</span> zygotePolicyFlags, <span class="meta">@NonNull</span> ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//是否用非特定的应用程序进程池进行处理，默认不使用</span></span><br><span class="line">        <span class="keyword">if</span> (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> attemptUsapSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="comment">// If there was an IOException using the USAP pool we will log the error and</span></span><br><span class="line">                <span class="comment">// attempt to start the process through the Zygote.</span></span><br><span class="line">                Log.e(LOG_TAG, <span class="string">&quot;IO Exception while communicating with USAP pool - &quot;</span></span><br><span class="line">                        + ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">attemptZygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteState zygoteState, String msgStr)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">            <span class="keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line"><span class="comment">// 这里实际就是连接SocketServer了，发送一个消息给zygote孵化出来的第一个进程</span></span><br><span class="line">            zygoteWriter.write(msgStr);</span><br><span class="line">            zygoteWriter.flush();</span><br><span class="line"></span><br><span class="line">            Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line">            result.pid = zygoteInputStream.readInt();</span><br><span class="line">            result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class="line"><span class="comment">// ZygoteServer创建好进程后，返回pid</span></span><br><span class="line">            <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            zygoteState.close();</span><br><span class="line">            Log.e(LOG_TAG, <span class="string">&quot;IO Exception while communicating with Zygote - &quot;</span></span><br><span class="line">                    + ex.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    到这里，回首看看前文中介绍<code>ZygoteServer</code>启动进程的流程，当时看到执行到最后是<code>findStaticMain</code>函数，是获取一个类名下的<code>main</code>函数，并返回后进行调用。现在启动进程时，在<code>startProcessLocked</code>函数中能看到类名赋值是<code>android.app.ActivityThread</code>，所以这里和<code>ZygoteServer</code>进行通信创建线程，最后调用的函数就是<code>android.app.ActivityThread</code>中的<code>main</code>函数。这样一来，启动流程就进入的应用的主线程。</p><p>​    <code>ActivityThread</code>是<code>Android</code>应用程序运行的<code>UI</code>主线程，负责处理应用程序的所有生命周期事件，接收系统消息并处理它们，<code>main</code>函数就是安卓应用的入口函数。<code>prepareMainLooper</code>函数将实例化一个<code>Looper</code>对象，然后由<code>Looper</code>对象创建一个消息队列，当<code>loop</code>函数调用时，<code>UI</code>线程就会进入消息循环，不断从消息队列获取到消息去进行相应的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ...</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line">    <span class="comment">// 主线程消息循环处理的handler</span></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在loop函数中是一个死循环进行`loopOnce`调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    继续看<code>loopOnce</code>的实现，看到了从队列中获取一条消息，并且将消息派发给对应的<code>Handler</code>来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">long</span> ident, <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride)</span> </span>&#123;</span><br><span class="line">        Message msg = me.mQueue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    对应的消息处理的<code>Handler</code>就是前面在入口函数<code>main</code>中看到的<code>sMainThreadHandler</code>对象，是通过<code>getHandler</code>函数获取的，跟进去寻找具体的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br></pre></td></tr></table></figure><p>​    找到的这个<code>H</code>类型就是对应的主线程消息处理<code>Handler</code>了。看看相关实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIND_APPLICATION        = <span class="number">110</span>;</span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_APPLICATION        = <span class="number">111</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="function">String <span class="title">codeToString</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                    <span class="keyword">case</span> BIND_APPLICATION: <span class="keyword">return</span> <span class="string">&quot;BIND_APPLICATION&quot;</span>;</span><br><span class="line">                    <span class="keyword">case</span> EXIT_APPLICATION: <span class="keyword">return</span> <span class="string">&quot;EXIT_APPLICATION&quot;</span>;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Integer.toString(code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">                    <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInitialApplication.onTerminate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Looper.myLooper().quit();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    再回头看看<code>thread.attach</code>中的处理，<code>mgr</code>就是<code>AMS</code>，所以来到<code>ActivityManagerService</code>查看<code>attachApplication</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main中调用的thread.attach函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将应用程序线程与 ActivityThread 绑定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Invalid application interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续追踪attachApplicationLocked</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">if</span> (app.getIsolatedEntryPoint() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// This is an isolated process which should just call an entry point instead of</span></span><br><span class="line">                <span class="comment">// being bound to an application.</span></span><br><span class="line">                thread.runIsolatedEntryPoint(</span><br><span class="line">                        app.getIsolatedEntryPoint(), app.getIsolatedEntryPointArgs());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果该应用程序未运行在隔离进程中，且有 Instrumentation</span></span><br><span class="line">                thread.bindApplication(processName, appInfo, providerList,</span><br><span class="line">                        instr2.mClass,</span><br><span class="line">                        profilerInfo, instr2.mArguments,</span><br><span class="line">                        instr2.mWatcher,</span><br><span class="line">                        instr2.mUiAutomationConnection, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                        <span class="keyword">new</span> Configuration(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                        app.getCompat(), getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">                        app.getDisabledCompatChanges(), serializedSystemFontMap);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有 Instrumentation</span></span><br><span class="line">                thread.bindApplication(processName, appInfo, providerList, <span class="keyword">null</span>, profilerInfo,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                        <span class="keyword">new</span> Configuration(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                        app.getCompat(), getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">                        app.getDisabledCompatChanges(), serializedSystemFontMap);</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    最后调用回<code>ActivityThread</code>的<code>bindApplication</code>，继续跟进去查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将应用程序和应用程序线程绑定所需的信息存储到AppBindData的各个字段中。</span></span><br><span class="line">    AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providerList.getList();</span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line">    data.buildSerial = buildSerial;</span><br><span class="line">    data.autofillOptions = autofillOptions;</span><br><span class="line">    data.contentCaptureOptions = contentCaptureOptions;</span><br><span class="line">    data.disabledCompatChanges = disabledCompatChanges;</span><br><span class="line">    data.mSerializedSystemFontMap = serializedSystemFontMap;</span><br><span class="line">    <span class="comment">// 发送消息给应用程序线程，调用 bindApplication 方法</span></span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>AppBindData</code>数据绑定完成后，最后发送消息<code>BIND_APPLICATION</code>通知准备就绪，并将准备好的数据发送过去。查看消息循环的处理部分<code>handleMessage</code>函数，看这个数据传给哪个函数处理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">             ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    发现调用到了<code>handleBindApplication</code>，继续跟进查看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//前面准备好的data数据赋值给了mBoundApplication</span></span><br><span class="line">    mBoundApplication = data;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建出了Context</span></span><br><span class="line">    <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info);</span><br><span class="line">    ...</span><br><span class="line">    Application app;</span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建出了Application</span></span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Application赋值给了mInitialApplication</span></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看是如何创建出Application的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">    cl, appClass, appContext);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续看newApplication的实现</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">ClassNotFoundException </span>&#123;</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    <span class="comment">// 最后发现调用了attach</span></span><br><span class="line">    app.attach(context);</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    在上面看到了<code>Context</code>的创建和<code>Application</code>的创建，继续看看怎么调用到自己开发的<code>app</code>中的<code>onCreate</code>的，追踪<code>callApplicationOnCreate</code>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callApplicationOnCreate</span><span class="params">(Application app)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    app.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    到这里，成功跟踪到最后调用<code>app</code>应用的<code>onCreate</code>函数，为什么很多人喜欢<code>hook attach</code>函数，因为在<code>Application</code>创建出来最早先调用了这个函数，该函数是一个较早<code>hook</code>时机。</p><h2><span id="38-了解service">3.8 了解Service</span></h2><p>​    <code>Service</code>是一种运行在后台的组件也可以称之为服务，它不像<code>Activity</code>那样有前台显示用户界面的能力，而是一种更加抽象的组件，它可以提供后台服务，在后台定时执行某些任务。<code>Service</code>可以被应用程序绑定，也可以独立运行，它可以接收外部的命令，执行耗时的任务。</p><p>​    在<code>Android</code>启动流程中，就已经看到了很多<code>Service</code>的启动，前文代码看到当系统启动后通过<code>forkSystemServer</code>执行到<code>SystemServer</code>来启动一系列的<code>Service</code>。这些<code>Service</code>有着各自负责的功能，其中最关键的是<code>ActivityManagerService</code>，常常被简称为<code>AMS</code>。而启动了<code>AMS</code>的<code>SystemServer</code>也是一个服务，这个服务负责在<code>Android</code>完成启动后，加载和启动所有的系统服务，管理系统级别的资源。</p><p>​    <code>AMS</code>是<code>Android</code>系统中的一个核心服务，负责<code>Android</code>系统中的所有活动管理，包括应用程序的启动，暂停，恢复，终止，以及对系统资源的管理和分配。负责<code>Android</code>系统中所有活动的管理。它负责管理任务栈，并允许任务栈中的任务来回切换，以便在任务之间改变焦点。它还负责管理进程，并将进程启动，暂停，恢复，终止，以及分配系统资源。在启动流程中能看到，所有<code>Service</code>都是由它来启动的.</p><p>​    除了<code>AMS</code>外，还有其他重要的<code>Service</code>为<code>Android</code>应用提供基础的功能，下面简单介绍这些常见的<code>Service</code>。</p><p>​     <code>WindowManagerService</code>，它是负责管理系统上所有窗口的显示和操作，包括管理全屏窗口、小窗口、弹窗、菜单和其他应用程序的窗口，使窗口在手机屏幕上正确的显示。</p><p>​    <code>PackageManagerService</code>，<code>Android</code>系统中提供给应用程序访问<code>Android</code>软件包的主要服务。负责管理<code>Android</code>软件包的安装、删除和更新，以及软件包的查询和配置。它有一个名为<code>Packages.xml</code>的<code>XML</code>文档，该文档是<code>Android</code>系统中所有软件包的列表，其中包含了每个软件包的基本信息，如应用程序的版本，安装时间，文件大小等。</p><p>​    <code>PowerManagerService</code>，管理设备电源状态的服务，可以有效地管理设备的电源，从而大大提升设备的电池续航能力，也可以降低设备运行时的功耗。它负责处理设备上的所有电源相关操作，例如屏幕亮度、屏幕超时时间、电池和充电时的运行模式、设备锁以及设备唤醒功能。</p><p>​    <code>InputMethodManagerService</code>，输入法服务，它负责处理用户输入，管理输入法状态，以及向应用程序提供输入服务，例如可以安装、卸载和更新输入法，还可以管理系统的输入法开关，应用程序可以通过它来访问输入法的当前状态和内容，以及实时输入的文本内容，可以接收并处理用户的输入事件，包括按键、触摸屏、语音输入等。</p><p>​    <code>NotificationManagerService</code>，通知服务。它主要是用来管理系统的通知，包括消息、提醒、更新等，它实现了通知的管理，收集、组织、过滤通知，并将它们发送给用户。它能够管理所有应用程序发出的通知，包括系统通知、应用程序发出的通知，并可以根据用户的偏好，显示哪些通知。</p><p>​    <code>LocationManagerService</code>，位置管理服务。可以根据应用程序的要求调用<code>GPS</code>、网络和其他位置技术来获取当前设备的定位信息。根据设备的位置信息，控制应用程序的定位功能，以及设备的位置报警功能。</p><p>​    <code>InputManagerService</code>，负责输入设备的管理和控制，以及系统中所有输入事件的处理。例如触摸屏、虚拟按键、键盘、轨迹球等。会将输入事件传递给应用程序，以便处理和响应。</p><p>​    <code>AlarmManagerService</code>负责处理所有系统定时任务，如闹钟，定时器等。它可以安排可执行的任务，使它们在指定的时刻开始执行。监控系统中的各种时间事件，以执行指定的任务。可以发送唤醒广播，以启动指定的服务或应用程序。可以用于处理设备睡眠、唤醒等系统状态切换。</p><p>​    <code>NetworkManagementService</code>，网络管理服务。用于控制和管理<code>Android</code>系统中的网络连接，能够在不同的网络之间进行切换，检查和管理手机的网络状态，监控网络设备的连接状态，如WiFi、蓝牙、移动数据等。</p><p>​    <code>BluetoothService</code>，蓝牙服务，它可以实现蓝牙设备之间的无线通信。它提供了一种方便的方式来建立和管理蓝牙连接，使蓝牙设备之间能够进行文件传输、远程打印、蓝牙键盘连接等活动。</p><p>​    还有更多的系统服务为<code>Android</code>的运行提供着各模块的基础功能，这里就不展开详细叙述了，当对某一个服务的功能实现感兴趣时，可以顺着启动服务的地方开始跟踪代码，分析实现的逻辑。也可以直接参考系统服务的定义方式来自定义系统服务来提供特殊需求的功能。</p><h2><span id="39-了解framework">3.9 了解Framework</span></h2><p>​    <code>Framework</code>指的是软件开发框架，由于系统处于内核中，无法直接对系统的功能进行请求，而是由框架层为开发的顶层应用提供接口调用，从而不必烦恼如何与底层交互，开发框架为开发人员提供各种功能，以及<code>Android</code>应用工具的支持来便于创建和管理<code>Android</code>应用程序，最终达到让用户能高效开发<code>Android</code>应用的目的，以生活中的事务为例，<code>Framework</code>就像是一个配套完善的小区，有高效的物业，周边配套有学校、医院、商场，各类设施非常齐全，而用户就像是小区内的业主。</p><p>​    看一张经典的<code>Android</code>架构图。</p><p><img src="/2025/04/07/chapter-03/android-framework.jpg" alt="在这里插入图片描述"></p><p>​    从上图中可以看到<code>Framewok</code>的组成部分，它们的功能分别是：</p><ol><li><code>Activity Manager</code>：用于管理和协调所有<code>Android</code>应用程序的活动和任务。</li><li><code>Content Providers</code>：允许<code>Android</code>应用程序之间共享数据。</li><li><code>Package Manager</code>：用于安装，升级和管理应用程序，以及处理应用程序的权限。</li><li><code>Resource Manager</code>：管理应用程序使用的资源，例如图像，字符串，布局。</li><li><code>Notification Manager</code>：处理<code>Android</code>系统的通知机制。</li><li><code>Telephony Manager</code>：提供电话功能，例如拨打电话，接听电话等。</li><li><code>Location Manager</code>：用于获取设备的位置信息。</li><li><code>View System</code>：提供用户界面的基本组件或部件，例如按钮，文本框等。</li><li><code>Window Manager</code>：处理屏幕上的窗口，例如在屏幕上绘制UI元素和管理窗口焦点。</li><li><code>Package Installer</code>：用于在设备上安装应用程序的控制面板。</li><li><code>Resource Manager</code>：管理所有允许应用程序访问的公共资源，例如铃声，照片和联系人信息。</li><li><code>Activity</code>和<code>Fragment</code>：提供应用程序的用户界面和控制器。</li></ol><p>​    可以看到前文中的各种系统服务就是属于<code>Framework</code>中的一部分，但是用户层并不能直接访问系统服务提供的功能，而是通过各服务对应的管理器来对系统服务进行调用。接下来开始跟踪，在开发应用中，当调用一个系统服务功能时发生了哪些调用，使用<code>Android Studio</code>创建一个项目，添加如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    TelephonyManager tm = (TelephonyManager) <span class="keyword">this</span>.getSystemService(TELEPHONY_SERVICE);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 电话状态：</span></span><br><span class="line"><span class="comment">         * 1.tm.CALL_STATE_IDLE=0     无活动</span></span><br><span class="line"><span class="comment">         * 2.tm.CALL_STATE_RINGING=1  响铃</span></span><br><span class="line"><span class="comment">         * 3.tm.CALL_STATE_OFFHOOK=2  摘机</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">int</span> state= tm.getCallState();<span class="comment">//int</span></span><br><span class="line">    Log.i(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;phone state &quot;</span>+state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    通过<code>getSystemService</code>函数提供了一个系统服务的名称，获取到了对应系统服务对应管理器，通过调用管理器的函数来触发对应系统服务的功能，看看具体是如何获取到系统服务的。找到<code>Android</code>源码中<code>Activity.java</code>文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(<span class="meta">@ServiceName</span> <span class="meta">@NonNull</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBaseContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;System services not available to Activities before onCreate()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WINDOW_SERVICE.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mWindowManager;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SEARCH_SERVICE.equals(name)) &#123;</span><br><span class="line">        ensureSearchManager();</span><br><span class="line">        <span class="keyword">return</span> mSearchManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果是<code>WINDOW_SERVICE</code>或者<code>SEARCH_SERVICE</code>就快速的返回对应的管理器了，其他系统服务则继续调用父类的函数。<code>Activity</code>继承自<code>ContextThemeWrapper</code>，找到对应实现代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInflater;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBaseContext().getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    找到<code>ContextImpl</code>中的对应实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    继续查看<code>SystemServiceRegistry</code>中的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    <span class="keyword">if</span> (fetcher == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sEnableServiceNotFoundWtf) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Unknown manager requested: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object ret = fetcher.getService(ctx);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    发现服务是从<code>SYSTEM_SERVICE_FETCHERS</code>中获取出来，然后返回的。看看这个对象的值是如何插进去的。搜索该对象的<code>put</code>函数调用处找到相关函数如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(<span class="meta">@NonNull</span> String serviceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="meta">@NonNull</span> Class&lt;T&gt; serviceClass, <span class="meta">@NonNull</span> ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class="line">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">    SYSTEM_SERVICE_CLASS_NAMES.put(serviceName, serviceClass.getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    从名字就能看的出来，这是一个注册系统服务的函数，在该函数中对大多数系统服务进行注册，想要查找到一个系统服务，可以顺着<code>registerService</code>注册函数进行跟踪，如果添加一个自定义的系统服务，同样也是需要在这里进行系统服务的注册。</p><p>​    下面继续观察<code>TelephonyManager</code>中<code>getCallState</code>函数的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@CallState</span> <span class="function"><span class="keyword">int</span> <span class="title">getCallState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TelecomManager telecomManager = mContext.getSystemService(TelecomManager.class);</span><br><span class="line">        <span class="keyword">if</span> (telecomManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> telecomManager.getCallState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CALL_STATE_IDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里又通过另一个管理器进行的函数调用，继续跟进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@CallState</span> <span class="function"><span class="keyword">int</span> <span class="title">getCallState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ITelecomService service = getTelecomService();</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> service.getCallStateUsingPackage(mContext.getPackageName(),</span><br><span class="line">                                                    mContext.getAttributionTag());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;RemoteException calling getCallState().&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TelephonyManager.CALL_STATE_IDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上述代码可以看出，<code>TelephonyManager</code>管理器不负责业务相关的处理，主要是调用对应的系统服务来获取结果。继续查看<code>getCallStateUsingPackage</code>函数实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCallStateUsingPackage</span><span class="params">(String callingPackage, String callingFeatureId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Log.startSession(<span class="string">&quot;TSI.getCallStateUsingPackage&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (CompatChanges.isChangeEnabled(</span><br><span class="line">            TelecomManager.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION, callingPackage,</span><br><span class="line">            Binder.getCallingUserHandle())) &#123;</span><br><span class="line">            <span class="comment">// Bypass canReadPhoneState check if this is being called from SHELL UID</span></span><br><span class="line">            <span class="keyword">if</span> (Binder.getCallingUid() != Process.SHELL_UID &amp;&amp; !canReadPhoneState(</span><br><span class="line">                callingPackage, callingFeatureId, <span class="string">&quot;getCallState&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;getCallState API requires READ_PHONE_STATE&quot;</span></span><br><span class="line">                                            + <span class="string">&quot; for API version 31+&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> mCallsManager.getCallState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Log.endSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在系统服务中就看到了管理状态相关的具体业务代码了，继续观察<code>mCallsManager.getCallStae</code>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCallState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mPhoneStateBroadcaster.getCallState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后是由<code>PhoneStateBroadcaster</code>对象维护着电话的状态信息了，<code>PhoneStateBroadcaster</code>是<code>Android</code>中的一个系统广播机制，它用于在电话状态发生变化时发出通知，以便其他组件和应用程序能够接收和处理这些变化。它可以发出包括新来电，挂断电话，拨号等状态变化的通知，以使系统中的其他组件能够更新和处理这些变化。<code>PhoneStateBroadcaster</code>还提供了一些其他的功能，例如电话状态监控，用于检测电话状态的变化，以便能够及时响应。简单的贴一下相关的代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneStateBroadcaster</span> <span class="keyword">extends</span> <span class="title">CallsManagerListenerBase</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallStateChanged</span><span class="params">(Call call, <span class="keyword">int</span> oldState, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (call.isExternalCall()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updateStates(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallAdded</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (call.isExternalCall()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updateStates(call);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (call.isEmergencyCall() &amp;&amp; !call.isIncoming()) &#123;</span><br><span class="line">            sendOutgoingEmergencyCallEvent(call);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallRemoved</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (call.isExternalCall()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updateStates(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExternalCallChanged</span><span class="params">(Call call, <span class="keyword">boolean</span> isExternalCall)</span> </span>&#123;</span><br><span class="line">        updateStates(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateStates</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> callState = TelephonyManager.CALL_STATE_IDLE;</span><br><span class="line">        <span class="keyword">if</span> (mCallsManager.hasRingingOrSimulatedRingingCall()) &#123;</span><br><span class="line">            callState = TelephonyManager.CALL_STATE_RINGING;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCallsManager.getFirstCallWithState(CallState.DIALING, CallState.PULLING,</span><br><span class="line">                CallState.ACTIVE, CallState.ON_HOLD) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callState = TelephonyManager.CALL_STATE_OFFHOOK;</span><br><span class="line">        &#125;</span><br><span class="line">        sendPhoneStateChangedBroadcast(call, callState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCallState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mCurrentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendPhoneStateChangedBroadcast</span><span class="params">(Call call, <span class="keyword">int</span> phoneState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (phoneState == mCurrentState) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCurrentState = phoneState;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="310-了解libcore">3.10 了解libcore</span></h2><p>​    <code>libcore</code>是<code>Android</code>平台下的<code>Java</code>核心库，主要提供与<code>Java</code>语言核心相关的类，如<code>Object</code>类、<code>String</code>类，<code>Java</code>集合类以及输入/输出流等。同时，<code>libcore</code>还包括了平台支持库，提供了一些用于<code>Android</code>平台特定功能的实现，如<code>Socket、SSL、File、URI</code>等类的平台特定实现。在<code>Android</code>应用程序开发中，<code>libcore</code>库是必不可少的一部分，其提供的类和实现对于开发和调试应用程序都具有非常重要的作用。</p><p>​    在<code>libcore</code>库中，<code>luni</code>是其中的一个子库，是指<code>Java</code>的基础类库（<code>LUNI = LANG + UTIL + NET + IO</code>），而<code>ojluni</code>是<code>OpenJDK</code>的代码在<code>Android</code>中的实现，其目录结构与<code>luni</code>子库类似，包含了<code>Java</code>语言核心类、<code>Java</code>集合类和<code>I/O</code>类等。<code>ojluni</code>是在<code>Java</code>标准库的基础上进行了一些定制化的修改，以便更好地适配<code>Android</code>系统。下面看看<code>ojluni</code>的目录结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">tree .&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F; -d</span><br><span class="line"></span><br><span class="line">├── com</span><br><span class="line">│   └── sun</span><br><span class="line">│       ├── net</span><br><span class="line">│       │   └── ssl</span><br><span class="line">│       │       └── internal</span><br><span class="line">│       │           └── ssl</span><br><span class="line">│       ├── nio</span><br><span class="line">│       │   └── file</span><br><span class="line">│       └── security</span><br><span class="line">│           └── cert</span><br><span class="line">│               └── internal</span><br><span class="line">│                   └── x509</span><br><span class="line">├── java</span><br><span class="line">│   ├── awt</span><br><span class="line">│   │   └── font</span><br><span class="line">│   ├── beans</span><br><span class="line">│   ├── io</span><br><span class="line">│   ├── lang</span><br><span class="line">│   │   ├── annotation</span><br><span class="line">│   │   ├── invoke</span><br><span class="line">│   │   ├── ref</span><br><span class="line">│   │   └── reflect</span><br><span class="line">│   ├── math</span><br><span class="line">│   ├── net</span><br><span class="line">│   ├── nio</span><br><span class="line">│   │   ├── channels</span><br><span class="line">│   │   │   └── spi</span><br><span class="line">│   │   ├── charset</span><br><span class="line">│   │   │   └── spi</span><br><span class="line">│   │   └── file</span><br><span class="line">│   │       ├── attribute</span><br><span class="line">│   │       └── spi</span><br><span class="line">│   ├── security</span><br><span class="line">│   │   ├── acl</span><br><span class="line">│   │   ├── cert</span><br><span class="line">│   │   ├── interfaces</span><br><span class="line">│   │   └── spec</span><br><span class="line">│   ├── sql</span><br><span class="line">│   ├── text</span><br><span class="line">│   ├── time</span><br><span class="line">│   │   ├── chrono</span><br><span class="line">│   │   ├── format</span><br><span class="line">│   │   ├── temporal</span><br><span class="line">│   │   └── zone</span><br><span class="line">│   └── util</span><br><span class="line">│       ├── concurrent</span><br><span class="line">│       │   ├── atomic</span><br><span class="line">│       │   └── locks</span><br><span class="line">│       ├── function</span><br><span class="line">│       ├── jar</span><br><span class="line">│       ├── logging</span><br><span class="line">│       ├── prefs</span><br><span class="line">│       ├── regex</span><br><span class="line">│       ├── stream</span><br><span class="line">│       └── zip</span><br><span class="line">├── javax</span><br><span class="line">│   ├── crypto</span><br><span class="line">│   │   ├── interfaces</span><br><span class="line">│   │   └── spec</span><br><span class="line">│   ├── net</span><br><span class="line">│   │   └── ssl</span><br><span class="line">│   ├── security</span><br><span class="line">│   │   ├── auth</span><br><span class="line">│   │   │   ├── callback</span><br><span class="line">│   │   │   ├── login</span><br><span class="line">│   │   │   └── x500</span><br><span class="line">│   │   └── cert</span><br><span class="line">│   └── sql</span><br><span class="line">│       └── rowset</span><br><span class="line">├── jdk</span><br><span class="line">│   ├── internal</span><br><span class="line">│   │   ├── util</span><br><span class="line">│   │   └── vm</span><br><span class="line">│   │       └── annotation</span><br><span class="line">│   └── net</span><br><span class="line">└── sun</span><br><span class="line">    ├── invoke</span><br><span class="line">    │   └── util</span><br><span class="line">    ├── misc</span><br><span class="line">    ├── net</span><br><span class="line">    │   ├── ftp</span><br><span class="line">    │   │   └── impl</span><br><span class="line">    │   ├── spi</span><br><span class="line">    │   │   └── nameservice</span><br><span class="line">    │   ├── util</span><br><span class="line">    │   └── www</span><br><span class="line">    │       └── protocol</span><br><span class="line">    │           ├── file</span><br><span class="line">    │           ├── ftp</span><br><span class="line">    │           └── jar</span><br><span class="line">    ├── nio</span><br><span class="line">    │   ├── ch</span><br><span class="line">    │   ├── cs</span><br><span class="line">    │   └── fs</span><br><span class="line">    ├── reflect</span><br><span class="line">    │   └── misc</span><br><span class="line">    ├── security</span><br><span class="line">    │   ├── action</span><br><span class="line">    │   ├── jca</span><br><span class="line">    │   ├── pkcs</span><br><span class="line">    │   ├── provider</span><br><span class="line">    │   │   └── certpath</span><br><span class="line">    │   ├── timestamp</span><br><span class="line">    │   ├── util</span><br><span class="line">    │   └── x509</span><br><span class="line">    └── util</span><br><span class="line">        ├── calendar</span><br><span class="line">        ├── locale</span><br><span class="line">        │   └── provider</span><br><span class="line">        ├── logging</span><br><span class="line">        └── resources</span><br></pre></td></tr></table></figure><h2><span id="311-了解sepolicy">3.11 了解sepolicy</span></h2><p>​    <code>sepolicy</code>主要用来存放<code>SELinux</code>策略的目录，<code>SELinux</code>是一种强制访问控制机制，<code>Android</code>系统中实现访问控制的一种安全机制，它在<code>Linux</code>内核的基础上实现，用于保证手机安全。</p><p>​    <code>SELinux</code>主要用于限制应用程序的权限，使其只能访问其所需的资源，并在需要时向用户请求权限。通过限制应用程序的权限，可以防止恶意软件和攻击者攻击系统。具体而言，<code>sepolicy</code>可以做到以下几点：</p><ol><li>限制应用程序访问系统的资源，例如系统设置、网络接口等。</li><li>限制应用程序的使用权限，例如读取联系人、访问存储空间等。</li><li>保护系统文件和目录，防止应用程序和攻击者修改和删除系统关键文件。</li></ol><p>​    <code>Type Enforcement</code>是<code>SELinux</code>中的一个安全策略机制，用于对系统中每个对象和主体的访问进行强制访问控制。在<code>Type Enforcement</code>的模型中，每个对象和主体都被赋予了一个安全上下文（<code>Security Context</code>），该上下文由多个标签组成。</p><p>​    <code>Role-Based Access Control（RBAC）</code>也是 <code>SELinux</code> 中的一种访问控制机制，用于对系统中多个用户、角色和对象的访问进行授权和限制。在<code>RBAC</code>模型中，每个用户都被分配了一个或多个角色，每个角色都有一组特定的权限和访问控制规则。与传统的访问控制方式不同，<code>RBAC</code>可以根据用户的职责和角色来授权和限制其访问，并且可以通过添加或删除角色等方式对访问控制进行动态管理。这种机制可以确保系统中不同用户之间的隔离和资源保护，并提高系统的安全性和可靠性。</p><p>​    在<code>SELinux</code>中，标签分为三种类型：用户标签（<code>User ID</code>）、角色标签（<code>Role</code>）和类型标签（<code>Type</code>）。每个安全上下文都包含了这三种标签的组合，如“<code>u:r:system_app:s0</code>”表示该上下文对应一个用户标签为“<code>system_app</code>”的进程，其角色标签和类型标签分别为“<code>r</code>”和“<code>s0</code>”。</p><p>​    通过安全上下文，<code>SELinux</code>可以对系统中的对象和主体进行细粒度控制，并限制它们之间的交互。例如，如果两个对象或主体的安全上下文不匹配，则它们不能相互通信或共享资源。这种机制可以有效地防止恶意应用程序或者攻击者对系统进行攻击或滥用。也可以通过修改 <code>sepolicy</code> 目录下的文件来调整安全策略，从而适应不同的应用程序和系统需求。</p><p>​    在<code>ROM</code>定制时，常会添加某些功能时由于权限问题导致系统输出警告信息提示错误，这种情况需要调整安全策略。调整策略的位置在<code>Android</code>源代码的 <code>./system/sepolicy/</code> 目录中，<code>public</code>、<code>private</code>目录下。</p><ol><li><code>public</code>：该目录包含<code>Android</code>系统与函数库等公共的<code>sepolicy</code>规则。这些规则是开发人员和厂商可以自由使用和修改的，因为这些规则涉及到的是公共区域的访问控制。</li><li><code>private</code>：该目录包含硬编码到<code>Android</code>系统中的特定规则。这些规则用于控制既定的<code>Android</code>系统功能和应用程序，例如拨号应用程序、电源管理等，因此这些规则不能被修改或覆盖。</li></ol><p>​    当修改<code>Android</code>系统的<code>SELinux</code>策略时，系统会使用<code>prebuilts</code>目录中的策略进行对比，这是因为<code>prebuilts</code>中包含了在 <code>Android</code>设备上预置的<code>SELinux</code>策略和规则。</p><p>​    对安全策略有一个大致的了解后，先看一个简单的例子，找到文件<code>./system/sepolicy/public/adbd.te</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 定义类型</span><br><span class="line">type adbd, domain;</span><br><span class="line"></span><br><span class="line"># 允许adbd类型的进程，在类型shell_test_data_file中的目录内创建子目录</span><br><span class="line">allow adbd shell_test_data_file:dir create_dir_perms;</span><br></pre></td></tr></table></figure><p>​    这里使用了三个类型：</p><ul><li><code>adbd</code>：指定进程的类型；</li><li><code>domain</code>：指定域的类型；</li><li><code>shell_test_data_file</code>：指定目录的类型。</li></ul><p>​    规则使用了<code>allow</code>关键字，表示允许某些操作。具体来说，上述规则允许<code>adbd</code>类型的进程在<code>shell_test_data_file</code>类型的目录下创建目录，并且该目录将被赋予允许创建子目录的权限（由<code>create_dir_perms</code>定义）。</p><p>​    这个规则的实际意义是，当<code>adbd</code>进程需要在<code>shell_test_data_file</code>目录下创建子目录时，允许该操作，并为新创建的目录设置适当的权限。注意，这个规则只对该目录有效，不能用于其他目录。</p><p>​    通常情况下采用按需修改的方式调整安全策略，当添加的功能被安全策略拦住时，会输出警告提示。例如在文件<code>com_android_internal_os_Zygote.cpp</code>的<code>SpecializeCommon</code>函数中加入如下代码，访问data目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> filepath=<span class="string">&quot;/data/app/demo&quot;</span>;</span><br><span class="line">ReadFileToString(filepath,&amp;file_contents)</span><br></pre></td></tr></table></figure><p>​    然后就会被<code>SELinux</code>拦截并提示警告信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avc: denied &#123; search &#125; for name&#x3D;&quot;app&quot; dev&#x3D;&quot;dm-8&quot; ino&#x3D;100 scontext&#x3D;u:r:zygote:s0 tcontext&#x3D;u:object_r:apk_data_file:s0 tclass&#x3D;dir permissive&#x3D;0</span><br></pre></td></tr></table></figure><p>​    在<code>SELinux</code>中，<code>avc: denied</code>是出现最频繁的提示之一，根据提示可以知道，进程<code>zygote</code>对安全上下文为<code>u:object_r:apk_data_file:s0</code>的目录进行<code>search</code>操作，该行为被拒绝了。除此之外，还有其他拒绝访问的提示消息如下。</p><ul><li><p><code>avc: denied &#123;open&#125; </code>- 表示进程被禁止打开文件或设备。</p></li><li><p><code>avc: denied &#123;read&#125; </code>- 表示进程被禁止读取一个文件、设备或目录。</p></li><li><p><code>avc: denied &#123;write&#125;</code> - 表示进程被禁止写入一个文件、设备或目录。</p></li><li><p><code>avc: denied &#123;getattr&#125;</code> - 表示进程被禁止读取一个文件或目录的元数据（例如，所有权、组、权限等）。</p></li><li><p><code>avc: denied &#123;execute&#125;</code> - 表示进程被禁止执行一个文件或进程。</p></li><li><p><code>avc: denied &#123;create&#125; </code>- 表示进程被禁止创建一个文件。</p></li><li><p><code>avc: denied &#123;search&#125; </code>- 表示此进程被禁止在某目录中搜索文件的操作</p></li></ul><p>​    除了 <code>avc: denied</code>之外，还有其他一些可能出现的提示信息。以下是一些常见提示信息以及它们的含义：</p><ul><li><p><code>avc: granted</code> - 操作被允许。</p></li><li><p><code>avc: audit</code> - 正在监视执行上下文之间的交互，并将相关信息记录到审计日志中。</p></li><li><p><code>avc: no audit</code> - 没有记录此操作的详细信息，这通常是因为没有启用<code>SELinux</code>的审计功能。</p></li><li><p><code>avc: invalid</code> - 操作请求的权限非法或无效。</p></li><li><p><code>avc: timeout</code> - <code>SELinux</code>规则分析器超时无法确定操作是否应该允许。在这种情况下，操作通常会被拒绝。</p></li><li><p><code>avc: failed</code> - <code>SELinux</code>规则分析器无法确定操作是否应该被允许或拒绝。</p></li></ul><p>​    在<code>SELinux</code>中，<code>scontext</code>代表系统中的安全上下文，<code>tcontext</code>代表对象的安全上下文。每个具有权限要求的进程和对象都有一个安全上下文。<code>SELinux</code>使用这些安全上下文来进行访问控制决策。</p><p><code>scontext</code>和<code>tcontext</code>中的“<code>u</code>”，“<code>r</code>”和“<code>s0</code>”是安全上下文标记的不同部分。含义如下：</p><ul><li><p><code>u </code>- 代表<code>selinux</code>中定义的用户，<code>tcontext</code>中的<code>u</code>代表对象所属用户。</p></li><li><p><code>r </code>- 代表进程的角色（<code>role</code>），<code>tcontext</code>中的r代表对象的角色。</p></li><li><p><code>s0</code> - 代表进程的安全策略范围（<code>security level</code>），<code>tcontext</code>中的<code>s0</code>代表对象的安全策略范围。<code>s0</code>通常表示为默认值。</p></li></ul><p>​    可以通过命令<code>ps -eZ</code>来查看进程的<code>scontext</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -eZ</span><br><span class="line"></span><br><span class="line">u:r:servicemanager:s0          system         672     1 10860740  3784 SyS_epoll+          0 S servicemanager</span><br><span class="line">u:r:hwservicemanager:s0        system         673     1 10880928  4648 SyS_epoll+          0 S hwservicemanager</span><br><span class="line">u:r:kernel:s0                  root           674     2       0      0 worker_th+          0 S [kworker&#x2F;7:1H]</span><br><span class="line">u:r:vndservicemanager:s0       system         675     1 10813436  2884 SyS_epoll+          0 S vndservicemanager</span><br><span class="line">u:r:kernel:s0                  root           676     2       0      0 kthread_w+          0 S [psimon]</span><br></pre></td></tr></table></figure><p>​    可以通过命令<code>ls -Z</code>来查看文件的<code>scontext</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;app</span><br><span class="line">ls -Z -all</span><br><span class="line"></span><br><span class="line">drwxrwxr-x  3 system system u:object_r:apk_data_file:s0          3488 2023-02-26 21:50:57.968696920 +0800 ~~QZ-rYHaywe6nr2ryYn3UoQ&#x3D;&#x3D;</span><br><span class="line">drwxrwxr-x  3 system system u:object_r:apk_data_file:s0          3488 2023-03-02 22:12:29.802016689 +0800 ~~W9dmzmphiDsjJm79RiBwdg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>​    重新对下面的这个提示进行一次解读。<code>selinux</code>拒绝搜索一个目录，目录名称为<code>app</code>，所在设备为<code>dm-8</code>，被拒绝的进程上下文特征是<code>u:r:zygote:s0</code>，角色是<code>zygote</code>，目标文件上下文特征是<code>u:object_r:apk_data_file:s0</code>，用户级别为<code>object_r</code>，文件的所属类型是<code>apk_data_file</code>，表示应用程序的数据文件。<code>tclass</code>表示请求对象的类型，<code>dir</code>为目录，<code>file</code>表示文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avc: denied &#123; search &#125; for name&#x3D;&quot;app&quot; dev&#x3D;&quot;dm-8&quot; ino&#x3D;100 scontext&#x3D;u:r:zygote:s0 tcontext&#x3D;u:object_r:apk_data_file:s0 tclass&#x3D;dir permissive&#x3D;0</span><br></pre></td></tr></table></figure><p>​    解读完成后，可以开始调整安全策略了，找到文件<code>system/sepolicy/private/zygote.te</code>，然后添加策略如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow zygote apk_data_file:dir search;</span><br></pre></td></tr></table></figure><p>​    修改完成后编译时，会报错，提示<code>diff</code>对比文件时发现内容不一致。最后再将文件<code>system/sepolicy/prebuilts/api/31.0/private/zygote.te</code>下添加相同的策略即可成功编译。</p><p>​    <code>neverallow</code>是<code>SELinux</code>策略语言中的一个规则，它用于指定某个操作永远不允许执行。<code>neverallow</code>规则用于设置一些强制访问控制规则，以在安全策略中明确禁止某些行为，从而提高其安全性。<code>neverallow</code>规则与<code>allow</code>规则在语法上非常相似，但在作用上截然不同。</p><p>​    有时按照警告信息提示，添加了对应策略后无法编译通过提示违反了<code>neverallow</code>。这种情况可以找到对应的<code>neverallow</code>，进行修改添加一个白名单来放过添加的规则。例如下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">neverallow &#123;</span><br><span class="line">  coredomain</span><br><span class="line">  -fsck</span><br><span class="line">  -init</span><br><span class="line">  -ueventd</span><br><span class="line">  -zygote</span><br><span class="line">&#125; device:&#123; blk_file file &#125; no_rw_file_perms;</span><br></pre></td></tr></table></figure><p>​    这个规则禁止上述进程以可读可写权限读写 <code>device</code> 类型的文件，其中<code>-zygote</code>，这种前面带有<code>-</code>表示排除掉这种进程，如果被设置了永不允许，只要找到对应的设置处，添加上排除对应进程即可成功编译了。</p><h2><span id="312-了解linker">3.12 了解Linker</span></h2><p>​    <code>Linker</code>是安卓中的一个系统组件，负责加载和链接系统动态库文件。</p><p>​    在<code>Android</code>源代码中，<code>Linker</code>源码的主要目录是<code>bionic/linker</code>。该目录包含<code>Linker</code>的核心实现，如动态加载、符号表管理、重定位、符号解析、<code>SO</code>文件搜索等。其中，<code>linker.c</code>是<code>Linker</code>的主要入口点，该文件中包含了大量的实现细节。<code>linker_phdr.c</code>是负责加载和处理<code>ELF</code>格式库文件的代码，<code>linker_namespaces.cpp</code>负责管理命名空间的代码，<code>linker_relocs.cpp</code>负责处理重定位的代码，<code>linker_sleb128.cpp</code>和<code>linker_uleb128.cpp</code>负责压缩和解压缩数据的实现等。除了<code>bionic/linker</code>目录外，<code>Linker</code>相关的代码还分散在其他系统组件中，例如系统服务和应用程序框架。</p><p>​    <code>linker</code>提供的一些函数来操作动态库，相关函数如下。</p><p>​    1. <code>dlopen</code>：打开一个动态链接库并返回句柄。</p><p>​    2. <code>dlsym</code>：查找动态链接库中符号的地址。</p><p>​    3. <code>dlclose</code>：关闭先前打开的动态链接库。</p><p>​    4. <code>dlerror</code>：返回最近的动态链接库错误。</p><p>​    5. <code>dladdr</code>：根据一个内存地址，返回映射到该地址的函数或变量的信息。</p><p>​    6. <code>dl_iterate_phdr</code>：遍历进程的动态链接库模块，可以获取模块地址、同名模块列表等信息。</p><p>​    在开始了解<code>Linker</code>如何加载动态库<code>so</code>文件前，需要先对<code>so</code>文件有一个简单的了解。</p><h3><span id="3121-elf文件格式">3.12.1 ELF文件格式</span></h3><p>​    在<code>Android</code>中，<code>so（Shared Object）</code>动态库是一种是一种基于<code>ELF</code>格式<code>（Executable and Linkable Format）</code>的可执行文件，它包含已编译的函数和数据，可以在运行时被加载到内存中，并被多个应用程序或共享库使用。</p><p>​    与静态库不同，动态库中的代码在可执行文件中并不存在，取而代之的是一些动态链接器（<code>Linker</code>）编译时不知道的外部引用符号。在运行时，<code>Linker</code>会根据动态库中的符号表来解析这些引用，并将动态库中的函数和数据链接到可执行程序中。</p><p>​    进程间共享动态库可以大大减少内存使用，提高代码重用性和可维护性。例如，如果多个应用程序都需要使用同一组件库，可以将其实现作为共享库提供。这样一来，每个应用程序都可以使用同一份库，而不必将代码重复添加到每个应用程序中。</p><p>​    在<code>ELF</code>文件结构中，包含以下三个部分：</p><ol><li><p><code>ELF Header</code>，<code>ELF</code>文件头，包含了文件的基本信息，例如文件类型、程序入口地址、节表的位置和大小等。</p></li><li><p><code>Section Header</code>，节头部分，描述了文件中各个节的大小、类型和位置等信息。<code>ELF</code>文件中的每个节都包含某种类型的信息，例如代码、数据、符号表、重定位表以及其他调试信息等。</p></li><li><p><code>Program Header</code>，段头部分，描述了可执行文件在内存中的布局。由于ELF文件的节可以以任意顺序排列，因此<code>Linker</code>在加载前需要使用<code>Program Header</code>来释放并映射虚拟内存，创建进程虚拟内存段布局。<code>Program Header</code>也包含了动态链接器所需的信息，例如动态库的位置、依赖关系和符号表位置等。</p></li></ol><p>​    使用<code>Android Studio</code>创建一个<code>Native C++</code>的项目，成功编译后来到<code>output</code>目录中，解压<code>app-debug.apk</code>文件，然后进入<code>app-debug\lib\arm64-v8a\</code>目录，找到<code>so</code>文件将其拖入<code>010 Editor</code>编辑器工具中。</p><p>​    接着给<code>010 Editor</code>编辑器安装一个<code>ELF</code>格式解析的模板，在工具栏找到模板-&gt;模板存储库。搜索<code>ELF</code>，点击安装，操作见下图。</p><p><img src="/2025/04/07/chapter-03/image-20230304135859598.png" alt="image-20230304135859598"></p><p>​    模板安装后，关闭文件，重新使用<code>010 Editor</code>打开后，将编辑方式切换为模板后，就能成功看到使用ELF格式解析so文件的结果了，如下图。</p><p><img src="/2025/04/07/chapter-03/image-20230304140328010.png" alt="image-20230304140328010"></p><p>​        <code>ELF</code>头部定义了<code>ELF</code>文件的基本属性和结构，也为后续的段表和节表等信息提供了重要的指导作用。加载<code>ELF</code>文件的第一步就是解析<code>ELF</code>头部后，再根据头部信息去解析其他部分的数据，<code>ELF</code>头部（<code>elf_header</code>）结构包含以下成员：</p><ul><li><p><code>e_ident</code>：长度为 16 字节的数组，用于标识文件类型和文件版本等信息。</p></li><li><p><code>e_type：ELF</code>文件类型，如可执行文件、共享库、目标文件等等。</p></li><li><p><code>e_machine</code>：目标硬件架构。</p></li><li><p><code>e_version</code>：<code>ELF文</code>件的版本，其一般为<code>EV_CURRENT</code>。</p></li><li><p><code>e_entry</code>：程序入口点的虚拟地址。</p></li><li><p><code>e_phoff</code>：程序头表（<code>program header table</code>）的偏移量（以字节为单位）。</p></li><li><p><code>e_shoff</code>：节头表（<code>section header table</code>）的偏移量（以字节为单位）。</p></li><li><p><code>e_flags</code>：表示一些标志，比如针对硬件进行微调的标志。</p></li><li><p><code>e_ehsize</code>：<code>ELF</code>头部的长度（以字节为单位）。</p></li><li><p><code>e_phentsize</code>：程序头表中一个入口的长度（以字节为单位）。</p></li><li><p><code>e_phnum</code>：程序头表中入口的数量。</p></li><li><p><code>e_shentsize</code>：节头表中一个入口的长度（以字节为单位）。</p></li><li><p><code>e_shnum</code>：节头表中入口的数量。</p></li><li><p><code>e_shstrndx</code>：节头表中节名称字符串表的索引。</p></li></ul><p>​    下图是<code>010 Edtior</code>解析展示的结果图。</p><p><img src="/2025/04/07/chapter-03/image-20230304141143199.png" alt="image-20230304141143199"></p><p>​    <code>program header table</code>是一种用于描述可执行文件和共享库的各个段（<code>section</code>）在进程内存中的映射关系的结构，也称为段表。每个程序头表入口表示一个段。在<code>Linux</code>系统中，它是被操作系统用于将<code>ELF</code>文件加载到进程地址空间的重要数据结构之一。每个<code>program header table</code>具有相同的固定结构，相关字段如下：</p><ul><li><p><code>p_type</code>：指定该段的类型，如可执行代码、只读数据、可读写数据、动态链接表、注释等等。</p></li><li><p><code>p_offset</code>：该段在<code>ELF</code>文件中的偏移量（以字节为单位）。</p></li><li><p><code>p_vaddr</code>：该段在进程虚拟地址空间中的起始地址。</p></li><li><p><code>p_paddr</code>：该项通常与<code>p_vaddr</code>相等。用于操作系统在将<code>ELF</code>文件的一个段映射到进程地址空间前，进行虚拟地址和物理地址的转换等操作。</p></li><li><p><code>p_filesz</code>：该段在文件中的长度（以字节为单位）。</p></li><li><p><code>p_memsz</code>：该段在加到进程地址空间后的长度（以字节为单位）。</p></li><li><p><code>p_flags</code>：用于描述该段的标志，如可读、可写、可执行、不可缓存等等。</p></li><li><p><code>p_align</code>：对于某些类型的段，该字段用于指定段在地址空间中的对齐方式。</p></li></ul><p>​    下图是编辑器中解析so看到的值</p><p><img src="/2025/04/07/chapter-03/image-20230304142500744.png" alt="image-20230304142500744"></p><p>​    <code>section header table</code>（节头表）是用于描述<code>ELF</code>文件中所有节（<code>section</code>）的元信息列表，也称为节表。它包含了每个节在文件中的位置、大小、类型、属性等信息。节头表的中相关字段如下：</p><ul><li><p><code>sh_name</code>: 节的名字在<code>.shstrtab</code>节中的向偏移量。这个偏移量可以用于获取该节的名字。</p></li><li><p><code>sh_type</code>：节的类型（<code>type</code>），如代码段、数据段、符号表等。</p></li><li><p><code>sh_flags</code>：节的属性标志，如是否可读、可写、可执行等。</p></li><li><p><code>sh_addr</code>：节的内存地址（<code>virtual address</code>），当这个地址为零时，表示这个节没有被加载到内存中。</p></li><li><p><code>sh_offset</code>：节在<code>ELF</code>文件中的偏移量（<code>offset</code>）。</p></li><li><p><code>sh_size</code>：节的长度（<code>size</code>）属性。</p></li><li><p><code>sh_link</code>：节的连接节（<code>linking section</code>），可以帮助定位一些节，如符号表。</p></li><li><p><code>sh_info</code>：与<code>sh_link</code>一起使用，具体含义与<code>sh_link</code>的值有关。</p></li><li><p><code>sh_addralign</code>：节的对齐方式（<code>alignment</code>）。</p></li><li><p><code>sh_entsize</code>：节的<code>entry</code>的大小。</p></li></ul><p>​    通过这些信息，<code>section header table</code>可以为执行链接和动态加载提供必要的元数据信息。样例数据看下图</p><p><img src="/2025/04/07/chapter-03/image-20230304143100841.png" alt="image-20230304143100841"></p><p>​    <code>ELF</code>文件中有各种节用于存放对应的信息，几个常见的节点存放数据的描述如下。</p><ul><li><p><code>.dynsym</code> 节：该节包含动态链接符号表（<code>dynamic symbol table</code>），用于描述<code>.so</code>文件所包含的动态链接库中的符号。符号是程序中一些命名实体的名称，例如函数、变量、常量等等，描述了这些实体在程序中的地址和大小等信息。<code>.dynsym</code> 节可以协助动态加载器（<code>Dynamic Linker</code>）在程序运行时逐个查找符号。</p></li><li><p><code>.dynstr</code> 节：用于存放符号表中的字符串，包括函数名、变量名、库名等等。</p></li><li><p><code>.plt</code> 节：保存了远程函数调用实现的跳转代码。</p></li><li><p><code>.rodata</code> 节：包含程序中只读数据的代码段，如字符串常量、全局常量等等。</p></li><li><p><code>.text</code> 节：程序的主要代码存放在该节中。该节包含可执行代码的机器语言指令，例如函数代码、条件语句、循环语句等等。</p></li><li><p><code>.bss</code> 节点（<code>Block Started by Symbol</code>）存储未初始化的全局变量和静态变量，其大小在编译时无法确定。因此，<code>.bss</code>节点在<code>ELF</code>文件中只占据一些空间，该空间称为<code>bss</code>段。而在运行时，操作系统会分配实际的内存空间给这些变量。<code>.bss</code>节点的大小在 <code>ELF</code>文件头的<code>e_shsize</code>字段中给出。</p></li><li><p><code>.shstrtab</code> 节点（<code>Section Header String Table</code>）存储节名称字符串，即每个节的名称和节头表中的节名称偏移量。它包含了<code>ELF</code>文件中每个节的字符串名称，方便读取程序在加载时快速访问。在<code>Android</code>中，<code>.shstrtab</code>节点是一个特殊的节，它位于节头表的末尾，可以通过<code>ELF</code>文件头的<code>e_shstrndx</code>字段找到。</p></li></ul><p><img src="/2025/04/07/chapter-03/image-20230304143003972.png" alt="image-20230304143003972"></p><h3><span id="3122-动态库加载流程">3.12.2 动态库加载流程</span></h3><p>​    <code>Linker</code>动态库加载是把代码（函数、变量、数据结构等）从动态链接库（<code>so</code>文件）中加载到内存中，并建立起代码之间的相互引用关系的过程。在<code>Android</code>等操作系统中，<code>Linker</code>动态加载主要用于模块化开发，将程序分为多个独立的模块，以便于代码的管理和维护。下面是<code>Linker</code>动态加载的主要步骤：</p><ol><li>根据系统的运行时需求，将需要的库文件加载进内存中，实现代码重用和共享。此时，<code>Linker</code>会执行一些特定的逻辑，如依赖优化、<code>so</code>文件版本检查等。</li><li>在进行动态链接的过程中，<code>Linker</code>会为每个库和每个函数生成全局唯一的标识符，以确定代码所在的地址。这个标识符会在编译过程中嵌入到库文件的头部，并且保存到动态链接库的符号表中。</li><li>解析符号表。<code>Linker</code>会读取库文件的符号表，并把符号名和符号地址配对起来，以便于在程序运行期间在内存中动态地连接他们。</li><li>检查符号表中的函数的其他库依赖项。如果当前库依赖于其他库，<code>Linker</code>就会递归地对这些依赖库进行加载、解析和链接。</li><li>调整符号地址。<code>Linker</code>会修改符号表中的函数地址，将函数重定向到动态库中正确的位置，以确保函数调用能够正确地传递和接收数据。</li><li>执行初始化和清理代码。在所有库和函数都被解析、链接和装载之后，<code>Linker</code>会执行全局构造函数来初始化代码，以及执行全局析构函数来清理代码。</li><li><code>Linker</code>动态加载过程中还会涉及到如动态追加、卸载等操作。</li></ol><p>​    以上是<code>Linker</code>动态加载的主要步骤及涉及到的主要逻辑。接着从源码层面跟踪动态加载的具体过程。打开前面创建的样例<code>app</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Used to load the &#x27;linkertest&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;linkertest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在应用层直接通过调用<code>loadLibrary</code>就可以完成一系列的加载动态库的操作了，看看内部是如何实现的。首先是<code>System</code>下的<code>loadLibrary</code>函数，前文有介绍过<code>libcore</code>中存放着<code>openjdk</code>的核心库的实现，而<code>java.lang.System</code>就是其中，找到文件<code>libcore/ojluni/src/main/java/java/lang/System.java</code>查看函数实现如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    继续在<code>ojluni</code>的目录中搜索<code>loadLibrary0</code>的函数实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(Class&lt;?&gt; fromClass, String libname)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = ClassLoader.getClassLoader(fromClass);</span><br><span class="line">    loadLibrary0(classLoader, fromClass, libname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(ClassLoader loader, Class&lt;?&gt; callerClass, String libname)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    String libraryName = libname;</span><br><span class="line">    <span class="comment">// 如果classloader不是BootClassLoader</span></span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; !(loader <span class="keyword">instanceof</span> BootClassLoader)) &#123;</span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (loader.getClass() == PathClassLoader.class ||</span><br><span class="line">             loader.getClass() == DelegateLastClassLoader.class)) &#123;</span><br><span class="line"></span><br><span class="line">            filename = System.mapLibraryName(libraryName);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        String error = nativeLoad(filename, loader);</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getLibPaths();</span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    String error = nativeLoad(filename, loader, callerClass);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看到不管是哪个Classloader都是调用的nativeLoad，只是重载不一样。但是两个参数的实际也是调用了三个参数重载的实现。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nativeLoad(filename, loader, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个参数重载的是一个native函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader, Class&lt;?&gt; caller)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    继续搜索<code>nativeLoad</code>的相关实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用了JVM_NativeLoad</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Runtime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,</span><br><span class="line">                   jobject javaLoader, jclass caller)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_NativeLoad(env, javaFilename, javaLoader, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>JVM_NativeLoad</code>的代码在art目录中，继续查看相关实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring <span class="title">JVM_NativeLoad</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jstring javaFilename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jclass caller)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">filename</span><span class="params">(env, javaFilename)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (filename.c_str() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">  &#123;</span><br><span class="line">    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();</span><br><span class="line">    <span class="keyword">bool</span> success = vm-&gt;LoadNativeLibrary(env,</span><br><span class="line">                                         filename.c_str(),</span><br><span class="line">                                         javaLoader,</span><br><span class="line">                                         caller,</span><br><span class="line">                                         &amp;error_msg);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续找到相关实现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JavaVMExt::LoadNativeLibrary</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  jobject class_loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  jclass caller_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="built_in">std</span>::<span class="built_in">string</span>* error_msg)</span> </span>&#123;</span><br><span class="line">  error_msg-&gt;clear();</span><br><span class="line">  SharedLibrary* library;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 已经加载过的，存在则返回true了。</span></span><br><span class="line">  <span class="keyword">if</span> (library != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedLocalRef&lt;jstring&gt; <span class="title">library_path</span><span class="params">(env, GetLibrarySearchPath(env, class_loader))</span></span>;</span><br><span class="line"></span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* path_str = path.empty() ? <span class="literal">nullptr</span> : path.c_str();</span><br><span class="line">  <span class="keyword">bool</span> needs_native_bridge = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">char</span>* nativeloader_error_msg = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 加载动态链接库</span></span><br><span class="line">  <span class="keyword">void</span>* handle = android::OpenNativeLibrary(</span><br><span class="line">      env,</span><br><span class="line">      runtime_-&gt;GetTargetSdkVersion(),</span><br><span class="line">      path_str,</span><br><span class="line">      class_loader,</span><br><span class="line">      (caller_location.empty() ? <span class="literal">nullptr</span> : caller_location.c_str()),</span><br><span class="line">      library_path.get(),</span><br><span class="line">      &amp;needs_native_bridge,</span><br><span class="line">      &amp;nativeloader_error_msg);</span><br><span class="line">  VLOG(jni) &lt;&lt; <span class="string">&quot;[Call to dlopen(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;, RTLD_NOW) returned &quot;</span> &lt;&lt; handle &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">bool</span> created_library = <span class="literal">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SharedLibrary&gt; <span class="title">new_library</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">new</span> SharedLibrary(env,</span></span></span><br><span class="line"><span class="function"><span class="params">                          self,</span></span></span><br><span class="line"><span class="function"><span class="params">                          path,</span></span></span><br><span class="line"><span class="function"><span class="params">                          handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                          needs_native_bridge,</span></span></span><br><span class="line"><span class="function"><span class="params">                          class_loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                          class_loader_allocator))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">    <span class="comment">// 将刚刚加载好的链接库保存起来</span></span><br><span class="line">    <span class="keyword">if</span> (library == <span class="literal">nullptr</span>) &#123;  <span class="comment">// We won race to get libraries_lock.</span></span><br><span class="line">      library = new_library.release();</span><br><span class="line">      libraries_-&gt;Put(path, library);</span><br><span class="line">      created_library = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">bool</span> was_successful = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 查找符号JNI_OnLoad</span></span><br><span class="line">  <span class="keyword">void</span>* sym = library-&gt;FindSymbol(<span class="string">&quot;JNI_OnLoad&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (sym == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));</span><br><span class="line">    self-&gt;SetClassLoaderOverride(class_loader);</span><br><span class="line"></span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">&quot;[Calling JNI_OnLoad in \&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">using</span> JNI_OnLoadFn = <span class="keyword">int</span>(*)(JavaVM*, <span class="keyword">void</span>*);</span><br><span class="line">    JNI_OnLoadFn jni_on_load = <span class="keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);</span><br><span class="line">    <span class="comment">// 调用JNI_OnLoad</span></span><br><span class="line">    <span class="keyword">int</span> version = (*jni_on_load)(<span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">  library-&gt;SetResult(was_successful);</span><br><span class="line">  <span class="keyword">return</span> was_successful;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    在这个函数中，看到使用<code>OpenNativeLibrary</code>来加载一个动态库，然后将加载动态库的信息包装成<code>SharedLibrary</code>对象，存入<code>libraries_</code>中，下次再加载时，会在<code>libraries_</code>查看是否存在，存在则直接返回。接着又通过函数<code>FindSymbol</code>查找<code>JNI_OnLoad</code>的符号地址，然后进行调用。继续跟踪加载动态库的具体实现，最后再回头看查找符号的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">OpenNativeLibrary</span><span class="params">(JNIEnv* env, <span class="keyword">int32_t</span> target_sdk_version, <span class="keyword">const</span> <span class="keyword">char</span>* path,</span></span></span><br><span class="line"><span class="function"><span class="params">                        jobject class_loader, <span class="keyword">const</span> <span class="keyword">char</span>* caller_location, jstring library_path,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">bool</span>* needs_native_bridge, <span class="keyword">char</span>** error_msg)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ART_TARGET_ANDROID)</span></span><br><span class="line">  UNUSED(target_sdk_version);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (class_loader == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span>* handle = android_dlopen_ext(path, RTLD_NOW, &amp;dlextinfo);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *error_msg = strdup(dlerror());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      Result&lt;<span class="keyword">void</span>*&gt; handle = TryLoadNativeloaderExtraLib(path);</span><br><span class="line">      <span class="keyword">if</span> (!handle.ok()) &#123;</span><br><span class="line">        *error_msg = strdup(handle.error().message().c_str());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (handle.value() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handle.value();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">void</span>* handle = OpenSystemLibrary(path, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *error_msg = strdup(dlerror());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; lib_path : library_paths) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(path_arg, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> handle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NativeBridgeIsSupported(path_arg)) &#123;</span><br><span class="line">      *needs_native_bridge = <span class="literal">true</span>;</span><br><span class="line">      handle = NativeBridgeLoadLibrary(path_arg, RTLD_NOW);</span><br><span class="line">      <span class="keyword">if</span> (handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handle;</span><br><span class="line">      &#125;</span><br><span class="line">      *error_msg = strdup(NativeBridgeGetError());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *error_msg = strdup(dlerror());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在这里函数看到，使用多种方式尝试进行动态加载，分别是<code>android_dlopen_ext</code>、<code>TryLoadNativeloaderExtraLib</code>、<code>OpenSystemLibrary</code>。它们都是在<code>Android</code>平台上用来加载动态库的方法，但是它们各自的使用场景略有不同：</p><ol><li><code>android_dlopen_ext</code>：是一个供开发者使用的公开函数，它支持指定库的绝对路径和不同的标志（如<code>RTLD_NOW</code>、<code>RTLD_LAZY</code>等），并返回一个指向已加载库的指针，供后续调用函数的时候使用。</li><li><code>TryLoadNativeloaderExtraLib</code>：是<code>Android</code>系统中的内部方法，用于加载额外的本地库。它被用于支持动态加载共享库的应用程序，例如使用反射实现的动态库加载方式。系统在应用程序启动时调用它，用于加载应用程序所需的额外本地库。使用该方法可以加载特定的本地库，并支持跨架构的执行。</li><li><code>OpenSystemLibrary</code>：也是<code>Android</code>系统中的内部方法，用于加载<code>Android</code>系统的本地库。它不需要指定库的路径，而是使用系统库路径中的路径名来加载相应的库文件。该方法主要用于加载<code>Android</code>操作系统核心中的一些固定的系统库，例如 <code>libz.so、liblog.so</code>等。</li></ol><p>​    总的来说，这三个方法都是用于加载动态库的方法，不同的是它们的使用场景略有不同。选一条路线分析即可，这里继续从<code>android_dlopen_ext</code>深入分析，该函数的相关代码在<code>libdl.cpp</code>中实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">android_dlopen_ext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">int</span> flag, <span class="keyword">const</span> android_dlextinfo* extinfo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* caller_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __loader_android_dlopen_ext(filename, flag, extinfo, caller_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    继续跟踪文件dlfcn.cpp中的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* __loader_android_dlopen_ext(<span class="keyword">const</span> <span class="keyword">char</span>* filename,</span><br><span class="line">                           <span class="keyword">int</span> flags,</span><br><span class="line">                           <span class="keyword">const</span> android_dlextinfo* extinfo,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">void</span>* caller_addr) &#123;</span><br><span class="line">  <span class="keyword">return</span> dlopen_ext(filename, flags, extinfo, caller_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">dlopen_ext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> android_dlextinfo* extinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">void</span>* caller_addr)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedPthreadMutexLocker <span class="title">locker</span><span class="params">(&amp;g_dl_mutex)</span></span>;</span><br><span class="line">  g_linker_logger.ResetState();</span><br><span class="line">  <span class="keyword">void</span>* result = do_dlopen(filename, flags, extinfo, caller_addr);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    __bionic_format_dlerror(<span class="string">&quot;dlopen failed&quot;</span>, linker_get_error_buffer());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    到这里<code>do_dlopen</code>则执行到了<code>Linker</code>部分的实现了，找到<code>linker.cpp</code>文件查看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">do_dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> android_dlextinfo* extinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">void</span>* caller_addr)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  soinfo* si = find_library(ns, translated_name, flags, extinfo, caller);</span><br><span class="line">  loading_trace.End();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = si-&gt;to_handle();</span><br><span class="line">    LD_LOG(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;... dlopen calling constructors: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;</span>,</span><br><span class="line">           si-&gt;get_realpath(), si-&gt;get_soname(), handle);</span><br><span class="line">    si-&gt;call_constructors();</span><br><span class="line">    failure_guard.Disable();</span><br><span class="line">    LD_LOG(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;... dlopen successful: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;</span>,</span><br><span class="line">           si-&gt;get_realpath(), si-&gt;get_soname(), handle);</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里看到通过<code>find_library</code>进行查找的，找到后又调用了<code>call_constructors</code>函数。先看看<code>call_constructors</code>函数的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">soinfo::call_constructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (constructors_called || g_is_ldd) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  call_function(<span class="string">&quot;DT_INIT&quot;</span>, init_func_, get_realpath());</span><br><span class="line">  call_array(<span class="string">&quot;DT_INIT_ARRAY&quot;</span>, init_array_, init_array_count_, <span class="literal">false</span>, get_realpath());</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    根据上面代码发现这里就是<code>.init</code>和<code>.initarray</code>执行的地方，继续看加载的流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> soinfo* <span class="title">find_library</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> android_dlextinfo* extinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                            soinfo* needed_by)</span> </span>&#123;</span><br><span class="line">  soinfo* si = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    si = solist_get_somain();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!find_libraries(ns,</span><br><span class="line">                             needed_by,</span><br><span class="line">                             &amp;name,</span><br><span class="line">                             <span class="number">1</span>,</span><br><span class="line">                             &amp;si,</span><br><span class="line">                             <span class="literal">nullptr</span>,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             rtld_flags,</span><br><span class="line">                             extinfo,</span><br><span class="line">                             <span class="literal">false</span> <span class="comment">/* add_as_children */</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (si != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      soinfo_unload(si);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  si-&gt;increment_ref_count();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向下跟踪</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_libraries</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ZipArchiveCache zip_archive_cache;</span><br><span class="line">  <span class="keyword">soinfo_list_t</span> new_global_group_members;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i&lt;load_tasks.size(); ++i) &#123;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> (!find_library_internal(<span class="keyword">const_cast</span>&lt;<span class="keyword">android_namespace_t</span>*&gt;(task-&gt;get_start_from()),</span><br><span class="line">                               task,</span><br><span class="line">                               &amp;zip_archive_cache,</span><br><span class="line">                               &amp;load_tasks,</span><br><span class="line">                               rtld_flags)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    soinfo* si = task-&gt;get_soinfo();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//追踪find_library_internal</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">find_library_internal</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  LoadTask* task,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> rtld_flags)</span> </span>&#123;</span><br><span class="line">  soinfo* candidate;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (load_library(ns, task, zip_archive_cache, load_tasks, rtld_flags,</span><br><span class="line">                   <span class="literal">true</span> <span class="comment">/* search_linked_namespaces */</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">load_library</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                         LoadTask* task,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="function"><span class="params">                         LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">bool</span> search_linked_namespaces)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name = task-&gt;get_name();</span><br><span class="line">  soinfo* needed_by = task-&gt;get_needed_by();</span><br><span class="line">  ...</span><br><span class="line">  LD_LOG(kLogDlopen,</span><br><span class="line">         <span class="string">&quot;load_library(ns=%s, task=%s, flags=0x%x, search_linked_namespaces=%d): calling &quot;</span></span><br><span class="line">         <span class="string">&quot;open_library&quot;</span>,</span><br><span class="line">         ns-&gt;get_name(), name, rtld_flags, search_linked_namespaces);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the file.</span></span><br><span class="line">  <span class="keyword">off64_t</span> file_offset;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> realpath;</span><br><span class="line">  <span class="keyword">int</span> fd = open_library(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open_library打开动态库文件将指定的共享库文件加载到当前进程的地址空间中，创建一个新的动态链接对象，并返回其的句柄。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_library</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">char</span>* name, soinfo *needed_by,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">off64_t</span>* file_offset, <span class="built_in">std</span>::<span class="built_in">string</span>* realpath)</span> </span>&#123;</span><br><span class="line">  TRACE(<span class="string">&quot;[ opening %s from namespace %s ]&quot;</span>, name, ns-&gt;get_name());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the name contains a slash, we should attempt to open it directly and not search the paths.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(name, <span class="string">&#x27;/&#x27;</span>) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> open_library_at_path(zip_archive_cache, name, file_offset, realpath);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load_library加载解析ELF格式并将其链接到进程的地址空间中，将动态链接对象中的符号解析为当前进程中的符号，从而创建动态链接的关系。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">load_library</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                         LoadTask* task,</span></span></span><br><span class="line"><span class="function"><span class="params">                         LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; realpath,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">bool</span> search_linked_namespaces)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  soinfo* si = soinfo_alloc(ns, realpath.c_str(), &amp;file_stat, file_offset, rtld_flags);</span><br><span class="line"></span><br><span class="line">  task-&gt;set_soinfo(si);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取elf header</span></span><br><span class="line">  <span class="keyword">if</span> (!task-&gt;read(realpath.c_str(), file_stat.st_size)) &#123;</span><br><span class="line">    task-&gt;remove_cached_elf_reader();</span><br><span class="line">    task-&gt;set_soinfo(<span class="literal">nullptr</span>);</span><br><span class="line">    soinfo_free(si);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后看看read函数，这个函数负责从elf文件格式的数据中读取内容</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* realpath, <span class="keyword">off64_t</span> file_size)</span> </span>&#123;</span><br><span class="line">    ElfReader&amp; elf_reader = get_elf_reader();</span><br><span class="line">    <span class="keyword">return</span> elf_reader.Read(realpath, fd_, file_offset_, file_size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    <code>ElfReader</code>是<code>Android</code>源文件中的工具，位于系统核心库<code>libcore</code>中，代码主要由<code>C++</code>编写。它可以读取<code>ELF</code>文件的所有信息，并将其解析为指定格式。</p><p><code>ElfReader</code>具备以下特点：</p><ul><li>读取<code>ELF</code>文件的头信息，包括<code>ELF</code>版本、目标体系结构、程序入口地址、节表偏移量等。</li><li>读取<code>ELF</code>文件的节表信息，包括节表名称、大小、偏移量、属性等。</li><li>通过节表信息可以获取符号表、重定位表、动态链接表等关键信息，如函数、变量、链接库、导出函数等。</li><li>支持通过指定节表名称获取某个节表的信息，如根据”<code>.rodata</code>“获取只读数据节表的信息等。</li></ul><h2><span id="小结">小结</span></h2><p>系统定制无论做怎样的修改，都要明白其原理，本章内容作为系统开发的内功心法，需要读者花费一些时间来吸收，在后面的内容的展开过程中，也可以随时重温本章内容，加深印象。</p><p>从设备开机到系统启动完成，整个启动链上涉及到的核心组件都在本节中进行了介绍。本节中介绍的系统组件，都是定制系统可能需要修改的地方。其中，Service与Framework的修改是最常见的，美化与安全定制都离不开它，读者朋友们可以重点阅读它们的代码来深入研究。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;[转]安卓系统定制：从入门到实践&lt;/strong&gt;&lt;/p&gt;
&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D&quot;&gt;3.1 源码结构介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#32-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B&quot;&gt;3.2 Android系统启动流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#33-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8&quot;&gt;3.3 内核启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#34-init%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8&quot;&gt;3.4 Init进程启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#35-initrc&quot;&gt;3.5 init.rc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#36-zygote%E5%90%AF%E5%8A%A8&quot;&gt;3.6 Zygote启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#37-android-app%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8&quot;&gt;3.7 Android app应用启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#38-%E4%BA%86%E8%A7%A3service&quot;&gt;3.8 了解Service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#39-%E4%BA%86%E8%A7%A3framework&quot;&gt;3.9 了解Framework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#310-%E4%BA%86%E8%A7%A3libcore&quot;&gt;3.10 了解libcore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#311-%E4%BA%86%E8%A7%A3sepolicy&quot;&gt;3.11 了解sepolicy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#312-%E4%BA%86%E8%A7%A3linker&quot;&gt;3.12 了解Linker&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#3121-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F&quot;&gt;3.12.1 ELF文件格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3122-%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B&quot;&gt;3.12.2 动态库加载流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B0%8F%E7%BB%93&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;

&lt;p&gt;在上一章的学习中，我们成功编译了&lt;code&gt;Android&lt;/code&gt;12，以及对应的系统内核，并且通过多种方式刷入手机。接下来需要先对&lt;code&gt;Android&lt;/code&gt;源码的根结构有一定的了解，了解结构有助于更快地定位和分析源码，同时能让开发人员更好地理解&lt;code&gt;Android&lt;/code&gt;系统。在修改系统时，有些简单的功能（例如&lt;code&gt;native&lt;/code&gt;中的文件读写、&lt;code&gt;java&lt;/code&gt;类型的转换&lt;code&gt;c++&lt;/code&gt;类型等）并不需要我们重新实现，因为这些需求大多数在&lt;code&gt;Android&lt;/code&gt;系统源码中都有类似的实现，熟练掌握&lt;code&gt;Android&lt;/code&gt;系统源码，了解系统中常用的那些功能性函数，可以大大提高定制系统的效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在学习系统源码时，碰到问题，要学会暂时记录并跳过，经历过一遍遍学习和实践后，之前遇到的问题可能简单思考便会明白，这不仅节省了时间，也不会在学习过程中逐渐失去信心。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Android源码" scheme="http://example.com/categories/Android%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Android源码" scheme="http://example.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="http://example.com/2021/11/28/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2021/11/28/%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-11-28T14:45:54.000Z</published>
    <updated>2025-05-19T05:18:58.875Z</updated>
    
    <content type="html"><![CDATA[<p>泛型（Generics）是编程语言中一种允许在定义类、接口或方法时使用类型参数的特性，目的是提高代码的类型安全性和可重用性。</p><blockquote><h2><span id="问题">问题</span></h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、为什么我们需要泛型？</span><br><span class="line">2、泛型类、泛型接口和泛型方法</span><br><span class="line">3、如何限定类型变量？</span><br><span class="line">4、泛型使用中的约束和局限性</span><br><span class="line">5、泛型类型能继承吗？</span><br><span class="line">6、泛型中通配符类型</span><br><span class="line">7、虚拟机是如何实现泛型的？</span><br><span class="line">8、反射获取泛型的真实类型</span><br></pre></td></tr></table></figure><!-- toc --><ul><li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B">1、为什么需要泛型？</a></li><li><a href="#2-%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">2、泛型类、泛型接口和泛型方法</a></li><li><a href="#3-%E5%A6%82%E4%BD%95%E9%99%90%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F">3、如何限定类型变量？</a></li><li><a href="#4-%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7">4、泛型使用中的约束和局限性</a></li><li><a href="#5-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%83%BD%E7%BB%A7%E6%89%BF%E5%90%97">5、泛型类型能继承吗？</a></li><li><a href="#6-%E6%B3%9B%E5%9E%8B%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B%E5%8F%AA%E8%83%BD%E7%94%A8%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A">6、泛型中通配符类型（?只能用在方法上）</a></li><li><a href="#7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B3%9B%E5%9E%8B%E7%9A%84">7、虚拟机是如何实现泛型的？</a></li><li><a href="#8-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%9C%9F%E5%AE%9E%E7%B1%BB%E5%9E%8B">8、反射获取泛型的真实类型</a></li></ul><!-- tocstop --><a id="more"></a><h2><span id="1-为什么需要泛型">1、为什么需要泛型？</span></h2><ul><li>多种数据类型执行相同的代码（增加代码复用性）</li><li>在编译时进行更强的类型检查。</li><li>使用泛型不需要强制转换类型</li></ul><h2><span id="2-泛型类-泛型接口和泛型方法">2、泛型类、泛型接口和泛型方法</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--泛型类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Genericity</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">--泛型方法</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInput</span><span class="params">(T input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    --泛型方法<span class="number">2</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">getInput2</span><span class="params">(E input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//泛型类</span></span><br><span class="line">        Genericity&lt;String&gt; genericity=<span class="keyword">new</span> Genericity&lt;&gt;();</span><br><span class="line">        genericity.setData(<span class="string">&quot;泛型&quot;</span>);</span><br><span class="line">        Genericity&lt;Integer&gt; genericityInteger=<span class="keyword">new</span> Genericity&lt;&gt;();</span><br><span class="line">        genericityInteger.setData(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//泛型方法</span></span><br><span class="line">        Genericity genericityMethod=<span class="keyword">new</span> Genericity();</span><br><span class="line">        genericityMethod.getInput(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        genericityMethod.getInput(<span class="number">11</span>);</span><br><span class="line">        genericityMethod.getInput(<span class="number">1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--泛型接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Genertor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">--实现<span class="number">1</span>、不传入具体类型，返回值为T</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Genertor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--实现<span class="number">2</span>、传入具体类型String，返回值为String</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorImpl2</span> <span class="keyword">implements</span> <span class="title">Genertor</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型类只影响它的普通方法</li><li>泛型类的T和泛型方法的T毫无关系，换成其他也一样，例如E，但是方法名不能一样，因为泛型在Java编译时是Object</li><li>泛型接口实现时，不传入具体类型传入T时，接口的方法返回的也是T。当传入具体类型时，接口的方法返回的也是具体的类型。</li><li>泛型方法只有方法前面有<t>的才是泛型方法</t></li></ul><h2><span id="3-如何限定类型变量">3、如何限定类型变量？</span></h2><ol><li>限定类型是写在类上的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenertorClass&lt;String&gt; genertorClass = <span class="keyword">new</span> GenertorClass&lt;&gt;();</span><br><span class="line">        GenertorClass&lt;Object&gt; genertorClass2 = <span class="keyword">new</span> GenertorClass&lt;&gt;();</span><br><span class="line"><span class="comment">//传入String是正常的，传入Object时报错：</span></span><br><span class="line">        <span class="comment">//Type parameter &#x27;java.lang.Object&#x27; is not within its bound; should implement &#x27;java.lang.Comparable&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码传入String时是正常的，传入Object时报错：<code>Type parameter &#39;java.lang.Object&#39; is not within its bound; should implement &#39;java.lang.Comparable&#39;</code></p><p>因为String继承了 Comparable接口，而Object没有继承该接口</p><ol start="2"><li>限定类型写在方法上</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.compareTo(b) &gt; <span class="number">0</span>) <span class="keyword">return</span> a;<span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenertorClass.min(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        GenertorClass.min(<span class="string">&quot;1&quot;</span>,<span class="keyword">new</span> Object());<span class="comment">//报reason: no instance(s) of type variable(s) exist so that Object conforms to Comparable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GenertorClass.min(“1”,”2”);是正确的，因为String继承了Comparable接口，而Object没有继承该接口。</p><ol start="3"><li>多个限定类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--类<span class="number">1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">--类<span class="number">2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">--类<span class="number">3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span> &amp; <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenertorClass&lt;Apple&gt; genertorClass = <span class="keyword">new</span> GenertorClass&lt;&gt;();</span><br><span class="line">        GenertorClass&lt;Fruit&gt; genertorClass2 = <span class="keyword">new</span> GenertorClass&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GenertorClass<apple>是正常的，GenertorClass<fruit>报错：<code>Type parameter &#39;Fruit&#39; is not within its bound; should implement &#39;java.io.Serializable&#39;</code>。</fruit></apple></p><p>因为两个限定类型都要实现才行，而且类3中Fruit&amp;Serializable两个位置不能调换。</p><ul><li>T extends B <strong>B可以是类也可以是接口。</strong></li><li>泛型类和泛型方法都可以使用多个限定类型</li><li>B可以是多个对象：T extends Comparable&amp;Serializable。<strong>多个对象时，传入的对象必需要同时实现多个限定类型Comparable和Serializable</strong></li><li><strong>B为类和接口混合时，类只能有一个（java里单继承，多实现），并且必需放在最前面 ,否则会报错。</strong></li></ul><h2><span id="4-泛型使用中的约束和局限性">4、泛型使用中的约束和局限性</span></h2><ul><li><p>不能实例化类型变量。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T data = <span class="keyword">new</span> T()<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure></li><li><p>静态域或者静态方法里不能引用类型变量。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> T instance;<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure><p>（因为在new对象时，才知道真实的类型，虚拟机运行时，先执行static对象、方法，再执行构造方法，所以静态中使用泛型，虚拟机是不知道泛型类型的）</p></li><li><p>静态方法本身是泛型方法是可行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priavte <span class="keyword">static</span> &lt;T&gt; <span class="function">T  <span class="title">getInstance</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//允许</span></span><br></pre></td></tr></table></figure></li><li><p>基本类型是不行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">int</span>&gt;,&lt;<span class="keyword">double</span>&gt;<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure><p>int,double(不是对象)，只允许其包装类Integer，Double</p></li><li><p>不能使用instanceof关键字判断变量类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;Double&gt; test=<span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(test <span class="keyword">instanceof</span> Test&lt;Double&gt;)&#123;&#125;<span class="comment">//不允许  编译时的类型擦除</span></span><br></pre></td></tr></table></figure></li><li><p>泛型能定义数据，但不能创建数组（new 对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T[] list;<span class="comment">//允许</span></span><br><span class="line"><span class="keyword">private</span> T[] list2=<span class="keyword">new</span> T[<span class="number">2</span>];<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure></li><li><p>泛型类获取的一定是类的原生类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;Integer&gt; test1 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">Test&lt;String&gt; test2 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">System.out.println(test1.getClass()==test2.getClass());</span><br><span class="line">System.out.println(test1.getClass().getName());</span><br><span class="line">System.out.println(test2.getClass().getName());</span><br><span class="line">out:========================================</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">com.example.annotation.Test</span><br><span class="line">com.example.annotation.Test</span><br></pre></td></tr></table></figure><p>这里的原生类型是Test，和传的参数无关</p></li><li><p>泛型类不能继承Exception</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;<span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//报错：Generic class may not extend &#x27;java.lang.Throwable&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>不能捕获泛型类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123; <span class="comment">//报错</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不能捕获，但是可以抛出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork2</span><span class="params">(T x)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> x; <span class="comment">//允许的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="5-泛型类型能继承吗">5、泛型类型能继承吗？</span></h2><ol><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类 Worker extents Employee类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型类Pair</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>Pair<worker>和Pair<employee> 没有任何继承关系</employee></worker></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; employeePair= <span class="keyword">new</span> Pair&lt;Worker&gt;();<span class="comment">//不允许，错误的</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ExtendPair</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>泛型类可以继承或者扩展其他泛型类 //比如List和ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; employee = <span class="keyword">new</span> ExtendPair&lt;&gt;; <span class="comment">//允许的</span></span><br></pre></td></tr></table></figure></li></ul><h2><span id="6-泛型中通配符类型只能用在方法上">6、泛型中通配符类型（?只能用在方法上）</span></h2><p>通配符主要用于安全的访问数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HongFuShi</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><? extends Fruit>表示Pair传进去的类型参数是Fruit的子类包括Fruit本身（Fruit,Apple,Orange,HongFuShi）</li></ol><ul><li><p>extends决定了类型参数的上界：向下的范围，即泛型对象必需继承Fruit或Fruit本身–Food不可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限定类型Fruit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassName</span><span class="params">(Pair&lt;? extends Fruit&gt; data)</span> </span>&#123;</span><br><span class="line">    System.out.println(data.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;Fruit&gt; fruitPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Apple&gt; applePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Food&gt; foodPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair.printClassName(fruitPair);<span class="comment">//允许</span></span><br><span class="line">Pair.printClassName(applePair);<span class="comment">//允许</span></span><br><span class="line">Pair.printClassName(foodPair);<span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Pair&lt;Food&gt;无法转换为Pair&lt;? extends Fruit&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限定类型变量赋值时，也是只能使用传入Fruit子类或者本身的对象</span></span><br><span class="line">Pair&lt;Fruit&gt; fruitPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Apple&gt; applePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Food&gt; foodPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;? extends Fruit&gt; f = fruitPair;<span class="comment">//允许</span></span><br><span class="line">Pair&lt;? extends Fruit&gt; f2 = applePair;<span class="comment">//允许</span></span><br><span class="line">Pair&lt;? extends Fruit&gt; f3 = foodPair;<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure></li></ul><p>  使用&lt;? extends Fruit&gt;给对象set，get值时：set是不允许的，get只能get到Fruit对象，即extends的上界类型。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Fruit&gt; fruitPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Apple&gt; applePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;? extends Fruit&gt; data = fruitPair;</span><br><span class="line">或</span><br><span class="line">Pair&lt;? extends Fruit&gt; data = applePair;</span><br><span class="line"></span><br><span class="line">data.setData(<span class="keyword">new</span> Apple());<span class="comment">//不允许</span></span><br><span class="line">data.setData(<span class="keyword">new</span> Fruit());<span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Fruit无法转换为CAP#1</span></span><br><span class="line"><span class="comment">//        data.setData(new Fruit());</span></span><br><span class="line"><span class="comment">//                     ^</span></span><br><span class="line"><span class="comment">//  其中, CAP#1是新类型变量:</span></span><br><span class="line"><span class="comment">//    CAP#1从? extends Fruit的捕获扩展Fruit</span></span><br><span class="line">Fruit fruit = data.getData();<span class="comment">//允许，获取到Fruit对象</span></span><br><span class="line">Apple apple = (Apple) data.getData();<span class="comment">//需要转型，如果类型不正确会报ClassCastException强转异常</span></span><br></pre></td></tr></table></figure><p>  get方法：不管我们传的是Fruit还是它的子类，对于编译器来说我们传的一定是个Fruit，所以获取到的对象一定是个Fruit（子类继承Fruit）。</p><p>  set方法：对于编译器来说你传的是个Fruit,但是是具体的哪一个子类，编译器是不知道的。</p><p><strong>&lt;? extends Fruit&gt;主要用于安全的访问数据–读数据</strong></p><ol start="2"><li><? super Apple>表示Pair传进去的类型参数是Apple的父类包括Apple本身。(Apple,Fruit,Food)</li></ol><ul><li><p>super 决定了类型参数的下界：向上的范围，即泛型对象是Apple的超类或Apple本身–HongFuShi不可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSuper</span><span class="params">(Pair&lt;? <span class="keyword">super</span> Apple&gt; data)</span></span>&#123;</span><br><span class="line">    System.out.println(data.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;Fruit&gt; fruitPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Apple&gt; applePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Orange&gt; orangePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;HongFuShi&gt; hongFuShiPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">printSuper(fruitPair);<span class="comment">//允许</span></span><br><span class="line">printSuper(applePair);<span class="comment">//允许</span></span><br><span class="line">printSuper(orangePair);<span class="comment">//不允许，平级类</span></span><br><span class="line">printSuper(hongFuShiPair);<span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Pair&lt;HongFuShi&gt;无法转换为Pair&lt;? super Apple&gt;</span></span><br><span class="line"><span class="comment">//        printSuper(hongFuShiPair);</span></span><br><span class="line"></span><br><span class="line">Pair&lt;? <span class="keyword">super</span> Apple&gt; data = fruitPair; <span class="comment">//允许</span></span><br><span class="line">Pair&lt;? <span class="keyword">super</span> Apple&gt; data = applePair; <span class="comment">//允许</span></span><br><span class="line">Pair&lt;? <span class="keyword">super</span> Apple&gt; data = hongFuShiPair; <span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Pair&lt;HongFuShi&gt;无法转换为Pair&lt;? super Apple&gt;</span></span><br><span class="line"><span class="comment">//        Pair&lt;? super Apple&gt; data = hongFuShiPair;</span></span><br><span class="line"><span class="comment">//                                   ^</span></span><br><span class="line"></span><br><span class="line">但是在设值的时候只能设置Apple的子类和它本身</span><br><span class="line">data.setData(<span class="keyword">new</span> Apple()); <span class="comment">//允许</span></span><br><span class="line">data.setData(<span class="keyword">new</span> HongFuShi()); <span class="comment">//允许</span></span><br><span class="line">data.setData(<span class="keyword">new</span> Fruit()); <span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Fruit无法转换为CAP#1</span></span><br><span class="line"><span class="comment">//        data.setData(new Fruit());</span></span><br><span class="line"><span class="comment">//                    ^</span></span><br><span class="line"><span class="comment">// 其中, CAP#1是新类型变量:</span></span><br><span class="line"><span class="comment">//    CAP#1从? super Apple的捕获扩展Object 超 Apple</span></span><br><span class="line"></span><br><span class="line">获取数据时获取到的是Object对象</span><br><span class="line">Object object = data.getData();</span><br></pre></td></tr></table></figure><? super Apple>set方法：只能传Apple和其子类，（因为子类包含了Apple或者HongFuShi，子类可以安全的转换为 super Apple）get方法：获取的对象一定是Apple的超类，Java中Object一定是Apple的超类。所以返回的是Object</li></ul><p><strong>&lt;? super Apple&gt;主要用于安全的写入数据，只能是其本身Apple和其子类</strong></p><h2><span id="7-虚拟机是如何实现泛型的">7、虚拟机是如何实现泛型的？</span></h2><p>我们定义了一个简单的泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过字节码查看工具查看该类的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature &lt;E:Ljava/lang/Object;&gt;Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// declaration: GenertorASM&lt;E&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: GenertorASM.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="comment">// signature TE;</span></span><br><span class="line">  <span class="comment">// declaration: data extends E</span></span><br><span class="line">  <span class="keyword">private</span> Ljava/lang/Object; data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">8</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature ()TE;</span></span><br><span class="line">  <span class="comment">// declaration: E getData()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getData</span><span class="params">()</span>Ljava/lang/Object</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">12</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    GETFIELD GenertorASM.data : Ljava/lang/Object;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature (TE;)V</span></span><br><span class="line">  <span class="comment">// declaration: void setData(E)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setData</span><span class="params">(Ljava/lang/Object;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 16 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    PUTFIELD GenertorASM.data : Ljava/lang/Object</span>;</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">17</span> L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L2 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    LOCALVARIABLE data Ljava/lang/Object; L0 L2 <span class="number">1</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data extends E</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用javap命令反编译.class文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">javap -c -l GenertorASM.class<span class="comment">// -c对代码进行反汇编,-l输出行号和本地变量表</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GenertorASM</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   LGenertorASM;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #2                  // Field data:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   LGenertorASM;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(E)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #2                  // Field data:Ljava/lang/Object;</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">17</span>: <span class="number">5</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   LGenertorASM;</span><br><span class="line">          <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span>  data   Ljava/lang/Object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反编译后，可以看到泛型被擦除了，对应的是Object对象，但在的signature中记录了泛型。</p><p>泛型擦除的原因：</p><pre><code>在Java1.5之前不存在泛型的，1.5之后才添加的泛型，为了向下兼容，所以在编译时使用了泛型擦除用Object代替。</code></pre><p>使用泛型限定符时,java编译时会将泛型转成限定符的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature &lt;E:LFruit;&gt;Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// declaration: GenertorASM&lt;E extends Fruit&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: GenertorASM.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="comment">// signature TE;</span></span><br><span class="line">  <span class="comment">// declaration: data extends E</span></span><br><span class="line">  <span class="keyword">private</span> LFruit; data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">8</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature ()TE;</span></span><br><span class="line">  <span class="comment">// declaration: E getData()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getData</span><span class="params">()</span>LFruit</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">11</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    GETFIELD GenertorASM.data : LFruit;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature (TE;)V</span></span><br><span class="line">  <span class="comment">// declaration: void setData(E)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setData</span><span class="params">(LFruit;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 14 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    PUTFIELD GenertorASM.data : LFruit</span>;</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">15</span> L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L2 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    LOCALVARIABLE data LFruit; L0 L2 <span class="number">1</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data extends E</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果限定符有多个时，字节码中泛型使用第一个限定的类型，在使用其他的类型时，会使用强转成对应的类型（所以多个限定符时要注意强转异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Fruit</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">compare</span><span class="params">(E data1, E data2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data1.compareTo(data2) &gt; <span class="number">0</span> ? data1 : data2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature &lt;E:LFruit;:Ljava/lang/Comparable;&gt;Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// declaration: GenertorASM&lt;E extends Fruit extends java.lang.Comparable&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: GenertorASM.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="comment">// signature TE;</span></span><br><span class="line">  <span class="comment">// declaration: data extends E</span></span><br><span class="line">  <span class="keyword">private</span> LFruit; data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">8</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature ()TE;</span></span><br><span class="line">  <span class="comment">// declaration: E getData()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getData</span><span class="params">()</span>LFruit</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">12</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    GETFIELD GenertorASM.data : LFruit;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature (TE;)V</span></span><br><span class="line">  <span class="comment">// declaration: void setData(E)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setData</span><span class="params">(LFruit;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 16 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    PUTFIELD GenertorASM.data : LFruit</span>;</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">17</span> L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L2 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    LOCALVARIABLE data LFruit; L0 L2 <span class="number">1</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data extends E</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature (TE;TE;)TE;</span></span><br><span class="line">  <span class="comment">// declaration: E compare(E, E)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">compare</span><span class="params">(LFruit;LFruit;)</span>LFruit</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">20</span> L0</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    CHECKCAST java/lang/Comparable</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    INVOKEINTERFACE java/lang/Comparable.compareTo (Ljava/lang/Object;)I (itf)</span><br><span class="line">    IFLE L1</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    GOTO L2</span><br><span class="line">   L1</span><br><span class="line">   FRAME SAME</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">   L2</span><br><span class="line">   FRAME SAME1 Fruit</span><br><span class="line">    ARETURN</span><br><span class="line">   L3</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L3 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    LOCALVARIABLE data1 LFruit; L0 L3 <span class="number">1</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data1 extends E</span></span><br><span class="line">    LOCALVARIABLE data2 LFruit; L0 L3 <span class="number">2</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data2 extends E</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在字节码中<code>CHECKCAST java/lang/Comparable</code> 将对象强转成Comparable类型</p><p>相同方法使用泛型，类型不同时报错-因为在编译时类型擦除后的对象都是Objects</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//报错：&#x27;method(List&lt;String&gt;)&#x27; clashes with &#x27;method(List&lt;Integer&gt;)&#x27;; both methods have same erasure</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外在jdk中如果返回值不同（一个返回String，一个返回Integer），编译是不会报错的，但是开发工具中是报上面错的（idea这种只比较方法名和参数没有比较返回值）</p><h2><span id="8-反射获取泛型的真实类型">8、反射获取泛型的真实类型</span></h2><p>当我们对一个泛型类进行反射时，需要得到泛型中的真实数据类型，业完成如json反序列化的操作。此时需要通过Type体系来完成。Type接口包含了一个实现类(Class)和四个实现接口，他们分别是：</p><ul><li>TypeVariable<ul><li>泛型类型变量。可以获得泛型上下限等信息。</li></ul></li><li>ParameterizedType<ul><li>具体的泛型类型，可以获得元数据中泛型签名类型（泛型真实类型）。</li></ul></li><li>GenericArrayType<ul><li>当需要描述的类型是泛型类的数组时，比如List[],Map[]，此接口会作为Type的实现。</li></ul></li><li>WildcardType<ul><li>通配符泛型，获得上下限信息。</li></ul></li></ul><p>Type是个接口,它的直接实现类就是Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Type</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们创建一个Response泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="keyword">int</span> code;</span><br><span class="line">    String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(T data, <span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">        String result;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Response&lt;Data&gt; response = <span class="keyword">new</span> Response&lt;&gt;(<span class="keyword">new</span> Data(<span class="string">&quot;数据&quot;</span>), <span class="number">0</span>, <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String json = gson.toJson(response);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Response&lt;Data&gt; result = gson.fromJson(json,Response.class);</span><br><span class="line">        System.out.println(result.data.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个response对象传入Data数据类型，打印序列化后的数据</p><p><code>&#123;&quot;data&quot;:&#123;&quot;result&quot;:&quot;数据&quot;&#125;,&quot;code&quot;:0,&quot;message&quot;:&quot;成功&quot;&#125;</code></p><p>然后我们通过gson反序列化打印data类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.lis.wanjob.jol.Response$Data</span></span><br><span class="line"><span class="comment">//at com.lis.wanjob.jol.Response.main(Response.java:35)</span></span><br></pre></td></tr></table></figure><p>gson解析时会把Data认为是LinkedTreeMap类型，所以在打印时强制转换时报错了。</p><p>正确的解析是通过Type</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Type type = <span class="keyword">new</span> TypeToken&lt;Response&lt;Data&gt;&gt;() &#123;</span><br><span class="line">        &#125;.getType();</span><br><span class="line">System.out.println(type);</span><br><span class="line">Response&lt;Data&gt; result = gson.fromJson(json, type);</span><br><span class="line">System.out.println(result.data.getClass());</span><br><span class="line">--打印结果为：</span><br><span class="line">com.lis.wanjob.jol.Response&lt;com.lis.wanjob.jol.Response$Data&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lis</span>.<span class="title">wanjob</span>.<span class="title">jol</span>.<span class="title">Response</span>$<span class="title">Data</span></span></span><br></pre></td></tr></table></figure><p>我们看一下TypeToken的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">TypeToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.type = getSuperclassTypeParameter(<span class="keyword">this</span>.getClass());</span><br><span class="line">       <span class="keyword">this</span>.rawType = Types.getRawType(<span class="keyword">this</span>.type);</span><br><span class="line">       <span class="keyword">this</span>.hashCode = <span class="keyword">this</span>.type.hashCode();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> Type <span class="title">getSuperclassTypeParameter</span><span class="params">(Class&lt;?&gt; subclass)</span> </span>&#123;</span><br><span class="line">       Type superclass = subclass.getGenericSuperclass();</span><br><span class="line">       <span class="keyword">if</span> (superclass <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Missing type parameter.&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ParameterizedType parameterized = (ParameterizedType)superclass;</span><br><span class="line">           <span class="keyword">return</span> Types.canonicalize(parameterized.getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里我们调用的是TypeToken 受保护的构造函数，getType()就是返回的type.</p><p>getSuperclassTypeParameter()方法中，如果TypeToken类的类型type是泛型类型的话，会被装载为Type的子接口ParameterizedType，可以让我们得到具体的泛型类型。</p><p>在实例化TypeToken时使用{}，实际上是匿名内部类。</p><p>我们自己创建个类来解析泛型的真实类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        Type actualTyep;</span><br><span class="line"></span><br><span class="line">        <span class="function">Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> actualTyep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TypeReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Type superclass = getClass().getGenericSuperclass();</span><br><span class="line">            ParameterizedType type = (ParameterizedType) superclass;</span><br><span class="line">            <span class="comment">//这里是数组，因为泛型可以有多个&lt;T,E&gt;</span></span><br><span class="line">            Type[] actualTypeArguments = type.getActualTypeArguments();</span><br><span class="line">            actualTyep = actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不加{}<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不加&#123;&#125;时，new TypeReference&lt;Response&lt;Data&gt;&gt;()代表一个对象</span></span><br><span class="line">Type type2 = <span class="keyword">new</span> TypeReference&lt;Response&lt;Data&gt;&gt;().getType();</span><br><span class="line">System.out.println(type2);</span><br><span class="line">Response&lt;Data&gt; result = gson.fromJson(json, type2);</span><br><span class="line">System.out.println(result.data.getClass());</span><br></pre></td></tr></table></figure></li></ul><p>我们在输出时，不加{}时报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.reflect.ParameterizedType</span><br><span class="line">at com.lis.wanjob.jol.Response$TypeReference.&lt;init&gt;(Response.java:<span class="number">41</span>)</span><br><span class="line">at com.lis.wanjob.jol.Response.main(Response.java:<span class="number">62</span>)</span><br></pre></td></tr></table></figure><ul><li>加{}<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加&#123;&#125;时，new TypeReference&lt;Response&lt;Data&gt;&gt;()&#123;&#125;代表一个匿名内部类</span></span><br><span class="line">Type type2 = <span class="keyword">new</span> TypeReference&lt;Response&lt;Data&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">System.out.println(type2);</span><br><span class="line">Response&lt;Data&gt; result = gson.fromJson(json, type2);</span><br><span class="line">System.out.println(result.data.getClass());</span><br></pre></td></tr></table></figure></li></ul><p>我们输出时：能正常的打印泛型的真实类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.lis.wanjob.jol.Response&lt;com.lis.wanjob.jol.Response$Data&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lis</span>.<span class="title">wanjob</span>.<span class="title">jol</span>.<span class="title">Response</span>$<span class="title">Data</span></span></span><br></pre></td></tr></table></figure><ol><li><p>因为不加{}时，new TypeReference&lt;Response<data>&gt;()只是一个对象，在TypeReference没有记录泛型真实类型的地方，此时的Type就是Class,所以强转ParameterizedType时会报错。编译文件Response$TypeReference.class，as中查看：</data></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span>$<span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Type actualTyep;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.actualTyep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Response$TypeReference() &#123;</span><br><span class="line">        Type superclass = <span class="keyword">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        ParameterizedType type = (ParameterizedType)superclass;</span><br><span class="line">        Type[] actualTypeArguments = type.getActualTypeArguments();</span><br><span class="line">        <span class="keyword">this</span>.actualTyep = actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>加了{}时，new TypeReference&lt;Response<data>&gt;(){}是匿名内部类，编译时，会为我们生成对应的内部类的文件Response$1.class，我们在as中打开看到如下代码</data></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>$1 <span class="keyword">extends</span> <span class="title">TypeReference</span>&lt;<span class="title">Response</span>&lt;<span class="title">Data</span>&gt;&gt; </span>&#123;</span><br><span class="line">    Response$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类中记录了泛型的真实类型。在getType()获取类型时，其实是获取的内部类的类型，所以我们可以得到泛型的真实类型。</p><p>PS：我们可以将解析泛型的真实类型的类定义为抽象或将构造方法改为受保护的（必需不同包下），这样在创建解析类时必需加{}成为匿名内部类，来获取泛型的真实类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">TypeReference</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;泛型（Generics）是编程语言中一种允许在定义类、接口或方法时使用类型参数的特性，目的是提高代码的类型安全性和可重用性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1、为什么我们需要泛型？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2、泛型类、泛型接口和泛型方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3、如何限定类型变量？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4、泛型使用中的约束和局限性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5、泛型类型能继承吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6、泛型中通配符类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7、虚拟机是如何实现泛型的？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8、反射获取泛型的真实类型&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B&quot;&gt;1、为什么需要泛型？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95&quot;&gt;2、泛型类、泛型接口和泛型方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-%E5%A6%82%E4%BD%95%E9%99%90%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F&quot;&gt;3、如何限定类型变量？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7&quot;&gt;4、泛型使用中的约束和局限性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%83%BD%E7%BB%A7%E6%89%BF%E5%90%97&quot;&gt;5、泛型类型能继承吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6-%E6%B3%9B%E5%9E%8B%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B%E5%8F%AA%E8%83%BD%E7%94%A8%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A&quot;&gt;6、泛型中通配符类型（?只能用在方法上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B3%9B%E5%9E%8B%E7%9A%84&quot;&gt;7、虚拟机是如何实现泛型的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%9C%9F%E5%AE%9E%E7%B1%BB%E5%9E%8B&quot;&gt;8、反射获取泛型的真实类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;</summary>
    
    
    
    <category term="Java基础与进阶" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="泛型" scheme="http://example.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>View基础</title>
    <link href="http://example.com/2021/06/15/view/"/>
    <id>http://example.com/2021/06/15/view/</id>
    <published>2021-06-15T06:56:23.000Z</published>
    <updated>2021-07-04T11:11:26.854Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android自定义view">Android自定义View</span></h1><h2><span id="概述">概述</span></h2><!-- toc --><ul><li><a href="#android%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E7%9A%84%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF">Android开发进阶的必经之路</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89view">为什么要自定义View</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">自定义View的基本方法</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%88%86%E7%B1%BB">自定义控件分类</a></li></ul><ul><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89view%E5%9F%BA%E7%A1%80">自定义View基础</a><ul><li><a href="#view%E7%9A%84%E5%88%86%E7%B1%BB">View的分类</a></li><li><a href="#view%E7%B1%BB%E7%AE%80%E4%BB%8B">View类简介</a></li><li><a href="#attributeset%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7">AttributeSet与自定义属性</a></li><li><a href="#view%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84">View视图结构</a></li><li><a href="#android%E5%9D%90%E6%A0%87%E7%B3%BB">Android坐标系</a></li><li><a href="#view%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E6%8F%8F%E8%BF%B0">View位置（坐标）描述</a></li><li><a href="#%E4%BD%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F">位置获取方式</a></li><li><a href="#android%E4%B8%AD%E9%A2%9C%E8%89%B2%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">Android中颜色相关内容</a></li></ul></li><li><a href="#view%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B">View树的绘制流程</a><ul><li><a href="#view%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E6%98%AF%E8%B0%81%E8%B4%9F%E8%B4%A3%E7%9A%84">View树的绘制流程是谁负责的？</a></li><li><a href="#view%E7%9A%84%E6%B7%BB%E5%8A%A0">view的添加</a></li><li><a href="#view%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B">view的绘制流程</a></li><li><a href="#measure">measure</a></li><li><a href="#layout">layout</a></li><li><a href="#draw">draw</a></li></ul></li><li><a href="#layoutparams">LayoutParams</a><ul><li><a href="#marginlayoutparams">MarginLayoutParams</a></li><li><a href="#layoutparams%E4%B8%8Eview%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%81%94%E7%B3%BB">LayoutParams与View如何建立联系</a></li><li><a href="#addview">addView</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89layoutparams">自定义LayoutParams</a></li><li><a href="#layoutparams%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%90%E7%B1%BB">LayoutParams常见的子类</a></li></ul></li><li><a href="#measurespec">MeasureSpec</a><ul><li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li><li><a href="#measurespecs-%E7%9A%84%E6%84%8F%E4%B9%89">MeasureSpecs 的意义</a></li><li><a href="#measurespec%E5%80%BC%E7%9A%84%E7%A1%AE%E5%AE%9A">MeasureSpec值的确定</a></li></ul></li></ul><!-- tocstop --><h3><span id="android开发进阶的必经之路">Android开发进阶的必经之路</span></h3><h3><span id="为什么要自定义view">为什么要自定义View</span></h3><h3><span id="自定义view的基本方法">自定义View的基本方法</span></h3><p>自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();<br>View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。</p><ul><li>测量：onMeasure()决定View的大小；</li><li>布局：onLayout()决定View在ViewGroup中的位置；</li><li>绘制：onDraw()决定绘制这个View。</li></ul><a id="more"></a><h3><span id="自定义控件分类">自定义控件分类</span></h3><ul><li>自定义View: 只需要重写onMeasure()和onDraw()</li><li>自定义ViewGroup: 则只需要重写onMeasure()和onLayout()</li></ul><h2><span id="自定义view基础">自定义View基础</span></h2><h3><span id="view的分类">View的分类</span></h3><p>视图View主要分为两类<br>| 类别     | 解释                                      | 特点         |<br>| ——– | —————————————– | ———— |<br>| 单一视图 | 即一个View，如TextView                    | 不包含子View |<br>| 视图组   | 即多个View组成的ViewGroup，如LinearLayout | 包含子View   |</p><h3><span id="view类简介">View类简介</span></h3><ul><li><p>View类是Android中各种组件的基类，如View是ViewGroup基类</p></li><li><p>View表现为显示在屏幕上的各种视图</p><blockquote><p>Android中的UI组件都由View、ViewGroup组成。</p></blockquote></li><li><p>View的构造函数：共有4个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果View是在Java代码里面new的，则调用第一个构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CarsonView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果View是在.xml里声明的，则调用第二个构造函数</span></span><br><span class="line"><span class="comment">// 自定义属性是从AttributeSet参数传进来的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用</span></span><br><span class="line"><span class="comment">// 一般是在第二个构造函数里主动调用</span></span><br><span class="line"><span class="comment">// 如View有style属性时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//API21之后才使用</span></span><br><span class="line">    <span class="comment">// 不会自动调用</span></span><br><span class="line">    <span class="comment">// 一般是在第二个构造函数里主动调用</span></span><br><span class="line">    <span class="comment">// 如View有style属性时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="attributeset与自定义属性">AttributeSet与自定义属性</span></h3><p>　系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤：</p><ol><li>通过<code>&lt;declare-styleable&gt;</code>为自定义View添加属性</li><li>在xml中为相应的属性声明属性值</li><li>在运行时（一般为构造函数）获取属性值</li><li>将获取到的属性值应用到View</li></ol><h3><span id="view视图结构">View视图结构</span></h3><ol><li>PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口</li><li>DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout</li><li>ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等</li></ol><p><img src="/2021/06/15/view/activity.png" alt="activity"></p><p>对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图：</p><p><img src="/2021/06/15/view/view_arch.png" alt="view_arch"></p><p>一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。</p><h3><span id="android坐标系">Android坐标系</span></h3><p>Android的坐标系定义为：</p><ul><li>屏幕的左上角为坐标原点</li><li>向右为x轴增大方向</li><li>向下为y轴增大方向<br><img src="/2021/06/15/view/zuobiaoxi.png" alt="zuobiaoxi"></li></ul><blockquote><p>区别于一般的数学坐标系<br><img src="/2021/06/15/view/zuobiaoxi_qubie.png" alt="zuobiaoxi_qubie"></p></blockquote><h3><span id="view位置坐标描述">View位置（坐标）描述</span></h3><p>View的位置由4个顶点决定的<br>4个顶点的位置描述分别由4个值决定：</p><blockquote><p>请记住：View的位置是相对于父控件而言的）</p></blockquote><ul><li>Top：子View上边界到父view上边界的距离</li><li>Left：子View左边界到父view左边界的距离</li><li>Bottom：子View下边距到父View上边界的距离</li><li>Right：子View右边界到父view左边界的距离</li></ul><h3><span id="位置获取方式">位置获取方式</span></h3><p>View的位置是通过view.getxxx()函数进行获取：（以Top为例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Top位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getTop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> mTop;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余如下：</span></span><br><span class="line">  getLeft();      <span class="comment">//获取子View左上角距父View左侧的距离</span></span><br><span class="line">  getBottom();    <span class="comment">//获取子View右下角距父View顶部的距离</span></span><br><span class="line">  getRight();     <span class="comment">//获取子View右下角距父View左侧的距离</span></span><br></pre></td></tr></table></figure><p>与MotionEvent中 get()和getRaw()的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get() ：触摸点相对于其所在组件坐标系的坐标</span></span><br><span class="line"> event.getX();       </span><br><span class="line"> event.getY();</span><br><span class="line"></span><br><span class="line"><span class="comment">//getRaw() ：触摸点相对于屏幕默认坐标系的坐标</span></span><br><span class="line"> event.getRawX();    </span><br><span class="line"> event.getRawY();</span><br></pre></td></tr></table></figure><p><img src="/2021/06/15/view/zuobiaoxiweizhi.png" alt="zuobiaoxiweizhi"></p><h3><span id="android中颜色相关内容">Android中颜色相关内容</span></h3><p>Android支持的颜色模式：<br><img src="/2021/06/15/view/color1.png" alt="color1"><br>以ARGB8888为例介绍颜色定义:<br><img src="/2021/06/15/view/color2.png" alt="color2"></p><h2><span id="view树的绘制流程">View树的绘制流程</span></h2><h3><span id="view树的绘制流程是谁负责的">View树的绘制流程是谁负责的？</span></h3><p>view树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的；</p><h3><span id="view的添加">view的添加</span></h3><p><img src="/2021/06/15/view/view_qiyuan.png" alt="view_qiyuan"></p><h3><span id="view的绘制流程">view的绘制流程</span></h3><p><img src="/2021/06/15/view/view_traversals.png" alt="view_traversals"></p><h3><span id="measure">measure</span></h3><ol><li>系统为什么要有measure过程？</li><li>measure过程都干了点什么事？</li><li>对于自适应的尺寸机制，如何合理的测量一颗View树？</li><li>那么ViewGroup是如何向子View传递限制信息的？</li><li>ScrollView嵌套ListView问题？</li></ol><p><img src="/2021/06/15/view/view_requestlayout.png" alt="view_requestlayout"></p><h3><span id="layout">layout</span></h3><ol><li>系统为什么要有layout过程？</li><li>layout过程都干了点什么事？</li></ol><p><img src="/2021/06/15/view/view_performlayout.png" alt="view_performlayout"></p><h3><span id="draw">draw</span></h3><ol><li>系统为什么要有draw过程？</li><li>draw过程都干了点什么事？</li></ol><p><img src="/2021/06/15/view/view_invalidate.png" alt="view_invalidate"></p><h2><span id="layoutparams">LayoutParams</span></h2><p>LayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。</p><p>事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类</p><h3><span id="marginlayoutparams">MarginLayoutParams</span></h3><p>MarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的</p><ul><li>属性优先级问题<br>MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级</li></ul><blockquote><p>margin &gt; horizontalMargin和verticalMargin &gt; leftMargin和RightMargin、topMargin和bottomMargin</p></blockquote><ul><li>属性覆盖问题<br>优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释</li></ul><blockquote><p>Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value</p></blockquote><h3><span id="layoutparams与view如何建立联系">LayoutParams与View如何建立联系</span></h3><ul><li>在XML中定义View</li><li>在Java代码中直接生成View对应的实例对象</li></ul><h3><span id="addview">addView</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法1：添加一个子View</span></span><br><span class="line"><span class="comment"> * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    addView(child, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法2：在指定位置添加一个子View</span></span><br><span class="line"><span class="comment"> * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index View将在ViewGroup中被添加的位置（-1代表添加到末尾）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add a null child view to a ViewGroup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams params = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">        params = generateDefaultLayoutParams();<span class="comment">// 生成当前ViewGroup默认的LayoutParams</span></span><br><span class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;generateDefaultLayoutParams() cannot return null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addView(child, index, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法3：添加一个子View</span></span><br><span class="line"><span class="comment"> * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams params = generateDefaultLayoutParams();  <span class="comment">// 生成当前ViewGroup默认的LayoutParams</span></span><br><span class="line">    params.width = width;</span><br><span class="line">    params.height = height;</span><br><span class="line">    addView(child, -<span class="number">1</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法4：添加一个子View，并使用传入的LayoutParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    addView(child, -<span class="number">1</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add a null child view to a ViewGroup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addViewInner() will call child.requestLayout() when setting the new LayoutParams</span></span><br><span class="line">    <span class="comment">// therefore, we call requestLayout() on ourselves before, so that the child&#x27;s request</span></span><br><span class="line">    <span class="comment">// will be blocked at our level</span></span><br><span class="line">    requestLayout();</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">    addViewInner(child, index, params, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewInner</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> preventRequestLayout)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTransition.addChild(<span class="keyword">this</span>, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkLayoutParams(params)) &#123; <span class="comment">// ① 检查传入的LayoutParams是否合法</span></span><br><span class="line">        params = generateLayoutParams(params); <span class="comment">// 如果传入的LayoutParams不合法，将进行转化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preventRequestLayout) &#123; <span class="comment">// ② 是否需要阻止重新执行布局流程</span></span><br><span class="line">        child.mLayoutParams = params; <span class="comment">// 这不会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.setLayoutParams(params); <span class="comment">// 这会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = mChildrenCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addInArray(child, index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell our children</span></span><br><span class="line">    <span class="keyword">if</span> (preventRequestLayout) &#123;</span><br><span class="line">        child.assignParent(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.mParent = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="自定义layoutparams">自定义LayoutParams</span></h3><ol><li>创建自定义属性</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;declare-styleable name=<span class="string">&quot;xxxViewGroup_Layout&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 自定义的属性 --&gt;</span><br><span class="line">        &lt;attr name=<span class="string">&quot;layout_simple_attr&quot;</span> format=<span class="string">&quot;integer&quot;</span>/&gt;</span><br><span class="line">        &lt;!-- 使用系统预置的属性 --&gt;</span><br><span class="line">        &lt;attr name=<span class="string">&quot;android:layout_gravity&quot;</span>/&gt;</span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>继承MarginLayout</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">MarginLayoutParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> simpleAttr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> gravity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(c, attrs);</span><br><span class="line">        <span class="comment">// 解析布局属性</span></span><br><span class="line">        TypedArray typedArray = c.obtainStyledAttributes(attrs, R.styleable.SimpleViewGroup_Layout);</span><br><span class="line">        simpleAttr = typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_layout_simple_attr, <span class="number">0</span>);</span><br><span class="line">        gravity=typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_android_layout_gravity, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        typedArray.recycle();<span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(MarginLayoutParams source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(ViewGroup.LayoutParams source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>重写ViewGroup中几个与LayoutParams相关的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查LayoutParams是否合法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">instanceof</span> SimpleViewGroup.LayoutParams;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成默认的LayoutParams</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对传入的LayoutParams进行转化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewGroup.LayoutParams(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对传入的LayoutParams进行转化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewGroup.LayoutParams(getContext(), attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="layoutparams常见的子类">LayoutParams常见的子类</span></h3><p>在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类：</p><ul><li>ViewGroup.MarginLayoutParams</li><li>FrameLayout.LayoutParams</li><li>LinearLayout.LayoutParams</li><li>RelativeLayout.LayoutParams</li><li>RecyclerView.LayoutParams</li><li>GridLayoutManager.LayoutParams</li><li>StaggeredGridLayoutManager.LayoutParams</li><li>ViewPager.LayoutParams</li><li>WindowManager.LayoutParams</li></ul><h2><span id="measurespec">MeasureSpec</span></h2><h3><span id="定义">定义</span></h3><p><img src="/2021/06/15/view/measureSpec.png" alt="measureSpec"><br>测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种：</p><ul><li>UNSPECIFIED<br>父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大）</li><li>EXACTLY<br>父控件已经知道你所需的精确大小，你的最终大小应该就是这么大。</li><li>AT_MOST<br>你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。<br><img src="/2021/06/15/view/measurespec1.png" alt="measurespec1"></li></ul><h3><span id="measurespecs-的意义">MeasureSpecs 的意义</span></h3><p>通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法</p><h3><span id="measurespec值的确定">MeasureSpec值的确定</span></h3><p>MeasureSpec值到底是如何计算得来的呢?<br><img src="/2021/06/15/view/measurespec2.png" alt="measurespec2"><br>子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个</span></span><br><span class="line"><span class="comment">   * 最可能符合条件的child view的测量规格。  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> spec 父控件的测量规格</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> padding 父控件里已经占用的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> childDimension child view布局LayoutParams里的尺寸</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> child view 的测量规格</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec); <span class="comment">//父控件的测量模式</span></span><br><span class="line">      <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec); <span class="comment">//父控件的测量大小</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">      <span class="comment">// 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了</span></span><br><span class="line">      <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">          <span class="comment">//如果child的布局参数有固定值，比如&quot;layout_width&quot; = &quot;100dp&quot;</span></span><br><span class="line">          <span class="comment">//那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY</span></span><br><span class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              resultSize = childDimension;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125; </span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果child的布局参数是&quot;match_parent&quot;，也就是想要占满父控件</span></span><br><span class="line">          <span class="comment">//而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果child的布局参数是&quot;wrap_content&quot;，也就是想要根据自己的逻辑决定自己大小，</span></span><br><span class="line">          <span class="comment">//比如TextView根据设置的字符串大小来决定自己的大小</span></span><br><span class="line">          <span class="comment">//那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛</span></span><br><span class="line">          <span class="comment">//所以测量模式就是AT_MOST，测量大小就是父控件的size</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size</span></span><br><span class="line">      <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">          <span class="comment">//同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求</span></span><br><span class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              resultSize = childDimension;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="comment">//child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小</span></span><br><span class="line">          <span class="comment">//但同样的，child的尺寸上限也是父控件的尺寸上限size</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//child想要根据自己逻辑决定大小，那就自己决定呗</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">      <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">              resultSize = childDimension;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">              <span class="comment">// be</span></span><br><span class="line">              resultSize = <span class="number">0</span>;</span><br><span class="line">              resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">              <span class="comment">// big it should be</span></span><br><span class="line">              resultSize = <span class="number">0</span>;</span><br><span class="line">              resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/15/view/measurespec3.png" alt="measurespec3"><br>针对上表，这里再做一下具体的说明</p><ul><li>对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定</li><li>对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。<pre><code>1.  当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小；    2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间；        3.  当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。        4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Android自定义View&quot;&gt;&lt;a href=&quot;#Android自定义View&quot; class=&quot;headerlink&quot; title=&quot;Android自定义View&quot;&gt;&lt;/a&gt;Android自定义View&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#android%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E7%9A%84%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF&quot;&gt;Android开发进阶的必经之路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89view&quot;&gt;为什么要自定义View&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95&quot;&gt;自定义View的基本方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%88%86%E7%B1%BB&quot;&gt;自定义控件分类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89view%E5%9F%BA%E7%A1%80&quot;&gt;自定义View基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#view%E7%9A%84%E5%88%86%E7%B1%BB&quot;&gt;View的分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E7%B1%BB%E7%AE%80%E4%BB%8B&quot;&gt;View类简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#attributeset%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7&quot;&gt;AttributeSet与自定义属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84&quot;&gt;View视图结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#android%E5%9D%90%E6%A0%87%E7%B3%BB&quot;&gt;Android坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E6%8F%8F%E8%BF%B0&quot;&gt;View位置（坐标）描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F&quot;&gt;位置获取方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#android%E4%B8%AD%E9%A2%9C%E8%89%B2%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9&quot;&gt;Android中颜色相关内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B&quot;&gt;View树的绘制流程&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#view%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E6%98%AF%E8%B0%81%E8%B4%9F%E8%B4%A3%E7%9A%84&quot;&gt;View树的绘制流程是谁负责的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E7%9A%84%E6%B7%BB%E5%8A%A0&quot;&gt;view的添加&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B&quot;&gt;view的绘制流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#measure&quot;&gt;measure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#layout&quot;&gt;layout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#draw&quot;&gt;draw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#layoutparams&quot;&gt;LayoutParams&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#marginlayoutparams&quot;&gt;MarginLayoutParams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#layoutparams%E4%B8%8Eview%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%81%94%E7%B3%BB&quot;&gt;LayoutParams与View如何建立联系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#addview&quot;&gt;addView&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89layoutparams&quot;&gt;自定义LayoutParams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#layoutparams%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%90%E7%B1%BB&quot;&gt;LayoutParams常见的子类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#measurespec&quot;&gt;MeasureSpec&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9A%E4%B9%89&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#measurespecs-%E7%9A%84%E6%84%8F%E4%B9%89&quot;&gt;MeasureSpecs 的意义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#measurespec%E5%80%BC%E7%9A%84%E7%A1%AE%E5%AE%9A&quot;&gt;MeasureSpec值的确定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;

&lt;h3 id=&quot;Android开发进阶的必经之路&quot;&gt;&lt;a href=&quot;#Android开发进阶的必经之路&quot; class=&quot;headerlink&quot; title=&quot;Android开发进阶的必经之路&quot;&gt;&lt;/a&gt;Android开发进阶的必经之路&lt;/h3&gt;&lt;h3 id=&quot;为什么要自定义View&quot;&gt;&lt;a href=&quot;#为什么要自定义View&quot; class=&quot;headerlink&quot; title=&quot;为什么要自定义View&quot;&gt;&lt;/a&gt;为什么要自定义View&lt;/h3&gt;&lt;h3 id=&quot;自定义View的基本方法&quot;&gt;&lt;a href=&quot;#自定义View的基本方法&quot; class=&quot;headerlink&quot; title=&quot;自定义View的基本方法&quot;&gt;&lt;/a&gt;自定义View的基本方法&lt;/h3&gt;&lt;p&gt;自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();&lt;br&gt;View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测量：onMeasure()决定View的大小；&lt;/li&gt;
&lt;li&gt;布局：onLayout()决定View在ViewGroup中的位置；&lt;/li&gt;
&lt;li&gt;绘制：onDraw()决定绘制这个View。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Activity启动模式</title>
    <link href="http://example.com/2020/12/11/activity/"/>
    <id>http://example.com/2020/12/11/activity/</id>
    <published>2020-12-11T02:40:35.000Z</published>
    <updated>2021-07-04T11:08:22.719Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="从四个视角理解android-activity启动模式">从四个视角理解Android Activity启动模式</span></h1><p>系统视角：</p><h2><span id="1-android的软件体系结构">1. Android的软件体系结构</span></h2><p><img src="/2020/12/11/activity/%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="系统结构图"></p><a id="more"></a><h2><span id="12-task">1.2 Task</span></h2><p><img src="/2020/12/11/activity/task.png" alt="Task"></p><p>Activity代码属于Application，但是Task属于Android操作系统</p><p>Task是可以跨应用的</p><h3><span id="手机查看task用户角度">手机查看Task：（用户角度）</span></h3><p>手机中按home键旁边那个方形键（recent-apps）时，屏幕上展示的就是一个个task。</p><p><img src="/2020/12/11/activity/%E6%9F%A5%E7%9C%8BTask.png" alt="查看手机Task"></p><h3><span id="代码中查看task程序角度">代码中查看Task：（程序角度）</span></h3><p>adb shell dumpsys activity activities | sed -En -e ‘/Stack #/p’ -e ‘/Running activities/,/Run #0/p’</p><p>sed工具不用单独下载，<code>D:\soft\Git\usr\bin\sed.exe</code> Git安装目录下包含，配置下环境变量就可以。 </p><p>用户视角：</p><h2><span id="21-task启动方式launcher启动">2.1 Task启动方式(launcher启动)</span></h2><p>Launcher启动</p><p>1、Task不存在</p><p>2、Task存在</p><h2><span id="22-task启动方式新建">2.2 Task启动方式（新建）</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;message&quot;</span>);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>通知：</p><p>1.系统通知<br>2.自己</p><p>其他第三方应用：</p><p>1、Scheme协议<br>2、第三方应用start</p><p><strong>launcher,新建  都是通过startActivity来创建的。</strong></p><h2><span id="23-task启动方式恢复">2.3 Task启动方式（恢复）</span></h2><p><strong>恢复</strong>   这属于Activity生命周期由不可见到获得焦点的范畴</p><p><img src="/2020/12/11/activity/Task%E6%81%A2%E5%A4%8D.png" alt="Task恢复"></p><p>程序视角：</p><h2><span id="31-activity和fragment">3.1 Activity和Fragment</span></h2><p>Fragment是Android3.0后引入的一个新的API，他出现的初衷是为了适应大屏幕的平板电脑， 当然现在他仍然是平板APP UI设计的宠儿，而且我们普通手机开发也会加入这个Fragment， 我们可以把他看成一个小型的Activity，又称Activity片段！</p><p><img src="/2020/12/11/activity/fragment%E9%9D%99%E6%80%81%E5%8A%A0%E8%BD%BD.png" alt="fragment静态加载"></p><p><img src="/2020/12/11/activity/fragment%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD.png" alt="fragment动态载"></p><h2><span id="32-activity的生命周期">3.2 Activity的生命周期</span></h2><p><img src="/2020/12/11/activity/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Activity生命周期"></p><p>Activity是否可见：</p><p><img src="/2020/12/11/activity/Activity%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A7%81.png" alt="Activity是否可见"></p><p>PS:Fragment生命周期</p><p><img src="/2020/12/11/activity/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.webp" alt="fragment生命周期"></p><p>Activity与Fragment生命周期</p><p><img src="/2020/12/11/activity/activity%E4%B8%8Efragment.png" alt="Activity与Fragment生命周期"></p><h2><span id="33-相邻状态之间的区别">3.3 相邻状态之间的区别</span></h2><p><img src="/2020/12/11/activity/%E7%9B%B8%E9%82%BB%E7%8A%B6%E6%80%81%E5%8C%BA%E5%88%AB.png" alt="A启动B和B返回A"></p><p>A启动B    和    B返回A</p><p><strong>1.onCreate</strong>和<strong>onStart</strong>之间有什么区别？</p><p>（1）可见与不可见的区别。前者不可见，后者可见。<br>（2）执行次数的区别。onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。因此Bundle数据的恢复在onStart中进行比onCreate中执行更合适。<br> （3）onCreate能做的事onStart其实都能做，但是onstart能做的事onCreate却未必适合做。如前文所说的，setContentView和资源初始化在两者都能做，然而想动画的初始化在onStart中做比较好。</p><p><strong>2.onStart</strong>方法和<strong>onResume</strong>方法有什么区别？</p><p>（1）是否在前台。onStart方法中Activity可见但不在前台，不可交互，而在onResume中在前台。<br>（2）职责不同，onStart方法中主要还是进行初始化工作，而onResume方法，根据官方的建议，可以做开启动画和独占设备的操作。</p><p><strong>3.onPause</strong>方法和<strong>onStop</strong>方法有什么区别？</p><p>（1）是否可见。onPause时Activity可见，onStop时Activity不可见，但Activity对象还在内存中。<br>（2）在系统内存不足的时候可能不会执行onStop方法，因此程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但要注意不能太耗时。</p><p><strong>4.onStop</strong>方法和<strong>onDestroy</strong>方法有什么区别？</p><p>onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Acivity被销毁</p><p>**PS:**闪屏页：在onStop()方法中进行finish();</p><h2><span id="34-onnewintent的生命周期">3.4 onNewIntent的生命周期</span></h2><p><img src="/2020/12/11/activity/onNewIntent.png" alt="onNewIntent"></p><p>1、只对<strong>singleTop，singleTask，singleInstance</strong>有效，因为standard每次都是新建(不是绝对，使用了Intent.FLAG_ACTIVITY_NEW_TASK,要启动的Activity已经有Task在运行了，新的activity不会再创建，而是把当前堆栈的activity带到前台)，所以不存在onNewIntent；</p><p>2、只对startActivity有效，对于从Navigation切换回来的恢复无效；</p><h2><span id="41-activity启动模式">4.1 Activity启动模式</span></h2><p><img src="/2020/12/11/activity/%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.png" alt="四种启动模式"></p><h2><span id="42-standard启动模式">4.2 standard启动模式</span></h2><p><strong>1、standard</strong>  <strong>默认模式</strong></p><p>系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，不管这个实例是否已经存在，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。这种模式的 Activity 被创建时它的 onCreate、onStart 都会被调用。这是一种典型的多实例实现，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。</p><p>a、当从非Activity的context启动activity时，需要带new_task的flag；</p><p>b、当启动一个带有affinity的activity，如果这个activity已经有实例存在该task，则不会重新创建；</p><p>c、如果从应用内启动的standard activity的Affinity就是App默认的Affinity，则会每次新建一个实例；</p><h2><span id="43-singletop启动模式">4.3 singleTop启动模式</span></h2><p>一个singleTop Activity 的实例可以无限多，唯一的区别是如果在栈顶已经有一个相同类型的Activity实例，Intent不会再创建一个Activity，而是通过onNewIntent()被发送到现有的Activity。</p><p><img src="/2020/12/11/activity/singetop.png" alt="singleTop"></p><h2><span id="44-singletask模式">4.4 singleTask模式</span></h2><p>这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例，和 singleTop一样，系统也会回调其 onNewIntent。当一个具有 singleTask 模式的Activity请求启动后，比如 Activity A，系统首先会寻找是否存在 A 想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建 A 的实例后把 A 放到栈中。如果存在 A 所需的任务栈，这时要看 A 是否在栈中有实例存在，如果有实例存在，那么系统就会把 A 调到栈顶并调用它的 onNewIntent 方法，如果实例不存在，就创建 A 的实例并把 A 压入栈中 。</p><p><img src="/2020/12/11/activity/singleTask.png" alt="singleTask"></p><p>不需要关注NEW_TASK</p><h2><span id="45-singleinstance模式">4.5 singleInstance模式</span></h2><p>与 singleTask 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。也就是有此种模式的 Activity 只能单独地位于一个任务栈中</p><p>PS：4种模式只能在AndroidManifest.xml中定义（定义层定义的）</p><h2><span id="46-intent-activity-flag">4.6 Intent Activity Flag</span></h2><p>启动层定义</p><p><img src="/2020/12/11/activity/IntentFlag.png" alt="IntentFlag"></p><h2><span id="51-启动模式的应用场景">5.1 启动模式的应用场景</span></h2><table><thead><tr><th><strong>launchMode</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td>singleTop</td><td>适合启动同类型的   Activity，例如：   •接收通知启动的内容显示页面   •耗时操作返回页面   •登录页面</td></tr><tr><td>singleTask</td><td>适合作为程序入口，例如：   •WebView页面   •扫一扫页面   •确认订单界面   •付款界面</td></tr><tr><td>singleInstance</td><td>适合需要与程序分离开的页面，例如：   •闹铃的响铃界面   •来电页面   •锁屏页</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从四个视角理解Android-Activity启动模式&quot;&gt;&lt;a href=&quot;#从四个视角理解Android-Activity启动模式&quot; class=&quot;headerlink&quot; title=&quot;从四个视角理解Android Activity启动模式&quot;&gt;&lt;/a&gt;从四个视角理解Android Activity启动模式&lt;/h1&gt;&lt;p&gt;系统视角：&lt;/p&gt;
&lt;h2 id=&quot;1-Android的软件体系结构&quot;&gt;&lt;a href=&quot;#1-Android的软件体系结构&quot; class=&quot;headerlink&quot; title=&quot;1. Android的软件体系结构&quot;&gt;&lt;/a&gt;1. Android的软件体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/12/11/activity/%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.jpg&quot; alt=&quot;系统结构图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="activity" scheme="http://example.com/tags/activity/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析</title>
    <link href="http://example.com/2020/12/10/okhttp/"/>
    <id>http://example.com/2020/12/10/okhttp/</id>
    <published>2020-12-10T05:26:56.000Z</published>
    <updated>2025-06-04T02:33:31.553Z</updated>
    
    <content type="html"><![CDATA[<ul><li>OkHttp请求流程</li><li>高并发请求分发器与线程池</li><li>责任链模式请求与响应拦截</li></ul><h2><span id="目录">目录</span></h2><!-- toc --><ul><li><a href="#okhttp%E4%BB%8B%E7%BB%8D">OkHttp介绍</a></li><li><a href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">简单使用：</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">使用流程：</a></li><li><a href="#%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B">调用流程：</a></li><li><a href="#%E5%88%86%E5%8F%91%E5%99%A8">分发器：</a><ul><li><a href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">异步请求工作流程：</a></li><li><a href="#okhttp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%89%B9%E7%82%B9">OkHttp线程池的特点：</a><ul><li><a href="#asynccall">AsyncCall</a></li></ul></li><li><a href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82">同步请求</a></li></ul></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器：</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94">获取响应：</a></li><li><a href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链模式：</a></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE">拦截器责任链：</a></li><li><a href="#%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8A%9F%E8%83%BD">五大拦截器功能：</a></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%A6%E6%83%85">拦截器详情：</a><ul><li><a href="#%E4%B8%80-%E9%87%8D%E8%AF%95%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8">一、重试及重定向拦截器</a><ul><li><a href="#%E9%87%8D%E8%AF%95">重试</a></li><li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#%E4%BA%8C-%E6%A1%A5%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8">二、桥接拦截器</a><ul><li><a href="#%E6%80%BB%E7%BB%93-1">总结</a></li></ul></li><li><a href="#%E4%B8%89-%E7%BC%93%E5%AD%98%E6%8B%A6%E6%88%AA%E5%99%A8">三、缓存拦截器</a><ul><li><a href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5">缓存策略</a></li><li><a href="#%E6%B5%81%E7%A8%8B">流程：</a></li><li><a href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B">详细流程：</a></li><li><a href="#ps%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4">PS：请求头与响应头</a></li></ul></li><li><a href="#%E5%9B%9B-%E8%BF%9E%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8">四、连接拦截器</a><ul><li><a href="#%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B">连接流程：</a></li><li><a href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B8%85%E7%90%86">连接池清理：</a></li><li><a href="#%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5">代理连接：</a></li></ul></li><li><a href="#%E4%BA%94-%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8">五、请求服务器拦截器</a><ul><li><a href="#expect-100-continue">Expect: 100-continue</a></li><li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li></ul></li></ul></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8">自定义拦截器</a></li><li><a href="#okhttp%E6%80%BB%E7%BB%93">OkHttp总结</a></li><li><a href="#%E8%A1%A5%E5%85%85-%E4%BB%A3%E7%90%86">补充: 代理</a></li></ul><!-- tocstop --><a id="more"></a><h2><span id="okhttp介绍">OkHttp介绍</span></h2><p>由Square公司贡献的一个处理网络请求的开源项目，是目前Android使用最广泛的网络框架，从Android4。4开始HttpURLConnection的底层实现采用的是OkHttp。</p><ul><li>支持HTTP/2并允许对同一主机的所有请求共享一个套接字</li><li>通过连接池，减少了请求延迟</li><li>默认通过GZip压缩数据</li><li>响应缓存，以免了重复请求的网络</li><li>请求失败自动重试主机的其他ip，自动重定向</li><li>……</li></ul><h2><span id="简单使用">简单使用：</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build();</span><br><span class="line">Call call = okHttpClient.newCall(request);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//同步请求</span></span><br><span class="line">    Response execute = call.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步请求</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2><span id="使用流程">使用流程：</span></h2><p><img src="/2020/12/10/okhttp/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="使用流程"></p><h2><span id="调用流程">调用流程：</span></h2><p>OkHttp请求过程中最少需要接触OkHttpClient、Request、Call、Response，但是框架内部进行大量的逻辑处理。</p><p>所有的逻辑大部分集中在拦截器中，但是在进入拦截器之前还需要依靠分发器来调配请求任务。</p><p><strong>分发器：</strong>内部维护队列与线程池，完成请求调配；Dispatcher</p><p><strong>拦截器：</strong>五大默认拦截器完成整个请求过程； Interceptors</p><h2><span id="分发器">分发器：</span></h2><h3><span id="异步请求工作流程">异步请求工作流程：</span></h3><p><img src="/2020/12/10/okhttp/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B7%A5%E4%BD%9C.png" alt="异步请求工作"></p><ol><li>Q：如何决定将请求放入ready还是running?</li><li>Q：从running移动到ready的条件是什么？</li><li>Q：分发器线程池的工作行为？</li></ol><p><strong>Dispatcher中</strong></p><ol><li><p>A:  client.dispatcher().enqueue(new AsyncCall(responseCallback));</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.running队列数小于最大请求数64（正在请求的的数量是有限制的，自己配置分发器时可以修改）</span></span><br><span class="line">    <span class="comment">//2.同一域名正在请求的个数也是有限制的小于5</span></span><br><span class="line">    <span class="comment">//PS:最大同时请求数64，与同一台服务器请求数5</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">//添加到running队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">//将runnable（call）提交到线程池当中</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不符合上面请求就加入到等待队列</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p> A:client.dispatcher().finished(this);-&gt; promoteCalls()移动队列（异步时才有移动队列）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//正在执行队列数</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="comment">//等待队列数得不为空</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall call = i.next();</span><br><span class="line">        <span class="comment">//如果拿到的等待请求host，在请求的列表中已经存在5个</span></span><br><span class="line">        <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            <span class="comment">//等待移除</span></span><br><span class="line">            i.remove();</span><br><span class="line">            <span class="comment">//加入running</span></span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            <span class="comment">//加入线程池</span></span><br><span class="line">            executorService().execute(call);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断正在执行队列数</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>A:ThreadPoolExecutor</li></ol><p><img src="/2020/12/10/okhttp/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="线程池"></p><p>当一个任务通过execute(Runnable)方法添加到线程池时：</p><ul><li><p>线程数量小于corePoolSize，新建线程(核心)来处理被添加的任务；</p></li><li><p>线程数量大于等于 corePoolSize，存在空闲线程，使用空闲线程执行新任务；-</p></li><li><p>线程数量大于等于 corePoolSize，不存在空闲线程，新任务被添加到等待队列，添加成功则等待空闲线程，添加失败：</p><ul><li>线程数量小于maximumPoolSize，新建线程执行新任务；</li><li>线程数量等于maximumPoolSize，拒绝此任务。 </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//corePoolSize:核心线程数  0 不缓存线程，（0和1的表现是一样的）不用时就不占用线程，闲置60就会回收掉</span></span><br><span class="line">        <span class="comment">//maximumPoolSize最大线程数（包括核心）</span></span><br><span class="line">        <span class="comment">//keepAliveTime 缓存60秒</span></span><br><span class="line">        <span class="comment">//workQueue 队列</span></span><br><span class="line">        <span class="comment">//threadFactory 创建一个thread</span></span><br><span class="line">        <span class="comment">//PS:和Executors.newCachedThreadPool();创建的线程池一样</span></span><br><span class="line">        executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>,</span><br><span class="line">                <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SynchronousQueue</strong> implements BlockingQueue  是个阻塞队列</p><p>PS:三种阻塞队列</p><p><code>ArrayBlockingQueue</code>：基于数组的阻塞队列，初始化需要指定固定大小。</p><p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p><p><code>SynchronousQueue</code> : 无容量的队列。</p><p>往队列中添加元素一定是失败的。</p><h3><span id="okhttp线程池的特点">OkHttp线程池的特点：</span></h3><p><strong>OkHttp提交请求，一定是往队列里提交，往队列中添加是一定是失败的，马上新建线程（没有到最大线程数），</strong></p><p><strong>不需要等待。获得最大的并发量</strong></p><h4><span id="asynccall">AsyncCall</span></h4><p>继承NamedRunnable类实现Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * run方法其实调用的AsyncCall的execute()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String oldName = Thread.currentThread().getName();</span><br><span class="line">        Thread.currentThread().setName(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            execute();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Thread.currentThread().setName(oldName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="同步请求">同步请求</span></h3><p>加入队列，执行完移除队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同步直接加入running队列，这里的running是同步队列不是异步的</span></span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="拦截器">拦截器：</span></h2><p>默认五大拦截器：（责任链模式）<br><strong>重定向与重试，</strong><br><strong>Header、Body处理，</strong><br><strong>缓存处理，</strong><br><strong>连接处理，</strong><br><strong>服务器通讯</strong><br><img src="/2020/12/10/okhttp/%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8.png" alt="五大拦截器"></p><p>请求是顺序的，响应是逆序的</p><h3><span id="获取响应">获取响应：</span></h3><p>无论同步还是异常都是通过getResponseWithInterceptorChain 获得请求结果：Response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 拦截器集合</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//重定向与重试</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">//Header,Body处理</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//缓存处理</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//连接处理</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务器通讯</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">            originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">            client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="责任链模式">责任链模式：</span></h3><p><strong>（一排，最后一位往前一个个传纸条[请求]，传到第一个又一个个往后传[响应]）</strong></p><p>为请求创建了一个接收者对象的链，在处理请求的时候执行过滤(各司其职)。</p><p>责任链上的处理者负责处理请求，客户只需要将请求发送到责任链即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><h3><span id="拦截器责任链">拦截器责任链：</span></h3><p><img src="/2020/12/10/okhttp/%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE.png" alt="拦截器责任链"></p><h3><span id="五大拦截器功能">五大拦截器功能：</span></h3><ol><li><p>重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。</p></li><li><p>桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。</p></li><li><p>缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。</p></li><li><p>连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。</p></li><li><p>请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。</p></li></ol><h3><span id="拦截器详情">拦截器详情：</span></h3><h4><span id="一-重试及重定向拦截器">一、重试及重定向拦截器</span></h4><p>第一个拦截器:<code>RetryAndFollowUpInterceptor</code>，主要就是完成两件事情：重试与重定向。</p><h5><span id="重试">重试</span></h5><p>场景：请求超时；域名解析后多个IP，如果一个IP失败了，重试其他IP</p><p><img src="/2020/12/10/okhttp/retry.png" alt="重试"></p><p><strong>设置是否允许重试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置是否允许重试 默认是允许</span></span><br><span class="line"><span class="keyword">new</span> OkHttpClient().newBuilder().retryOnConnectionFailure(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>在<code>RetryAndFollowUpInterceptor</code>中失败时，进入recover方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//todo 请求出现了异常，那么releaseConnection依旧为true。</span></span><br><span class="line">    response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">    <span class="comment">//todo 路由异常，连接未成功，请求还没发出去</span></span><br><span class="line">    <span class="comment">//The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">    <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">    &#125;</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//重试</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">//todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接)</span></span><br><span class="line">    <span class="comment">// ConnectionShutdownException只对HTTP2存在。假定它就是false</span></span><br><span class="line">    <span class="comment">//An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">    <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">    <span class="keyword">if</span> (!recover(e, streamAllocation, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在recover中 获取是否允许重试，如果不允许就抛异常，结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(IOException e, StreamAllocation streamAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;</span><br><span class="line">        streamAllocation.streamFailed(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 1、在配置OkhttpClient是设置了不允许重试（默认允许），则一旦发生请求失败就不再重试</span></span><br><span class="line">        <span class="comment">//The application layer has forbidden retries.</span></span><br><span class="line">        <span class="keyword">if</span> (!client.retryOnConnectionFailure()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 2、由于requestSendStarted只在http2的io异常中为true，先不管http2</span></span><br><span class="line">        <span class="comment">//We can&#x27;t send the request body again.</span></span><br><span class="line">        <span class="keyword">if</span> (requestSendStarted &amp;&amp; userRequest.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 3、判断是不是属于重试的异常</span></span><br><span class="line">        <span class="comment">//This exception is fatal.</span></span><br><span class="line">        <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 4、是不是存在更多的路线 （多个ip，多个代理）</span></span><br><span class="line">        <span class="comment">//No more routes to attempt.</span></span><br><span class="line">        <span class="keyword">if</span> (!streamAllocation.hasMoreRoutes()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For failure recovery, use the same route selector with a new connection.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>重试的异常包括哪些：</strong></p><p>在 <code>todo 3</code>的isRecoverable方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRecoverable</span><span class="params">(IOException e, <span class="keyword">boolean</span> requestSendStarted)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.是不是协议异常（code为204,205代表没有响应体，同时响应数据长度还大于0两都冲突，参照CallServerInterceptor中</span></span><br><span class="line">    <span class="comment">// if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0)）</span></span><br><span class="line">    <span class="comment">//：不重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ProtocolException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.socket超时异常 返回true:重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InterruptedIOException) &#123;</span><br><span class="line">        <span class="keyword">return</span> e <span class="keyword">instanceof</span> SocketTimeoutException &amp;&amp; !requestSendStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.//SSL证书不正确  可能证书格式损坏 有问题：不重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLHandshakeException) &#123;</span><br><span class="line">        <span class="comment">// If the problem was a CertificateException from the X509TrustManager,</span></span><br><span class="line">        <span class="comment">// do not retry.</span></span><br><span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> CertificateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.SSL证书校验 ：不重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在socket超时异常时会进行重试，其他异常不再进行重试</p><h5><span id="重定向">重定向</span></h5><p>场景：30X，资源改变</p><p><img src="/2020/12/10/okhttp/%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="重定向"></p><p><strong>最大重定向次数为：20</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 处理3和4xx的一些状态码，如301 302重定向</span></span><br><span class="line">Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line"><span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Request <span class="title">followUpRequest</span><span class="params">(Response userResponse, Route route)</span></span></span><br></pre></td></tr></table></figure><p><strong>在followUpRequest中响应码</strong></p><hr><p>407:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//407 身份校验</span></span><br><span class="line"><span class="keyword">case</span> HTTP_PROXY_AUTH:</span><br><span class="line">    Proxy selectedProxy = route != <span class="keyword">null</span></span><br><span class="line">            ? route.proxy()</span><br><span class="line">            : client.proxy();</span><br><span class="line">    <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">&quot;Received HTTP_PROXY_AUTH (407) code while not &quot;</span> +</span><br><span class="line">                <span class="string">&quot;using proxy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户没有设置就返回null,重定向就结束了</span></span><br><span class="line">    <span class="keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);</span><br></pre></td></tr></table></figure><p>用户设置身份校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置身份校验的代理</span></span><br><span class="line"><span class="keyword">new</span> OkHttpClient.Builder().proxy(<span class="keyword">new</span> Proxy(Proxy.Type.HTTP, <span class="keyword">new</span> InetSocketAddress(</span><br><span class="line">        <span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span></span><br><span class="line">)))</span><br><span class="line"><span class="comment">//设置身份校验(默认不设置这个）</span></span><br><span class="line">.proxyAuthenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//参照Authenticator接口注释</span></span><br><span class="line">        <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">                .header(<span class="string">&quot;Proxy-Authorization&quot;</span>, Credentials.basic(<span class="string">&quot;用户名&quot;</span>,<span class="string">&quot;密码&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure><p>401:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 401 需要身份验证 有些服务器接口需要验证使用者身份 在请求头中添加 “Authorization”</span></span><br><span class="line"><span class="keyword">case</span> HTTP_UNAUTHORIZED:</span><br><span class="line">    <span class="comment">//类似407身份验证，设置authenticator()</span></span><br><span class="line">    <span class="keyword">return</span> client.authenticator().authenticate(route, userResponse);</span><br></pre></td></tr></table></figure><p>重定向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 308 永久重定向</span></span><br><span class="line"><span class="comment">// 307 临时重定向</span></span><br><span class="line"><span class="keyword">case</span> HTTP_PERM_REDIRECT:</span><br><span class="line"><span class="keyword">case</span> HTTP_TEMP_REDIRECT:</span><br><span class="line">    <span class="comment">// 如果请求方式不是GET或者HEAD，框架不会自动重定向请求</span></span><br><span class="line">    <span class="keyword">if</span> (!method.equals(<span class="string">&quot;GET&quot;</span>) &amp;&amp; !method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 300 301 302 303</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MULT_CHOICE:</span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_PERM:</span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_TEMP:</span><br><span class="line"><span class="keyword">case</span> HTTP_SEE_OTHER:</span><br><span class="line">    <span class="comment">// 如果用户不允许重定向，那就返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从响应头取出location</span></span><br><span class="line">    String location = userResponse.header(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 根据location 配置新的请求 url</span></span><br><span class="line">    HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line">    <span class="comment">// 如果为null，说明协议有问题，取不出来HttpUrl，那就返回null，不进行重定向</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果重定向在http到https之间切换，需要检查用户是不是允许(默认允许)</span></span><br><span class="line">    <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">    <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重定向请求中 只要不是 PROPFIND 请求，无论是POST还是其他的方法都要改为GET请求方式，</span></span><br><span class="line"><span class="comment">     *  即只有 PROPFIND 请求才能有请求体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//请求不是get与head</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">        <span class="comment">// 除了 PROPFIND 请求之外都改成GET请求</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">            requestBuilder.method(<span class="string">&quot;GET&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</span><br><span class="line">            requestBuilder.method(method, requestBody);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是 PROPFIND 的请求，把请求头中关于请求体的数据删掉</span></span><br><span class="line">        <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在跨主机重定向时，删除身份验证请求头</span></span><br><span class="line">    <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestBuilder.url(url).build();</span><br></pre></td></tr></table></figure><p>408请求超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 408 客户端请求超时 </span></span><br><span class="line"><span class="keyword">case</span> HTTP_CLIENT_TIMEOUT:</span><br><span class="line">    <span class="comment">// 408 算是连接失败了，所以判断用户是不是允许重试</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// UnrepeatableRequestBody实际并没发现有其他地方用到</span></span><br><span class="line">    <span class="keyword">if</span> (userResponse.request().body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是本身这次的响应就是重新请求的产物同时上一次之所以重请求还是因为408，那我们这次不再重请求了</span></span><br><span class="line">    <span class="keyword">if</span> (userResponse.priorResponse() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果服务器告诉我们了 Retry-After 多久后重试，那框架不管了。</span></span><br><span class="line">    <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userResponse.request();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>503:</p><p>// 503 服务不可用 和408差不多，但是只在服务器告诉你 Retry-After：0（意思就是立即重试） 才重请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> HTTP_UNAVAILABLE:</span><br><span class="line">    <span class="keyword">if</span> (userResponse.priorResponse() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> userResponse.request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>重定向总结：服务器返回300 301 302 303需要重定向，会获取返回头的Location中的新地址。</p><p>如果此方法followUpRequest返回空，那就表示不需要再重定向了，直接返回响应；但是如果返回非空，那就要重新请求返回的<code>Request</code>，但是需要注意的是，我们的<code>followup</code>在拦截器中定义的最大次数为<strong>20</strong>次。</p><h5><span id="总结">总结</span></h5><p>本拦截器是整个责任链中的第一个，这意味着它会是首次接触到<code>Request</code>与最后接收到<code>Response</code>的角色，在这个拦截器中主要功能就是判断是否需要重试与重定向。</p><p>重试的前提是出现了<code>RouteException</code>或者<code>IOException</code>。一但在后续的拦截器执行过程中出现这两个异常，就会通过<code>recover</code>方法进行判断是否进行连接重试。</p><p>重定向发生在重试的判定之后，如果不满足重试的条件，还需要进一步调用<code>followUpRequest</code>根据<code>Response</code> 的响应码(当然，如果直接请求失败，<code>Response</code>都不存在就会抛出异常)。<code>followup</code>最大发生20次。</p><h4><span id="二-桥接拦截器">二、桥接拦截器</span></h4><p>两大作用：补全请求头，处理响应（保存cookie，GzipSource）</p><p>补全请求与响应后处理</p><table><thead><tr><th>请求头</th><th>说明</th></tr></thead><tbody><tr><td><code>Content-Type</code></td><td>请求体类型,如：<code>application/x-www-form-urlencoded</code></td></tr><tr><td><code>Content-Length</code>/<code>Transfer-Encoding</code></td><td>请求体解析方式</td></tr><tr><td><code>Host</code></td><td>请求的主机站点</td></tr><tr><td><code>Connection: Keep-Alive</code></td><td>保持长连接</td></tr><tr><td><code>Accept-Encoding: gzip</code></td><td>接受响应支持gzip压缩</td></tr><tr><td><code>Cookie</code></td><td>cookie身份辨别</td></tr><tr><td><code>User-Agent</code></td><td>请求的用户信息，如:操作系统、浏览器等</td></tr></tbody></table><p>得到响应：<br>    1、读取Set-Cookie响应头并调用接口告知用户，在下次请求则会读取对应的数据设置进入请求头，默认CookieJar无实现；</p><p>​    2、响应头Content-Encoding为gzip，使用GzipSource包装便于解析。</p><h5><span id="总结">总结</span></h5><p>桥接拦截器的执行逻辑主要就是以下几点</p><p>对用户构建的<code>Request</code>进行添加或者删除相关头部信息，以转化成能够真正进行网络请求的<code>Request</code><br>将符合网络请求规范的Request交给下一个拦截器处理，并获取<code>Response</code><br>如果响应体经过了GZIP压缩，那就需要解压，再构建成用户可用的<code>Response</code>并返回</p><h4><span id="三-缓存拦截器">三、缓存拦截器</span></h4><p><code>CacheInterceptor</code>，在发出请求前，判断是否命中缓存。如果命中则可以不请求，直接使用缓存的响应。 (只会存在Get请求的缓存)</p><p>步骤为:</p><p>1、从缓存中获得对应请求的响应缓存</p><p>2、创建<code>CacheStrategy</code> ,创建时会判断是否能够使用缓存，在<code>CacheStrategy</code> 中存在两个成员:<code>networkRequest</code>与<code>cacheResponse</code>。他们的组合如下:</p><table><thead><tr><th>networkRequest</th><th>cacheResponse</th><th>说明</th></tr></thead><tbody><tr><td>Null</td><td>Not Null</td><td>直接使用缓存</td></tr><tr><td>Not Null</td><td>Null</td><td>向服务器发起请求</td></tr><tr><td>Null</td><td>Null</td><td>直接gg，okhttp直接返回504</td></tr><tr><td>Not Null</td><td>Not Null</td><td>发起请求，若得到响应为304(无修改)，则更新缓存响应并返回</td></tr></tbody></table><p>即：networkRequest存在则优先发起网络请求，否则使用cacheResponse缓存，若都不存在则请求失败！</p><p>3、交给下一个责任链继续处理</p><p>4、后续工作，返回304则用缓存的响应；否则使用网络响应并缓存本次响应（只缓存Get请求的响应）</p><p>缓存拦截器的工作说起来比较简单，但是具体的实现，需要处理的内容很多。在缓存拦截器中判断是否可以使用缓存，或是请求服务器都是通过<code>CacheStrategy</code>判断。</p><h5><span id="缓存策略">缓存策略</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 缓存策略:根据各种条件(请求头)组成 请求与缓存</span></span><br><span class="line">CacheStrategy strategy =</span><br><span class="line">        <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheStrategy candidate = getCandidate();</span><br><span class="line">    <span class="comment">//todo 如果可以使用缓存，那networkRequest必定为null；指定了只使用缓存但是networkRequest又不为null，冲突。那就gg(拦截器返回504)</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/10/okhttp/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%A3%80%E6%B5%8B.png" alt="缓存策略-缓存检测"></p><h5><span id="流程">流程：</span></h5><ol><li><p>没有缓存，就进行网络请求</p></li><li><p>如果是Https请求，缓存中没有保存握手信息，发起网络请求</p></li><li><p>通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求（isCacheable方法）：不允许用</p></li><li><p>如果请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性（用户配置不进行缓存）：不想用</p></li><li><p>如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存</p></li><li><p>响应的缓存有效期</p><p>这一步为进一步根据缓存响应中的一些信息判定缓存是否处于有效期内。如果满足：</p><blockquote><p><strong>缓存存活时间 &lt; 缓存新鲜度 - 缓存最小新鲜度 + 过期后继续使用时长</strong></p></blockquote><p> 代表可以使用缓存。其中新鲜度可以理解为有效时间，而这里的 <strong>“缓存新鲜度-缓存最小新鲜度”</strong> 就代表了缓存真正有效的时间。</p></li><li><p>缓存过期处理</p><p>如果继续执行，表示缓存已经过期无法使用。此时我们判定缓存的响应中如果存在<code>Etag</code>，则使用<code>If-None-Match</code>交给服务器进行验证；如果存在<code>Last-Modified</code>或者<code>Data</code>，则使用<code>If-Modified-Since</code>交给服务器验证。服务器如果无修改则会返回304，这时候注意：</p><p><strong>由于是缓存过期而发起的请求(与第4个判断用户的主动设置不同)，如果服务器返回304，那框架会自动更新缓存，所以此时<code>CacheStrategy</code>既包含<code>networkRequest</code>也包含<code>cacheResponse</code></strong></p></li></ol><h5><span id="详细流程">详细流程：</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// No cached response.</span></span><br><span class="line">    <span class="comment">//todo 1、没有缓存,进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 2、https请求，但是没有握手信息,进行网络请求</span></span><br><span class="line">    <span class="comment">// OkHttp会保存ssl握手信息 handshake,如果这次发起了https请求，</span></span><br><span class="line">    <span class="comment">// 但是缓存的响应信息中没有握手信息，发起网络请求</span></span><br><span class="line">    <span class="comment">//Drop the cached response if it&#x27;s missing a required handshake.</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 3、主要是通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求</span></span><br><span class="line">    <span class="comment">//If this response shouldn&#x27;t have been stored, it should never be used</span></span><br><span class="line">    <span class="comment">//as a response source. This check should be redundant as long as the</span></span><br><span class="line">    <span class="comment">//persistence store is well-behaved and the rules are constant.</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheControl requestCaching = request.cacheControl();</span><br><span class="line">    <span class="comment">//todo 4、如果 请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性</span></span><br><span class="line">    <span class="comment">// 或者请求头包含 If-Modified-Since：时间 值为lastModified或者data 如果服务器没有在该头部指定的时间之后修改了请求的数据，服务器返回304(无修改)</span></span><br><span class="line">    <span class="comment">// 或者请求头包含 If-None-Match：值就是Etag（资源标记）服务器将其与存在服务端的Etag值进行比较；如果匹配，返回304</span></span><br><span class="line">    <span class="comment">// 请求头中只要存在三者中任意一个，进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 5、如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存</span></span><br><span class="line">    CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">    <span class="keyword">if</span> (responseCaching.immutable()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, cacheResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 6、根据 缓存响应的 控制缓存的响应头 判断是否允许使用缓存</span></span><br><span class="line">    <span class="comment">// 6.1、获得缓存的响应从创建到现在的时间</span></span><br><span class="line">    <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.2、获取这个响应有效缓存的时长</span></span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//todo 如果请求中指定了 max-age 表示指定了能拿的缓存有效时长，就需要综合响应有效缓存时长与请求能拿缓存的时长，获得最小的能够使用响应缓存的时长</span></span><br><span class="line">        freshMillis = Math.min(freshMillis,</span><br><span class="line">                SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.3 请求包含  Cache-Control:min-fresh=[秒]  能够使用还未过指定时间的缓存 （请求认为的缓存有效时间）</span></span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.4</span></span><br><span class="line">    <span class="comment">//  6.4.1、Cache-Control:must-revalidate 可缓存但必须再向源服务器进行确认</span></span><br><span class="line">    <span class="comment">//  6.4.2、Cache-Control:max-stale=[秒] 缓存过期后还能使用指定的时长  如果未指定多少秒，则表示无论过期多长时间都可以；如果指定了，则只要是指定时间内就能使用缓存</span></span><br><span class="line">    <span class="comment">// 前者会忽略后者，所以判断了不必须向服务器确认，再获得请求头中的max-stale</span></span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.5 不需要与服务器验证有效性 &amp;&amp; 响应存在的时间+请求认为的缓存有效时间 小于 缓存有效时长+过期后还可以使用的时间</span></span><br><span class="line">    <span class="comment">// 允许使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="comment">//todo 如果已过期，但未超过 过期后继续使用时长，那还可以继续使用，只用添加相应的头部字段</span></span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//todo 如果缓存已超过一天并且响应中没有设置过期时间也需要添加警告</span></span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a condition to add to the request. If the condition is satisfied, the</span></span><br><span class="line">    <span class="comment">// response body</span></span><br><span class="line">    <span class="comment">// will not be transmitted.</span></span><br><span class="line">    <span class="comment">//todo 7、缓存过期了</span></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-None-Match&quot;</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 如果设置了 If-None-Match/If-Modified-Since 服务器是可能返回304(无修改)的,使用缓存的响应体</span></span><br><span class="line">    Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">    Request conditionalRequest = request.newBuilder()</span><br><span class="line">            .headers(conditionalRequestHeaders.build())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="ps请求头与响应头">PS：请求头与响应头</span></h5><table><thead><tr><th>响应头</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>Date</td><td>消息发送的时间</td><td>Date: Sat, 18 Nov 2028 06:17:41 GMT</td></tr><tr><td>Expires</td><td>资源过期的时间</td><td>Expires: Sat, 18 Nov 2028 06:17:41 GMT</td></tr><tr><td>Last-Modified</td><td>资源最后修改时间</td><td>Last-Modified: Fri, 22 Jul 2016 02:57:17 GMT</td></tr><tr><td>ETag</td><td>资源在服务器的唯一标识</td><td>ETag: “16df0-5383097a03d40”</td></tr><tr><td>Age</td><td>服务器用缓存响应请求，该缓存从产生到现在经过多长时间(秒)</td><td>Age: 3825683</td></tr><tr><td>Cache-Control</td><td>-</td><td>-</td></tr></tbody></table><table><thead><tr><th>请求头</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td><code>If-Modified-Since</code></td><td>服务器没有在指定的时间后修改请求对应资源,返回304(无修改)</td><td>If-Modified-Since: Fri, 22 Jul 2016 02:57:17 GMT</td></tr><tr><td><code>If-None-Match</code></td><td>服务器将其与请求对应资源的<code>Etag</code>值进行比较，匹配返回304</td><td>If-None-Match: “16df0-5383097a03d40”</td></tr><tr><td><code>Cache-Control</code></td><td>-</td><td>-</td></tr></tbody></table><p>其中<code>Cache-Control</code>可以在请求头存在，也能在响应头存在，对应的value可以设置多种组合：</p><ol><li><code>max-age=[秒]</code> ：资源最大有效时间;</li><li><code>public</code> ：表明该资源可以被任何用户缓存，比如客户端，代理服务器等都可以缓存资源;</li><li><code>private</code>：表明该资源只能被单个用户缓存，默认是private。</li><li><code>no-store</code>：资源不允许被缓存</li><li><code>no-cache</code>：(请求)不使用缓存</li><li><code>immutable</code>：(响应)资源不会改变</li><li> <code> min-fresh=[秒]</code>：(请求)缓存最小新鲜度(用户认为这个缓存有效的时长)</li><li><code>must-revalidate</code>：(响应)不允许使用过期缓存</li><li><code>max-stale=[秒]</code>：(请求)缓存过期后多久内仍然有效</li></ol><blockquote><p>假设存在max-age=100，min-fresh=20。这代表了用户认为这个缓存的响应，从服务器创建响应 到 能够缓存使用的时间为100-20=80s。但是如果max-stale=100。这代表了缓存有效时间80s过后，仍然允许使用100s，可以看成缓存有效时长为180s。</p></blockquote><h4><span id="四-连接拦截器">四、连接拦截器</span></h4><h5><span id="连接流程">连接流程：</span></h5><p><img src="/2020/12/10/okhttp/%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B.png" alt="连接流程"></p><p><code>ConnectInterceptor</code>，打开与目标服务器的连接，并执行下一个拦截器。它简短的可以直接完整贴在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 首先我们看到的<code>StreamAllocation</code>这个对象是在第一个拦截器：重定向拦截器创建的，但是真正使用的地方却在这里。</p><p>*”当一个请求发出，需要建立连接，连接建立后需要使用流用来读写数据”*；而这个StreamAllocation就是协调请求、连接与数据流三者之间的关系，它负责为一次请求寻找连接，然后获得流来实现网络通信。</p><p>这里使用的<code>newStream</code>方法实际上就是去查找或者建立一个与请求主机有效的连接，返回的<code>HttpCodec</code>中包含了输入输出流，并且封装了对HTTP请求报文的编码与解码，直接使用它就能够与请求主机完成HTTP通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//todo  找到一个健康的连接</span></span><br><span class="line">        RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">                writeTimeout, pingIntervalMillis, connectionRetryEnabled,</span><br><span class="line">                doExtensiveHealthChecks);</span><br><span class="line">        <span class="comment">//todo 利用连接实例化流HttpCodec对象，如果是HTTP/2返回Http2Codec，否则返回Http1Codec</span></span><br><span class="line">        HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            codec = resultCodec;</span><br><span class="line">            <span class="keyword">return</span> resultCodec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>StreamAllocation</code>中简单来说就是维护连接：<code>RealConnection</code>——封装了Socket与一个Socket连接池。可复用的<code>RealConnection</code></strong></p><p>findHealthyConnection方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> connectionRetryEnabled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//todo 找到一个连接</span></span><br><span class="line">        RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">                pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 如果这个连接是新建立的，那肯定是健康的，直接返回</span></span><br><span class="line">        <span class="comment">//If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 如果不是新创建的，需要检查是否健康</span></span><br><span class="line">        <span class="comment">//Do a (potentially slow) check to confirm that the pooled connection is still good.</span></span><br><span class="line">      <span class="comment">// If it</span></span><br><span class="line">        <span class="comment">// isn&#x27;t, take it out of the pool and start again.</span></span><br><span class="line">        <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">            <span class="comment">//todo 不健康 关闭连接，释放Socket,从连接池移除</span></span><br><span class="line">            <span class="comment">// 继续下次寻找连接操作</span></span><br><span class="line">            noNewStreams();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findConnection方法中的</p><ul><li>尝试从连接池获取连接，如果有可复用的连接,会给第三个参数 this的connection赋值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>调到了（ConnectionPool）connectionPool.get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class="line">      streamAllocation.acquire(connection, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isEligible判断是否能够复用</p><ul><li>使用http1.1就不能用</li><li>如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口</li><li>都相同那就可以复用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligible</span><span class="params">(Address address, <span class="meta">@Nullable</span> Route route)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If this connection is not accepting new streams, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 实际上就是在使用http1.1就不能用</span></span><br><span class="line">    <span class="keyword">if</span> (allocations.size() &gt;= allocationLimit || noNewStreams) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the non-host fields of the address don&#x27;t overlap, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口（域名没有判断，所以下面马上判断）</span></span><br><span class="line">    <span class="keyword">if</span> (!Internal.instance.equalsNonHost(<span class="keyword">this</span>.route.address(), address)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the host exactly matches, we&#x27;re done: this connection can carry the address.</span></span><br><span class="line">    <span class="comment">//todo: 都相同那就可以复用了</span></span><br><span class="line">    <span class="keyword">if</span> (address.url().host().equals(<span class="keyword">this</span>.route().address().url().host())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// This connection is a perfect match.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we don&#x27;t have a hostname match. But we still be able to carry the</span></span><br><span class="line">  <span class="comment">// request if</span></span><br><span class="line">    <span class="comment">// our connection coalescing requirements are met. See also:</span></span><br><span class="line">    <span class="comment">// https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding</span></span><br><span class="line">    <span class="comment">// https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. This connection must be HTTP/2.</span></span><br><span class="line">    <span class="keyword">if</span> (http2Connection == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. The routes must share an IP address. This requires us to have a DNS address for both</span></span><br><span class="line">    <span class="comment">// hosts, which only happens after route planning. We can&#x27;t coalesce connections that use a</span></span><br><span class="line">    <span class="comment">// proxy, since proxies don&#x27;t tell us the origin server&#x27;s IP address.</span></span><br><span class="line">    <span class="keyword">if</span> (route == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.route.socketAddress().equals(route.socketAddress())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. This connection&#x27;s server certificate&#x27;s must cover the new host.</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!supportsUrl(address.url())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Certificate pinning must match the host.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        address.certificatePinner().check(address.url().host(), handshake().peerCertificates());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SSLPeerUnverifiedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// The caller&#x27;s address can be carried by this connection.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没找到，必须新建一个连接了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">            selectedRoute = routeSelection.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a connection and assign it to this allocation immediately. This makes</span></span><br><span class="line">      <span class="comment">// it possible</span></span><br><span class="line">        <span class="comment">// for an asynchronous cancel() to interrupt the handshake we&#x27;re about to do.</span></span><br><span class="line">        route = selectedRoute;</span><br><span class="line">        refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">        result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">        acquire(result, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="连接池清理">连接池清理：</span></h5><p><img src="/2020/12/10/okhttp/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B8%85%E7%90%86.png" alt="连接池清理"></p><p>findConnection方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 将新创建的连接放到连接池中</span></span><br><span class="line">Internal.instance.put(connectionPool, result);</span><br></pre></td></tr></table></figure><p>调的是ConnectionPool.put方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">    cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//启动清理</span></span><br><span class="line">    executor.execute(cleanupRunnable);</span><br><span class="line">  &#125;</span><br><span class="line">  connections.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//todo:最快多久后需要清理</span></span><br><span class="line">      <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">      <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//todo:因为等待是纳秒级，wait方法可以接收纳秒级控制，但是把毫秒与纳秒分开</span></span><br><span class="line">        <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">        waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//todo:参数多一个纳秒，控制更加精确</span></span><br><span class="line">            ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">  RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">      <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        inUseConnectionCount++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      idleConnectionCount++;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 获得这个连接闲置多久</span></span><br><span class="line">      <span class="comment">// If the connection is ready to be evicted, we&#x27;re done.</span></span><br><span class="line">      <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">      <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">        longestIdleDurationNs = idleDurationNs;</span><br><span class="line">        longestIdleConnection = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超过保活时间（5分钟）或者池内数量超过了5个，马上移除，然后返回0，表示不等待，马上再次检查</span></span><br><span class="line">    <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">        || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class="line">      <span class="comment">// of the synchronized block).</span></span><br><span class="line">      connections.remove(longestIdleConnection);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// A connection will be ready to evict soon.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 池内存在闲置连接，就等待，保活时间（5分钟）-最长闲置时间=还能闲置多久 再检查</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// All connections are in use. It&#x27;ll be at least the keep alive duration &#x27;til we run again.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 有使用中的连接就等待5分钟，再检查</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No connections, idle or in use.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 都不满足，可能池内没任何连接，直接停止清理（put后再次启用）</span></span><br><span class="line">      cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5><span id="代理连接">代理连接：</span></h5><p><img src="/2020/12/10/okhttp/%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5.png" alt="代理连接"></p><p>findConnection中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 实际上就是创建socket连接，但是要注意的是如果存在http代理的情况</span></span><br><span class="line">result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br></pre></td></tr></table></figure><p>RealConnection.connect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">    <span class="comment">//todo http隧道代理</span></span><br><span class="line">    connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">    <span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We were unable to connect the tunnel but properly closed down our</span></span><br><span class="line">      <span class="comment">// resources.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//todo 创建socket连接</span></span><br><span class="line">    connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有http代理先设置代理头，最终都用调用connectSocket方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTunnel</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                           EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request tunnelRequest = createTunnelRequest();</span><br><span class="line">    HttpUrl url = tunnelRequest.url();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_TUNNEL_ATTEMPTS; i++) &#123;</span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">        tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tunnelRequest == <span class="keyword">null</span>) <span class="keyword">break</span>; <span class="comment">// Tunnel successfully created.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The proxy decided to close the connection after an auth challenge. We need to</span></span><br><span class="line">      <span class="comment">// create a new</span></span><br><span class="line">        <span class="comment">// connection, but this time with the auth credentials.</span></span><br><span class="line">        closeQuietly(rawSocket);</span><br><span class="line">        rawSocket = <span class="keyword">null</span>;</span><br><span class="line">        sink = <span class="keyword">null</span>;</span><br><span class="line">        source = <span class="keyword">null</span>;</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">createTunnelRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(route.address().url())</span><br><span class="line">            .header(<span class="string">&quot;Host&quot;</span>, Util.hostHeader(route.address().url(), <span class="keyword">true</span>))</span><br><span class="line">            .header(<span class="string">&quot;Proxy-Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>) <span class="comment">// For HTTP/1.0 proxies like Squid.</span></span><br><span class="line">            .header(<span class="string">&quot;User-Agent&quot;</span>, Version.userAgent())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * todo:创建socket连接</span></span><br><span class="line"><span class="comment"> * Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                           EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Proxy proxy = route.proxy();</span><br><span class="line">    Address address = route.address();</span><br><span class="line">    <span class="comment">//todo:没有代理直接new一个Socket（），有代理就创建一个带代理参数的socket</span></span><br><span class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">            ? address.socketFactory().createSocket()</span><br><span class="line">            : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line"></span><br><span class="line">    eventListener.connectStart(call, route.socketAddress(), proxy);</span><br><span class="line">    rawSocket.setSoTimeout(readTimeout);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> socket.connect</span></span><br><span class="line">        Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">        ConnectException ce =</span><br><span class="line">                <span class="keyword">new</span> ConnectException(<span class="string">&quot;Failed to connect to &quot;</span> + route.socketAddress());</span><br><span class="line">        ce.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0</span></span><br><span class="line">    <span class="comment">// More details:</span></span><br><span class="line">    <span class="comment">// https://github.com/square/okhttp/issues/3245</span></span><br><span class="line">    <span class="comment">// https://android-review.googlesource.com/#/c/271775/</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">        sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">        <span class="keyword">if</span> (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(npe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="五-请求服务器拦截器">五、请求服务器拦截器</span></h4><h5><span id="expect-100-continue">Expect: 100-continue</span></h5><p>一般出现于上传大容量请求体或者需要验证。代表了先询问服务器是否原因接收发送请求体数据。（先只发送请求头）</p><p>OkHttp的做法：<br>如果服务器允许则返回100，客户端继续发送请求体；<br>如果服务器不允许则直接返回给用户。</p><p>同时服务器也可能会忽略此请求头，一直无法读取应答，此时抛出超时异常。</p><p><img src="/2020/12/10/okhttp/100-continue.png" alt="100-continue"></p><p><code>CallServerInterceptor</code>，利用<code>HttpCodec</code>发出请求到服务器并且解析生成<code>Response</code>。</p><p>首先调用<code>httpCodec.writeRequestHeaders(request);</code> 将请求头写入到缓存中(直到调用<code>flushRequest()</code>才真正发送给服务器)。然后马上进行第一个逻辑判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallServerInterceptor</span><span class="params">(<span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">        <span class="comment">//todo:拼接请求的数据</span></span><br><span class="line">        httpCodec.writeRequestHeaders(request);</span><br><span class="line">        realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line"></span><br><span class="line">        Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//todo:如果没有请求体或者不是post跳过</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span></span><br><span class="line">            <span class="comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span></span><br><span class="line">            <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">            <span class="comment">// todo: 如果是post请求，并包含了100-continue,不发请求体，读服务器的响应</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equalsIgnoreCase(request.header(<span class="string">&quot;Expect&quot;</span>))) &#123;</span><br><span class="line">                <span class="comment">// todo: 发送请求头</span></span><br><span class="line">                httpCodec.flushRequest();</span><br><span class="line">                realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">                responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务返回100，responseBuilder会置为null</span></span><br><span class="line">            <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">                realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">                <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">                CountingSink requestBodyOut =</span><br><span class="line">                        <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                <span class="comment">//todo：写入请求体</span></span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">                realChain.eventListener()</span><br><span class="line">                        .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">                <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1</span></span><br><span class="line">              <span class="comment">// connection</span></span><br><span class="line">                <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request</span></span><br><span class="line">              <span class="comment">// body to</span></span><br><span class="line">                <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        httpCodec.finishRequest();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 读取服务器响应</span></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = responseBuilder</span><br><span class="line">                .request(request)</span><br><span class="line">                .handshake(streamAllocation.connection().handshake())</span><br><span class="line">                .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> code = response.code();</span><br><span class="line">        <span class="comment">// todo: 服务器允许继续发送响应体</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">            <span class="comment">// try again to read the actual response</span></span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            response = responseBuilder</span><br><span class="line">                    .request(request)</span><br><span class="line">                    .handshake(streamAllocation.connection().handshake())</span><br><span class="line">                    .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            code = response.code();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        realChain.eventListener()</span><br><span class="line">                .responseHeadersEnd(realChain.call(), response);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">            <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null</span></span><br><span class="line">          <span class="comment">// response body.</span></span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(httpCodec.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.request().header(<span class="string">&quot;Connection&quot;</span>))</span><br><span class="line">                || <span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.header(<span class="string">&quot;Connection&quot;</span>))) &#123;</span><br><span class="line">            streamAllocation.noNewStreams();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">                    <span class="string">&quot;HTTP &quot;</span> + code + <span class="string">&quot; had non-zero Content-Length: &quot;</span> + response.body().contentLength());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSink</span> <span class="keyword">extends</span> <span class="title">ForwardingSink</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> successfulCount;</span><br><span class="line"></span><br><span class="line">        CountingSink(Sink delegate) &#123;</span><br><span class="line">            <span class="keyword">super</span>(delegate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Buffer source, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.write(source, byteCount);</span><br><span class="line">            successfulCount += byteCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个if都和一个请求头有关： <code>Expect: 100-continue</code>。这个请求头代表了在发送请求体之前需要和服务器确定是否愿意接受客户端发送的请求体。所以<code>permitsRequestBody</code>判断为是否会携带请求体的方式(POST)，如果命中if，则会先给服务器发起一次查询是否愿意接收请求体，这时候如果服务器愿意会响应100(没有响应体，responseBuilder 即为nul)。这时候才能够继续发送剩余请求数据。</p><p>但是如果服务器不同意接受请求体，那么我们就需要标记该连接不能再被复用，调用<code>noNewStreams()</code>关闭相关的Socket。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 读取服务器响应</span></span><br><span class="line"><span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(streamAllocation.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>这时<code>responseBuilder</code>的情况即为：</p><p>1、POST方式请求，请求头中包含<code>Expect</code>，服务器允许接受请求体，并且已经发出了请求体，<code>responseBuilder</code>为null;</p><p>2、POST方式请求，请求头中包含<code>Expect</code>，服务器不允许接受请求体，<code>responseBuilder</code>不为null</p><p>3、POST方式请求，未包含<code>Expect</code>，直接发出请求体，<code>responseBuilder</code>为null;</p><p>4、POST方式请求，没有请求体，<code>responseBuilder</code>为null;</p><p>5、GET方式请求，<code>responseBuilder</code>为null;</p><p>对应上面的5种情况，读取响应头并且组成响应<code>Response</code>，注意：此<code>Response</code>没有响应体。同时需要注意的是，如果服务器接受 <code>Expect: 100-continue</code>这是不是意味着我们发起了两次<code>Request</code>？那此时的响应头是第一次查询服务器是否支持接受请求体的，而不是真正的请求对应的结果响应。</p><p>所以 如果响应是100，这代表了是请求<code>Expect: 100-continue</code>成功的响应，需要马上再次读取一份响应头，这才是真正的请求对应结果响应头。</p><p>最后：</p><p><code>forWebSocket</code>代表websocket的请求，我们直接进入else，这里就是读取响应体数据。然后判断请求和服务器是不是都希望长连接，一旦有一方指明<code>close</code>，那么就需要关闭<code>socket</code>。而如果服务器返回204/205，一般情况而言不会存在这些返回码，但是一旦出现这意味着没有响应体，但是解析到的响应头中包含<code>Content-Lenght</code>且不为0，这表响应体的数据字节长度。此时出现了冲突，直接抛出协议异常！</p><h5><span id="总结">总结</span></h5><p>在这个拦截器中就是完成HTTP协议报文的封装与解析。</p><h2><span id="自定义拦截器">自定义拦截器</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> OkHttpClient().newBuilder().addInterceptor(<span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// todo: .......</span></span><br><span class="line">        <span class="keyword">final</span> Response response = chain.proceed(chain.request());</span><br><span class="line">        <span class="comment">// todo: .......</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一定要调用chain.proceed,并将response返回。</p><p>不调用的话，会使责任链中断，后面其他就没法执行了。</p><h2><span id="okhttp总结">OkHttp总结</span></h2><p>整个OkHttp功能的实现就在这五个默认的拦截器中，所以先理解拦截器模式的工作机制是先决条件。这五个拦截器分别为: 重试拦截器、桥接拦截器、缓存拦截器、连接拦截器、请求服务拦截器。每一个拦截器负责的工作不一样，就好像工厂流水线，最终经过这五道工序，就完成了最终的产品。</p><p>但是与流水线不同的是，OkHttp中的拦截器每次发起请求都会在交给下一个拦截器之前干一些事情，在获得了结果之后又干一些事情。整个过程在请求向是顺序的，而响应向则是逆序。</p><p>当用户发起一个请求后，会由任务分发起<code>Dispatcher</code>将请求包装并交给重试拦截器处理。</p><p>1、重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。</p><p>2、桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。</p><p>3、缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。</p><p>4、连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。</p><p>5、请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。</p><p>在经过了这一系列的流程后，就完成了一次HTTP请求！</p><h2><span id="补充-代理">补充: 代理</span></h2><p>在使用OkHttp时，如果用户在创建<code>OkHttpClient</code>时，配置了<code>proxy</code>或者<code>proxySelector</code>，则会使用配置的代理，并且<code>proxy</code>优先级高于<code>proxySelector</code>。而如果未配置，则会获取机器配置的代理并使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK : ProxySelector</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">URI uri = <span class="keyword">new</span> URI(<span class="string">&quot;http://restapi.amap.com&quot;</span>);</span><br><span class="line">List&lt;Proxy&gt; proxyList = ProxySelector.getDefault().select(uri);</span><br><span class="line">System.out.println(proxyList.get(<span class="number">0</span>).address());</span><br><span class="line">System.out.println(proxyList.get(<span class="number">0</span>).type());</span><br><span class="line">&#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果我们不需要自己的App中的请求走代理，则可以配置一个<code>proxy(Proxy.NO_PROXY)</code>，这样也可以避免被抓包。<code>NO_PROXY</code>的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Proxy NO_PROXY = <span class="keyword">new</span> Proxy();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.type = Proxy.Type.DIRECT;</span><br><span class="line"><span class="keyword">this</span>.sa = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理在Java中对应的抽象类有三种类型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        DIRECT,</span><br><span class="line">        HTTP,</span><br><span class="line">        SOCKS;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DIRECT</code>：无代理，<code>HTTP</code>：http代理，<code>SOCKS</code>：socks代理。第一种自然不用多说，而Http代理与Socks代理有什么区别？</p><p>对于Socks代理，在HTTP的场景下，代理服务器完成TCP数据包的转发工作;<br>而Http代理服务器，在转发数据之外，还会解析HTTP的请求及响应，并根据请求及响应的内容做一些处理。</p><blockquote><p><code>RealConnection</code>的<code>connectSocket</code>方法:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是Socks代理则 new Socket(proxy); 否则相当于直接:new Socket()</span></span><br><span class="line">rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">                ? address.socketFactory().createSocket()</span><br><span class="line">                : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line"><span class="comment">//connect方法</span></span><br><span class="line">socket.connect(address);</span><br></pre></td></tr></table></figure><p>设置了SOCKS代理的情况下，创建Socket时，为其传入proxy，连接时还是以HTTP服务器为目标地址；但是如果设置的是Http代理，创建Socket是与Http代理服务器建立连接。</p><blockquote><p>在<code>connect</code>方法时传递的<code>address</code>来自于下面的集合<code>inetSocketAddresses</code><br><code>RouteSelector</code>的<code>resetNextInetSocketAddress</code>方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetNextInetSocketAddress</span><span class="params">(Proxy proxy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">        <span class="comment">//无代理和socks代理，使用http服务器域名与端口</span></span><br><span class="line">      socketHost = address.url().host();</span><br><span class="line">      socketPort = address.url().port();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SocketAddress proxyAddress = proxy.address();</span><br><span class="line">      <span class="keyword">if</span> (!(proxyAddress <span class="keyword">instanceof</span> InetSocketAddress)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">&quot;Proxy.address() is not an &quot;</span> + <span class="string">&quot;InetSocketAddress: &quot;</span> + proxyAddress.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;</span><br><span class="line">      socketHost = getHostString(proxySocketAddress);</span><br><span class="line">      socketPort = proxySocketAddress.getPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">        <span class="comment">//socks代理 connect http服务器 （DNS没用，由代理服务器解析域名）</span></span><br><span class="line">      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//无代理，dns解析http服务器</span></span><br><span class="line">        <span class="comment">//http代理,dns解析http代理服务器</span></span><br><span class="line">      List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;</span><br><span class="line">        InetAddress inetAddress = addresses.get(i);</span><br><span class="line">        inetSocketAddresses.add(<span class="keyword">new</span> InetSocketAddress(inetAddress, socketPort));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置代理时，Http服务器的域名解析会被交给代理服务器执行。但是如果是设置了Http代理，会对Http代理服务器的域名使用<code>OkhttpClient</code>配置的dns解析代理服务器，Http服务器的域名解析被交给代理服务器解析。</p><p>上述代码就是代理与DNS在OkHttp中的使用，但是还有一点需要注意，Http代理也分成两种类型：普通代理与隧道代理。</p><p>其中普通代理不需要额外的操作，扮演「中间人」的角色，在两端之间来回传递报文。这个“中间人”在收到客户端发送的请求报文时，需要正确的处理请求和连接状态，同时向服务器发送新的请求，在收到响应后，将响应结果包装成一个响应体返回给客户端。在普通代理的流程中，代理两端都是有可能察觉不到”中间人“的存在。</p><p>但是隧道代理不再作为中间人，无法改写客户端的请求，而仅仅是在建立连接后，将客户端的请求，通过建立好的隧道，无脑的转发给终端服务器。隧道代理需要发起Http <strong>CONNECT</strong>请求，这种请求方式没有请求体，仅供代理服务器使用，并不会传递给终端服务器。请求头 部分一旦结束，后面的所有数据，都被视为应该转发给终端服务器的数据，代理需要把他们无脑的直接转发，直到从客户端的 TCP 读通道关闭。<strong>CONNECT</strong> 的响应报文，在代理服务器和终端服务器建立连接后，可以向客户端返回一个 <code>200 Connect established</code> 的状态码，以此表示和终端服务器的连接，建立成功。</p><blockquote><p>RealConnection的connect方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.requiresTunnel()) &#123;         </span><br><span class="line">connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line"><span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// We were unable to connect the tunnel but properly closed down our</span></span><br><span class="line"><span class="comment">// resources.</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>requiresTunnel</code>方法的判定为：当前请求为https并且存在http代理，这时候<code>connectTunnel</code>中会发起:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">xxxx</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: xxxx</span><br><span class="line"><span class="attribute">Proxy-Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">User-Agent</span>: okhttp/$&#123;version&#125;</span><br></pre></td></tr></table></figure><p>的请求，连接成功代理服务器会返回200；如果返回407表示代理服务器需要鉴权(如：付费代理)，这时需要在请求头中加入<code>Proxy-Authorization</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> Authenticator authenticator = <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(response.code == <span class="number">407</span>)&#123;</span><br><span class="line">            <span class="comment">//代理鉴权</span></span><br><span class="line">            String credential = Credentials.basic(<span class="string">&quot;代理服务用户名&quot;</span>, <span class="string">&quot;代理服务密码&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">                    .header(<span class="string">&quot;Proxy-Authorization&quot;</span>, credential)</span><br><span class="line">                    .build();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="keyword">new</span> OkHttpClient.Builder().proxyAuthenticator(authenticator);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;OkHttp请求流程&lt;/li&gt;
&lt;li&gt;高并发请求分发器与线程池&lt;/li&gt;
&lt;li&gt;责任链模式请求与响应拦截&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#okhttp%E4%BB%8B%E7%BB%8D&quot;&gt;OkHttp介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8&quot;&gt;简单使用：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B&quot;&gt;使用流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B&quot;&gt;调用流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%86%E5%8F%91%E5%99%A8&quot;&gt;分发器：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B&quot;&gt;异步请求工作流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#okhttp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%89%B9%E7%82%B9&quot;&gt;OkHttp线程池的特点：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#asynccall&quot;&gt;AsyncCall&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82&quot;&gt;同步请求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;拦截器：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94&quot;&gt;获取响应：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F&quot;&gt;责任链模式：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE&quot;&gt;拦截器责任链：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8A%9F%E8%83%BD&quot;&gt;五大拦截器功能：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%A6%E6%83%85&quot;&gt;拦截器详情：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80-%E9%87%8D%E8%AF%95%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;一、重试及重定向拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%87%8D%E8%AF%95&quot;&gt;重试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%87%8D%E5%AE%9A%E5%90%91&quot;&gt;重定向&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C-%E6%A1%A5%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;二、桥接拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93-1&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89-%E7%BC%93%E5%AD%98%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;三、缓存拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5&quot;&gt;缓存策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B5%81%E7%A8%8B&quot;&gt;流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B&quot;&gt;详细流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ps%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4&quot;&gt;PS：请求头与响应头&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%9B-%E8%BF%9E%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;四、连接拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B&quot;&gt;连接流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B8%85%E7%90%86&quot;&gt;连接池清理：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5&quot;&gt;代理连接：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%94-%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;五、请求服务器拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#expect-100-continue&quot;&gt;Expect: 100-continue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;自定义拦截器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#okhttp%E6%80%BB%E7%BB%93&quot;&gt;OkHttp总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%A1%A5%E5%85%85-%E4%BB%A3%E7%90%86&quot;&gt;补充: 代理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;</summary>
    
    
    
    <category term="Android三方库源码分析" scheme="http://example.com/categories/Android%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="OkHttp" scheme="http://example.com/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>View事件分发</title>
    <link href="http://example.com/2020/12/09/dispatch/"/>
    <id>http://example.com/2020/12/09/dispatch/</id>
    <published>2020-12-09T02:01:42.000Z</published>
    <updated>2021-07-04T11:09:25.548Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="目录">目录</span></h2><!-- toc --><ul><li><a href="#motionevent">MotionEvent</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E6%8B%A6%E6%88%AA%E4%B8%8E%E6%B6%88%E8%B4%B9">事件分发、拦截与消费</a></li><li><a href="#%E6%80%BB%E6%B5%81%E7%A8%8B">总流程</a></li><li><a href="#ontouch%E5%92%8Conclick">onTouch和onClick</a><ul><li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">源码分析：</a><ul><li><a href="#viewdispatchtouchevent">View.dispatchTouchEvent</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结：</a></li></ul></li><li><a href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">事件分发源码解析：</a><ul><li><a href="#%E4%BA%8B%E4%BB%B6action_down">事件：ACTION_DOWN</a><ul><li><a href="#1%E5%81%87%E8%AE%BEonintercepttouchevent%E6%B2%A1%E6%9C%89%E6%8B%A6%E6%88%AA%E8%BF%99%E9%87%8Cintercepted%E4%B8%BAfalse">1.假设onInterceptTouchEvent没有拦截，这里intercepted为false;</a></li><li><a href="#2%E5%81%87%E8%AE%BEonintercepttouchevent%E7%9B%B4%E6%8E%A5%E6%8B%A6%E6%88%AA%E8%BF%99%E9%87%8Cintercepted%E4%B8%BAtrue">2.假设onInterceptTouchEvent直接拦截，这里intercepted为true;</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93-1">总结：</a></li><li><a href="#%E4%BA%8B%E4%BB%B6action_move">事件：ACTION_MOVE</a><ul><li><a href="#1%E5%81%87%E8%AE%BEonintercepttouchevent%E6%B2%A1%E6%9C%89%E6%8B%A6%E6%88%AA">1.假设onInterceptTouchEvent没有拦截</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93-2">总结：</a></li></ul></li></ul><ul><li><a href="#%E4%BA%8B%E4%BB%B6%E5%86%B2%E7%AA%81">事件冲突</a><ul><li><a href="#viewgrouponintercepttouchevent">ViewGroup#onInterceptTouchEvent</a></li><li><a href="#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3">冲突解决：</a><ul><li><a href="#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E5%9C%A8%E5%AD%90view%E4%B8%AD%E8%A7%A3%E5%86%B3">内部拦截法（在子View中解决）</a></li><li><a href="#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E6%80%BB%E7%BB%93">内部拦截法总结：</a></li><li><a href="#%E5%A4%96%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E5%9C%A8%E7%88%B6view%E4%B8%AD%E8%A7%A3%E5%86%B3">外部拦截法（在父View中解决）</a></li></ul></li></ul></li></ul><!-- tocstop --><a id="more"></a><h2><span id="motionevent">MotionEvent</span></h2><p><img src="/2020/12/09/dispatch/MotionEvent.png" alt="MotionEvent"></p><h2><span id="事件分发-拦截与消费">事件分发、拦截与消费</span></h2><p><img src="/2020/12/09/dispatch/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%8B%A6%E6%88%AA%E6%B6%88%E8%B4%B9.png" alt="事件分发拦截消费"></p><p>事件分发：Activity，ViewGroup，   View</p><p>事件拦截：                 ViewGroup</p><p>事件消费：Activity，                          View</p><h2><span id="总流程">总流程</span></h2><p><img src="/2020/12/09/dispatch/%E6%80%BB%E6%B5%81%E7%A8%8B.png" alt="总流程"></p><h2><span id="ontouch和onclick">onTouch和onClick</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">textView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;Text&quot;</span>, <span class="string">&quot;onClick&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">textView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;Text&quot;</span>, <span class="string">&quot;onTouch&quot;</span>+event.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3><span id="源码分析">源码分析：</span></h3><h4><span id="viewdispatchtouchevent">View.dispatchTouchEvent</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the event should be handled by accessibility focus first.</span></span><br><span class="line">    <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t have focus or no virtual descendant has it, do not handle the event.</span></span><br><span class="line">        <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We have focus and got the event, then use normal event dispatch.</span></span><br><span class="line">        event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// Defensive cleanup for new gesture</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class="line">    <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest</span></span><br><span class="line">    <span class="comment">// of the gesture.</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListenerInfo li = mListenerInfo;</span><br><span class="line"><span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">        &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">    result = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里li不等于空</p><p>在view.setOnTouchListener或setOnClickListener调用时</p><p>都会调用getListenerInfo()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnTouchListener</span><span class="params">(OnTouchListener l)</span> </span>&#123;</span><br><span class="line">    getListenerInfo().mOnTouchListener = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListenerInfo <span class="title">getListenerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    mListenerInfo = <span class="keyword">new</span> ListenerInfo();</span><br><span class="line">    <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里li肯定不为空</p><p><code>(mViewFlags &amp; ENABLED_MASK) == ENABLED</code>这里代表可view可用状态</p><p>所以<code>li.mOnTouchListener.onTouch(this, event)</code>这里如果返回为</p><ul><li><p>为true时  result=true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">    result = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>所以这里的onTouchEvent(event)方法就不会再走。</p><p>onTouchEvent中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">    <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">               performClickInternal();</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performClickInternal–&gt;performClick</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We still need to call this method to handle the cases where performClick() was called</span></span><br><span class="line">    <span class="comment">// externally, instead of through performClickInternal()</span></span><br><span class="line">    notifyAutofillManagerOnClick();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">    notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>li.mOnClickListener.onClick(this);</code>调用了onClick方法，并返回true</p><h3><span id="总结">总结：</span></h3><p>onTouch返回fasle时，调用onTouchEvent,再到onClick</p><p>onTouch返回true时，不调用onTouchEvent和onClick</p><p>onTouch=false—-&gt;onTouchEvent—-&gt;onClick</p><p>onTouch=true 结束</p><h2><span id="事件分发源码解析">事件分发源码解析：</span></h2><p>Activity#dispatchTouchEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getWindow().superDispatchTouchEvent(ev)</code>–&gt;PhoneWindow#superDispatchTouchEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mDecor.superDispatchTouchEvent(event)</code>–&gt;DecorView#superDispatchTouchEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的dispatchTouchEvent–&gt;ViewGroup#dispatchTouchEvent</p><h3><span id="事件action_down">事件：ACTION_DOWN</span></h3><p>一进入down就会清除事件和状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">    <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">    <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否拦截的标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br></pre></td></tr></table></figure><h4><span id="1假设onintercepttouchevent没有拦截这里intercepted为false">1.假设onInterceptTouchEvent没有拦截，这里intercepted为false;</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">     || actionMasked == MotionEvent.ACTION_CANCEL;</span><br></pre></td></tr></table></figure><p>假设这里的canceled也为false(没有取消)</p><p>所以进入了这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">            ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">        <span class="comment">// have become out of sync.</span></span><br><span class="line">        removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里newTouchTarget为null,并且childrenCount也不可能为0</p><p>if (newTouchTarget == null &amp;&amp; childrenCount != 0)中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br></pre></td></tr></table></figure><p>buildTouchDispatchChildList()方法对子View进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">    <span class="comment">// add next child (in child order) to end of list</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">    <span class="keyword">final</span> View nextChild = mChildren[childIndex];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> currentZ = nextChild.getZ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert ahead of any Views with greater Z</span></span><br><span class="line">    <span class="keyword">int</span> insertIndex = i;</span><br><span class="line">    <span class="keyword">while</span> (insertIndex &gt; <span class="number">0</span> &amp;&amp; mPreSortedChildren.get(insertIndex - <span class="number">1</span>).getZ() &gt; currentZ) &#123;</span><br><span class="line">        insertIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    mPreSortedChildren.add(insertIndex, nextChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Z轴越大越在数组后面，越小越在数组前面（页面上View越在上层越在数组后面，越底层越在数组前面）</p><p>​        这里从排好序的preorderedList中，从最后往前取值（即先取z轴最上层的view）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">            childrenCount, i, customOrder);</span><br><span class="line">    <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">            preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">    <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">    <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">    <span class="comment">// safer given the timeframe.</span></span><br><span class="line">    <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">        i = childrenCount - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newTouchTarget = getTouchTarget(child);</span><br><span class="line">    <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">        <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resetCancelNextUpFlag(child);</span><br><span class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">        <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">        mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">        <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                    mLastTouchDownIndex = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLastTouchDownIndex = childIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastTouchDownX = ev.getX();</span><br><span class="line">        mLastTouchDownY = ev.getY();</span><br><span class="line">        newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">        alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The accessibility focus didn&#x27;t handle the event, so clear</span></span><br><span class="line">    <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断取到的View是不是点击到的View（判断是否能够接收手指事件和点击区域是不是在View上）</p><p>不是的话继续循环拿取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canReceivePointerEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || getAnimation() != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isTransformedTouchPointInView</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        PointF outLocalPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[] point = getTempPoint();</span><br><span class="line">    point[<span class="number">0</span>] = x;</span><br><span class="line">    point[<span class="number">1</span>] = y;</span><br><span class="line">    transformPointToViewLocal(point, child);</span><br><span class="line">    <span class="comment">// pointInView：x &gt;= 0 &amp;&amp; localY &gt;= 0 &amp;&amp; y &lt; ((mRight - mLeft) + 0) &amp;&amp;y &lt; ((mBottom - mTop) + 0) 判断触点是否在View上</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isInView = child.pointInView(point[<span class="number">0</span>], point[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (isInView &amp;&amp; outLocalPoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outLocalPoint.set(point[<span class="number">0</span>], point[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isInView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pointInView</span><span class="params">(<span class="keyword">float</span> localX, <span class="keyword">float</span> localY, <span class="keyword">float</span> slop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; ((mRight - mLeft) + slop) &amp;&amp;</span><br><span class="line">            localY &lt; ((mBottom - mTop) + slop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里获取TouchTarget，这里返回的还是空，因为mFirstTouchTarget初始为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTouchTarget = getTouchTarget(child);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">getTouchTarget</span><span class="params">(<span class="meta">@NonNull</span> View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TouchTarget target = mFirstTouchTarget; target != <span class="keyword">null</span>; target = target.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.child == child) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchTransformedTouchEvent –分发给谁处理事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里child不为空，所以就会调用child.dispatchTouchEvent(transformedEvent)–&gt;就到了上文onTouch和onClick的源码分析View.dispatchTouchEvent</p><p>View.dispatchTouchEvent处理事件后，返回result为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">    result &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就进入if，然后break;结束整个for循环，其他view就处理不了事件了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line"></span><br><span class="line">    mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                mLastTouchDownIndex = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLastTouchDownIndex = childIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastTouchDownX = ev.getX();</span><br><span class="line">    mLastTouchDownY = ev.getY();</span><br><span class="line">    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用addTouchTarget(),进行newTouchTarget赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123;</span><br><span class="line">    final TouchTarget target &#x3D; TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next &#x3D; mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget &#x3D; target;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mFirstTouchTarget==newTouchTarget并且alreadyDispatchedToNewTouchTarget=true;</strong></p><p>如果没有处理，当前循环就结束了， 进行下一次的for循环。</p><p>继续往下走：进入else了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                    || intercepted;</span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                    target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                handled = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mFirstTouchTarget = next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    predecessor.next = next;</span><br><span class="line">                &#125;</span><br><span class="line">                target.recycle();</span><br><span class="line">                target = next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        target = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TouchTarget next = target.next;</span><br></pre></td></tr></table></figure><p>这里的next为null，最后target = next; 所以这里的while循环只会进入一次。（这里while是为多指触摸准备的，几个手指就会循环几次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里都满足所以handled为true  最后返回 handled。整个Down事件就结束了。    </p><h4><span id="2假设onintercepttouchevent直接拦截这里intercepted为true">2.假设onInterceptTouchEvent直接拦截，这里intercepted为true;</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里整个if语句都 不会进入</p><p><strong>而且这里拦截了以后，ViewGroup的子View就不再往下分发事件（分发是在这个if中for循环中分发的）</strong></p><p>这里mFirstTouchTarget为null，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里的child为null传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以会调用super.dispatchTouchEvent(transformedEvent); 即调用ViewGroup自己的dispatchTouchEvent方法来处理</p><h3><span id="总结">总结：</span></h3><p>当ViewGroup#onInterceptTouchEvent为false时，就会调用子View的dispatchTouchEvent</p><p>当ViewGroup#onInterceptTouchEvent为true时，就会调用自身的dispatchTouchEvent</p><h3><span id="事件action_move">事件：ACTION_MOVE</span></h3><h4><span id="1假设onintercepttouchevent没有拦截">1.假设onInterceptTouchEvent没有拦截</span></h4><p>这里mFirstTouchTarget经过Down事件后不为null,所以intercepted为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入下面if之前boolean alreadyDispatchedToNewTouchTarget = false;</p><p> if (!canceled &amp;&amp; !intercepted) 中直接进入下面 else中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                    || intercepted;</span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                    target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                handled = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mFirstTouchTarget = next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    predecessor.next = next;</span><br><span class="line">                &#125;</span><br><span class="line">                target.recycle();</span><br><span class="line">                target = next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        target = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里while走了else</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">        handled = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted;</span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mFirstTouchTarget = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                predecessor.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            target.recycle();</span><br><span class="line">            target = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    predecessor = target;</span><br><span class="line">    target = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchTransformedTouchEvent方法 中走了<code>handled = child.dispatchTouchEvent(transformedEvent);</code></p><h3><span id="总结">总结：</span></h3><p>当ViewGroup#onInterceptTouchEvent为false时，就会调用子View的dispatchTouchEvent</p><h1><span id="事件冲突">事件冲突</span></h1><h2><span id="viewgrouponintercepttouchevent">ViewGroup#onInterceptTouchEvent</span></h2><p>Viewpager+Listview</p><h2><span id="冲突解决">冲突解决：</span></h2><h3><span id="内部拦截法在子view中解决">内部拦截法（在子View中解决）</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mLastX;</span><br><span class="line"><span class="keyword">int</span> mLastY;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);<span class="comment">//请求不允许中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(deltaX)&gt; Math.abs(deltaY))&#123; <span class="comment">//左右滑</span></span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);<span class="comment">//允许中断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDisallowInterceptTouchEvent</span><span class="params">(<span class="keyword">boolean</span> disallowIntercept)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re already in this state, assume our ancestors are too</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (disallowIntercept) &#123;</span><br><span class="line">        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass it up to our parent</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置了 getParent().requestDisallowInterceptTouchEvent(true)后，disallowIntercept就为true，就不会走父View的onInterceptTouchEvent方法进行拦截，实现子View接收事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是，不能在MotionEvent.ACTION_DOWN方法中设置。</strong></p><p><strong>在进入上面事件判断前会进行状态的初始化。所以在ACTION_DOWN事件中onInterceptTouchEvent肯定会执行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法：在父View中为ACTION_DOWN返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="内部拦截法总结">内部拦截法总结：</span></h3><p><strong>MotionEvent.ACTION_DOWN时</strong>，父View中onInterceptTouchEvent设为false，子View调用getParent().requestDisallowInterceptTouchEvent(true);方法</p><p><strong>MotionEvent.ACTION_MOVE时</strong>，父View中onInterceptTouchEvent设为true，非子View事件时getParent().requestDisallowInterceptTouchEvent(false);方法</p><h3><span id="外部拦截法在父view中解决">外部拦截法（在父View中解决）</span></h3><p>在父View当中进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mLastX;</span><br><span class="line"><span class="keyword">int</span> mLastY;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">           mLastX= (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">           mLastY= (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123; <span class="comment">//左右滑</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#motionevent&quot;&gt;MotionEvent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E6%8B%A6%E6%88%AA%E4%B8%8E%E6%B6%88%E8%B4%B9&quot;&gt;事件分发、拦截与消费&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E6%B5%81%E7%A8%8B&quot;&gt;总流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ontouch%E5%92%8Conclick&quot;&gt;onTouch和onClick&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90&quot;&gt;源码分析：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#viewdispatchtouchevent&quot;&gt;View.dispatchTouchEvent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90&quot;&gt;事件分发源码解析：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6action_down&quot;&gt;事件：ACTION_DOWN&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1%E5%81%87%E8%AE%BEonintercepttouchevent%E6%B2%A1%E6%9C%89%E6%8B%A6%E6%88%AA%E8%BF%99%E9%87%8Cintercepted%E4%B8%BAfalse&quot;&gt;1.假设onInterceptTouchEvent没有拦截，这里intercepted为false;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2%E5%81%87%E8%AE%BEonintercepttouchevent%E7%9B%B4%E6%8E%A5%E6%8B%A6%E6%88%AA%E8%BF%99%E9%87%8Cintercepted%E4%B8%BAtrue&quot;&gt;2.假设onInterceptTouchEvent直接拦截，这里intercepted为true;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93-1&quot;&gt;总结：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6action_move&quot;&gt;事件：ACTION_MOVE&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1%E5%81%87%E8%AE%BEonintercepttouchevent%E6%B2%A1%E6%9C%89%E6%8B%A6%E6%88%AA&quot;&gt;1.假设onInterceptTouchEvent没有拦截&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93-2&quot;&gt;总结：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6%E5%86%B2%E7%AA%81&quot;&gt;事件冲突&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#viewgrouponintercepttouchevent&quot;&gt;ViewGroup#onInterceptTouchEvent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3&quot;&gt;冲突解决：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E5%9C%A8%E5%AD%90view%E4%B8%AD%E8%A7%A3%E5%86%B3&quot;&gt;内部拦截法（在子View中解决）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E6%80%BB%E7%BB%93&quot;&gt;内部拦截法总结：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%96%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E5%9C%A8%E7%88%B6view%E4%B8%AD%E8%A7%A3%E5%86%B3&quot;&gt;外部拦截法（在父View中解决）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;</summary>
    
    
    
    
    <category term="dispatch" scheme="http://example.com/tags/dispatch/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio开发Gradle插件</title>
    <link href="http://example.com/2020/12/08/gradle/"/>
    <id>http://example.com/2020/12/08/gradle/</id>
    <published>2020-12-08T03:46:53.099Z</published>
    <updated>2021-07-04T11:10:29.898Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="项目结构">项目结构：</span></h2><p>gradlePlugin</p><ul><li>app</li><li><ul><li>src</li></ul></li><li><ul><li>build.gradle</li></ul></li><li>buildSrc</li><li><ul><li>src</li></ul></li><li><ul><li><ul><li>main</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>java</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>com.lis.buildsrc</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li>MyPlugin.java</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li>build.gradle</li></ul></li><li>build.gradle</li></ul><a id="more"></a><h2><span id="简单的gradle插件buildsrc">简单的Gradle插件BuildSrc</span></h2><p>如果开发的插件仅用于当前项目，不需要发布的话，只需要注意两点:</p><ol><li><p>插件的Module名称必须是buildSrc(开头一定要小写)</p></li><li><p>无须resources目录</p><p>build.gradle的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:<span class="string">&#x27;java&#x27;</span></span><br><span class="line">   apply plugin:<span class="string">&#x27;groovy&#x27;</span></span><br><span class="line">   repositories &#123;</span><br><span class="line">       google()</span><br><span class="line">       jcenter()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   dependencies &#123;</span><br><span class="line">       <span class="function">implementation <span class="title">gradleApi</span><span class="params">()</span> <span class="comment">//gradle sdk</span></span></span><br><span class="line"><span class="function">     implementation <span class="title">localGroovy</span><span class="params">()</span> <span class="comment">//groovy sdk</span></span></span><br><span class="line"><span class="function">       implementation &#x27;com.android.tools.build:gradle:3.6.3&#x27;</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">   sourceCompatibility </span>= <span class="string">&quot;1.7&quot;</span></span><br><span class="line">   targetCompatibility = <span class="string">&quot;1.7&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>这里引入groovy sdk和gradle sdk,因为开发Android插件，还需要Android专用的gradle（这里需要使用到google仓库）</p><p>然后我们编写插件，MyPlugin:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin;</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project;</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        Logger logger = project.getLogger();</span><br><span class="line">        logger.error(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;最简单的Gradle插件&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app的build.gradle中添加你的插件  注意：这里不加’  ‘单引号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: com.lis.buildsrc.MyPlugin</span><br></pre></td></tr></table></figure><p>执行：**Build-make Module ‘app’**生成补丁。</p><p><img src="/2020/12/08/gradle/build.png" alt="image-20200724100113259"></p><p>在底部的 <strong>Buid-Build Output</strong>中便可以看到打印日志：</p><p>=====================<br>简单的Gradle插件</p><p>=====================</p><p><img src="/2020/12/08/gradle/buildoutput.png" alt="image-20200724100524283"></p><h2><span id="插件的发布">插件的发布</span></h2><p>如果想复用你的gradle插件，就需要把它发布出去。</p><ul><li>发布到本地仓库</li><li>发布到远程仓库</li></ul><h3><span id="本地仓库">本地仓库</span></h3><p>项目结构：</p><p>gradlePlugin</p><ul><li>app</li><li><ul><li>src</li></ul></li><li><ul><li>build.gradle</li></ul></li><li>buildSrc</li><li><ul><li>src</li></ul></li><li><ul><li><ul><li>main</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>java</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>com.lis.buildsrc</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li>MyPlugin.java</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>resources</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>META-INF.gradle-plugins</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li>com.lis.myplugin.properties</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li>build.gradle</li></ul></li><li>build.gradle</li></ul><p>在buildSrc的main文件夹下添加<strong>resources</strong>文件夹，在该文件夹下添加*<strong>META-INF**<em>，</em></strong>META-INF*<strong>文件夹下添加**<em>gradle-plugins</em></strong></p><p>在**<em>gradle-plugins**</em>中添加com.lis.myplugin.properties  </p><p>这里命名为 <code>com.lis.myplugin.properties</code> ，一定要注意后缀名称，那么使用插件时的名称就是<code>com.lis.myplugin</code>，文件里面的内容填写如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span>=<span class="title">com</span>.<span class="title">lis</span>.<span class="title">buildsrc</span>.<span class="title">MyPlugin</span></span></span><br></pre></td></tr></table></figure><p>这里指定的路径为MyPlugin的类名，即插件的入口类</p><p>buidSrc中的build.gradle，添加maven插件及发布用到的配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span><span class="string">&#x27;java&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span><span class="string">&#x27;groovy&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line">tasks.withType(JavaCompile) &#123; options.encoding = <span class="string">&quot;UTF-8&quot;</span> &#125; <span class="comment">//编码格式</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi() <span class="comment">//gradle sdk</span></span><br><span class="line">    implementation localGroovy() <span class="comment">//groovy sdk</span></span><br><span class="line">    implementation <span class="string">&#x27;com.android.tools.build:gradle:3.6.3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories.mavenDeployer &#123;</span><br><span class="line">        repository(<span class="attr">url:</span> uri(<span class="string">&#x27;../repo&#x27;</span>)) <span class="comment">//仓库的路径，此处是项目根目录下的 repo 的文件夹</span></span><br><span class="line">        pom.groupId = <span class="string">&#x27;com.lis.gradleplugin&#x27;</span>  <span class="comment">//groupId ，自行定义，一般是包名</span></span><br><span class="line">        pom.artifactId = <span class="string">&#x27;myplugin&#x27;</span> <span class="comment">//artifactId ，自行定义</span></span><br><span class="line">        pom.version = <span class="string">&#x27;1.0.0&#x27;</span> <span class="comment">//version 版本号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sourceCompatibility = <span class="string">&quot;1.7&quot;</span></span><br><span class="line">targetCompatibility = <span class="string">&quot;1.7&quot;</span></span><br></pre></td></tr></table></figure><p>同步后在gradle模块内，会出现发布按钮</p><p><img src="/2020/12/08/gradle/upload.png" alt="image-20200724141451792"></p><p>双击<strong>uploadArchives</strong> ,插件就发布到了本地的maven仓库，这里我们是在项目的根目录里，所以会在GradlePlugin下生成repo文件夹及文件</p><p><img src="/2020/12/08/gradle/repo.png" alt="image-20200724141759298"></p><p><strong>使用插件:</strong></p><p>在GradlePlugin根目录的build.gradle中添加本地仓库及插件引用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        <span class="comment">//首先需要配置本地的 maven 仓库地址，这里填写的是相对路径，也可以是全路径</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            url uri(<span class="string">&#x27;./repo&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:3.6.3&#x27;</span></span><br><span class="line">        <span class="comment">//然后，添加依赖的插件，形式是 groupId：artifactId：version</span></span><br><span class="line">        <span class="comment">//这些都是插件发布时，定义的名称</span></span><br><span class="line">        classpath <span class="string">&#x27;com.lis.gradleplugin:myplugin:1.0.0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url uri(<span class="string">&#x27;./repo&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在app的build.gradle里，添加插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.lis.myplugin&#x27;</span><span class="comment">//这里就填写 .properties 文件的名称</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">29</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;29.0.3&quot;</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.lis.gradleplugin&quot;</span></span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">29</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.1.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:1.1.3&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.1&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.2.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apply plugin: &#39;com.lis.myplugin&#39;</code>这里的com.lis.myplugin即我们上面<code>com.lis.myplugin.properties</code>文件的名称</p><p>这就完成了本地仓库的插件使用！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;项目结构：&quot;&gt;&lt;a href=&quot;#项目结构：&quot; class=&quot;headerlink&quot; title=&quot;项目结构：&quot;&gt;&lt;/a&gt;项目结构：&lt;/h2&gt;&lt;p&gt;gradlePlugin&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;app&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;build.gradle&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;buildSrc&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;main&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;java&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;com.lis.buildsrc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;MyPlugin.java&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;build.gradle&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;build.gradle&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/12/08/hello-world/"/>
    <id>http://example.com/2020/12/08/hello-world/</id>
    <published>2020-12-08T03:27:25.134Z</published>
    <updated>2020-12-08T03:27:25.134Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
