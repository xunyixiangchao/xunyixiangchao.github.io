<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lis</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-04-02T03:01:37.170Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>泛型</title>
    <link href="http://example.com/2021/11/28/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2021/11/28/%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-11-28T14:45:54.000Z</published>
    <updated>2025-04-02T03:01:37.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2><span id="问题">问题</span></h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、为什么我们需要泛型？</span><br><span class="line">2、泛型类、泛型接口和泛型方法</span><br><span class="line">3、如何限定类型变量？</span><br><span class="line">4、泛型使用中的约束和局限性</span><br><span class="line">5、泛型类型能继承吗？</span><br><span class="line">6、泛型中通配符类型</span><br><span class="line">7、虚拟机是如何实现泛型的？</span><br><span class="line">8、反射获取泛型的真实类型</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="1-为什么需要泛型">1、为什么需要泛型？</span></h2><ul><li>多种数据类型执行相同的代码（增加代码复用性）</li><li>在编译时进行更强的类型检查。</li><li>使用泛型不需要强制转换类型</li></ul><h2><span id="2-泛型类-泛型接口和泛型方法">2、泛型类、泛型接口和泛型方法</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--泛型类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Genericity</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">--泛型方法</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInput</span><span class="params">(T input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    --泛型方法<span class="number">2</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">getInput2</span><span class="params">(E input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//泛型类</span></span><br><span class="line">        Genericity&lt;String&gt; genericity=<span class="keyword">new</span> Genericity&lt;&gt;();</span><br><span class="line">        genericity.setData(<span class="string">&quot;泛型&quot;</span>);</span><br><span class="line">        Genericity&lt;Integer&gt; genericityInteger=<span class="keyword">new</span> Genericity&lt;&gt;();</span><br><span class="line">        genericityInteger.setData(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//泛型方法</span></span><br><span class="line">        Genericity genericityMethod=<span class="keyword">new</span> Genericity();</span><br><span class="line">        genericityMethod.getInput(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        genericityMethod.getInput(<span class="number">11</span>);</span><br><span class="line">        genericityMethod.getInput(<span class="number">1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--泛型接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Genertor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">--实现<span class="number">1</span>、不传入具体类型</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Genertor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--实现<span class="number">2</span>、传入具体类型String</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorImpl2</span> <span class="keyword">implements</span> <span class="title">Genertor</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型类只影响它的普通方法</li><li>泛型类的T和泛型方法的T毫无关系，换成其他也一样，例如E，但是方法名不能一样，因为泛型在Java编译时是Object</li><li>泛型接口实现时，不传入具体类型传入T时，接口的方法返回的也是T。当传入具体类型时，接口的方法返回的也是具体的类型。</li><li>泛型方法只有方法前面有<t>的才是泛型方法</t></li></ul><h2><span id="3-如何限定类型变量">3、如何限定类型变量？</span></h2><ol><li>限定类型是写在类上的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenertorClass&lt;String&gt; genertorClass = <span class="keyword">new</span> GenertorClass&lt;&gt;();</span><br><span class="line">        GenertorClass&lt;Object&gt; genertorClass2 = <span class="keyword">new</span> GenertorClass&lt;&gt;();</span><br><span class="line"><span class="comment">//传入String是正常的，传入Object时报错：</span></span><br><span class="line">        <span class="comment">//Type parameter &#x27;java.lang.Object&#x27; is not within its bound; should implement &#x27;java.lang.Comparable&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码传入String时是正常的，传入Object时报错：<code>Type parameter &#39;java.lang.Object&#39; is not within its bound; should implement &#39;java.lang.Comparable&#39;</code></p><p>因为String继承了 Comparable接口，而Object没有继承该接口</p><ol start="2"><li>限定类型写在方法上</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.compareTo(b) &gt; <span class="number">0</span>) <span class="keyword">return</span> a;<span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenertorClass.min(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        GenertorClass.min(<span class="string">&quot;1&quot;</span>,<span class="keyword">new</span> Object());<span class="comment">//报reason: no instance(s) of type variable(s) exist so that Object conforms to Comparable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GenertorClass.min(“1”,”2”);是正确的，因为String继承了Comparable接口，而Object没有继承该接口。</p><ol start="3"><li>多个限定类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--类<span class="number">1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">--类<span class="number">2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">--类<span class="number">3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span> &amp; <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenertorClass&lt;Apple&gt; genertorClass = <span class="keyword">new</span> GenertorClass&lt;&gt;();</span><br><span class="line">        GenertorClass&lt;Fruit&gt; genertorClass2 = <span class="keyword">new</span> GenertorClass&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GenertorClass<apple>是正常的，GenertorClass<fruit>报错：<code>Type parameter &#39;Fruit&#39; is not within its bound; should implement &#39;java.io.Serializable&#39;</code>。</fruit></apple></p><p>因为两个限定类型都要实现才行，而且类3中Fruit&amp;Serializable两个位置不能调换。</p><ul><li>T extends B <strong>B可以是类也可以是接口。</strong></li><li>泛型类和泛型方法都可以使用多个限定类型</li><li>B可以是多个对象：T extends Comparable&amp;Serializable。<strong>多个对象时，传入的对象必需要同时实现多个限定类型Comparable和Serializable</strong></li><li><strong>B为类和接口混合时，类只能有一个（java里单继承，多实现），并且必需放在最前面 ,否则会报错。</strong></li></ul><h2><span id="4-泛型使用中的约束和局限性">4、泛型使用中的约束和局限性</span></h2><ul><li><p>不能实例化类型变量。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T data = <span class="keyword">new</span> T()<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure></li><li><p>静态域或者静态方法里不能引用类型变量。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> T instance;<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure><p>（因为在new对象时，才知道真实的类型，虚拟机运行时，先执行static对象、方法，再执行构造方法，所以静态中使用泛型，虚拟机是不知道泛型类型的）</p></li><li><p>静态方法本身是泛型方法是可行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priavte <span class="keyword">static</span> &lt;T&gt; <span class="function">T  <span class="title">getInstance</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//允许</span></span><br></pre></td></tr></table></figure></li><li><p>基本类型是不行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">int</span>&gt;,&lt;<span class="keyword">double</span>&gt;<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure><p>int,double(不是对象)，只允许其包装类Integer，Double</p></li><li><p>不能使用instanceof关键字判断变量类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;Double&gt; test=<span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(test <span class="keyword">instanceof</span> Test&lt;Double&gt;)&#123;&#125;<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure></li><li><p>泛型能定义数据，但不能创建数组（new 对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T[] list;<span class="comment">//允许</span></span><br><span class="line"><span class="keyword">private</span> T[] list2=<span class="keyword">new</span> T[<span class="number">2</span>];<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure></li><li><p>泛型类获取的一定是类的原生类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;Integer&gt; test1 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">Test&lt;String&gt; test2 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">System.out.println(test1.getClass()==test2.getClass());</span><br><span class="line">System.out.println(test1.getClass().getName());</span><br><span class="line">System.out.println(test2.getClass().getName());</span><br><span class="line">out:========================================</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">com.example.annotation.Test</span><br><span class="line">com.example.annotation.Test</span><br></pre></td></tr></table></figure><p>这里的原生类型是Test，和传的参数无关紧要</p></li><li><p>泛型类不能继承Exception</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;<span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//报错：Generic class may not extend &#x27;java.lang.Throwable&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>不能捕获泛型类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123; <span class="comment">//报错</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不能捕获，但是可以抛出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork2</span><span class="params">(T x)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> x; <span class="comment">//允许的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="5-泛型类型能继承吗">5、泛型类型能继承吗？</span></h2><ol><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类 Worker extents Employee类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型类Pair</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>Pair<worker>和Pair<employee> 没有任何继承关系</employee></worker></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; employeePair= <span class="keyword">new</span> Pair&lt;Worker&gt;();<span class="comment">//不允许，错误的</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ExtendPair</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>泛型类可以继承或者扩展其他泛型类 //比如List和ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; employee = <span class="keyword">new</span> ExtendPair&lt;&gt;; <span class="comment">//允许的</span></span><br></pre></td></tr></table></figure></li></ul><h2><span id="6-泛型中通配符类型只用在方法上">6、泛型中通配符类型（?只用在方法上）</span></h2><p>通配符主要用于安全的访问数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HongFuShi</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><? extends Fruit>表示Pair传进去的类型参数是Fruit的子类包括Fruit本身（Fruit,Apple,Orange,HongFuShi）</li></ol><ul><li><p>extends决定了类型参数的上界：向下的范围，即泛型对象必需继承Fruit或Fruit本身–Food不可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限定类型Fruit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassName</span><span class="params">(Pair&lt;? extends Fruit&gt; data)</span> </span>&#123;</span><br><span class="line">    System.out.println(data.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;Fruit&gt; fruitPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Apple&gt; applePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Food&gt; foodPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair.printClassName(fruitPair);<span class="comment">//允许</span></span><br><span class="line">Pair.printClassName(applePair);<span class="comment">//允许</span></span><br><span class="line">Pair.printClassName(foodPair);<span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Pair&lt;Food&gt;无法转换为Pair&lt;? extends Fruit&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限定类型变量赋值时，也是只能使用传入Fruit子类或者本身的对象</span></span><br><span class="line">Pair&lt;Fruit&gt; fruitPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Apple&gt; applePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Food&gt; foodPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;? extends Fruit&gt; f = fruitPair;<span class="comment">//允许</span></span><br><span class="line">Pair&lt;? extends Fruit&gt; f2 = applePair;<span class="comment">//允许</span></span><br><span class="line">Pair&lt;? extends Fruit&gt; f3 = foodPair;<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure></li></ul><p>  使用&lt;? extends Fruit&gt;给对象set，get值时：set是不允许的，get只能get到Fruit对象，即extends的上界类型。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Fruit&gt; fruitPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Apple&gt; applePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;? extends Fruit&gt; data = fruitPair;</span><br><span class="line">或</span><br><span class="line">Pair&lt;? extends Fruit&gt; data = applePair;</span><br><span class="line"></span><br><span class="line">data.setData(<span class="keyword">new</span> Apple());<span class="comment">//不允许</span></span><br><span class="line">data.setData(<span class="keyword">new</span> Fruit());<span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Fruit无法转换为CAP#1</span></span><br><span class="line"><span class="comment">//        data.setData(new Fruit());</span></span><br><span class="line"><span class="comment">//                     ^</span></span><br><span class="line"><span class="comment">//  其中, CAP#1是新类型变量:</span></span><br><span class="line"><span class="comment">//    CAP#1从? extends Fruit的捕获扩展Fruit</span></span><br><span class="line">Fruit fruit = data.getData();<span class="comment">//允许，获取到Fruit对象</span></span><br><span class="line">Apple apple = (Apple) data.getData();<span class="comment">//需要转型，如果类型不正确会报ClassCastException强转异常</span></span><br></pre></td></tr></table></figure><p>  get方法：不管我们传的是Fruit还是它的子类，对于编译器来说我们传的一定是个Fruit，所以获取到的对象一定是个Fruit（子类继承Fruit）。</p><p>  set方法：对于编译器来说你传的是个Fruit,但是是具体的哪一个子类，编译器是不知道的。</p><p><strong>&lt;? extends Fruit&gt;主要用于安全的访问数据–读数据</strong></p><ol start="2"><li><? super Apple>表示Pair传进去的类型参数是Apple的父类包括Apple本身。(Apple,Fruit,Food)</li></ol><ul><li><p>super 决定了类型参数的下界：向上的范围，即泛型对象是Apple的超类或Apple本身–HongFuShi不可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSuper</span><span class="params">(Pair&lt;? <span class="keyword">super</span> Apple&gt; data)</span></span>&#123;</span><br><span class="line">    System.out.println(data.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;Fruit&gt; fruitPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Apple&gt; applePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Orange&gt; orangePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;HongFuShi&gt; hongFuShiPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">printSuper(fruitPair);<span class="comment">//允许</span></span><br><span class="line">printSuper(applePair);<span class="comment">//允许</span></span><br><span class="line">printSuper(orangePair);<span class="comment">//不允许，平级类</span></span><br><span class="line">printSuper(hongFuShiPair);<span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Pair&lt;HongFuShi&gt;无法转换为Pair&lt;? super Apple&gt;</span></span><br><span class="line"><span class="comment">//        printSuper(hongFuShiPair);</span></span><br><span class="line"></span><br><span class="line">Pair&lt;? <span class="keyword">super</span> Apple&gt; data = fruitPair; <span class="comment">//允许</span></span><br><span class="line">Pair&lt;? <span class="keyword">super</span> Apple&gt; data = applePair; <span class="comment">//允许</span></span><br><span class="line">Pair&lt;? <span class="keyword">super</span> Apple&gt; data = hongFuShiPair; <span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Pair&lt;HongFuShi&gt;无法转换为Pair&lt;? super Apple&gt;</span></span><br><span class="line"><span class="comment">//        Pair&lt;? super Apple&gt; data = hongFuShiPair;</span></span><br><span class="line"><span class="comment">//                                   ^</span></span><br><span class="line"></span><br><span class="line">但是在设值的时候只能设置Apple的子类和它本身</span><br><span class="line">data.setData(<span class="keyword">new</span> Apple()); <span class="comment">//允许</span></span><br><span class="line">data.setData(<span class="keyword">new</span> HongFuShi()); <span class="comment">//允许</span></span><br><span class="line">data.setData(<span class="keyword">new</span> Fruit()); <span class="comment">//不允许</span></span><br><span class="line"><span class="comment">//错误: 不兼容的类型: Fruit无法转换为CAP#1</span></span><br><span class="line"><span class="comment">//        data.setData(new Fruit());</span></span><br><span class="line"><span class="comment">//                    ^</span></span><br><span class="line"><span class="comment">// 其中, CAP#1是新类型变量:</span></span><br><span class="line"><span class="comment">//    CAP#1从? super Apple的捕获扩展Object 超 Apple</span></span><br><span class="line"></span><br><span class="line">获取数据时获取到的是Object对象</span><br><span class="line">Object object = data.getData();</span><br></pre></td></tr></table></figure><? super Apple>set方法：只能传Apple和其子类，（因为子类包含了Apple或者HongFuShi，子类可以安全的转换为 super Apple）get方法：获取的对象一定是Apple的超类，Java中Object一定是Apple的超类。所以返回的是Object</li></ul><p><strong>&lt;? super Apple&gt;主要用于安全的写入数据，只能是其本身Apple和其子类</strong></p><h2><span id="7-虚拟机是如何实现泛型的">7、虚拟机是如何实现泛型的？</span></h2><p>我们定义了一个简单的泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过字节码查看工具查看该类的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature &lt;E:Ljava/lang/Object;&gt;Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// declaration: GenertorASM&lt;E&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: GenertorASM.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="comment">// signature TE;</span></span><br><span class="line">  <span class="comment">// declaration: data extends E</span></span><br><span class="line">  <span class="keyword">private</span> Ljava/lang/Object; data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">8</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature ()TE;</span></span><br><span class="line">  <span class="comment">// declaration: E getData()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getData</span><span class="params">()</span>Ljava/lang/Object</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">12</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    GETFIELD GenertorASM.data : Ljava/lang/Object;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature (TE;)V</span></span><br><span class="line">  <span class="comment">// declaration: void setData(E)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setData</span><span class="params">(Ljava/lang/Object;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 16 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    PUTFIELD GenertorASM.data : Ljava/lang/Object</span>;</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">17</span> L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L2 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    LOCALVARIABLE data Ljava/lang/Object; L0 L2 <span class="number">1</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data extends E</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用javap命令反编译.class文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">javap -c -l GenertorASM.class<span class="comment">// -c对代码进行反汇编,-l输出行号和本地变量表</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GenertorASM</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   LGenertorASM;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #2                  // Field data:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   LGenertorASM;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(E)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #2                  // Field data:Ljava/lang/Object;</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">17</span>: <span class="number">5</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   LGenertorASM;</span><br><span class="line">          <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span>  data   Ljava/lang/Object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反编译后，可以看到泛型被擦除了，对应的是Object对象，但在的signature中记录了泛型。</p><p>泛型擦除的原因：</p><pre><code>在Java1.5之前不存在泛型的，1.5之后才添加的泛型，为了向下兼容，所以在编译时使用了泛型擦除用Object代替。</code></pre><p>使用泛型限定符时,java编译时会将泛型转成限定符的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature &lt;E:LFruit;&gt;Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// declaration: GenertorASM&lt;E extends Fruit&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: GenertorASM.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="comment">// signature TE;</span></span><br><span class="line">  <span class="comment">// declaration: data extends E</span></span><br><span class="line">  <span class="keyword">private</span> LFruit; data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">8</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature ()TE;</span></span><br><span class="line">  <span class="comment">// declaration: E getData()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getData</span><span class="params">()</span>LFruit</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">11</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    GETFIELD GenertorASM.data : LFruit;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature (TE;)V</span></span><br><span class="line">  <span class="comment">// declaration: void setData(E)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setData</span><span class="params">(LFruit;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 14 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    PUTFIELD GenertorASM.data : LFruit</span>;</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">15</span> L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L2 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    LOCALVARIABLE data LFruit; L0 L2 <span class="number">1</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data extends E</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果限定符有多个时，字节码中泛型使用第一个限定的类型，在使用其他的类型时，会使用强转成对应的类型（所以多个限定符时要注意强转异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Fruit</span> &amp; <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">compare</span><span class="params">(E data1, E data2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data1.compareTo(data2) &gt; <span class="number">0</span> ? data1 : data2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature &lt;E:LFruit;:Ljava/lang/Comparable;&gt;Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// declaration: GenertorASM&lt;E extends Fruit extends java.lang.Comparable&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenertorASM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: GenertorASM.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="comment">// signature TE;</span></span><br><span class="line">  <span class="comment">// declaration: data extends E</span></span><br><span class="line">  <span class="keyword">private</span> LFruit; data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">8</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature ()TE;</span></span><br><span class="line">  <span class="comment">// declaration: E getData()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getData</span><span class="params">()</span>LFruit</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">12</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    GETFIELD GenertorASM.data : LFruit;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature (TE;)V</span></span><br><span class="line">  <span class="comment">// declaration: void setData(E)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setData</span><span class="params">(LFruit;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 16 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    PUTFIELD GenertorASM.data : LFruit</span>;</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">17</span> L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L2 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    LOCALVARIABLE data LFruit; L0 L2 <span class="number">1</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data extends E</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature (TE;TE;)TE;</span></span><br><span class="line">  <span class="comment">// declaration: E compare(E, E)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">compare</span><span class="params">(LFruit;LFruit;)</span>LFruit</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">20</span> L0</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    CHECKCAST java/lang/Comparable</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    INVOKEINTERFACE java/lang/Comparable.compareTo (Ljava/lang/Object;)I (itf)</span><br><span class="line">    IFLE L1</span><br><span class="line">    ALOAD <span class="number">1</span></span><br><span class="line">    GOTO L2</span><br><span class="line">   L1</span><br><span class="line">   FRAME SAME</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">   L2</span><br><span class="line">   FRAME SAME1 Fruit</span><br><span class="line">    ARETURN</span><br><span class="line">   L3</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LGenertorASM; L0 L3 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LGenertorASM&lt;TE;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: this extends GenertorASM&lt;E&gt;</span></span><br><span class="line">    LOCALVARIABLE data1 LFruit; L0 L3 <span class="number">1</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data1 extends E</span></span><br><span class="line">    LOCALVARIABLE data2 LFruit; L0 L3 <span class="number">2</span></span><br><span class="line">    <span class="comment">// signature TE;</span></span><br><span class="line">    <span class="comment">// declaration: data2 extends E</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在字节码中<code>CHECKCAST java/lang/Comparable</code> 将对象强转成Comparable类型</p><h2><span id="8-反射获取泛型的真实类型">8、反射获取泛型的真实类型</span></h2><p>当我们对一个泛型类进行反射时，需要得到泛型中的真实数据类型，业完成如json反序列化的操作。此时需要通过Type体系来完成。Type接口包含了一个实现类(Class)和四个实现接口，他们分别是：</p><ul><li>TypeVariable<ul><li>泛型类型变量。可以获得泛型上下限等信息。</li></ul></li><li>ParameterizedType<ul><li>具体的泛型类型，可以获得元数据中泛型签名类型（泛型真实类型）。</li></ul></li><li>GenericArrayType<ul><li>当需要描述的类型是泛型类的数组时，比如List[],Map[]，此接口会作为Type的实现。</li></ul></li><li>WildcardType<ul><li>通配符泛型，获得上下限信息。</li></ul></li></ul><p>Type是个接口,它的直接实现类就是Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Type</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们创建一个Response泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="keyword">int</span> code;</span><br><span class="line">    String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(T data, <span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">        String result;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Response&lt;Data&gt; response = <span class="keyword">new</span> Response&lt;&gt;(<span class="keyword">new</span> Data(<span class="string">&quot;数据&quot;</span>), <span class="number">0</span>, <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String json = gson.toJson(response);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        Response&lt;Data&gt; result = gson.fromJson(json,Response.class);</span><br><span class="line">        System.out.println(result.data.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个response对象传入Data数据类型，打印序列化后的数据</p><p><code>&#123;&quot;data&quot;:&#123;&quot;result&quot;:&quot;数据&quot;&#125;,&quot;code&quot;:0,&quot;message&quot;:&quot;成功&quot;&#125;</code></p><p>然后我们通过gson反序列化打印data类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.lis.wanjob.jol.Response$Data</span></span><br><span class="line"><span class="comment">//at com.lis.wanjob.jol.Response.main(Response.java:35)</span></span><br></pre></td></tr></table></figure><p>gson解析时会把Data认为是LinkedTreeMap类型，所以在打印时强制转换时报错了。</p><p>正确的解析是通过Type</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Type type = <span class="keyword">new</span> TypeToken&lt;Response&lt;Data&gt;&gt;() &#123;</span><br><span class="line">        &#125;.getType();</span><br><span class="line">System.out.println(type);</span><br><span class="line">Response&lt;Data&gt; result = gson.fromJson(json, type);</span><br><span class="line">System.out.println(result.data.getClass());</span><br><span class="line">--打印结果为：</span><br><span class="line">com.lis.wanjob.jol.Response&lt;com.lis.wanjob.jol.Response$Data&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lis</span>.<span class="title">wanjob</span>.<span class="title">jol</span>.<span class="title">Response</span>$<span class="title">Data</span></span></span><br></pre></td></tr></table></figure><p>我们看一下TypeToken的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">TypeToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.type = getSuperclassTypeParameter(<span class="keyword">this</span>.getClass());</span><br><span class="line">       <span class="keyword">this</span>.rawType = Types.getRawType(<span class="keyword">this</span>.type);</span><br><span class="line">       <span class="keyword">this</span>.hashCode = <span class="keyword">this</span>.type.hashCode();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> Type <span class="title">getSuperclassTypeParameter</span><span class="params">(Class&lt;?&gt; subclass)</span> </span>&#123;</span><br><span class="line">       Type superclass = subclass.getGenericSuperclass();</span><br><span class="line">       <span class="keyword">if</span> (superclass <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Missing type parameter.&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ParameterizedType parameterized = (ParameterizedType)superclass;</span><br><span class="line">           <span class="keyword">return</span> Types.canonicalize(parameterized.getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里我们调用的是TypeToken 受保护的构造函数，getType()就是返回的type.</p><p>getSuperclassTypeParameter()方法中，如果TypeToken类的类型type是泛型类型的话，会被装载为Type的子接口ParameterizedType，可以让我们得到具体的泛型类型。</p><p>在实例化TypeToken时使用{}，实际上是匿名内部类。</p><p>我们自己创建个类来解析泛型的真实类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        Type actualTyep;</span><br><span class="line"></span><br><span class="line">        <span class="function">Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> actualTyep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TypeReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Type superclass = getClass().getGenericSuperclass();</span><br><span class="line">            ParameterizedType type = (ParameterizedType) superclass;</span><br><span class="line">            <span class="comment">//这里是数组，因为泛型可以有多个&lt;T,E&gt;</span></span><br><span class="line">            Type[] actualTypeArguments = type.getActualTypeArguments();</span><br><span class="line">            actualTyep = actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不加{}<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不加&#123;&#125;时，new TypeReference&lt;Response&lt;Data&gt;&gt;()代表一个对象</span></span><br><span class="line">Type type2 = <span class="keyword">new</span> TypeReference&lt;Response&lt;Data&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">System.out.println(type2);</span><br><span class="line">Response&lt;Data&gt; result = gson.fromJson(json, type2);</span><br><span class="line">System.out.println(result.data.getClass());</span><br></pre></td></tr></table></figure></li></ul><p>我们在输出时，不加{}时报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.reflect.ParameterizedType</span><br><span class="line">at com.lis.wanjob.jol.Response$TypeReference.&lt;init&gt;(Response.java:<span class="number">41</span>)</span><br><span class="line">at com.lis.wanjob.jol.Response.main(Response.java:<span class="number">62</span>)</span><br></pre></td></tr></table></figure><ul><li>加{}<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加&#123;&#125;时，new TypeReference&lt;Response&lt;Data&gt;&gt;()&#123;&#125;代表一个匿名内部类</span></span><br><span class="line">Type type2 = <span class="keyword">new</span> TypeReference&lt;Response&lt;Data&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">System.out.println(type2);</span><br><span class="line">Response&lt;Data&gt; result = gson.fromJson(json, type2);</span><br><span class="line">System.out.println(result.data.getClass());</span><br></pre></td></tr></table></figure></li></ul><p>我们输出时：能正常的打印泛型的真实类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.lis.wanjob.jol.Response&lt;com.lis.wanjob.jol.Response$Data&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">lis</span>.<span class="title">wanjob</span>.<span class="title">jol</span>.<span class="title">Response</span>$<span class="title">Data</span></span></span><br></pre></td></tr></table></figure><ol><li><p>因为不加{}时，new TypeReference&lt;Response<data>&gt;()只是一个对象，在TypeReference没有记录泛型真实类型的地方，此时的Type就是Class,所以强转ParameterizedType时会报错。编译文件Response$TypeReference.class，as中查看：</data></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span>$<span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Type actualTyep;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.actualTyep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Response$TypeReference() &#123;</span><br><span class="line">        Type superclass = <span class="keyword">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        ParameterizedType type = (ParameterizedType)superclass;</span><br><span class="line">        Type[] actualTypeArguments = type.getActualTypeArguments();</span><br><span class="line">        <span class="keyword">this</span>.actualTyep = actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>加了{}时，new TypeReference&lt;Response<data>&gt;(){}是匿名内部类，编译时，会为我们生成对应的内部类的文件Response$1.class，我们在as中打开看到如下代码</data></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>$1 <span class="keyword">extends</span> <span class="title">TypeReference</span>&lt;<span class="title">Response</span>&lt;<span class="title">Data</span>&gt;&gt; </span>&#123;</span><br><span class="line">    Response$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类中记录了泛型的真实类型。在getType()获取类型时，其实是获取的内部类的类型，所以我们可以得到泛型的真实类型。</p><p>PS：我们可以将解析泛型的真实类型的类定义为抽象或将构造方法改为受保护的（必需不同包下），这样在创建解析类时必需加{}成为匿名内部类，来获取泛型的真实类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeReference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">TypeReference</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1、为什么我们需要泛型？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2、泛型类、泛型接口和泛型方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3、如何限定类型变量？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4、泛型使用中的约束和局限性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5、泛型类型能继承吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6、泛型中通配符类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7、虚拟机是如何实现泛型的？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8、反射获取泛型的真实类型&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java基础与进阶" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="泛型" scheme="http://example.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>View基础</title>
    <link href="http://example.com/2021/06/15/view/"/>
    <id>http://example.com/2021/06/15/view/</id>
    <published>2021-06-15T06:56:23.000Z</published>
    <updated>2021-07-04T11:11:26.854Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android自定义view">Android自定义View</span></h1><h2><span id="概述">概述</span></h2><!-- toc --><ul><li><a href="#android%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E7%9A%84%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF">Android开发进阶的必经之路</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89view">为什么要自定义View</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95">自定义View的基本方法</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%88%86%E7%B1%BB">自定义控件分类</a></li></ul><ul><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89view%E5%9F%BA%E7%A1%80">自定义View基础</a><ul><li><a href="#view%E7%9A%84%E5%88%86%E7%B1%BB">View的分类</a></li><li><a href="#view%E7%B1%BB%E7%AE%80%E4%BB%8B">View类简介</a></li><li><a href="#attributeset%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7">AttributeSet与自定义属性</a></li><li><a href="#view%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84">View视图结构</a></li><li><a href="#android%E5%9D%90%E6%A0%87%E7%B3%BB">Android坐标系</a></li><li><a href="#view%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E6%8F%8F%E8%BF%B0">View位置（坐标）描述</a></li><li><a href="#%E4%BD%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F">位置获取方式</a></li><li><a href="#android%E4%B8%AD%E9%A2%9C%E8%89%B2%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">Android中颜色相关内容</a></li></ul></li><li><a href="#view%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B">View树的绘制流程</a><ul><li><a href="#view%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E6%98%AF%E8%B0%81%E8%B4%9F%E8%B4%A3%E7%9A%84">View树的绘制流程是谁负责的？</a></li><li><a href="#view%E7%9A%84%E6%B7%BB%E5%8A%A0">view的添加</a></li><li><a href="#view%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B">view的绘制流程</a></li><li><a href="#measure">measure</a></li><li><a href="#layout">layout</a></li><li><a href="#draw">draw</a></li></ul></li><li><a href="#layoutparams">LayoutParams</a><ul><li><a href="#marginlayoutparams">MarginLayoutParams</a></li><li><a href="#layoutparams%E4%B8%8Eview%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%81%94%E7%B3%BB">LayoutParams与View如何建立联系</a></li><li><a href="#addview">addView</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89layoutparams">自定义LayoutParams</a></li><li><a href="#layoutparams%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%90%E7%B1%BB">LayoutParams常见的子类</a></li></ul></li><li><a href="#measurespec">MeasureSpec</a><ul><li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li><li><a href="#measurespecs-%E7%9A%84%E6%84%8F%E4%B9%89">MeasureSpecs 的意义</a></li><li><a href="#measurespec%E5%80%BC%E7%9A%84%E7%A1%AE%E5%AE%9A">MeasureSpec值的确定</a></li></ul></li></ul><!-- tocstop --><h3><span id="android开发进阶的必经之路">Android开发进阶的必经之路</span></h3><h3><span id="为什么要自定义view">为什么要自定义View</span></h3><h3><span id="自定义view的基本方法">自定义View的基本方法</span></h3><p>自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();<br>View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。</p><ul><li>测量：onMeasure()决定View的大小；</li><li>布局：onLayout()决定View在ViewGroup中的位置；</li><li>绘制：onDraw()决定绘制这个View。</li></ul><a id="more"></a><h3><span id="自定义控件分类">自定义控件分类</span></h3><ul><li>自定义View: 只需要重写onMeasure()和onDraw()</li><li>自定义ViewGroup: 则只需要重写onMeasure()和onLayout()</li></ul><h2><span id="自定义view基础">自定义View基础</span></h2><h3><span id="view的分类">View的分类</span></h3><p>视图View主要分为两类<br>| 类别     | 解释                                      | 特点         |<br>| ——– | —————————————– | ———— |<br>| 单一视图 | 即一个View，如TextView                    | 不包含子View |<br>| 视图组   | 即多个View组成的ViewGroup，如LinearLayout | 包含子View   |</p><h3><span id="view类简介">View类简介</span></h3><ul><li><p>View类是Android中各种组件的基类，如View是ViewGroup基类</p></li><li><p>View表现为显示在屏幕上的各种视图</p><blockquote><p>Android中的UI组件都由View、ViewGroup组成。</p></blockquote></li><li><p>View的构造函数：共有4个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果View是在Java代码里面new的，则调用第一个构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CarsonView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果View是在.xml里声明的，则调用第二个构造函数</span></span><br><span class="line"><span class="comment">// 自定义属性是从AttributeSet参数传进来的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会自动调用</span></span><br><span class="line"><span class="comment">// 一般是在第二个构造函数里主动调用</span></span><br><span class="line"><span class="comment">// 如View有style属性时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//API21之后才使用</span></span><br><span class="line">    <span class="comment">// 不会自动调用</span></span><br><span class="line">    <span class="comment">// 一般是在第二个构造函数里主动调用</span></span><br><span class="line">    <span class="comment">// 如View有style属性时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="attributeset与自定义属性">AttributeSet与自定义属性</span></h3><p>　系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤：</p><ol><li>通过<code>&lt;declare-styleable&gt;</code>为自定义View添加属性</li><li>在xml中为相应的属性声明属性值</li><li>在运行时（一般为构造函数）获取属性值</li><li>将获取到的属性值应用到View</li></ol><h3><span id="view视图结构">View视图结构</span></h3><ol><li>PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口</li><li>DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout</li><li>ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等</li></ol><p><img src="/2021/06/15/view/activity.png" alt="activity"></p><p>对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图：</p><p><img src="/2021/06/15/view/view_arch.png" alt="view_arch"></p><p>一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。</p><h3><span id="android坐标系">Android坐标系</span></h3><p>Android的坐标系定义为：</p><ul><li>屏幕的左上角为坐标原点</li><li>向右为x轴增大方向</li><li>向下为y轴增大方向<br><img src="/2021/06/15/view/zuobiaoxi.png" alt="zuobiaoxi"></li></ul><blockquote><p>区别于一般的数学坐标系<br><img src="/2021/06/15/view/zuobiaoxi_qubie.png" alt="zuobiaoxi_qubie"></p></blockquote><h3><span id="view位置坐标描述">View位置（坐标）描述</span></h3><p>View的位置由4个顶点决定的<br>4个顶点的位置描述分别由4个值决定：</p><blockquote><p>请记住：View的位置是相对于父控件而言的）</p></blockquote><ul><li>Top：子View上边界到父view上边界的距离</li><li>Left：子View左边界到父view左边界的距离</li><li>Bottom：子View下边距到父View上边界的距离</li><li>Right：子View右边界到父view左边界的距离</li></ul><h3><span id="位置获取方式">位置获取方式</span></h3><p>View的位置是通过view.getxxx()函数进行获取：（以Top为例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Top位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getTop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> mTop;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余如下：</span></span><br><span class="line">  getLeft();      <span class="comment">//获取子View左上角距父View左侧的距离</span></span><br><span class="line">  getBottom();    <span class="comment">//获取子View右下角距父View顶部的距离</span></span><br><span class="line">  getRight();     <span class="comment">//获取子View右下角距父View左侧的距离</span></span><br></pre></td></tr></table></figure><p>与MotionEvent中 get()和getRaw()的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get() ：触摸点相对于其所在组件坐标系的坐标</span></span><br><span class="line"> event.getX();       </span><br><span class="line"> event.getY();</span><br><span class="line"></span><br><span class="line"><span class="comment">//getRaw() ：触摸点相对于屏幕默认坐标系的坐标</span></span><br><span class="line"> event.getRawX();    </span><br><span class="line"> event.getRawY();</span><br></pre></td></tr></table></figure><p><img src="/2021/06/15/view/zuobiaoxiweizhi.png" alt="zuobiaoxiweizhi"></p><h3><span id="android中颜色相关内容">Android中颜色相关内容</span></h3><p>Android支持的颜色模式：<br><img src="/2021/06/15/view/color1.png" alt="color1"><br>以ARGB8888为例介绍颜色定义:<br><img src="/2021/06/15/view/color2.png" alt="color2"></p><h2><span id="view树的绘制流程">View树的绘制流程</span></h2><h3><span id="view树的绘制流程是谁负责的">View树的绘制流程是谁负责的？</span></h3><p>view树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的；</p><h3><span id="view的添加">view的添加</span></h3><p><img src="/2021/06/15/view/view_qiyuan.png" alt="view_qiyuan"></p><h3><span id="view的绘制流程">view的绘制流程</span></h3><p><img src="/2021/06/15/view/view_traversals.png" alt="view_traversals"></p><h3><span id="measure">measure</span></h3><ol><li>系统为什么要有measure过程？</li><li>measure过程都干了点什么事？</li><li>对于自适应的尺寸机制，如何合理的测量一颗View树？</li><li>那么ViewGroup是如何向子View传递限制信息的？</li><li>ScrollView嵌套ListView问题？</li></ol><p><img src="/2021/06/15/view/view_requestlayout.png" alt="view_requestlayout"></p><h3><span id="layout">layout</span></h3><ol><li>系统为什么要有layout过程？</li><li>layout过程都干了点什么事？</li></ol><p><img src="/2021/06/15/view/view_performlayout.png" alt="view_performlayout"></p><h3><span id="draw">draw</span></h3><ol><li>系统为什么要有draw过程？</li><li>draw过程都干了点什么事？</li></ol><p><img src="/2021/06/15/view/view_invalidate.png" alt="view_invalidate"></p><h2><span id="layoutparams">LayoutParams</span></h2><p>LayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。</p><p>事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类</p><h3><span id="marginlayoutparams">MarginLayoutParams</span></h3><p>MarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的</p><ul><li>属性优先级问题<br>MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级</li></ul><blockquote><p>margin &gt; horizontalMargin和verticalMargin &gt; leftMargin和RightMargin、topMargin和bottomMargin</p></blockquote><ul><li>属性覆盖问题<br>优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释</li></ul><blockquote><p>Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value</p></blockquote><h3><span id="layoutparams与view如何建立联系">LayoutParams与View如何建立联系</span></h3><ul><li>在XML中定义View</li><li>在Java代码中直接生成View对应的实例对象</li></ul><h3><span id="addview">addView</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法1：添加一个子View</span></span><br><span class="line"><span class="comment"> * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    addView(child, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法2：在指定位置添加一个子View</span></span><br><span class="line"><span class="comment"> * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index View将在ViewGroup中被添加的位置（-1代表添加到末尾）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add a null child view to a ViewGroup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams params = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">        params = generateDefaultLayoutParams();<span class="comment">// 生成当前ViewGroup默认的LayoutParams</span></span><br><span class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;generateDefaultLayoutParams() cannot return null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addView(child, index, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法3：添加一个子View</span></span><br><span class="line"><span class="comment"> * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams params = generateDefaultLayoutParams();  <span class="comment">// 生成当前ViewGroup默认的LayoutParams</span></span><br><span class="line">    params.width = width;</span><br><span class="line">    params.height = height;</span><br><span class="line">    addView(child, -<span class="number">1</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法4：添加一个子View，并使用传入的LayoutParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    addView(child, -<span class="number">1</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add a null child view to a ViewGroup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addViewInner() will call child.requestLayout() when setting the new LayoutParams</span></span><br><span class="line">    <span class="comment">// therefore, we call requestLayout() on ourselves before, so that the child&#x27;s request</span></span><br><span class="line">    <span class="comment">// will be blocked at our level</span></span><br><span class="line">    requestLayout();</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">    addViewInner(child, index, params, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewInner</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> preventRequestLayout)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTransition.addChild(<span class="keyword">this</span>, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkLayoutParams(params)) &#123; <span class="comment">// ① 检查传入的LayoutParams是否合法</span></span><br><span class="line">        params = generateLayoutParams(params); <span class="comment">// 如果传入的LayoutParams不合法，将进行转化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preventRequestLayout) &#123; <span class="comment">// ② 是否需要阻止重新执行布局流程</span></span><br><span class="line">        child.mLayoutParams = params; <span class="comment">// 这不会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.setLayoutParams(params); <span class="comment">// 这会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = mChildrenCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addInArray(child, index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell our children</span></span><br><span class="line">    <span class="keyword">if</span> (preventRequestLayout) &#123;</span><br><span class="line">        child.assignParent(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.mParent = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="自定义layoutparams">自定义LayoutParams</span></h3><ol><li>创建自定义属性</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;declare-styleable name=<span class="string">&quot;xxxViewGroup_Layout&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 自定义的属性 --&gt;</span><br><span class="line">        &lt;attr name=<span class="string">&quot;layout_simple_attr&quot;</span> format=<span class="string">&quot;integer&quot;</span>/&gt;</span><br><span class="line">        &lt;!-- 使用系统预置的属性 --&gt;</span><br><span class="line">        &lt;attr name=<span class="string">&quot;android:layout_gravity&quot;</span>/&gt;</span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>继承MarginLayout</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">MarginLayoutParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> simpleAttr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> gravity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(c, attrs);</span><br><span class="line">        <span class="comment">// 解析布局属性</span></span><br><span class="line">        TypedArray typedArray = c.obtainStyledAttributes(attrs, R.styleable.SimpleViewGroup_Layout);</span><br><span class="line">        simpleAttr = typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_layout_simple_attr, <span class="number">0</span>);</span><br><span class="line">        gravity=typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_android_layout_gravity, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        typedArray.recycle();<span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(MarginLayoutParams source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(ViewGroup.LayoutParams source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>重写ViewGroup中几个与LayoutParams相关的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查LayoutParams是否合法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">instanceof</span> SimpleViewGroup.LayoutParams;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成默认的LayoutParams</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对传入的LayoutParams进行转化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewGroup.LayoutParams(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对传入的LayoutParams进行转化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ViewGroup.<span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleViewGroup.LayoutParams(getContext(), attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="layoutparams常见的子类">LayoutParams常见的子类</span></h3><p>在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类：</p><ul><li>ViewGroup.MarginLayoutParams</li><li>FrameLayout.LayoutParams</li><li>LinearLayout.LayoutParams</li><li>RelativeLayout.LayoutParams</li><li>RecyclerView.LayoutParams</li><li>GridLayoutManager.LayoutParams</li><li>StaggeredGridLayoutManager.LayoutParams</li><li>ViewPager.LayoutParams</li><li>WindowManager.LayoutParams</li></ul><h2><span id="measurespec">MeasureSpec</span></h2><h3><span id="定义">定义</span></h3><p><img src="/2021/06/15/view/measureSpec.png" alt="measureSpec"><br>测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种：</p><ul><li>UNSPECIFIED<br>父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大）</li><li>EXACTLY<br>父控件已经知道你所需的精确大小，你的最终大小应该就是这么大。</li><li>AT_MOST<br>你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。<br><img src="/2021/06/15/view/measurespec1.png" alt="measurespec1"></li></ul><h3><span id="measurespecs-的意义">MeasureSpecs 的意义</span></h3><p>通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法</p><h3><span id="measurespec值的确定">MeasureSpec值的确定</span></h3><p>MeasureSpec值到底是如何计算得来的呢?<br><img src="/2021/06/15/view/measurespec2.png" alt="measurespec2"><br>子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个</span></span><br><span class="line"><span class="comment">   * 最可能符合条件的child view的测量规格。  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> spec 父控件的测量规格</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> padding 父控件里已经占用的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> childDimension child view布局LayoutParams里的尺寸</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> child view 的测量规格</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec); <span class="comment">//父控件的测量模式</span></span><br><span class="line">      <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec); <span class="comment">//父控件的测量大小</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">      <span class="comment">// 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了</span></span><br><span class="line">      <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">          <span class="comment">//如果child的布局参数有固定值，比如&quot;layout_width&quot; = &quot;100dp&quot;</span></span><br><span class="line">          <span class="comment">//那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY</span></span><br><span class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              resultSize = childDimension;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125; </span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果child的布局参数是&quot;match_parent&quot;，也就是想要占满父控件</span></span><br><span class="line">          <span class="comment">//而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果child的布局参数是&quot;wrap_content&quot;，也就是想要根据自己的逻辑决定自己大小，</span></span><br><span class="line">          <span class="comment">//比如TextView根据设置的字符串大小来决定自己的大小</span></span><br><span class="line">          <span class="comment">//那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛</span></span><br><span class="line">          <span class="comment">//所以测量模式就是AT_MOST，测量大小就是父控件的size</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size</span></span><br><span class="line">      <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">          <span class="comment">//同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求</span></span><br><span class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              resultSize = childDimension;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="comment">//child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小</span></span><br><span class="line">          <span class="comment">//但同样的，child的尺寸上限也是父控件的尺寸上限size</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//child想要根据自己逻辑决定大小，那就自己决定呗</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              resultSize = size;</span><br><span class="line">              resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">      <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">          <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">              resultSize = childDimension;</span><br><span class="line">              resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">              <span class="comment">// be</span></span><br><span class="line">              resultSize = <span class="number">0</span>;</span><br><span class="line">              resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">              <span class="comment">// big it should be</span></span><br><span class="line">              resultSize = <span class="number">0</span>;</span><br><span class="line">              resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/15/view/measurespec3.png" alt="measurespec3"><br>针对上表，这里再做一下具体的说明</p><ul><li>对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定</li><li>对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。<pre><code>1.  当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小；    2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间；        3.  当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。        4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Android自定义View&quot;&gt;&lt;a href=&quot;#Android自定义View&quot; class=&quot;headerlink&quot; title=&quot;Android自定义View&quot;&gt;&lt;/a&gt;Android自定义View&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#android%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E7%9A%84%E5%BF%85%E7%BB%8F%E4%B9%8B%E8%B7%AF&quot;&gt;Android开发进阶的必经之路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89view&quot;&gt;为什么要自定义View&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95&quot;&gt;自定义View的基本方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%88%86%E7%B1%BB&quot;&gt;自定义控件分类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89view%E5%9F%BA%E7%A1%80&quot;&gt;自定义View基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#view%E7%9A%84%E5%88%86%E7%B1%BB&quot;&gt;View的分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E7%B1%BB%E7%AE%80%E4%BB%8B&quot;&gt;View类简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#attributeset%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7&quot;&gt;AttributeSet与自定义属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84&quot;&gt;View视图结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#android%E5%9D%90%E6%A0%87%E7%B3%BB&quot;&gt;Android坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E6%8F%8F%E8%BF%B0&quot;&gt;View位置（坐标）描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F&quot;&gt;位置获取方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#android%E4%B8%AD%E9%A2%9C%E8%89%B2%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9&quot;&gt;Android中颜色相关内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B&quot;&gt;View树的绘制流程&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#view%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E6%98%AF%E8%B0%81%E8%B4%9F%E8%B4%A3%E7%9A%84&quot;&gt;View树的绘制流程是谁负责的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E7%9A%84%E6%B7%BB%E5%8A%A0&quot;&gt;view的添加&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#view%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B&quot;&gt;view的绘制流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#measure&quot;&gt;measure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#layout&quot;&gt;layout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#draw&quot;&gt;draw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#layoutparams&quot;&gt;LayoutParams&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#marginlayoutparams&quot;&gt;MarginLayoutParams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#layoutparams%E4%B8%8Eview%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%81%94%E7%B3%BB&quot;&gt;LayoutParams与View如何建立联系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#addview&quot;&gt;addView&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89layoutparams&quot;&gt;自定义LayoutParams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#layoutparams%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%90%E7%B1%BB&quot;&gt;LayoutParams常见的子类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#measurespec&quot;&gt;MeasureSpec&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9A%E4%B9%89&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#measurespecs-%E7%9A%84%E6%84%8F%E4%B9%89&quot;&gt;MeasureSpecs 的意义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#measurespec%E5%80%BC%E7%9A%84%E7%A1%AE%E5%AE%9A&quot;&gt;MeasureSpec值的确定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;

&lt;h3 id=&quot;Android开发进阶的必经之路&quot;&gt;&lt;a href=&quot;#Android开发进阶的必经之路&quot; class=&quot;headerlink&quot; title=&quot;Android开发进阶的必经之路&quot;&gt;&lt;/a&gt;Android开发进阶的必经之路&lt;/h3&gt;&lt;h3 id=&quot;为什么要自定义View&quot;&gt;&lt;a href=&quot;#为什么要自定义View&quot; class=&quot;headerlink&quot; title=&quot;为什么要自定义View&quot;&gt;&lt;/a&gt;为什么要自定义View&lt;/h3&gt;&lt;h3 id=&quot;自定义View的基本方法&quot;&gt;&lt;a href=&quot;#自定义View的基本方法&quot; class=&quot;headerlink&quot; title=&quot;自定义View的基本方法&quot;&gt;&lt;/a&gt;自定义View的基本方法&lt;/h3&gt;&lt;p&gt;自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();&lt;br&gt;View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测量：onMeasure()决定View的大小；&lt;/li&gt;
&lt;li&gt;布局：onLayout()决定View在ViewGroup中的位置；&lt;/li&gt;
&lt;li&gt;绘制：onDraw()决定绘制这个View。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Activity启动模式</title>
    <link href="http://example.com/2020/12/11/activity/"/>
    <id>http://example.com/2020/12/11/activity/</id>
    <published>2020-12-11T02:40:35.000Z</published>
    <updated>2021-07-04T11:08:22.719Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="从四个视角理解android-activity启动模式">从四个视角理解Android Activity启动模式</span></h1><p>系统视角：</p><h2><span id="1-android的软件体系结构">1. Android的软件体系结构</span></h2><p><img src="/2020/12/11/activity/%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="系统结构图"></p><a id="more"></a><h2><span id="12-task">1.2 Task</span></h2><p><img src="/2020/12/11/activity/task.png" alt="Task"></p><p>Activity代码属于Application，但是Task属于Android操作系统</p><p>Task是可以跨应用的</p><h3><span id="手机查看task用户角度">手机查看Task：（用户角度）</span></h3><p>手机中按home键旁边那个方形键（recent-apps）时，屏幕上展示的就是一个个task。</p><p><img src="/2020/12/11/activity/%E6%9F%A5%E7%9C%8BTask.png" alt="查看手机Task"></p><h3><span id="代码中查看task程序角度">代码中查看Task：（程序角度）</span></h3><p>adb shell dumpsys activity activities | sed -En -e ‘/Stack #/p’ -e ‘/Running activities/,/Run #0/p’</p><p>sed工具不用单独下载，<code>D:\soft\Git\usr\bin\sed.exe</code> Git安装目录下包含，配置下环境变量就可以。 </p><p>用户视角：</p><h2><span id="21-task启动方式launcher启动">2.1 Task启动方式(launcher启动)</span></h2><p>Launcher启动</p><p>1、Task不存在</p><p>2、Task存在</p><h2><span id="22-task启动方式新建">2.2 Task启动方式（新建）</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;message&quot;</span>);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>通知：</p><p>1.系统通知<br>2.自己</p><p>其他第三方应用：</p><p>1、Scheme协议<br>2、第三方应用start</p><p><strong>launcher,新建  都是通过startActivity来创建的。</strong></p><h2><span id="23-task启动方式恢复">2.3 Task启动方式（恢复）</span></h2><p><strong>恢复</strong>   这属于Activity生命周期由不可见到获得焦点的范畴</p><p><img src="/2020/12/11/activity/Task%E6%81%A2%E5%A4%8D.png" alt="Task恢复"></p><p>程序视角：</p><h2><span id="31-activity和fragment">3.1 Activity和Fragment</span></h2><p>Fragment是Android3.0后引入的一个新的API，他出现的初衷是为了适应大屏幕的平板电脑， 当然现在他仍然是平板APP UI设计的宠儿，而且我们普通手机开发也会加入这个Fragment， 我们可以把他看成一个小型的Activity，又称Activity片段！</p><p><img src="/2020/12/11/activity/fragment%E9%9D%99%E6%80%81%E5%8A%A0%E8%BD%BD.png" alt="fragment静态加载"></p><p><img src="/2020/12/11/activity/fragment%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD.png" alt="fragment动态载"></p><h2><span id="32-activity的生命周期">3.2 Activity的生命周期</span></h2><p><img src="/2020/12/11/activity/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Activity生命周期"></p><p>Activity是否可见：</p><p><img src="/2020/12/11/activity/Activity%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A7%81.png" alt="Activity是否可见"></p><p>PS:Fragment生命周期</p><p><img src="/2020/12/11/activity/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.webp" alt="fragment生命周期"></p><p>Activity与Fragment生命周期</p><p><img src="/2020/12/11/activity/activity%E4%B8%8Efragment.png" alt="Activity与Fragment生命周期"></p><h2><span id="33-相邻状态之间的区别">3.3 相邻状态之间的区别</span></h2><p><img src="/2020/12/11/activity/%E7%9B%B8%E9%82%BB%E7%8A%B6%E6%80%81%E5%8C%BA%E5%88%AB.png" alt="A启动B和B返回A"></p><p>A启动B    和    B返回A</p><p><strong>1.onCreate</strong>和<strong>onStart</strong>之间有什么区别？</p><p>（1）可见与不可见的区别。前者不可见，后者可见。<br>（2）执行次数的区别。onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。因此Bundle数据的恢复在onStart中进行比onCreate中执行更合适。<br> （3）onCreate能做的事onStart其实都能做，但是onstart能做的事onCreate却未必适合做。如前文所说的，setContentView和资源初始化在两者都能做，然而想动画的初始化在onStart中做比较好。</p><p><strong>2.onStart</strong>方法和<strong>onResume</strong>方法有什么区别？</p><p>（1）是否在前台。onStart方法中Activity可见但不在前台，不可交互，而在onResume中在前台。<br>（2）职责不同，onStart方法中主要还是进行初始化工作，而onResume方法，根据官方的建议，可以做开启动画和独占设备的操作。</p><p><strong>3.onPause</strong>方法和<strong>onStop</strong>方法有什么区别？</p><p>（1）是否可见。onPause时Activity可见，onStop时Activity不可见，但Activity对象还在内存中。<br>（2）在系统内存不足的时候可能不会执行onStop方法，因此程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但要注意不能太耗时。</p><p><strong>4.onStop</strong>方法和<strong>onDestroy</strong>方法有什么区别？</p><p>onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Acivity被销毁</p><p>**PS:**闪屏页：在onStop()方法中进行finish();</p><h2><span id="34-onnewintent的生命周期">3.4 onNewIntent的生命周期</span></h2><p><img src="/2020/12/11/activity/onNewIntent.png" alt="onNewIntent"></p><p>1、只对<strong>singleTop，singleTask，singleInstance</strong>有效，因为standard每次都是新建(不是绝对，使用了Intent.FLAG_ACTIVITY_NEW_TASK,要启动的Activity已经有Task在运行了，新的activity不会再创建，而是把当前堆栈的activity带到前台)，所以不存在onNewIntent；</p><p>2、只对startActivity有效，对于从Navigation切换回来的恢复无效；</p><h2><span id="41-activity启动模式">4.1 Activity启动模式</span></h2><p><img src="/2020/12/11/activity/%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.png" alt="四种启动模式"></p><h2><span id="42-standard启动模式">4.2 standard启动模式</span></h2><p><strong>1、standard</strong>  <strong>默认模式</strong></p><p>系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，不管这个实例是否已经存在，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。这种模式的 Activity 被创建时它的 onCreate、onStart 都会被调用。这是一种典型的多实例实现，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。</p><p>a、当从非Activity的context启动activity时，需要带new_task的flag；</p><p>b、当启动一个带有affinity的activity，如果这个activity已经有实例存在该task，则不会重新创建；</p><p>c、如果从应用内启动的standard activity的Affinity就是App默认的Affinity，则会每次新建一个实例；</p><h2><span id="43-singletop启动模式">4.3 singleTop启动模式</span></h2><p>一个singleTop Activity 的实例可以无限多，唯一的区别是如果在栈顶已经有一个相同类型的Activity实例，Intent不会再创建一个Activity，而是通过onNewIntent()被发送到现有的Activity。</p><p><img src="/2020/12/11/activity/singetop.png" alt="singleTop"></p><h2><span id="44-singletask模式">4.4 singleTask模式</span></h2><p>这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例，和 singleTop一样，系统也会回调其 onNewIntent。当一个具有 singleTask 模式的Activity请求启动后，比如 Activity A，系统首先会寻找是否存在 A 想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建 A 的实例后把 A 放到栈中。如果存在 A 所需的任务栈，这时要看 A 是否在栈中有实例存在，如果有实例存在，那么系统就会把 A 调到栈顶并调用它的 onNewIntent 方法，如果实例不存在，就创建 A 的实例并把 A 压入栈中 。</p><p><img src="/2020/12/11/activity/singleTask.png" alt="singleTask"></p><p>不需要关注NEW_TASK</p><h2><span id="45-singleinstance模式">4.5 singleInstance模式</span></h2><p>与 singleTask 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。也就是有此种模式的 Activity 只能单独地位于一个任务栈中</p><p>PS：4种模式只能在AndroidManifest.xml中定义（定义层定义的）</p><h2><span id="46-intent-activity-flag">4.6 Intent Activity Flag</span></h2><p>启动层定义</p><p><img src="/2020/12/11/activity/IntentFlag.png" alt="IntentFlag"></p><h2><span id="51-启动模式的应用场景">5.1 启动模式的应用场景</span></h2><table><thead><tr><th><strong>launchMode</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td>singleTop</td><td>适合启动同类型的   Activity，例如：   •接收通知启动的内容显示页面   •耗时操作返回页面   •登录页面</td></tr><tr><td>singleTask</td><td>适合作为程序入口，例如：   •WebView页面   •扫一扫页面   •确认订单界面   •付款界面</td></tr><tr><td>singleInstance</td><td>适合需要与程序分离开的页面，例如：   •闹铃的响铃界面   •来电页面   •锁屏页</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;从四个视角理解Android-Activity启动模式&quot;&gt;&lt;a href=&quot;#从四个视角理解Android-Activity启动模式&quot; class=&quot;headerlink&quot; title=&quot;从四个视角理解Android Activity启动模式&quot;&gt;&lt;/a&gt;从四个视角理解Android Activity启动模式&lt;/h1&gt;&lt;p&gt;系统视角：&lt;/p&gt;
&lt;h2 id=&quot;1-Android的软件体系结构&quot;&gt;&lt;a href=&quot;#1-Android的软件体系结构&quot; class=&quot;headerlink&quot; title=&quot;1. Android的软件体系结构&quot;&gt;&lt;/a&gt;1. Android的软件体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/12/11/activity/%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.jpg&quot; alt=&quot;系统结构图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="activity" scheme="http://example.com/tags/activity/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析</title>
    <link href="http://example.com/2020/12/10/okhttp/"/>
    <id>http://example.com/2020/12/10/okhttp/</id>
    <published>2020-12-10T05:26:56.000Z</published>
    <updated>2021-11-28T13:03:08.849Z</updated>
    
    <content type="html"><![CDATA[<ul><li>OkHttp请求流程</li><li>高并发请求分发器与线程池</li><li>责任链模式请求与响应拦截</li></ul><h2><span id="目录">目录</span></h2><!-- toc --><ul><li><a href="#okhttp%E4%BB%8B%E7%BB%8D">OkHttp介绍</a></li><li><a href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">简单使用：</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">使用流程：</a></li><li><a href="#%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B">调用流程：</a></li><li><a href="#%E5%88%86%E5%8F%91%E5%99%A8">分发器：</a><ul><li><a href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">异步请求工作流程：</a></li><li><a href="#okhttp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%89%B9%E7%82%B9">OkHttp线程池的特点：</a><ul><li><a href="#asynccall">AsyncCall</a></li></ul></li><li><a href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82">同步请求</a></li></ul></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器：</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94">获取响应：</a></li><li><a href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链模式：</a></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE">拦截器责任链：</a></li><li><a href="#%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8A%9F%E8%83%BD">五大拦截器功能：</a></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%A6%E6%83%85">拦截器详情：</a><ul><li><a href="#%E4%B8%80-%E9%87%8D%E8%AF%95%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8">一、重试及重定向拦截器</a><ul><li><a href="#%E9%87%8D%E8%AF%95">重试</a></li><li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li><li><a href="#%E4%BA%8C-%E6%A1%A5%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8">二、桥接拦截器</a><ul><li><a href="#%E6%80%BB%E7%BB%93-1">总结</a></li></ul></li><li><a href="#%E4%B8%89-%E7%BC%93%E5%AD%98%E6%8B%A6%E6%88%AA%E5%99%A8">三、缓存拦截器</a><ul><li><a href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5">缓存策略</a></li><li><a href="#%E6%B5%81%E7%A8%8B">流程：</a></li><li><a href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B">详细流程：</a></li><li><a href="#ps%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4">PS：请求头与响应头</a></li></ul></li><li><a href="#%E5%9B%9B-%E8%BF%9E%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8">四、连接拦截器</a><ul><li><a href="#%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B">连接流程：</a></li><li><a href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B8%85%E7%90%86">连接池清理：</a></li><li><a href="#%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5">代理连接：</a></li></ul></li><li><a href="#%E4%BA%94-%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8">五、请求服务器拦截器</a><ul><li><a href="#expect-100-continue">Expect: 100-continue</a></li><li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li></ul></li></ul></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8">自定义拦截器</a></li><li><a href="#okhttp%E6%80%BB%E7%BB%93">OkHttp总结</a></li><li><a href="#%E8%A1%A5%E5%85%85-%E4%BB%A3%E7%90%86">补充: 代理</a></li></ul><!-- tocstop --><a id="more"></a><h2><span id="okhttp介绍">OkHttp介绍</span></h2><p>由Square公司贡献的一个处理网络请求的开源项目，是目前Android使用最广泛的网络框架，从Android4。4开始HttpURLConnection的底层实现采用的是OkHttp。</p><ul><li>支持HTTP/2并允许对同一主机的所有请求共享一个套接字</li><li>通过连接池，减少了请求延迟</li><li>默认通过GZip压缩数据</li><li>响应缓存，以免了重复请求的网络</li><li>请求失败自动重试主机的其他ip，自动重定向</li><li>……</li></ul><h2><span id="简单使用">简单使用：</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build();</span><br><span class="line">Call call = okHttpClient.newCall(request);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//同步请求</span></span><br><span class="line">    Response execute = call.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步请求</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2><span id="使用流程">使用流程：</span></h2><p><img src="/2020/12/10/okhttp/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="使用流程"></p><h2><span id="调用流程">调用流程：</span></h2><p>OkHttp请求过程中最少需要接触OkHttpClient、Request、Call、Response，但是框架内部进行大量的逻辑处理。</p><p>所有的逻辑大部分集中在拦截器中，但是在进入拦截器之前还需要依靠分发器来调配请求任务。</p><p><strong>分发器：</strong>内部维护队列与线程池，完成请求调配；Dispatcher</p><p><strong>拦截器：</strong>五大默认拦截器完成整个请求过程； Interceptors</p><h2><span id="分发器">分发器：</span></h2><h3><span id="异步请求工作流程">异步请求工作流程：</span></h3><p><img src="/2020/12/10/okhttp/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B7%A5%E4%BD%9C.png" alt="异步请求工作"></p><ol><li>Q：如何决定将请求放入ready还是running?</li><li>Q：从running移动到ready的条件是什么？</li><li>Q：分发器线程池的工作行为？</li></ol><p><strong>Dispatcher中</strong></p><ol><li><p>A:  client.dispatcher().enqueue(new AsyncCall(responseCallback));</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.running队列数小于最大请求数64（正在请求的的数量是有限制的，自己配置分发器时可以修改）</span></span><br><span class="line">    <span class="comment">//2.同一域名正在请求的个数也是有限制的小于5</span></span><br><span class="line">    <span class="comment">//PS:最大同时请求数64，与同一台服务器请求数5</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">//添加到running队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">//将runnable（call）提交到线程池当中</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不符合上面请求就加入到等待队列</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p> A:client.dispatcher().finished(this);-&gt; promoteCalls()移动队列（异步时才有移动队列）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//正在执行队列数</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="comment">//等待队列数得不为空</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall call = i.next();</span><br><span class="line">        <span class="comment">//如果拿到的等待请求host，在请求的列表中已经存在5个</span></span><br><span class="line">        <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            <span class="comment">//等待移除</span></span><br><span class="line">            i.remove();</span><br><span class="line">            <span class="comment">//加入running</span></span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            <span class="comment">//加入线程池</span></span><br><span class="line">            executorService().execute(call);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断正在执行队列数</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>A:ThreadPoolExecutor</li></ol><p><img src="/2020/12/10/okhttp/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="线程池"></p><p>当一个任务通过execute(Runnable)方法添加到线程池时：</p><ul><li><p>线程数量小于corePoolSize，新建线程(核心)来处理被添加的任务；</p></li><li><p>线程数量大于等于 corePoolSize，存在空闲线程，使用空闲线程执行新任务；-</p></li><li><p>线程数量大于等于 corePoolSize，不存在空闲线程，新任务被添加到等待队列，添加成功则等待空闲线程，添加失败：</p><ul><li>线程数量小于maximumPoolSize，新建线程执行新任务；</li><li>线程数量等于maximumPoolSize，拒绝此任务。 </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//corePoolSize:核心线程数  0 不缓存线程，（0和1的表现是一样的）不用时就不占用线程，闲置60就会回收掉</span></span><br><span class="line">        <span class="comment">//maximumPoolSize最大线程数（包括核心）</span></span><br><span class="line">        <span class="comment">//keepAliveTime 缓存60秒</span></span><br><span class="line">        <span class="comment">//workQueue 队列</span></span><br><span class="line">        <span class="comment">//threadFactory 创建一个thread</span></span><br><span class="line">        <span class="comment">//PS:和Executors.newCachedThreadPool();创建的线程池一样</span></span><br><span class="line">        executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>,</span><br><span class="line">                <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SynchronousQueue</strong> implements BlockingQueue  是个阻塞队列</p><p>PS:三种阻塞队列</p><p><code>ArrayBlockingQueue</code>：基于数组的阻塞队列，初始化需要指定固定大小。</p><p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p><p><code>SynchronousQueue</code> : 无容量的队列。</p><p>往队列中添加元素一定是失败的。</p><h3><span id="okhttp线程池的特点">OkHttp线程池的特点：</span></h3><p><strong>OkHttp提交请求，一定是往队列里提交，往队列中添加是一定是失败的，马上新建线程（没有到最大线程数），</strong></p><p><strong>不需要等待。获得最大的并发量</strong></p><h4><span id="asynccall">AsyncCall</span></h4><p>继承NamedRunnable类实现Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * run方法其实调用的AsyncCall的execute()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String oldName = Thread.currentThread().getName();</span><br><span class="line">        Thread.currentThread().setName(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            execute();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Thread.currentThread().setName(oldName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="同步请求">同步请求</span></h3><p>加入队列，执行完移除队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同步直接加入running队列，这里的running是同步队列不是异步的</span></span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="拦截器">拦截器：</span></h2><p>默认五大拦截器：（责任链模式）<br><strong>重定向与重试，</strong><br><strong>Header、Body处理，</strong><br><strong>缓存处理，</strong><br><strong>连接处理，</strong><br><strong>服务器通讯</strong><br><img src="/2020/12/10/okhttp/%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8.png" alt="五大拦截器"></p><p>请求是顺序的，响应是逆序的</p><h3><span id="获取响应">获取响应：</span></h3><p>无论同步还是异常都是通过getResponseWithInterceptorChain 获得请求结果：Response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 拦截器集合</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//重定向与重试</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">//Header,Body处理</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//缓存处理</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//连接处理</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务器通讯</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">            originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">            client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="责任链模式">责任链模式：</span></h3><p><strong>（一排，最后一位往前一个个传纸条[请求]，传到第一个又一个个往后传[响应]）</strong></p><p>为请求创建了一个接收者对象的链，在处理请求的时候执行过滤(各司其职)。</p><p>责任链上的处理者负责处理请求，客户只需要将请求发送到责任链即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><h3><span id="拦截器责任链">拦截器责任链：</span></h3><p><img src="/2020/12/10/okhttp/%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE.png" alt="拦截器责任链"></p><h3><span id="五大拦截器功能">五大拦截器功能：</span></h3><ol><li><p>重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。</p></li><li><p>桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。</p></li><li><p>缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。</p></li><li><p>连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。</p></li><li><p>请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。</p></li></ol><h3><span id="拦截器详情">拦截器详情：</span></h3><h4><span id="一-重试及重定向拦截器">一、重试及重定向拦截器</span></h4><p>第一个拦截器:<code>RetryAndFollowUpInterceptor</code>，主要就是完成两件事情：重试与重定向。</p><h5><span id="重试">重试</span></h5><p>场景：请求超时；域名解析后多个IP，如果一个IP失败了，重试其他IP</p><p><img src="/2020/12/10/okhttp/retry.png" alt="重试"></p><p><strong>设置是否允许重试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置是否允许重试 默认是允许</span></span><br><span class="line"><span class="keyword">new</span> OkHttpClient().newBuilder().retryOnConnectionFailure(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>在<code>RetryAndFollowUpInterceptor</code>中失败时，进入recover方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//todo 请求出现了异常，那么releaseConnection依旧为true。</span></span><br><span class="line">    response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">    <span class="comment">//todo 路由异常，连接未成功，请求还没发出去</span></span><br><span class="line">    <span class="comment">//The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">    <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">    &#125;</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//重试</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">//todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接)</span></span><br><span class="line">    <span class="comment">// ConnectionShutdownException只对HTTP2存在。假定它就是false</span></span><br><span class="line">    <span class="comment">//An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">    <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">    <span class="keyword">if</span> (!recover(e, streamAllocation, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在recover中 获取是否允许重试，如果不允许就抛异常，结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(IOException e, StreamAllocation streamAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;</span><br><span class="line">        streamAllocation.streamFailed(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 1、在配置OkhttpClient是设置了不允许重试（默认允许），则一旦发生请求失败就不再重试</span></span><br><span class="line">        <span class="comment">//The application layer has forbidden retries.</span></span><br><span class="line">        <span class="keyword">if</span> (!client.retryOnConnectionFailure()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 2、由于requestSendStarted只在http2的io异常中为true，先不管http2</span></span><br><span class="line">        <span class="comment">//We can&#x27;t send the request body again.</span></span><br><span class="line">        <span class="keyword">if</span> (requestSendStarted &amp;&amp; userRequest.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 3、判断是不是属于重试的异常</span></span><br><span class="line">        <span class="comment">//This exception is fatal.</span></span><br><span class="line">        <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 4、是不是存在更多的路线 （多个ip，多个代理）</span></span><br><span class="line">        <span class="comment">//No more routes to attempt.</span></span><br><span class="line">        <span class="keyword">if</span> (!streamAllocation.hasMoreRoutes()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For failure recovery, use the same route selector with a new connection.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>重试的异常包括哪些：</strong></p><p>在 <code>todo 3</code>的isRecoverable方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRecoverable</span><span class="params">(IOException e, <span class="keyword">boolean</span> requestSendStarted)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.是不是协议异常（code为204,205代表没有响应体，同时响应数据长度还大于0两都冲突，参照CallServerInterceptor中</span></span><br><span class="line">    <span class="comment">// if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0)）</span></span><br><span class="line">    <span class="comment">//：不重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ProtocolException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.socket超时异常 返回true:重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InterruptedIOException) &#123;</span><br><span class="line">        <span class="keyword">return</span> e <span class="keyword">instanceof</span> SocketTimeoutException &amp;&amp; !requestSendStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.//SSL证书不正确  可能证书格式损坏 有问题：不重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLHandshakeException) &#123;</span><br><span class="line">        <span class="comment">// If the problem was a CertificateException from the X509TrustManager,</span></span><br><span class="line">        <span class="comment">// do not retry.</span></span><br><span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> CertificateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.SSL证书校验 ：不重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在socket超时异常时会进行重试，其他异常不再进行重试</p><h5><span id="重定向">重定向</span></h5><p>场景：30X，资源改变</p><p><img src="/2020/12/10/okhttp/%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="重定向"></p><p><strong>最大重定向次数为：20</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 处理3和4xx的一些状态码，如301 302重定向</span></span><br><span class="line">Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line"><span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Request <span class="title">followUpRequest</span><span class="params">(Response userResponse, Route route)</span></span></span><br></pre></td></tr></table></figure><p><strong>在followUpRequest中响应码</strong></p><hr><p>407:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//407 身份校验</span></span><br><span class="line"><span class="keyword">case</span> HTTP_PROXY_AUTH:</span><br><span class="line">    Proxy selectedProxy = route != <span class="keyword">null</span></span><br><span class="line">            ? route.proxy()</span><br><span class="line">            : client.proxy();</span><br><span class="line">    <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">&quot;Received HTTP_PROXY_AUTH (407) code while not &quot;</span> +</span><br><span class="line">                <span class="string">&quot;using proxy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户没有设置就返回null,重定向就结束了</span></span><br><span class="line">    <span class="keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);</span><br></pre></td></tr></table></figure><p>用户设置身份校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置身份校验的代理</span></span><br><span class="line"><span class="keyword">new</span> OkHttpClient.Builder().proxy(<span class="keyword">new</span> Proxy(Proxy.Type.HTTP, <span class="keyword">new</span> InetSocketAddress(</span><br><span class="line">        <span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span></span><br><span class="line">)))</span><br><span class="line"><span class="comment">//设置身份校验(默认不设置这个）</span></span><br><span class="line">.proxyAuthenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//参照Authenticator接口注释</span></span><br><span class="line">        <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">                .header(<span class="string">&quot;Proxy-Authorization&quot;</span>, Credentials.basic(<span class="string">&quot;用户名&quot;</span>,<span class="string">&quot;密码&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure><p>401:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 401 需要身份验证 有些服务器接口需要验证使用者身份 在请求头中添加 “Authorization”</span></span><br><span class="line"><span class="keyword">case</span> HTTP_UNAUTHORIZED:</span><br><span class="line">    <span class="comment">//类似407身份验证，设置authenticator()</span></span><br><span class="line">    <span class="keyword">return</span> client.authenticator().authenticate(route, userResponse);</span><br></pre></td></tr></table></figure><p>重定向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 308 永久重定向</span></span><br><span class="line"><span class="comment">// 307 临时重定向</span></span><br><span class="line"><span class="keyword">case</span> HTTP_PERM_REDIRECT:</span><br><span class="line"><span class="keyword">case</span> HTTP_TEMP_REDIRECT:</span><br><span class="line">    <span class="comment">// 如果请求方式不是GET或者HEAD，框架不会自动重定向请求</span></span><br><span class="line">    <span class="keyword">if</span> (!method.equals(<span class="string">&quot;GET&quot;</span>) &amp;&amp; !method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 300 301 302 303</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MULT_CHOICE:</span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_PERM:</span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_TEMP:</span><br><span class="line"><span class="keyword">case</span> HTTP_SEE_OTHER:</span><br><span class="line">    <span class="comment">// 如果用户不允许重定向，那就返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从响应头取出location</span></span><br><span class="line">    String location = userResponse.header(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 根据location 配置新的请求 url</span></span><br><span class="line">    HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line">    <span class="comment">// 如果为null，说明协议有问题，取不出来HttpUrl，那就返回null，不进行重定向</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果重定向在http到https之间切换，需要检查用户是不是允许(默认允许)</span></span><br><span class="line">    <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">    <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重定向请求中 只要不是 PROPFIND 请求，无论是POST还是其他的方法都要改为GET请求方式，</span></span><br><span class="line"><span class="comment">     *  即只有 PROPFIND 请求才能有请求体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//请求不是get与head</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">        <span class="comment">// 除了 PROPFIND 请求之外都改成GET请求</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">            requestBuilder.method(<span class="string">&quot;GET&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</span><br><span class="line">            requestBuilder.method(method, requestBody);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是 PROPFIND 的请求，把请求头中关于请求体的数据删掉</span></span><br><span class="line">        <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在跨主机重定向时，删除身份验证请求头</span></span><br><span class="line">    <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestBuilder.url(url).build();</span><br></pre></td></tr></table></figure><p>408请求超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 408 客户端请求超时 </span></span><br><span class="line"><span class="keyword">case</span> HTTP_CLIENT_TIMEOUT:</span><br><span class="line">    <span class="comment">// 408 算是连接失败了，所以判断用户是不是允许重试</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// UnrepeatableRequestBody实际并没发现有其他地方用到</span></span><br><span class="line">    <span class="keyword">if</span> (userResponse.request().body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是本身这次的响应就是重新请求的产物同时上一次之所以重请求还是因为408，那我们这次不再重请求了</span></span><br><span class="line">    <span class="keyword">if</span> (userResponse.priorResponse() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果服务器告诉我们了 Retry-After 多久后重试，那框架不管了。</span></span><br><span class="line">    <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userResponse.request();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>503:</p><p>// 503 服务不可用 和408差不多，但是只在服务器告诉你 Retry-After：0（意思就是立即重试） 才重请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> HTTP_UNAVAILABLE:</span><br><span class="line">    <span class="keyword">if</span> (userResponse.priorResponse() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> userResponse.request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>重定向总结：服务器返回300 301 302 303需要重定向，会获取返回头的Location中的新地址。</p><p>如果此方法followUpRequest返回空，那就表示不需要再重定向了，直接返回响应；但是如果返回非空，那就要重新请求返回的<code>Request</code>，但是需要注意的是，我们的<code>followup</code>在拦截器中定义的最大次数为<strong>20</strong>次。</p><h5><span id="总结">总结</span></h5><p>本拦截器是整个责任链中的第一个，这意味着它会是首次接触到<code>Request</code>与最后接收到<code>Response</code>的角色，在这个拦截器中主要功能就是判断是否需要重试与重定向。</p><p>重试的前提是出现了<code>RouteException</code>或者<code>IOException</code>。一但在后续的拦截器执行过程中出现这两个异常，就会通过<code>recover</code>方法进行判断是否进行连接重试。</p><p>重定向发生在重试的判定之后，如果不满足重试的条件，还需要进一步调用<code>followUpRequest</code>根据<code>Response</code> 的响应码(当然，如果直接请求失败，<code>Response</code>都不存在就会抛出异常)。<code>followup</code>最大发生20次。</p><h4><span id="二-桥接拦截器">二、桥接拦截器</span></h4><p>两大作用：补全请求头，处理响应（保存cookie，GzipSource）</p><p>补全请求与响应后处理</p><table><thead><tr><th>请求头</th><th>说明</th></tr></thead><tbody><tr><td><code>Content-Type</code></td><td>请求体类型,如：<code>application/x-www-form-urlencoded</code></td></tr><tr><td><code>Content-Length</code>/<code>Transfer-Encoding</code></td><td>请求体解析方式</td></tr><tr><td><code>Host</code></td><td>请求的主机站点</td></tr><tr><td><code>Connection: Keep-Alive</code></td><td>保持长连接</td></tr><tr><td><code>Accept-Encoding: gzip</code></td><td>接受响应支持gzip压缩</td></tr><tr><td><code>Cookie</code></td><td>cookie身份辨别</td></tr><tr><td><code>User-Agent</code></td><td>请求的用户信息，如:操作系统、浏览器等</td></tr></tbody></table><p>得到响应：<br>    1、读取Set-Cookie响应头并调用接口告知用户，在下次请求则会读取对应的数据设置进入请求头，默认CookieJar无实现；</p><p>​    2、响应头Content-Encoding为gzip，使用GzipSource包装便于解析。</p><h5><span id="总结">总结</span></h5><p>桥接拦截器的执行逻辑主要就是以下几点</p><p>对用户构建的<code>Request</code>进行添加或者删除相关头部信息，以转化成能够真正进行网络请求的<code>Request</code><br>将符合网络请求规范的Request交给下一个拦截器处理，并获取<code>Response</code><br>如果响应体经过了GZIP压缩，那就需要解压，再构建成用户可用的<code>Response</code>并返回</p><h4><span id="三-缓存拦截器">三、缓存拦截器</span></h4><p><code>CacheInterceptor</code>，在发出请求前，判断是否命中缓存。如果命中则可以不请求，直接使用缓存的响应。 (只会存在Get请求的缓存)</p><p>步骤为:</p><p>1、从缓存中获得对应请求的响应缓存</p><p>2、创建<code>CacheStrategy</code> ,创建时会判断是否能够使用缓存，在<code>CacheStrategy</code> 中存在两个成员:<code>networkRequest</code>与<code>cacheResponse</code>。他们的组合如下:</p><table><thead><tr><th>networkRequest</th><th>cacheResponse</th><th>说明</th></tr></thead><tbody><tr><td>Null</td><td>Not Null</td><td>直接使用缓存</td></tr><tr><td>Not Null</td><td>Null</td><td>向服务器发起请求</td></tr><tr><td>Null</td><td>Null</td><td>直接gg，okhttp直接返回504</td></tr><tr><td>Not Null</td><td>Not Null</td><td>发起请求，若得到响应为304(无修改)，则更新缓存响应并返回</td></tr></tbody></table><p>即：networkRequest存在则优先发起网络请求，否则使用cacheResponse缓存，若都不存在则请求失败！</p><p>3、交给下一个责任链继续处理</p><p>4、后续工作，返回304则用缓存的响应；否则使用网络响应并缓存本次响应（只缓存Get请求的响应）</p><p>缓存拦截器的工作说起来比较简单，但是具体的实现，需要处理的内容很多。在缓存拦截器中判断是否可以使用缓存，或是请求服务器都是通过<code>CacheStrategy</code>判断。</p><h5><span id="缓存策略">缓存策略</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 缓存策略:根据各种条件(请求头)组成 请求与缓存</span></span><br><span class="line">CacheStrategy strategy =</span><br><span class="line">        <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheStrategy candidate = getCandidate();</span><br><span class="line">    <span class="comment">//todo 如果可以使用缓存，那networkRequest必定为null；指定了只使用缓存但是networkRequest又不为null，冲突。那就gg(拦截器返回504)</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/10/okhttp/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%A3%80%E6%B5%8B.png" alt="缓存策略-缓存检测"></p><h5><span id="流程">流程：</span></h5><ol><li><p>没有缓存，就进行网络请求</p></li><li><p>如果是Https请求，缓存中没有保存握手信息，发起网络请求</p></li><li><p>通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求（isCacheable方法）：不允许用</p></li><li><p>如果请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性（用户配置不进行缓存）：不想用</p></li><li><p>如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存</p></li><li><p>响应的缓存有效期</p><p>这一步为进一步根据缓存响应中的一些信息判定缓存是否处于有效期内。如果满足：</p><blockquote><p><strong>缓存存活时间 &lt; 缓存新鲜度 - 缓存最小新鲜度 + 过期后继续使用时长</strong></p></blockquote><p> 代表可以使用缓存。其中新鲜度可以理解为有效时间，而这里的 <strong>“缓存新鲜度-缓存最小新鲜度”</strong> 就代表了缓存真正有效的时间。</p></li><li><p>缓存过期处理</p><p>如果继续执行，表示缓存已经过期无法使用。此时我们判定缓存的响应中如果存在<code>Etag</code>，则使用<code>If-None-Match</code>交给服务器进行验证；如果存在<code>Last-Modified</code>或者<code>Data</code>，则使用<code>If-Modified-Since</code>交给服务器验证。服务器如果无修改则会返回304，这时候注意：</p><p><strong>由于是缓存过期而发起的请求(与第4个判断用户的主动设置不同)，如果服务器返回304，那框架会自动更新缓存，所以此时<code>CacheStrategy</code>既包含<code>networkRequest</code>也包含<code>cacheResponse</code></strong></p></li></ol><h5><span id="详细流程">详细流程：</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// No cached response.</span></span><br><span class="line">    <span class="comment">//todo 1、没有缓存,进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 2、https请求，但是没有握手信息,进行网络请求</span></span><br><span class="line">    <span class="comment">// OkHttp会保存ssl握手信息 handshake,如果这次发起了https请求，</span></span><br><span class="line">    <span class="comment">// 但是缓存的响应信息中没有握手信息，发起网络请求</span></span><br><span class="line">    <span class="comment">//Drop the cached response if it&#x27;s missing a required handshake.</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 3、主要是通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求</span></span><br><span class="line">    <span class="comment">//If this response shouldn&#x27;t have been stored, it should never be used</span></span><br><span class="line">    <span class="comment">//as a response source. This check should be redundant as long as the</span></span><br><span class="line">    <span class="comment">//persistence store is well-behaved and the rules are constant.</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheControl requestCaching = request.cacheControl();</span><br><span class="line">    <span class="comment">//todo 4、如果 请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性</span></span><br><span class="line">    <span class="comment">// 或者请求头包含 If-Modified-Since：时间 值为lastModified或者data 如果服务器没有在该头部指定的时间之后修改了请求的数据，服务器返回304(无修改)</span></span><br><span class="line">    <span class="comment">// 或者请求头包含 If-None-Match：值就是Etag（资源标记）服务器将其与存在服务端的Etag值进行比较；如果匹配，返回304</span></span><br><span class="line">    <span class="comment">// 请求头中只要存在三者中任意一个，进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 5、如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存</span></span><br><span class="line">    CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">    <span class="keyword">if</span> (responseCaching.immutable()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, cacheResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 6、根据 缓存响应的 控制缓存的响应头 判断是否允许使用缓存</span></span><br><span class="line">    <span class="comment">// 6.1、获得缓存的响应从创建到现在的时间</span></span><br><span class="line">    <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.2、获取这个响应有效缓存的时长</span></span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//todo 如果请求中指定了 max-age 表示指定了能拿的缓存有效时长，就需要综合响应有效缓存时长与请求能拿缓存的时长，获得最小的能够使用响应缓存的时长</span></span><br><span class="line">        freshMillis = Math.min(freshMillis,</span><br><span class="line">                SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.3 请求包含  Cache-Control:min-fresh=[秒]  能够使用还未过指定时间的缓存 （请求认为的缓存有效时间）</span></span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.4</span></span><br><span class="line">    <span class="comment">//  6.4.1、Cache-Control:must-revalidate 可缓存但必须再向源服务器进行确认</span></span><br><span class="line">    <span class="comment">//  6.4.2、Cache-Control:max-stale=[秒] 缓存过期后还能使用指定的时长  如果未指定多少秒，则表示无论过期多长时间都可以；如果指定了，则只要是指定时间内就能使用缓存</span></span><br><span class="line">    <span class="comment">// 前者会忽略后者，所以判断了不必须向服务器确认，再获得请求头中的max-stale</span></span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.5 不需要与服务器验证有效性 &amp;&amp; 响应存在的时间+请求认为的缓存有效时间 小于 缓存有效时长+过期后还可以使用的时间</span></span><br><span class="line">    <span class="comment">// 允许使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="comment">//todo 如果已过期，但未超过 过期后继续使用时长，那还可以继续使用，只用添加相应的头部字段</span></span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//todo 如果缓存已超过一天并且响应中没有设置过期时间也需要添加警告</span></span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a condition to add to the request. If the condition is satisfied, the</span></span><br><span class="line">    <span class="comment">// response body</span></span><br><span class="line">    <span class="comment">// will not be transmitted.</span></span><br><span class="line">    <span class="comment">//todo 7、缓存过期了</span></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-None-Match&quot;</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 如果设置了 If-None-Match/If-Modified-Since 服务器是可能返回304(无修改)的,使用缓存的响应体</span></span><br><span class="line">    Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">    Request conditionalRequest = request.newBuilder()</span><br><span class="line">            .headers(conditionalRequestHeaders.build())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="ps请求头与响应头">PS：请求头与响应头</span></h5><table><thead><tr><th>响应头</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>Date</td><td>消息发送的时间</td><td>Date: Sat, 18 Nov 2028 06:17:41 GMT</td></tr><tr><td>Expires</td><td>资源过期的时间</td><td>Expires: Sat, 18 Nov 2028 06:17:41 GMT</td></tr><tr><td>Last-Modified</td><td>资源最后修改时间</td><td>Last-Modified: Fri, 22 Jul 2016 02:57:17 GMT</td></tr><tr><td>ETag</td><td>资源在服务器的唯一标识</td><td>ETag: “16df0-5383097a03d40”</td></tr><tr><td>Age</td><td>服务器用缓存响应请求，该缓存从产生到现在经过多长时间(秒)</td><td>Age: 3825683</td></tr><tr><td>Cache-Control</td><td>-</td><td>-</td></tr></tbody></table><table><thead><tr><th>请求头</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td><code>If-Modified-Since</code></td><td>服务器没有在指定的时间后修改请求对应资源,返回304(无修改)</td><td>If-Modified-Since: Fri, 22 Jul 2016 02:57:17 GMT</td></tr><tr><td><code>If-None-Match</code></td><td>服务器将其与请求对应资源的<code>Etag</code>值进行比较，匹配返回304</td><td>If-None-Match: “16df0-5383097a03d40”</td></tr><tr><td><code>Cache-Control</code></td><td>-</td><td>-</td></tr></tbody></table><p>其中<code>Cache-Control</code>可以在请求头存在，也能在响应头存在，对应的value可以设置多种组合：</p><ol><li><code>max-age=[秒]</code> ：资源最大有效时间;</li><li><code>public</code> ：表明该资源可以被任何用户缓存，比如客户端，代理服务器等都可以缓存资源;</li><li><code>private</code>：表明该资源只能被单个用户缓存，默认是private。</li><li><code>no-store</code>：资源不允许被缓存</li><li><code>no-cache</code>：(请求)不使用缓存</li><li><code>immutable</code>：(响应)资源不会改变</li><li> <code> min-fresh=[秒]</code>：(请求)缓存最小新鲜度(用户认为这个缓存有效的时长)</li><li><code>must-revalidate</code>：(响应)不允许使用过期缓存</li><li><code>max-stale=[秒]</code>：(请求)缓存过期后多久内仍然有效</li></ol><blockquote><p>假设存在max-age=100，min-fresh=20。这代表了用户认为这个缓存的响应，从服务器创建响应 到 能够缓存使用的时间为100-20=80s。但是如果max-stale=100。这代表了缓存有效时间80s过后，仍然允许使用100s，可以看成缓存有效时长为180s。</p></blockquote><h4><span id="四-连接拦截器">四、连接拦截器</span></h4><h5><span id="连接流程">连接流程：</span></h5><p><img src="/2020/12/10/okhttp/%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B.png" alt="连接流程"></p><p><code>ConnectInterceptor</code>，打开与目标服务器的连接，并执行下一个拦截器。它简短的可以直接完整贴在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 首先我们看到的<code>StreamAllocation</code>这个对象是在第一个拦截器：重定向拦截器创建的，但是真正使用的地方却在这里。</p><p>*”当一个请求发出，需要建立连接，连接建立后需要使用流用来读写数据”*；而这个StreamAllocation就是协调请求、连接与数据流三者之间的关系，它负责为一次请求寻找连接，然后获得流来实现网络通信。</p><p>这里使用的<code>newStream</code>方法实际上就是去查找或者建立一个与请求主机有效的连接，返回的<code>HttpCodec</code>中包含了输入输出流，并且封装了对HTTP请求报文的编码与解码，直接使用它就能够与请求主机完成HTTP通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//todo  找到一个健康的连接</span></span><br><span class="line">        RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">                writeTimeout, pingIntervalMillis, connectionRetryEnabled,</span><br><span class="line">                doExtensiveHealthChecks);</span><br><span class="line">        <span class="comment">//todo 利用连接实例化流HttpCodec对象，如果是HTTP/2返回Http2Codec，否则返回Http1Codec</span></span><br><span class="line">        HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            codec = resultCodec;</span><br><span class="line">            <span class="keyword">return</span> resultCodec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>StreamAllocation</code>中简单来说就是维护连接：<code>RealConnection</code>——封装了Socket与一个Socket连接池。可复用的<code>RealConnection</code></strong></p><p>findHealthyConnection方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> connectionRetryEnabled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//todo 找到一个连接</span></span><br><span class="line">        RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">                pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 如果这个连接是新建立的，那肯定是健康的，直接返回</span></span><br><span class="line">        <span class="comment">//If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 如果不是新创建的，需要检查是否健康</span></span><br><span class="line">        <span class="comment">//Do a (potentially slow) check to confirm that the pooled connection is still good.</span></span><br><span class="line">      <span class="comment">// If it</span></span><br><span class="line">        <span class="comment">// isn&#x27;t, take it out of the pool and start again.</span></span><br><span class="line">        <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">            <span class="comment">//todo 不健康 关闭连接，释放Socket,从连接池移除</span></span><br><span class="line">            <span class="comment">// 继续下次寻找连接操作</span></span><br><span class="line">            noNewStreams();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findConnection方法中的</p><ul><li>尝试从连接池获取连接，如果有可复用的连接,会给第三个参数 this的connection赋值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>调到了（ConnectionPool）connectionPool.get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class="line">      streamAllocation.acquire(connection, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isEligible判断是否能够复用</p><ul><li>使用http1.1就不能用</li><li>如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口</li><li>都相同那就可以复用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligible</span><span class="params">(Address address, <span class="meta">@Nullable</span> Route route)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If this connection is not accepting new streams, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 实际上就是在使用http1.1就不能用</span></span><br><span class="line">    <span class="keyword">if</span> (allocations.size() &gt;= allocationLimit || noNewStreams) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the non-host fields of the address don&#x27;t overlap, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口（域名没有判断，所以下面马上判断）</span></span><br><span class="line">    <span class="keyword">if</span> (!Internal.instance.equalsNonHost(<span class="keyword">this</span>.route.address(), address)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the host exactly matches, we&#x27;re done: this connection can carry the address.</span></span><br><span class="line">    <span class="comment">//todo: 都相同那就可以复用了</span></span><br><span class="line">    <span class="keyword">if</span> (address.url().host().equals(<span class="keyword">this</span>.route().address().url().host())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// This connection is a perfect match.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we don&#x27;t have a hostname match. But we still be able to carry the</span></span><br><span class="line">  <span class="comment">// request if</span></span><br><span class="line">    <span class="comment">// our connection coalescing requirements are met. See also:</span></span><br><span class="line">    <span class="comment">// https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding</span></span><br><span class="line">    <span class="comment">// https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. This connection must be HTTP/2.</span></span><br><span class="line">    <span class="keyword">if</span> (http2Connection == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. The routes must share an IP address. This requires us to have a DNS address for both</span></span><br><span class="line">    <span class="comment">// hosts, which only happens after route planning. We can&#x27;t coalesce connections that use a</span></span><br><span class="line">    <span class="comment">// proxy, since proxies don&#x27;t tell us the origin server&#x27;s IP address.</span></span><br><span class="line">    <span class="keyword">if</span> (route == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.route.socketAddress().equals(route.socketAddress())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. This connection&#x27;s server certificate&#x27;s must cover the new host.</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!supportsUrl(address.url())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Certificate pinning must match the host.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        address.certificatePinner().check(address.url().host(), handshake().peerCertificates());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SSLPeerUnverifiedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// The caller&#x27;s address can be carried by this connection.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没找到，必须新建一个连接了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">            selectedRoute = routeSelection.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a connection and assign it to this allocation immediately. This makes</span></span><br><span class="line">      <span class="comment">// it possible</span></span><br><span class="line">        <span class="comment">// for an asynchronous cancel() to interrupt the handshake we&#x27;re about to do.</span></span><br><span class="line">        route = selectedRoute;</span><br><span class="line">        refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">        result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">        acquire(result, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="连接池清理">连接池清理：</span></h5><p><img src="/2020/12/10/okhttp/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B8%85%E7%90%86.png" alt="连接池清理"></p><p>findConnection方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 将新创建的连接放到连接池中</span></span><br><span class="line">Internal.instance.put(connectionPool, result);</span><br></pre></td></tr></table></figure><p>调的是ConnectionPool.put方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">    cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//启动清理</span></span><br><span class="line">    executor.execute(cleanupRunnable);</span><br><span class="line">  &#125;</span><br><span class="line">  connections.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//todo:最快多久后需要清理</span></span><br><span class="line">      <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">      <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//todo:因为等待是纳秒级，wait方法可以接收纳秒级控制，但是把毫秒与纳秒分开</span></span><br><span class="line">        <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">        waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//todo:参数多一个纳秒，控制更加精确</span></span><br><span class="line">            ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">  RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">      <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        inUseConnectionCount++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      idleConnectionCount++;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 获得这个连接闲置多久</span></span><br><span class="line">      <span class="comment">// If the connection is ready to be evicted, we&#x27;re done.</span></span><br><span class="line">      <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">      <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">        longestIdleDurationNs = idleDurationNs;</span><br><span class="line">        longestIdleConnection = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超过保活时间（5分钟）或者池内数量超过了5个，马上移除，然后返回0，表示不等待，马上再次检查</span></span><br><span class="line">    <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">        || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class="line">      <span class="comment">// of the synchronized block).</span></span><br><span class="line">      connections.remove(longestIdleConnection);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// A connection will be ready to evict soon.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 池内存在闲置连接，就等待，保活时间（5分钟）-最长闲置时间=还能闲置多久 再检查</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// All connections are in use. It&#x27;ll be at least the keep alive duration &#x27;til we run again.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 有使用中的连接就等待5分钟，再检查</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No connections, idle or in use.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 都不满足，可能池内没任何连接，直接停止清理（put后再次启用）</span></span><br><span class="line">      cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5><span id="代理连接">代理连接：</span></h5><p><img src="/2020/12/10/okhttp/%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5.png" alt="代理连接"></p><p>findConnection中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 实际上就是创建socket连接，但是要注意的是如果存在http代理的情况</span></span><br><span class="line">result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br></pre></td></tr></table></figure><p>RealConnection.connect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">    <span class="comment">//todo http隧道代理</span></span><br><span class="line">    connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">    <span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We were unable to connect the tunnel but properly closed down our</span></span><br><span class="line">      <span class="comment">// resources.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//todo 创建socket连接</span></span><br><span class="line">    connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有http代理先设置代理头，最终都用调用connectSocket方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTunnel</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                           EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request tunnelRequest = createTunnelRequest();</span><br><span class="line">    HttpUrl url = tunnelRequest.url();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_TUNNEL_ATTEMPTS; i++) &#123;</span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">        tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tunnelRequest == <span class="keyword">null</span>) <span class="keyword">break</span>; <span class="comment">// Tunnel successfully created.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The proxy decided to close the connection after an auth challenge. We need to</span></span><br><span class="line">      <span class="comment">// create a new</span></span><br><span class="line">        <span class="comment">// connection, but this time with the auth credentials.</span></span><br><span class="line">        closeQuietly(rawSocket);</span><br><span class="line">        rawSocket = <span class="keyword">null</span>;</span><br><span class="line">        sink = <span class="keyword">null</span>;</span><br><span class="line">        source = <span class="keyword">null</span>;</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">createTunnelRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(route.address().url())</span><br><span class="line">            .header(<span class="string">&quot;Host&quot;</span>, Util.hostHeader(route.address().url(), <span class="keyword">true</span>))</span><br><span class="line">            .header(<span class="string">&quot;Proxy-Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>) <span class="comment">// For HTTP/1.0 proxies like Squid.</span></span><br><span class="line">            .header(<span class="string">&quot;User-Agent&quot;</span>, Version.userAgent())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * todo:创建socket连接</span></span><br><span class="line"><span class="comment"> * Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                           EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Proxy proxy = route.proxy();</span><br><span class="line">    Address address = route.address();</span><br><span class="line">    <span class="comment">//todo:没有代理直接new一个Socket（），有代理就创建一个带代理参数的socket</span></span><br><span class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">            ? address.socketFactory().createSocket()</span><br><span class="line">            : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line"></span><br><span class="line">    eventListener.connectStart(call, route.socketAddress(), proxy);</span><br><span class="line">    rawSocket.setSoTimeout(readTimeout);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> socket.connect</span></span><br><span class="line">        Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">        ConnectException ce =</span><br><span class="line">                <span class="keyword">new</span> ConnectException(<span class="string">&quot;Failed to connect to &quot;</span> + route.socketAddress());</span><br><span class="line">        ce.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0</span></span><br><span class="line">    <span class="comment">// More details:</span></span><br><span class="line">    <span class="comment">// https://github.com/square/okhttp/issues/3245</span></span><br><span class="line">    <span class="comment">// https://android-review.googlesource.com/#/c/271775/</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">        sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">        <span class="keyword">if</span> (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(npe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="五-请求服务器拦截器">五、请求服务器拦截器</span></h4><h5><span id="expect-100-continue">Expect: 100-continue</span></h5><p>一般出现于上传大容量请求体或者需要验证。代表了先询问服务器是否原因接收发送请求体数据。（先只发送请求头）</p><p>OkHttp的做法：<br>如果服务器允许则返回100，客户端继续发送请求体；<br>如果服务器不允许则直接返回给用户。</p><p>同时服务器也可能会忽略此请求头，一直无法读取应答，此时抛出超时异常。</p><p><img src="/2020/12/10/okhttp/100-continue.png" alt="100-continue"></p><p><code>CallServerInterceptor</code>，利用<code>HttpCodec</code>发出请求到服务器并且解析生成<code>Response</code>。</p><p>首先调用<code>httpCodec.writeRequestHeaders(request);</code> 将请求头写入到缓存中(直到调用<code>flushRequest()</code>才真正发送给服务器)。然后马上进行第一个逻辑判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallServerInterceptor</span><span class="params">(<span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">        <span class="comment">//todo:拼接请求的数据</span></span><br><span class="line">        httpCodec.writeRequestHeaders(request);</span><br><span class="line">        realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line"></span><br><span class="line">        Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//todo:如果没有请求体或者不是post跳过</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span></span><br><span class="line">            <span class="comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span></span><br><span class="line">            <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">            <span class="comment">// todo: 如果是post请求，并包含了100-continue,不发请求体，读服务器的响应</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equalsIgnoreCase(request.header(<span class="string">&quot;Expect&quot;</span>))) &#123;</span><br><span class="line">                <span class="comment">// todo: 发送请求头</span></span><br><span class="line">                httpCodec.flushRequest();</span><br><span class="line">                realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">                responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务返回100，responseBuilder会置为null</span></span><br><span class="line">            <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">                realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">                <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">                CountingSink requestBodyOut =</span><br><span class="line">                        <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                <span class="comment">//todo：写入请求体</span></span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">                realChain.eventListener()</span><br><span class="line">                        .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">                <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1</span></span><br><span class="line">              <span class="comment">// connection</span></span><br><span class="line">                <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request</span></span><br><span class="line">              <span class="comment">// body to</span></span><br><span class="line">                <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        httpCodec.finishRequest();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 读取服务器响应</span></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = responseBuilder</span><br><span class="line">                .request(request)</span><br><span class="line">                .handshake(streamAllocation.connection().handshake())</span><br><span class="line">                .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> code = response.code();</span><br><span class="line">        <span class="comment">// todo: 服务器允许继续发送响应体</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">            <span class="comment">// try again to read the actual response</span></span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            response = responseBuilder</span><br><span class="line">                    .request(request)</span><br><span class="line">                    .handshake(streamAllocation.connection().handshake())</span><br><span class="line">                    .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            code = response.code();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        realChain.eventListener()</span><br><span class="line">                .responseHeadersEnd(realChain.call(), response);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">            <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null</span></span><br><span class="line">          <span class="comment">// response body.</span></span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(httpCodec.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.request().header(<span class="string">&quot;Connection&quot;</span>))</span><br><span class="line">                || <span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.header(<span class="string">&quot;Connection&quot;</span>))) &#123;</span><br><span class="line">            streamAllocation.noNewStreams();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">                    <span class="string">&quot;HTTP &quot;</span> + code + <span class="string">&quot; had non-zero Content-Length: &quot;</span> + response.body().contentLength());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSink</span> <span class="keyword">extends</span> <span class="title">ForwardingSink</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> successfulCount;</span><br><span class="line"></span><br><span class="line">        CountingSink(Sink delegate) &#123;</span><br><span class="line">            <span class="keyword">super</span>(delegate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Buffer source, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.write(source, byteCount);</span><br><span class="line">            successfulCount += byteCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个if都和一个请求头有关： <code>Expect: 100-continue</code>。这个请求头代表了在发送请求体之前需要和服务器确定是否愿意接受客户端发送的请求体。所以<code>permitsRequestBody</code>判断为是否会携带请求体的方式(POST)，如果命中if，则会先给服务器发起一次查询是否愿意接收请求体，这时候如果服务器愿意会响应100(没有响应体，responseBuilder 即为nul)。这时候才能够继续发送剩余请求数据。</p><p>但是如果服务器不同意接受请求体，那么我们就需要标记该连接不能再被复用，调用<code>noNewStreams()</code>关闭相关的Socket。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 读取服务器响应</span></span><br><span class="line"><span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(streamAllocation.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>这时<code>responseBuilder</code>的情况即为：</p><p>1、POST方式请求，请求头中包含<code>Expect</code>，服务器允许接受请求体，并且已经发出了请求体，<code>responseBuilder</code>为null;</p><p>2、POST方式请求，请求头中包含<code>Expect</code>，服务器不允许接受请求体，<code>responseBuilder</code>不为null</p><p>3、POST方式请求，未包含<code>Expect</code>，直接发出请求体，<code>responseBuilder</code>为null;</p><p>4、POST方式请求，没有请求体，<code>responseBuilder</code>为null;</p><p>5、GET方式请求，<code>responseBuilder</code>为null;</p><p>对应上面的5种情况，读取响应头并且组成响应<code>Response</code>，注意：此<code>Response</code>没有响应体。同时需要注意的是，如果服务器接受 <code>Expect: 100-continue</code>这是不是意味着我们发起了两次<code>Request</code>？那此时的响应头是第一次查询服务器是否支持接受请求体的，而不是真正的请求对应的结果响应。</p><p>所以 如果响应是100，这代表了是请求<code>Expect: 100-continue</code>成功的响应，需要马上再次读取一份响应头，这才是真正的请求对应结果响应头。</p><p>最后：</p><p><code>forWebSocket</code>代表websocket的请求，我们直接进入else，这里就是读取响应体数据。然后判断请求和服务器是不是都希望长连接，一旦有一方指明<code>close</code>，那么就需要关闭<code>socket</code>。而如果服务器返回204/205，一般情况而言不会存在这些返回码，但是一旦出现这意味着没有响应体，但是解析到的响应头中包含<code>Content-Lenght</code>且不为0，这表响应体的数据字节长度。此时出现了冲突，直接抛出协议异常！</p><h5><span id="总结">总结</span></h5><p>在这个拦截器中就是完成HTTP协议报文的封装与解析。</p><h2><span id="自定义拦截器">自定义拦截器</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> OkHttpClient().newBuilder().addInterceptor(<span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// todo: .......</span></span><br><span class="line">        <span class="keyword">final</span> Response response = chain.proceed(chain.request());</span><br><span class="line">        <span class="comment">// todo: .......</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一定要调用chain.proceed,并将response返回。</p><p>不调用的话，会使责任链中断，后面其他就没法执行了。</p><h2><span id="okhttp总结">OkHttp总结</span></h2><p>整个OkHttp功能的实现就在这五个默认的拦截器中，所以先理解拦截器模式的工作机制是先决条件。这五个拦截器分别为: 重试拦截器、桥接拦截器、缓存拦截器、连接拦截器、请求服务拦截器。每一个拦截器负责的工作不一样，就好像工厂流水线，最终经过这五道工序，就完成了最终的产品。</p><p>但是与流水线不同的是，OkHttp中的拦截器每次发起请求都会在交给下一个拦截器之前干一些事情，在获得了结果之后又干一些事情。整个过程在请求向是顺序的，而响应向则是逆序。</p><p>当用户发起一个请求后，会由任务分发起<code>Dispatcher</code>将请求包装并交给重试拦截器处理。</p><p>1、重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。</p><p>2、桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。</p><p>3、缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。</p><p>4、连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。</p><p>5、请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。</p><p>在经过了这一系列的流程后，就完成了一次HTTP请求！</p><h2><span id="补充-代理">补充: 代理</span></h2><p>在使用OkHttp时，如果用户在创建<code>OkHttpClient</code>时，配置了<code>proxy</code>或者<code>proxySelector</code>，则会使用配置的代理，并且<code>proxy</code>优先级高于<code>proxySelector</code>。而如果未配置，则会获取机器配置的代理并使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK : ProxySelector</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">URI uri = <span class="keyword">new</span> URI(<span class="string">&quot;http://restapi.amap.com&quot;</span>);</span><br><span class="line">List&lt;Proxy&gt; proxyList = ProxySelector.getDefault().select(uri);</span><br><span class="line">System.out.println(proxyList.get(<span class="number">0</span>).address());</span><br><span class="line">System.out.println(proxyList.get(<span class="number">0</span>).type());</span><br><span class="line">&#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果我们不需要自己的App中的请求走代理，则可以配置一个<code>proxy(Proxy.NO_PROXY)</code>，这样也可以避免被抓包。<code>NO_PROXY</code>的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Proxy NO_PROXY = <span class="keyword">new</span> Proxy();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.type = Proxy.Type.DIRECT;</span><br><span class="line"><span class="keyword">this</span>.sa = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理在Java中对应的抽象类有三种类型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        DIRECT,</span><br><span class="line">        HTTP,</span><br><span class="line">        SOCKS;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DIRECT</code>：无代理，<code>HTTP</code>：http代理，<code>SOCKS</code>：socks代理。第一种自然不用多说，而Http代理与Socks代理有什么区别？</p><p>对于Socks代理，在HTTP的场景下，代理服务器完成TCP数据包的转发工作;<br>而Http代理服务器，在转发数据之外，还会解析HTTP的请求及响应，并根据请求及响应的内容做一些处理。</p><blockquote><p><code>RealConnection</code>的<code>connectSocket</code>方法:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是Socks代理则 new Socket(proxy); 否则相当于直接:new Socket()</span></span><br><span class="line">rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">                ? address.socketFactory().createSocket()</span><br><span class="line">                : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line"><span class="comment">//connect方法</span></span><br><span class="line">socket.connect(address);</span><br></pre></td></tr></table></figure><p>设置了SOCKS代理的情况下，创建Socket时，为其传入proxy，连接时还是以HTTP服务器为目标地址；但是如果设置的是Http代理，创建Socket是与Http代理服务器建立连接。</p><blockquote><p>在<code>connect</code>方法时传递的<code>address</code>来自于下面的集合<code>inetSocketAddresses</code><br><code>RouteSelector</code>的<code>resetNextInetSocketAddress</code>方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetNextInetSocketAddress</span><span class="params">(Proxy proxy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">        <span class="comment">//无代理和socks代理，使用http服务器域名与端口</span></span><br><span class="line">      socketHost = address.url().host();</span><br><span class="line">      socketPort = address.url().port();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SocketAddress proxyAddress = proxy.address();</span><br><span class="line">      <span class="keyword">if</span> (!(proxyAddress <span class="keyword">instanceof</span> InetSocketAddress)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">&quot;Proxy.address() is not an &quot;</span> + <span class="string">&quot;InetSocketAddress: &quot;</span> + proxyAddress.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;</span><br><span class="line">      socketHost = getHostString(proxySocketAddress);</span><br><span class="line">      socketPort = proxySocketAddress.getPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">        <span class="comment">//socks代理 connect http服务器 （DNS没用，由代理服务器解析域名）</span></span><br><span class="line">      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//无代理，dns解析http服务器</span></span><br><span class="line">        <span class="comment">//http代理,dns解析http代理服务器</span></span><br><span class="line">      List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;</span><br><span class="line">        InetAddress inetAddress = addresses.get(i);</span><br><span class="line">        inetSocketAddresses.add(<span class="keyword">new</span> InetSocketAddress(inetAddress, socketPort));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置代理时，Http服务器的域名解析会被交给代理服务器执行。但是如果是设置了Http代理，会对Http代理服务器的域名使用<code>OkhttpClient</code>配置的dns解析代理服务器，Http服务器的域名解析被交给代理服务器解析。</p><p>上述代码就是代理与DNS在OkHttp中的使用，但是还有一点需要注意，Http代理也分成两种类型：普通代理与隧道代理。</p><p>其中普通代理不需要额外的操作，扮演「中间人」的角色，在两端之间来回传递报文。这个“中间人”在收到客户端发送的请求报文时，需要正确的处理请求和连接状态，同时向服务器发送新的请求，在收到响应后，将响应结果包装成一个响应体返回给客户端。在普通代理的流程中，代理两端都是有可能察觉不到”中间人“的存在。</p><p>但是隧道代理不再作为中间人，无法改写客户端的请求，而仅仅是在建立连接后，将客户端的请求，通过建立好的隧道，无脑的转发给终端服务器。隧道代理需要发起Http <strong>CONNECT</strong>请求，这种请求方式没有请求体，仅供代理服务器使用，并不会传递给终端服务器。请求头 部分一旦结束，后面的所有数据，都被视为应该转发给终端服务器的数据，代理需要把他们无脑的直接转发，直到从客户端的 TCP 读通道关闭。<strong>CONNECT</strong> 的响应报文，在代理服务器和终端服务器建立连接后，可以向客户端返回一个 <code>200 Connect established</code> 的状态码，以此表示和终端服务器的连接，建立成功。</p><blockquote><p>RealConnection的connect方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.requiresTunnel()) &#123;         </span><br><span class="line">connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line"><span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// We were unable to connect the tunnel but properly closed down our</span></span><br><span class="line"><span class="comment">// resources.</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>requiresTunnel</code>方法的判定为：当前请求为https并且存在http代理，这时候<code>connectTunnel</code>中会发起:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">xxxx</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: xxxx</span><br><span class="line"><span class="attribute">Proxy-Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">User-Agent</span>: okhttp/$&#123;version&#125;</span><br></pre></td></tr></table></figure><p>的请求，连接成功代理服务器会返回200；如果返回407表示代理服务器需要鉴权(如：付费代理)，这时需要在请求头中加入<code>Proxy-Authorization</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> Authenticator authenticator = <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(response.code == <span class="number">407</span>)&#123;</span><br><span class="line">            <span class="comment">//代理鉴权</span></span><br><span class="line">            String credential = Credentials.basic(<span class="string">&quot;代理服务用户名&quot;</span>, <span class="string">&quot;代理服务密码&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">                    .header(<span class="string">&quot;Proxy-Authorization&quot;</span>, credential)</span><br><span class="line">                    .build();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="keyword">new</span> OkHttpClient.Builder().proxyAuthenticator(authenticator);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;OkHttp请求流程&lt;/li&gt;
&lt;li&gt;高并发请求分发器与线程池&lt;/li&gt;
&lt;li&gt;责任链模式请求与响应拦截&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#okhttp%E4%BB%8B%E7%BB%8D&quot;&gt;OkHttp介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8&quot;&gt;简单使用：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B&quot;&gt;使用流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B&quot;&gt;调用流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%86%E5%8F%91%E5%99%A8&quot;&gt;分发器：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B&quot;&gt;异步请求工作流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#okhttp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%89%B9%E7%82%B9&quot;&gt;OkHttp线程池的特点：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#asynccall&quot;&gt;AsyncCall&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82&quot;&gt;同步请求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;拦截器：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94&quot;&gt;获取响应：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F&quot;&gt;责任链模式：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE&quot;&gt;拦截器责任链：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8A%9F%E8%83%BD&quot;&gt;五大拦截器功能：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%A6%E6%83%85&quot;&gt;拦截器详情：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80-%E9%87%8D%E8%AF%95%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;一、重试及重定向拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%87%8D%E8%AF%95&quot;&gt;重试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%87%8D%E5%AE%9A%E5%90%91&quot;&gt;重定向&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C-%E6%A1%A5%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;二、桥接拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93-1&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89-%E7%BC%93%E5%AD%98%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;三、缓存拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5&quot;&gt;缓存策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B5%81%E7%A8%8B&quot;&gt;流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B&quot;&gt;详细流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ps%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4&quot;&gt;PS：请求头与响应头&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%9B-%E8%BF%9E%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;四、连接拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B&quot;&gt;连接流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B8%85%E7%90%86&quot;&gt;连接池清理：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5&quot;&gt;代理连接：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%94-%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;五、请求服务器拦截器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#expect-100-continue&quot;&gt;Expect: 100-continue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8&quot;&gt;自定义拦截器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#okhttp%E6%80%BB%E7%BB%93&quot;&gt;OkHttp总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%A1%A5%E5%85%85-%E4%BB%A3%E7%90%86&quot;&gt;补充: 代理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;</summary>
    
    
    
    <category term="Android三方库源码分析" scheme="http://example.com/categories/Android%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="OkHttp" scheme="http://example.com/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>View事件分发</title>
    <link href="http://example.com/2020/12/09/dispatch/"/>
    <id>http://example.com/2020/12/09/dispatch/</id>
    <published>2020-12-09T02:01:42.000Z</published>
    <updated>2021-07-04T11:09:25.548Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="目录">目录</span></h2><!-- toc --><ul><li><a href="#motionevent">MotionEvent</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E6%8B%A6%E6%88%AA%E4%B8%8E%E6%B6%88%E8%B4%B9">事件分发、拦截与消费</a></li><li><a href="#%E6%80%BB%E6%B5%81%E7%A8%8B">总流程</a></li><li><a href="#ontouch%E5%92%8Conclick">onTouch和onClick</a><ul><li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">源码分析：</a><ul><li><a href="#viewdispatchtouchevent">View.dispatchTouchEvent</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结：</a></li></ul></li><li><a href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">事件分发源码解析：</a><ul><li><a href="#%E4%BA%8B%E4%BB%B6action_down">事件：ACTION_DOWN</a><ul><li><a href="#1%E5%81%87%E8%AE%BEonintercepttouchevent%E6%B2%A1%E6%9C%89%E6%8B%A6%E6%88%AA%E8%BF%99%E9%87%8Cintercepted%E4%B8%BAfalse">1.假设onInterceptTouchEvent没有拦截，这里intercepted为false;</a></li><li><a href="#2%E5%81%87%E8%AE%BEonintercepttouchevent%E7%9B%B4%E6%8E%A5%E6%8B%A6%E6%88%AA%E8%BF%99%E9%87%8Cintercepted%E4%B8%BAtrue">2.假设onInterceptTouchEvent直接拦截，这里intercepted为true;</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93-1">总结：</a></li><li><a href="#%E4%BA%8B%E4%BB%B6action_move">事件：ACTION_MOVE</a><ul><li><a href="#1%E5%81%87%E8%AE%BEonintercepttouchevent%E6%B2%A1%E6%9C%89%E6%8B%A6%E6%88%AA">1.假设onInterceptTouchEvent没有拦截</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93-2">总结：</a></li></ul></li></ul><ul><li><a href="#%E4%BA%8B%E4%BB%B6%E5%86%B2%E7%AA%81">事件冲突</a><ul><li><a href="#viewgrouponintercepttouchevent">ViewGroup#onInterceptTouchEvent</a></li><li><a href="#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3">冲突解决：</a><ul><li><a href="#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E5%9C%A8%E5%AD%90view%E4%B8%AD%E8%A7%A3%E5%86%B3">内部拦截法（在子View中解决）</a></li><li><a href="#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E6%80%BB%E7%BB%93">内部拦截法总结：</a></li><li><a href="#%E5%A4%96%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E5%9C%A8%E7%88%B6view%E4%B8%AD%E8%A7%A3%E5%86%B3">外部拦截法（在父View中解决）</a></li></ul></li></ul></li></ul><!-- tocstop --><a id="more"></a><h2><span id="motionevent">MotionEvent</span></h2><p><img src="/2020/12/09/dispatch/MotionEvent.png" alt="MotionEvent"></p><h2><span id="事件分发-拦截与消费">事件分发、拦截与消费</span></h2><p><img src="/2020/12/09/dispatch/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%8B%A6%E6%88%AA%E6%B6%88%E8%B4%B9.png" alt="事件分发拦截消费"></p><p>事件分发：Activity，ViewGroup，   View</p><p>事件拦截：                 ViewGroup</p><p>事件消费：Activity，                          View</p><h2><span id="总流程">总流程</span></h2><p><img src="/2020/12/09/dispatch/%E6%80%BB%E6%B5%81%E7%A8%8B.png" alt="总流程"></p><h2><span id="ontouch和onclick">onTouch和onClick</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">textView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;Text&quot;</span>, <span class="string">&quot;onClick&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">textView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;Text&quot;</span>, <span class="string">&quot;onTouch&quot;</span>+event.getAction());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3><span id="源码分析">源码分析：</span></h3><h4><span id="viewdispatchtouchevent">View.dispatchTouchEvent</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the event should be handled by accessibility focus first.</span></span><br><span class="line">    <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t have focus or no virtual descendant has it, do not handle the event.</span></span><br><span class="line">        <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We have focus and got the event, then use normal event dispatch.</span></span><br><span class="line">        event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// Defensive cleanup for new gesture</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class="line">    <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest</span></span><br><span class="line">    <span class="comment">// of the gesture.</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListenerInfo li = mListenerInfo;</span><br><span class="line"><span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">        &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">    result = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里li不等于空</p><p>在view.setOnTouchListener或setOnClickListener调用时</p><p>都会调用getListenerInfo()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnTouchListener</span><span class="params">(OnTouchListener l)</span> </span>&#123;</span><br><span class="line">    getListenerInfo().mOnTouchListener = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListenerInfo <span class="title">getListenerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    mListenerInfo = <span class="keyword">new</span> ListenerInfo();</span><br><span class="line">    <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里li肯定不为空</p><p><code>(mViewFlags &amp; ENABLED_MASK) == ENABLED</code>这里代表可view可用状态</p><p>所以<code>li.mOnTouchListener.onTouch(this, event)</code>这里如果返回为</p><ul><li><p>为true时  result=true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">    result = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>所以这里的onTouchEvent(event)方法就不会再走。</p><p>onTouchEvent中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">    <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">               performClickInternal();</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performClickInternal–&gt;performClick</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We still need to call this method to handle the cases where performClick() was called</span></span><br><span class="line">    <span class="comment">// externally, instead of through performClickInternal()</span></span><br><span class="line">    notifyAutofillManagerOnClick();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">    notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>li.mOnClickListener.onClick(this);</code>调用了onClick方法，并返回true</p><h3><span id="总结">总结：</span></h3><p>onTouch返回fasle时，调用onTouchEvent,再到onClick</p><p>onTouch返回true时，不调用onTouchEvent和onClick</p><p>onTouch=false—-&gt;onTouchEvent—-&gt;onClick</p><p>onTouch=true 结束</p><h2><span id="事件分发源码解析">事件分发源码解析：</span></h2><p>Activity#dispatchTouchEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getWindow().superDispatchTouchEvent(ev)</code>–&gt;PhoneWindow#superDispatchTouchEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mDecor.superDispatchTouchEvent(event)</code>–&gt;DecorView#superDispatchTouchEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的dispatchTouchEvent–&gt;ViewGroup#dispatchTouchEvent</p><h3><span id="事件action_down">事件：ACTION_DOWN</span></h3><p>一进入down就会清除事件和状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">    <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">    <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否拦截的标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br></pre></td></tr></table></figure><h4><span id="1假设onintercepttouchevent没有拦截这里intercepted为false">1.假设onInterceptTouchEvent没有拦截，这里intercepted为false;</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">     || actionMasked == MotionEvent.ACTION_CANCEL;</span><br></pre></td></tr></table></figure><p>假设这里的canceled也为false(没有取消)</p><p>所以进入了这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">            ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">        <span class="comment">// have become out of sync.</span></span><br><span class="line">        removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里newTouchTarget为null,并且childrenCount也不可能为0</p><p>if (newTouchTarget == null &amp;&amp; childrenCount != 0)中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br></pre></td></tr></table></figure><p>buildTouchDispatchChildList()方法对子View进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">    <span class="comment">// add next child (in child order) to end of list</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">    <span class="keyword">final</span> View nextChild = mChildren[childIndex];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> currentZ = nextChild.getZ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert ahead of any Views with greater Z</span></span><br><span class="line">    <span class="keyword">int</span> insertIndex = i;</span><br><span class="line">    <span class="keyword">while</span> (insertIndex &gt; <span class="number">0</span> &amp;&amp; mPreSortedChildren.get(insertIndex - <span class="number">1</span>).getZ() &gt; currentZ) &#123;</span><br><span class="line">        insertIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    mPreSortedChildren.add(insertIndex, nextChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Z轴越大越在数组后面，越小越在数组前面（页面上View越在上层越在数组后面，越底层越在数组前面）</p><p>​        这里从排好序的preorderedList中，从最后往前取值（即先取z轴最上层的view）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">            childrenCount, i, customOrder);</span><br><span class="line">    <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">            preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">    <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">    <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">    <span class="comment">// safer given the timeframe.</span></span><br><span class="line">    <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">        i = childrenCount - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newTouchTarget = getTouchTarget(child);</span><br><span class="line">    <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">        <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resetCancelNextUpFlag(child);</span><br><span class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">        <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">        mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">        <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                    mLastTouchDownIndex = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLastTouchDownIndex = childIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastTouchDownX = ev.getX();</span><br><span class="line">        mLastTouchDownY = ev.getY();</span><br><span class="line">        newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">        alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The accessibility focus didn&#x27;t handle the event, so clear</span></span><br><span class="line">    <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断取到的View是不是点击到的View（判断是否能够接收手指事件和点击区域是不是在View上）</p><p>不是的话继续循环拿取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canReceivePointerEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || getAnimation() != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isTransformedTouchPointInView</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        PointF outLocalPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[] point = getTempPoint();</span><br><span class="line">    point[<span class="number">0</span>] = x;</span><br><span class="line">    point[<span class="number">1</span>] = y;</span><br><span class="line">    transformPointToViewLocal(point, child);</span><br><span class="line">    <span class="comment">// pointInView：x &gt;= 0 &amp;&amp; localY &gt;= 0 &amp;&amp; y &lt; ((mRight - mLeft) + 0) &amp;&amp;y &lt; ((mBottom - mTop) + 0) 判断触点是否在View上</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isInView = child.pointInView(point[<span class="number">0</span>], point[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (isInView &amp;&amp; outLocalPoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outLocalPoint.set(point[<span class="number">0</span>], point[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isInView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pointInView</span><span class="params">(<span class="keyword">float</span> localX, <span class="keyword">float</span> localY, <span class="keyword">float</span> slop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; ((mRight - mLeft) + slop) &amp;&amp;</span><br><span class="line">            localY &lt; ((mBottom - mTop) + slop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里获取TouchTarget，这里返回的还是空，因为mFirstTouchTarget初始为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTouchTarget = getTouchTarget(child);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">getTouchTarget</span><span class="params">(<span class="meta">@NonNull</span> View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TouchTarget target = mFirstTouchTarget; target != <span class="keyword">null</span>; target = target.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.child == child) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchTransformedTouchEvent –分发给谁处理事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里child不为空，所以就会调用child.dispatchTouchEvent(transformedEvent)–&gt;就到了上文onTouch和onClick的源码分析View.dispatchTouchEvent</p><p>View.dispatchTouchEvent处理事件后，返回result为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">    result &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就进入if，然后break;结束整个for循环，其他view就处理不了事件了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line"></span><br><span class="line">    mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                mLastTouchDownIndex = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLastTouchDownIndex = childIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastTouchDownX = ev.getX();</span><br><span class="line">    mLastTouchDownY = ev.getY();</span><br><span class="line">    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用addTouchTarget(),进行newTouchTarget赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123;</span><br><span class="line">    final TouchTarget target &#x3D; TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next &#x3D; mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget &#x3D; target;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mFirstTouchTarget==newTouchTarget并且alreadyDispatchedToNewTouchTarget=true;</strong></p><p>如果没有处理，当前循环就结束了， 进行下一次的for循环。</p><p>继续往下走：进入else了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                    || intercepted;</span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                    target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                handled = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mFirstTouchTarget = next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    predecessor.next = next;</span><br><span class="line">                &#125;</span><br><span class="line">                target.recycle();</span><br><span class="line">                target = next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        target = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TouchTarget next = target.next;</span><br></pre></td></tr></table></figure><p>这里的next为null，最后target = next; 所以这里的while循环只会进入一次。（这里while是为多指触摸准备的，几个手指就会循环几次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里都满足所以handled为true  最后返回 handled。整个Down事件就结束了。    </p><h4><span id="2假设onintercepttouchevent直接拦截这里intercepted为true">2.假设onInterceptTouchEvent直接拦截，这里intercepted为true;</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里整个if语句都 不会进入</p><p><strong>而且这里拦截了以后，ViewGroup的子View就不再往下分发事件（分发是在这个if中for循环中分发的）</strong></p><p>这里mFirstTouchTarget为null，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里的child为null传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以会调用super.dispatchTouchEvent(transformedEvent); 即调用ViewGroup自己的dispatchTouchEvent方法来处理</p><h3><span id="总结">总结：</span></h3><p>当ViewGroup#onInterceptTouchEvent为false时，就会调用子View的dispatchTouchEvent</p><p>当ViewGroup#onInterceptTouchEvent为true时，就会调用自身的dispatchTouchEvent</p><h3><span id="事件action_move">事件：ACTION_MOVE</span></h3><h4><span id="1假设onintercepttouchevent没有拦截">1.假设onInterceptTouchEvent没有拦截</span></h4><p>这里mFirstTouchTarget经过Down事件后不为null,所以intercepted为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入下面if之前boolean alreadyDispatchedToNewTouchTarget = false;</p><p> if (!canceled &amp;&amp; !intercepted) 中直接进入下面 else中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                    || intercepted;</span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                    target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                handled = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mFirstTouchTarget = next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    predecessor.next = next;</span><br><span class="line">                &#125;</span><br><span class="line">                target.recycle();</span><br><span class="line">                target = next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        target = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里while走了else</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">        handled = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted;</span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mFirstTouchTarget = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                predecessor.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            target.recycle();</span><br><span class="line">            target = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    predecessor = target;</span><br><span class="line">    target = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchTransformedTouchEvent方法 中走了<code>handled = child.dispatchTouchEvent(transformedEvent);</code></p><h3><span id="总结">总结：</span></h3><p>当ViewGroup#onInterceptTouchEvent为false时，就会调用子View的dispatchTouchEvent</p><h1><span id="事件冲突">事件冲突</span></h1><h2><span id="viewgrouponintercepttouchevent">ViewGroup#onInterceptTouchEvent</span></h2><p>Viewpager+Listview</p><h2><span id="冲突解决">冲突解决：</span></h2><h3><span id="内部拦截法在子view中解决">内部拦截法（在子View中解决）</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mLastX;</span><br><span class="line"><span class="keyword">int</span> mLastY;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);<span class="comment">//请求不允许中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(deltaX)&gt; Math.abs(deltaY))&#123; <span class="comment">//左右滑</span></span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);<span class="comment">//允许中断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDisallowInterceptTouchEvent</span><span class="params">(<span class="keyword">boolean</span> disallowIntercept)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re already in this state, assume our ancestors are too</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (disallowIntercept) &#123;</span><br><span class="line">        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass it up to our parent</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置了 getParent().requestDisallowInterceptTouchEvent(true)后，disallowIntercept就为true，就不会走父View的onInterceptTouchEvent方法进行拦截，实现子View接收事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是，不能在MotionEvent.ACTION_DOWN方法中设置。</strong></p><p><strong>在进入上面事件判断前会进行状态的初始化。所以在ACTION_DOWN事件中onInterceptTouchEvent肯定会执行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法：在父View中为ACTION_DOWN返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="内部拦截法总结">内部拦截法总结：</span></h3><p><strong>MotionEvent.ACTION_DOWN时</strong>，父View中onInterceptTouchEvent设为false，子View调用getParent().requestDisallowInterceptTouchEvent(true);方法</p><p><strong>MotionEvent.ACTION_MOVE时</strong>，父View中onInterceptTouchEvent设为true，非子View事件时getParent().requestDisallowInterceptTouchEvent(false);方法</p><h3><span id="外部拦截法在父view中解决">外部拦截法（在父View中解决）</span></h3><p>在父View当中进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mLastX;</span><br><span class="line"><span class="keyword">int</span> mLastY;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">           mLastX= (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">           mLastY= (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123; <span class="comment">//左右滑</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#motionevent&quot;&gt;MotionEvent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E6%8B%A6%E6%88%AA%E4%B8%8E%E6%B6%88%E8%B4%B9&quot;&gt;事件分发、拦截与消费&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E6%B5%81%E7%A8%8B&quot;&gt;总流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ontouch%E5%92%8Conclick&quot;&gt;onTouch和onClick&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90&quot;&gt;源码分析：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#viewdispatchtouchevent&quot;&gt;View.dispatchTouchEvent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90&quot;&gt;事件分发源码解析：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6action_down&quot;&gt;事件：ACTION_DOWN&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1%E5%81%87%E8%AE%BEonintercepttouchevent%E6%B2%A1%E6%9C%89%E6%8B%A6%E6%88%AA%E8%BF%99%E9%87%8Cintercepted%E4%B8%BAfalse&quot;&gt;1.假设onInterceptTouchEvent没有拦截，这里intercepted为false;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2%E5%81%87%E8%AE%BEonintercepttouchevent%E7%9B%B4%E6%8E%A5%E6%8B%A6%E6%88%AA%E8%BF%99%E9%87%8Cintercepted%E4%B8%BAtrue&quot;&gt;2.假设onInterceptTouchEvent直接拦截，这里intercepted为true;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93-1&quot;&gt;总结：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6action_move&quot;&gt;事件：ACTION_MOVE&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1%E5%81%87%E8%AE%BEonintercepttouchevent%E6%B2%A1%E6%9C%89%E6%8B%A6%E6%88%AA&quot;&gt;1.假设onInterceptTouchEvent没有拦截&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93-2&quot;&gt;总结：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8B%E4%BB%B6%E5%86%B2%E7%AA%81&quot;&gt;事件冲突&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#viewgrouponintercepttouchevent&quot;&gt;ViewGroup#onInterceptTouchEvent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3&quot;&gt;冲突解决：&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E5%9C%A8%E5%AD%90view%E4%B8%AD%E8%A7%A3%E5%86%B3&quot;&gt;内部拦截法（在子View中解决）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E6%80%BB%E7%BB%93&quot;&gt;内部拦截法总结：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%96%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95%E5%9C%A8%E7%88%B6view%E4%B8%AD%E8%A7%A3%E5%86%B3&quot;&gt;外部拦截法（在父View中解决）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;</summary>
    
    
    
    
    <category term="dispatch" scheme="http://example.com/tags/dispatch/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio开发Gradle插件</title>
    <link href="http://example.com/2020/12/08/gradle/"/>
    <id>http://example.com/2020/12/08/gradle/</id>
    <published>2020-12-08T03:46:53.099Z</published>
    <updated>2021-07-04T11:10:29.898Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="项目结构">项目结构：</span></h2><p>gradlePlugin</p><ul><li>app</li><li><ul><li>src</li></ul></li><li><ul><li>build.gradle</li></ul></li><li>buildSrc</li><li><ul><li>src</li></ul></li><li><ul><li><ul><li>main</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>java</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>com.lis.buildsrc</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li>MyPlugin.java</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li>build.gradle</li></ul></li><li>build.gradle</li></ul><a id="more"></a><h2><span id="简单的gradle插件buildsrc">简单的Gradle插件BuildSrc</span></h2><p>如果开发的插件仅用于当前项目，不需要发布的话，只需要注意两点:</p><ol><li><p>插件的Module名称必须是buildSrc(开头一定要小写)</p></li><li><p>无须resources目录</p><p>build.gradle的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:<span class="string">&#x27;java&#x27;</span></span><br><span class="line">   apply plugin:<span class="string">&#x27;groovy&#x27;</span></span><br><span class="line">   repositories &#123;</span><br><span class="line">       google()</span><br><span class="line">       jcenter()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   dependencies &#123;</span><br><span class="line">       <span class="function">implementation <span class="title">gradleApi</span><span class="params">()</span> <span class="comment">//gradle sdk</span></span></span><br><span class="line"><span class="function">     implementation <span class="title">localGroovy</span><span class="params">()</span> <span class="comment">//groovy sdk</span></span></span><br><span class="line"><span class="function">       implementation &#x27;com.android.tools.build:gradle:3.6.3&#x27;</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">   sourceCompatibility </span>= <span class="string">&quot;1.7&quot;</span></span><br><span class="line">   targetCompatibility = <span class="string">&quot;1.7&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>这里引入groovy sdk和gradle sdk,因为开发Android插件，还需要Android专用的gradle（这里需要使用到google仓库）</p><p>然后我们编写插件，MyPlugin:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin;</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project;</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        Logger logger = project.getLogger();</span><br><span class="line">        logger.error(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;最简单的Gradle插件&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app的build.gradle中添加你的插件  注意：这里不加’  ‘单引号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: com.lis.buildsrc.MyPlugin</span><br></pre></td></tr></table></figure><p>执行：**Build-make Module ‘app’**生成补丁。</p><p><img src="/2020/12/08/gradle/build.png" alt="image-20200724100113259"></p><p>在底部的 <strong>Buid-Build Output</strong>中便可以看到打印日志：</p><p>=====================<br>简单的Gradle插件</p><p>=====================</p><p><img src="/2020/12/08/gradle/buildoutput.png" alt="image-20200724100524283"></p><h2><span id="插件的发布">插件的发布</span></h2><p>如果想复用你的gradle插件，就需要把它发布出去。</p><ul><li>发布到本地仓库</li><li>发布到远程仓库</li></ul><h3><span id="本地仓库">本地仓库</span></h3><p>项目结构：</p><p>gradlePlugin</p><ul><li>app</li><li><ul><li>src</li></ul></li><li><ul><li>build.gradle</li></ul></li><li>buildSrc</li><li><ul><li>src</li></ul></li><li><ul><li><ul><li>main</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>java</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>com.lis.buildsrc</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li>MyPlugin.java</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>resources</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>META-INF.gradle-plugins</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li>com.lis.myplugin.properties</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li>build.gradle</li></ul></li><li>build.gradle</li></ul><p>在buildSrc的main文件夹下添加<strong>resources</strong>文件夹，在该文件夹下添加*<strong>META-INF**<em>，</em></strong>META-INF*<strong>文件夹下添加**<em>gradle-plugins</em></strong></p><p>在**<em>gradle-plugins**</em>中添加com.lis.myplugin.properties  </p><p>这里命名为 <code>com.lis.myplugin.properties</code> ，一定要注意后缀名称，那么使用插件时的名称就是<code>com.lis.myplugin</code>，文件里面的内容填写如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span>=<span class="title">com</span>.<span class="title">lis</span>.<span class="title">buildsrc</span>.<span class="title">MyPlugin</span></span></span><br></pre></td></tr></table></figure><p>这里指定的路径为MyPlugin的类名，即插件的入口类</p><p>buidSrc中的build.gradle，添加maven插件及发布用到的配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span><span class="string">&#x27;java&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span><span class="string">&#x27;groovy&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line">tasks.withType(JavaCompile) &#123; options.encoding = <span class="string">&quot;UTF-8&quot;</span> &#125; <span class="comment">//编码格式</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi() <span class="comment">//gradle sdk</span></span><br><span class="line">    implementation localGroovy() <span class="comment">//groovy sdk</span></span><br><span class="line">    implementation <span class="string">&#x27;com.android.tools.build:gradle:3.6.3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories.mavenDeployer &#123;</span><br><span class="line">        repository(<span class="attr">url:</span> uri(<span class="string">&#x27;../repo&#x27;</span>)) <span class="comment">//仓库的路径，此处是项目根目录下的 repo 的文件夹</span></span><br><span class="line">        pom.groupId = <span class="string">&#x27;com.lis.gradleplugin&#x27;</span>  <span class="comment">//groupId ，自行定义，一般是包名</span></span><br><span class="line">        pom.artifactId = <span class="string">&#x27;myplugin&#x27;</span> <span class="comment">//artifactId ，自行定义</span></span><br><span class="line">        pom.version = <span class="string">&#x27;1.0.0&#x27;</span> <span class="comment">//version 版本号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sourceCompatibility = <span class="string">&quot;1.7&quot;</span></span><br><span class="line">targetCompatibility = <span class="string">&quot;1.7&quot;</span></span><br></pre></td></tr></table></figure><p>同步后在gradle模块内，会出现发布按钮</p><p><img src="/2020/12/08/gradle/upload.png" alt="image-20200724141451792"></p><p>双击<strong>uploadArchives</strong> ,插件就发布到了本地的maven仓库，这里我们是在项目的根目录里，所以会在GradlePlugin下生成repo文件夹及文件</p><p><img src="/2020/12/08/gradle/repo.png" alt="image-20200724141759298"></p><p><strong>使用插件:</strong></p><p>在GradlePlugin根目录的build.gradle中添加本地仓库及插件引用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        <span class="comment">//首先需要配置本地的 maven 仓库地址，这里填写的是相对路径，也可以是全路径</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            url uri(<span class="string">&#x27;./repo&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:3.6.3&#x27;</span></span><br><span class="line">        <span class="comment">//然后，添加依赖的插件，形式是 groupId：artifactId：version</span></span><br><span class="line">        <span class="comment">//这些都是插件发布时，定义的名称</span></span><br><span class="line">        classpath <span class="string">&#x27;com.lis.gradleplugin:myplugin:1.0.0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url uri(<span class="string">&#x27;./repo&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在app的build.gradle里，添加插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.lis.myplugin&#x27;</span><span class="comment">//这里就填写 .properties 文件的名称</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">29</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;29.0.3&quot;</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.lis.gradleplugin&quot;</span></span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">29</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.1.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:1.1.3&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.1&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.2.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apply plugin: &#39;com.lis.myplugin&#39;</code>这里的com.lis.myplugin即我们上面<code>com.lis.myplugin.properties</code>文件的名称</p><p>这就完成了本地仓库的插件使用！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;项目结构：&quot;&gt;&lt;a href=&quot;#项目结构：&quot; class=&quot;headerlink&quot; title=&quot;项目结构：&quot;&gt;&lt;/a&gt;项目结构：&lt;/h2&gt;&lt;p&gt;gradlePlugin&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;app&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;build.gradle&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;buildSrc&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;main&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;java&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;com.lis.buildsrc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;MyPlugin.java&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;build.gradle&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;build.gradle&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/12/08/hello-world/"/>
    <id>http://example.com/2020/12/08/hello-world/</id>
    <published>2020-12-08T03:27:25.134Z</published>
    <updated>2020-12-08T03:27:25.134Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
