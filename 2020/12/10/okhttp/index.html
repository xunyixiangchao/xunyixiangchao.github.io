<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>OkHttp源码分析 - Lis</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Lis"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Lis"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="OkHttp请求流程 高并发请求分发器与线程池 责任链模式请求与响应拦截  目录   OkHttp介绍 简单使用： 使用流程： 调用流程： 分发器： 异步请求工作流程： OkHttp线程池的特点： AsyncCall   同步请求   拦截器： 获取响应： 责任链模式： 拦截器责任链： 五大拦截器功能： 拦截器详情： 一、重试及重定向拦截器 重试 重定向 总结   二、桥接拦截器 总结   三、"><meta property="og:type" content="blog"><meta property="og:title" content="Lis"><meta property="og:url" content="https://xunyixiangchao.github.io/"><meta property="og:site_name" content="Lis"><meta property="og:description" content="OkHttp请求流程 高并发请求分发器与线程池 责任链模式请求与响应拦截  目录   OkHttp介绍 简单使用： 使用流程： 调用流程： 分发器： 异步请求工作流程： OkHttp线程池的特点： AsyncCall   同步请求   拦截器： 获取响应： 责任链模式： 拦截器责任链： 五大拦截器功能： 拦截器详情： 一、重试及重定向拦截器 重试 重定向 总结   二、桥接拦截器 总结   三、"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xunyixiangchao.github.io/source/img/2018.jpg"><meta property="article:published_time" content="2020-12-10T05:26:56.000Z"><meta property="article:modified_time" content="2021-07-04T11:10:49.479Z"><meta property="article:author" content="Lis"><meta property="article:tag" content="OkHttp"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/source/img/2018.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/12/10/okhttp/"},"headline":"Lis","image":["http://example.com/2020/12/10/okhttp/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png","http://example.com/2020/12/10/okhttp/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B7%A5%E4%BD%9C.png","http://example.com/2020/12/10/okhttp/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png","http://example.com/2020/12/10/okhttp/%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8.png","http://example.com/2020/12/10/okhttp/%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE.png","http://example.com/2020/12/10/okhttp/retry.png","http://example.com/2020/12/10/okhttp/%E9%87%8D%E5%AE%9A%E5%90%91.png","http://example.com/2020/12/10/okhttp/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%A3%80%E6%B5%8B.png","http://example.com/2020/12/10/okhttp/%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B.png","http://example.com/2020/12/10/okhttp/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B8%85%E7%90%86.png","http://example.com/2020/12/10/okhttp/%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5.png","http://example.com/2020/12/10/okhttp/100-continue.png"],"datePublished":"2020-12-10T05:26:56.000Z","dateModified":"2021-07-04T11:10:49.479Z","author":{"@type":"Person","name":"John Doe"},"description":"OkHttp请求流程 高并发请求分发器与线程池 责任链模式请求与响应拦截  目录   OkHttp介绍 简单使用： 使用流程： 调用流程： 分发器： 异步请求工作流程： OkHttp线程池的特点： AsyncCall   同步请求   拦截器： 获取响应： 责任链模式： 拦截器责任链： 五大拦截器功能： 拦截器详情： 一、重试及重定向拦截器 重试 重定向 总结   二、桥接拦截器 总结   三、"}</script><link rel="canonical" href="http://example.com/2020/12/10/okhttp/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Lis" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/logo.png" alt="Lis" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://github.com/xunyixiangchao"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/xunyixiangchao"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-12-10  <a class="commentCountImg" href="/2020/12/10/okhttp/#comment-container"><span class="display-none-class">e7299605d4e64bb7e8fce5c37308cb8c</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="e7299605d4e64bb7e8fce5c37308cb8c">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>11.9 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">OkHttp源码分析</h1><div class="content"><ul>
<li>OkHttp请求流程</li>
<li>高并发请求分发器与线程池</li>
<li>责任链模式请求与响应拦截</li>
</ul>
<h2><span id="目录">目录</span></h2><!-- toc -->

<ul>
<li><a href="#okhttp%E4%BB%8B%E7%BB%8D">OkHttp介绍</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">简单使用：</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">使用流程：</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B">调用流程：</a></li>
<li><a href="#%E5%88%86%E5%8F%91%E5%99%A8">分发器：</a><ul>
<li><a href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">异步请求工作流程：</a></li>
<li><a href="#okhttp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%89%B9%E7%82%B9">OkHttp线程池的特点：</a><ul>
<li><a href="#asynccall">AsyncCall</a></li>
</ul>
</li>
<li><a href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82">同步请求</a></li>
</ul>
</li>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器：</a><ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94">获取响应：</a></li>
<li><a href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链模式：</a></li>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE">拦截器责任链：</a></li>
<li><a href="#%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8A%9F%E8%83%BD">五大拦截器功能：</a></li>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%A6%E6%83%85">拦截器详情：</a><ul>
<li><a href="#%E4%B8%80-%E9%87%8D%E8%AF%95%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8">一、重试及重定向拦截器</a><ul>
<li><a href="#%E9%87%8D%E8%AF%95">重试</a></li>
<li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E6%A1%A5%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8">二、桥接拦截器</a><ul>
<li><a href="#%E6%80%BB%E7%BB%93-1">总结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E7%BC%93%E5%AD%98%E6%8B%A6%E6%88%AA%E5%99%A8">三、缓存拦截器</a><ul>
<li><a href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5">缓存策略</a></li>
<li><a href="#%E6%B5%81%E7%A8%8B">流程：</a></li>
<li><a href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B">详细流程：</a></li>
<li><a href="#ps%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4">PS：请求头与响应头</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E8%BF%9E%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8">四、连接拦截器</a><ul>
<li><a href="#%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B">连接流程：</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B8%85%E7%90%86">连接池清理：</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5">代理连接：</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8">五、请求服务器拦截器</a><ul>
<li><a href="#expect-100-continue">Expect: 100-continue</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8">自定义拦截器</a></li>
<li><a href="#okhttp%E6%80%BB%E7%BB%93">OkHttp总结</a></li>
<li><a href="#%E8%A1%A5%E5%85%85-%E4%BB%A3%E7%90%86">补充: 代理</a></li>
</ul>
<!-- tocstop -->

<a id="more"></a>


<h2><span id="okhttp介绍">OkHttp介绍</span></h2><p>由Square公司贡献的一个处理网络请求的开源项目，是目前Android使用最广泛的网络框架，从Android4。4开始HttpURLConnection的底层实现采用的是OkHttp。</p>
<ul>
<li>支持HTTP/2并允许对同一主机的所有请求共享一个套接字</li>
<li>通过连接池，减少了请求延迟</li>
<li>默认通过GZip压缩数据</li>
<li>响应缓存，以免了重复请求的网络</li>
<li>请求失败自动重试主机的其他ip，自动重定向</li>
<li>……</li>
</ul>
<h2><span id="简单使用">简单使用：</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build();</span><br><span class="line">Call call = okHttpClient.newCall(request);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//同步请求</span></span><br><span class="line">    Response execute = call.execute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步请求</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2><span id="使用流程">使用流程：</span></h2><p><img src="/2020/12/10/okhttp/%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="使用流程"></p>
<h2><span id="调用流程">调用流程：</span></h2><p>OkHttp请求过程中最少需要接触OkHttpClient、Request、Call、Response，但是框架内部进行大量的逻辑处理。</p>
<p>所有的逻辑大部分集中在拦截器中，但是在进入拦截器之前还需要依靠分发器来调配请求任务。</p>
<p><strong>分发器：</strong>内部维护队列与线程池，完成请求调配；Dispatcher</p>
<p><strong>拦截器：</strong>五大默认拦截器完成整个请求过程； Interceptors</p>
<h2><span id="分发器">分发器：</span></h2><h3><span id="异步请求工作流程">异步请求工作流程：</span></h3><p><img src="/2020/12/10/okhttp/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%B7%A5%E4%BD%9C.png" alt="异步请求工作"></p>
<ol>
<li>Q：如何决定将请求放入ready还是running?</li>
<li>Q：从running移动到ready的条件是什么？</li>
<li>Q：分发器线程池的工作行为？</li>
</ol>
<p><strong>Dispatcher中</strong></p>
<ol>
<li><p>A:  client.dispatcher().enqueue(new AsyncCall(responseCallback));</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.running队列数小于最大请求数64（正在请求的的数量是有限制的，自己配置分发器时可以修改）</span></span><br><span class="line">    <span class="comment">//2.同一域名正在请求的个数也是有限制的小于5</span></span><br><span class="line">    <span class="comment">//PS:最大同时请求数64，与同一台服务器请求数5</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">//添加到running队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">//将runnable（call）提交到线程池当中</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不符合上面请求就加入到等待队列</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p> A:client.dispatcher().finished(this);-&gt; promoteCalls()移动队列（异步时才有移动队列）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//正在执行队列数</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="comment">//等待队列数得不为空</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall call = i.next();</span><br><span class="line">        <span class="comment">//如果拿到的等待请求host，在请求的列表中已经存在5个</span></span><br><span class="line">        <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            <span class="comment">//等待移除</span></span><br><span class="line">            i.remove();</span><br><span class="line">            <span class="comment">//加入running</span></span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            <span class="comment">//加入线程池</span></span><br><span class="line">            executorService().execute(call);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断正在执行队列数</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>A:ThreadPoolExecutor</li>
</ol>
<p><img src="/2020/12/10/okhttp/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="线程池"></p>
<p>当一个任务通过execute(Runnable)方法添加到线程池时：</p>
<ul>
<li><p>线程数量小于corePoolSize，新建线程(核心)来处理被添加的任务；</p>
</li>
<li><p>线程数量大于等于 corePoolSize，存在空闲线程，使用空闲线程执行新任务；-</p>
</li>
<li><p>线程数量大于等于 corePoolSize，不存在空闲线程，新任务被添加到等待队列，添加成功则等待空闲线程，添加失败：</p>
<ul>
<li>线程数量小于maximumPoolSize，新建线程执行新任务；</li>
<li>线程数量等于maximumPoolSize，拒绝此任务。 </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//corePoolSize:核心线程数  0 不缓存线程，（0和1的表现是一样的）不用时就不占用线程，闲置60就会回收掉</span></span><br><span class="line">        <span class="comment">//maximumPoolSize最大线程数（包括核心）</span></span><br><span class="line">        <span class="comment">//keepAliveTime 缓存60秒</span></span><br><span class="line">        <span class="comment">//workQueue 队列</span></span><br><span class="line">        <span class="comment">//threadFactory 创建一个thread</span></span><br><span class="line">        <span class="comment">//PS:和Executors.newCachedThreadPool();创建的线程池一样</span></span><br><span class="line">        executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>,</span><br><span class="line">                <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SynchronousQueue</strong> implements BlockingQueue  是个阻塞队列</p>
<p>PS:三种阻塞队列</p>
<p><code>ArrayBlockingQueue</code>：基于数组的阻塞队列，初始化需要指定固定大小。</p>
<p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p>
<p><code>SynchronousQueue</code> : 无容量的队列。</p>
<p>往队列中添加元素一定是失败的。</p>
<h3><span id="okhttp线程池的特点">OkHttp线程池的特点：</span></h3><p><strong>OkHttp提交请求，一定是往队列里提交，往队列中添加是一定是失败的，马上新建线程（没有到最大线程数），</strong></p>
<p><strong>不需要等待。获得最大的并发量</strong></p>
<h4><span id="asynccall">AsyncCall</span></h4><p>继承NamedRunnable类实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * run方法其实调用的AsyncCall的execute()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String oldName = Thread.currentThread().getName();</span><br><span class="line">        Thread.currentThread().setName(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            execute();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Thread.currentThread().setName(oldName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="同步请求">同步请求</span></h3><p>加入队列，执行完移除队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同步直接加入running队列，这里的running是同步队列不是异步的</span></span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="拦截器">拦截器：</span></h2><p>默认五大拦截器：（责任链模式）<br><strong>重定向与重试，</strong><br><strong>Header、Body处理，</strong><br><strong>缓存处理，</strong><br><strong>连接处理，</strong><br><strong>服务器通讯</strong><br><img src="/2020/12/10/okhttp/%E4%BA%94%E5%A4%A7%E6%8B%A6%E6%88%AA%E5%99%A8.png" alt="五大拦截器"></p>
<p>请求是顺序的，响应是逆序的</p>
<h3><span id="获取响应">获取响应：</span></h3><p>无论同步还是异常都是通过getResponseWithInterceptorChain 获得请求结果：Response</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 拦截器集合</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//重定向与重试</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">//Header,Body处理</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//缓存处理</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//连接处理</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务器通讯</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">            originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">            client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="责任链模式">责任链模式：</span></h3><p><strong>（一排，最后一位往前一个个传纸条[请求]，传到第一个又一个个往后传[响应]）</strong></p>
<p>为请求创建了一个接收者对象的链，在处理请求的时候执行过滤(各司其职)。</p>
<p>责任链上的处理者负责处理请求，客户只需要将请求发送到责任链即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<h3><span id="拦截器责任链">拦截器责任链：</span></h3><p><img src="/2020/12/10/okhttp/%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE.png" alt="拦截器责任链"></p>
<h3><span id="五大拦截器功能">五大拦截器功能：</span></h3><ol>
<li><p>重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。</p>
</li>
<li><p>桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。</p>
</li>
<li><p>缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。</p>
</li>
<li><p>连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。</p>
</li>
<li><p>请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。</p>
</li>
</ol>
<h3><span id="拦截器详情">拦截器详情：</span></h3><h4><span id="一-重试及重定向拦截器">一、重试及重定向拦截器</span></h4><p>第一个拦截器:<code>RetryAndFollowUpInterceptor</code>，主要就是完成两件事情：重试与重定向。</p>
<h5><span id="重试">重试</span></h5><p>场景：请求超时；域名解析后多个IP，如果一个IP失败了，重试其他IP</p>
<p><img src="/2020/12/10/okhttp/retry.png" alt="重试"></p>
<p><strong>设置是否允许重试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置是否允许重试 默认是允许</span></span><br><span class="line"><span class="keyword">new</span> OkHttpClient().newBuilder().retryOnConnectionFailure(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>RetryAndFollowUpInterceptor</code>中失败时，进入recover方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//todo 请求出现了异常，那么releaseConnection依旧为true。</span></span><br><span class="line">    response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">    <span class="comment">//todo 路由异常，连接未成功，请求还没发出去</span></span><br><span class="line">    <span class="comment">//The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">    <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">    &#125;</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//重试</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">//todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接)</span></span><br><span class="line">    <span class="comment">// ConnectionShutdownException只对HTTP2存在。假定它就是false</span></span><br><span class="line">    <span class="comment">//An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">    <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">    <span class="keyword">if</span> (!recover(e, streamAllocation, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在recover中 获取是否允许重试，如果不允许就抛异常，结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(IOException e, StreamAllocation streamAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;</span><br><span class="line">        streamAllocation.streamFailed(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 1、在配置OkhttpClient是设置了不允许重试（默认允许），则一旦发生请求失败就不再重试</span></span><br><span class="line">        <span class="comment">//The application layer has forbidden retries.</span></span><br><span class="line">        <span class="keyword">if</span> (!client.retryOnConnectionFailure()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 2、由于requestSendStarted只在http2的io异常中为true，先不管http2</span></span><br><span class="line">        <span class="comment">//We can&#x27;t send the request body again.</span></span><br><span class="line">        <span class="keyword">if</span> (requestSendStarted &amp;&amp; userRequest.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 3、判断是不是属于重试的异常</span></span><br><span class="line">        <span class="comment">//This exception is fatal.</span></span><br><span class="line">        <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 4、是不是存在更多的路线 （多个ip，多个代理）</span></span><br><span class="line">        <span class="comment">//No more routes to attempt.</span></span><br><span class="line">        <span class="keyword">if</span> (!streamAllocation.hasMoreRoutes()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For failure recovery, use the same route selector with a new connection.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>重试的异常包括哪些：</strong></p>
<p>在 <code>todo 3</code>的isRecoverable方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRecoverable</span><span class="params">(IOException e, <span class="keyword">boolean</span> requestSendStarted)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.是不是协议异常（code为204,205代表没有响应体，同时响应数据长度还大于0两都冲突，参照CallServerInterceptor中</span></span><br><span class="line">    <span class="comment">// if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0)）</span></span><br><span class="line">    <span class="comment">//：不重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ProtocolException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.socket超时异常 返回true:重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InterruptedIOException) &#123;</span><br><span class="line">        <span class="keyword">return</span> e <span class="keyword">instanceof</span> SocketTimeoutException &amp;&amp; !requestSendStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.//SSL证书不正确  可能证书格式损坏 有问题：不重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLHandshakeException) &#123;</span><br><span class="line">        <span class="comment">// If the problem was a CertificateException from the X509TrustManager,</span></span><br><span class="line">        <span class="comment">// do not retry.</span></span><br><span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> CertificateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.SSL证书校验 ：不重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在socket超时异常时会进行重试，其他异常不再进行重试</p>
<h5><span id="重定向">重定向</span></h5><p>场景：30X，资源改变</p>
<p><img src="/2020/12/10/okhttp/%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="重定向"></p>
<p><strong>最大重定向次数为：20</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 处理3和4xx的一些状态码，如301 302重定向</span></span><br><span class="line">Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line"><span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Request <span class="title">followUpRequest</span><span class="params">(Response userResponse, Route route)</span></span></span><br></pre></td></tr></table></figure>


<p><strong>在followUpRequest中响应码</strong></p>
<hr>
<p>407:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//407 身份校验</span></span><br><span class="line"><span class="keyword">case</span> HTTP_PROXY_AUTH:</span><br><span class="line">    Proxy selectedProxy = route != <span class="keyword">null</span></span><br><span class="line">            ? route.proxy()</span><br><span class="line">            : client.proxy();</span><br><span class="line">    <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">&quot;Received HTTP_PROXY_AUTH (407) code while not &quot;</span> +</span><br><span class="line">                <span class="string">&quot;using proxy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户没有设置就返回null,重定向就结束了</span></span><br><span class="line">    <span class="keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);</span><br></pre></td></tr></table></figure>

<p>用户设置身份校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置身份校验的代理</span></span><br><span class="line"><span class="keyword">new</span> OkHttpClient.Builder().proxy(<span class="keyword">new</span> Proxy(Proxy.Type.HTTP, <span class="keyword">new</span> InetSocketAddress(</span><br><span class="line">        <span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span></span><br><span class="line">)))</span><br><span class="line"><span class="comment">//设置身份校验(默认不设置这个）</span></span><br><span class="line">.proxyAuthenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//参照Authenticator接口注释</span></span><br><span class="line">        <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">                .header(<span class="string">&quot;Proxy-Authorization&quot;</span>, Credentials.basic(<span class="string">&quot;用户名&quot;</span>,<span class="string">&quot;密码&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure>
<p>401:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 401 需要身份验证 有些服务器接口需要验证使用者身份 在请求头中添加 “Authorization”</span></span><br><span class="line"><span class="keyword">case</span> HTTP_UNAUTHORIZED:</span><br><span class="line">    <span class="comment">//类似407身份验证，设置authenticator()</span></span><br><span class="line">    <span class="keyword">return</span> client.authenticator().authenticate(route, userResponse);</span><br></pre></td></tr></table></figure>

<p>重定向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 308 永久重定向</span></span><br><span class="line"><span class="comment">// 307 临时重定向</span></span><br><span class="line"><span class="keyword">case</span> HTTP_PERM_REDIRECT:</span><br><span class="line"><span class="keyword">case</span> HTTP_TEMP_REDIRECT:</span><br><span class="line">    <span class="comment">// 如果请求方式不是GET或者HEAD，框架不会自动重定向请求</span></span><br><span class="line">    <span class="keyword">if</span> (!method.equals(<span class="string">&quot;GET&quot;</span>) &amp;&amp; !method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 300 301 302 303</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MULT_CHOICE:</span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_PERM:</span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_TEMP:</span><br><span class="line"><span class="keyword">case</span> HTTP_SEE_OTHER:</span><br><span class="line">    <span class="comment">// 如果用户不允许重定向，那就返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从响应头取出location</span></span><br><span class="line">    String location = userResponse.header(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 根据location 配置新的请求 url</span></span><br><span class="line">    HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line">    <span class="comment">// 如果为null，说明协议有问题，取不出来HttpUrl，那就返回null，不进行重定向</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果重定向在http到https之间切换，需要检查用户是不是允许(默认允许)</span></span><br><span class="line">    <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">    <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重定向请求中 只要不是 PROPFIND 请求，无论是POST还是其他的方法都要改为GET请求方式，</span></span><br><span class="line"><span class="comment">     *  即只有 PROPFIND 请求才能有请求体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//请求不是get与head</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">        <span class="comment">// 除了 PROPFIND 请求之外都改成GET请求</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">            requestBuilder.method(<span class="string">&quot;GET&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</span><br><span class="line">            requestBuilder.method(method, requestBody);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是 PROPFIND 的请求，把请求头中关于请求体的数据删掉</span></span><br><span class="line">        <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在跨主机重定向时，删除身份验证请求头</span></span><br><span class="line">    <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestBuilder.url(url).build();</span><br></pre></td></tr></table></figure>

<p>408请求超时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 408 客户端请求超时 </span></span><br><span class="line"><span class="keyword">case</span> HTTP_CLIENT_TIMEOUT:</span><br><span class="line">    <span class="comment">// 408 算是连接失败了，所以判断用户是不是允许重试</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// UnrepeatableRequestBody实际并没发现有其他地方用到</span></span><br><span class="line">    <span class="keyword">if</span> (userResponse.request().body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是本身这次的响应就是重新请求的产物同时上一次之所以重请求还是因为408，那我们这次不再重请求了</span></span><br><span class="line">    <span class="keyword">if</span> (userResponse.priorResponse() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果服务器告诉我们了 Retry-After 多久后重试，那框架不管了。</span></span><br><span class="line">    <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userResponse.request();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>503:</p>
<p>// 503 服务不可用 和408差不多，但是只在服务器告诉你 Retry-After：0（意思就是立即重试） 才重请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> HTTP_UNAVAILABLE:</span><br><span class="line">    <span class="keyword">if</span> (userResponse.priorResponse() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> userResponse.request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>重定向总结：服务器返回300 301 302 303需要重定向，会获取返回头的Location中的新地址。</p>
<p>如果此方法followUpRequest返回空，那就表示不需要再重定向了，直接返回响应；但是如果返回非空，那就要重新请求返回的<code>Request</code>，但是需要注意的是，我们的<code>followup</code>在拦截器中定义的最大次数为<strong>20</strong>次。</p>
<h5><span id="总结">总结</span></h5><p>本拦截器是整个责任链中的第一个，这意味着它会是首次接触到<code>Request</code>与最后接收到<code>Response</code>的角色，在这个拦截器中主要功能就是判断是否需要重试与重定向。</p>
<p>重试的前提是出现了<code>RouteException</code>或者<code>IOException</code>。一但在后续的拦截器执行过程中出现这两个异常，就会通过<code>recover</code>方法进行判断是否进行连接重试。</p>
<p>重定向发生在重试的判定之后，如果不满足重试的条件，还需要进一步调用<code>followUpRequest</code>根据<code>Response</code> 的响应码(当然，如果直接请求失败，<code>Response</code>都不存在就会抛出异常)。<code>followup</code>最大发生20次。</p>
<h4><span id="二-桥接拦截器">二、桥接拦截器</span></h4><p>两大作用：补全请求头，处理响应（保存cookie，GzipSource）</p>
<p>补全请求与响应后处理</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Content-Type</code></td>
<td>请求体类型,如：<code>application/x-www-form-urlencoded</code></td>
</tr>
<tr>
<td><code>Content-Length</code>/<code>Transfer-Encoding</code></td>
<td>请求体解析方式</td>
</tr>
<tr>
<td><code>Host</code></td>
<td>请求的主机站点</td>
</tr>
<tr>
<td><code>Connection: Keep-Alive</code></td>
<td>保持长连接</td>
</tr>
<tr>
<td><code>Accept-Encoding: gzip</code></td>
<td>接受响应支持gzip压缩</td>
</tr>
<tr>
<td><code>Cookie</code></td>
<td>cookie身份辨别</td>
</tr>
<tr>
<td><code>User-Agent</code></td>
<td>请求的用户信息，如:操作系统、浏览器等</td>
</tr>
</tbody></table>
<p>得到响应：<br>    1、读取Set-Cookie响应头并调用接口告知用户，在下次请求则会读取对应的数据设置进入请求头，默认CookieJar无实现；</p>
<p>​    2、响应头Content-Encoding为gzip，使用GzipSource包装便于解析。</p>
<h5><span id="总结">总结</span></h5><p>桥接拦截器的执行逻辑主要就是以下几点</p>
<p>对用户构建的<code>Request</code>进行添加或者删除相关头部信息，以转化成能够真正进行网络请求的<code>Request</code><br>将符合网络请求规范的Request交给下一个拦截器处理，并获取<code>Response</code><br>如果响应体经过了GZIP压缩，那就需要解压，再构建成用户可用的<code>Response</code>并返回</p>
<h4><span id="三-缓存拦截器">三、缓存拦截器</span></h4><p><code>CacheInterceptor</code>，在发出请求前，判断是否命中缓存。如果命中则可以不请求，直接使用缓存的响应。 (只会存在Get请求的缓存)</p>
<p>步骤为:</p>
<p>1、从缓存中获得对应请求的响应缓存</p>
<p>2、创建<code>CacheStrategy</code> ,创建时会判断是否能够使用缓存，在<code>CacheStrategy</code> 中存在两个成员:<code>networkRequest</code>与<code>cacheResponse</code>。他们的组合如下:</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Null</td>
<td>Not Null</td>
<td>直接使用缓存</td>
</tr>
<tr>
<td>Not Null</td>
<td>Null</td>
<td>向服务器发起请求</td>
</tr>
<tr>
<td>Null</td>
<td>Null</td>
<td>直接gg，okhttp直接返回504</td>
</tr>
<tr>
<td>Not Null</td>
<td>Not Null</td>
<td>发起请求，若得到响应为304(无修改)，则更新缓存响应并返回</td>
</tr>
</tbody></table>
<p>即：networkRequest存在则优先发起网络请求，否则使用cacheResponse缓存，若都不存在则请求失败！</p>
<p>3、交给下一个责任链继续处理</p>
<p>4、后续工作，返回304则用缓存的响应；否则使用网络响应并缓存本次响应（只缓存Get请求的响应）</p>
<p>缓存拦截器的工作说起来比较简单，但是具体的实现，需要处理的内容很多。在缓存拦截器中判断是否可以使用缓存，或是请求服务器都是通过<code>CacheStrategy</code>判断。</p>
<h5><span id="缓存策略">缓存策略</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 缓存策略:根据各种条件(请求头)组成 请求与缓存</span></span><br><span class="line">CacheStrategy strategy =</span><br><span class="line">        <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheStrategy candidate = getCandidate();</span><br><span class="line">    <span class="comment">//todo 如果可以使用缓存，那networkRequest必定为null；指定了只使用缓存但是networkRequest又不为null，冲突。那就gg(拦截器返回504)</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/10/okhttp/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%A3%80%E6%B5%8B.png" alt="缓存策略-缓存检测"></p>
<h5><span id="流程">流程：</span></h5><ol>
<li><p>没有缓存，就进行网络请求</p>
</li>
<li><p>如果是Https请求，缓存中没有保存握手信息，发起网络请求</p>
</li>
<li><p>通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求（isCacheable方法）：不允许用</p>
</li>
<li><p>如果请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性（用户配置不进行缓存）：不想用</p>
</li>
<li><p>如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存</p>
</li>
<li><p>响应的缓存有效期</p>
<p>这一步为进一步根据缓存响应中的一些信息判定缓存是否处于有效期内。如果满足：</p>
<blockquote>
<p><strong>缓存存活时间 &lt; 缓存新鲜度 - 缓存最小新鲜度 + 过期后继续使用时长</strong></p>
</blockquote>
<p> 代表可以使用缓存。其中新鲜度可以理解为有效时间，而这里的 <strong>“缓存新鲜度-缓存最小新鲜度”</strong> 就代表了缓存真正有效的时间。</p>
</li>
<li><p>缓存过期处理</p>
<p>如果继续执行，表示缓存已经过期无法使用。此时我们判定缓存的响应中如果存在<code>Etag</code>，则使用<code>If-None-Match</code>交给服务器进行验证；如果存在<code>Last-Modified</code>或者<code>Data</code>，则使用<code>If-Modified-Since</code>交给服务器验证。服务器如果无修改则会返回304，这时候注意：</p>
<p><strong>由于是缓存过期而发起的请求(与第4个判断用户的主动设置不同)，如果服务器返回304，那框架会自动更新缓存，所以此时<code>CacheStrategy</code>既包含<code>networkRequest</code>也包含<code>cacheResponse</code></strong></p>
</li>
</ol>
<h5><span id="详细流程">详细流程：</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// No cached response.</span></span><br><span class="line">    <span class="comment">//todo 1、没有缓存,进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 2、https请求，但是没有握手信息,进行网络请求</span></span><br><span class="line">    <span class="comment">// OkHttp会保存ssl握手信息 handshake,如果这次发起了https请求，</span></span><br><span class="line">    <span class="comment">// 但是缓存的响应信息中没有握手信息，发起网络请求</span></span><br><span class="line">    <span class="comment">//Drop the cached response if it&#x27;s missing a required handshake.</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 3、主要是通过响应码以及头部缓存控制字段判断响应能不能缓存，不能缓存那就进行网络请求</span></span><br><span class="line">    <span class="comment">//If this response shouldn&#x27;t have been stored, it should never be used</span></span><br><span class="line">    <span class="comment">//as a response source. This check should be redundant as long as the</span></span><br><span class="line">    <span class="comment">//persistence store is well-behaved and the rules are constant.</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheControl requestCaching = request.cacheControl();</span><br><span class="line">    <span class="comment">//todo 4、如果 请求包含：CacheControl:no-cache 需要与服务器验证缓存有效性</span></span><br><span class="line">    <span class="comment">// 或者请求头包含 If-Modified-Since：时间 值为lastModified或者data 如果服务器没有在该头部指定的时间之后修改了请求的数据，服务器返回304(无修改)</span></span><br><span class="line">    <span class="comment">// 或者请求头包含 If-None-Match：值就是Etag（资源标记）服务器将其与存在服务端的Etag值进行比较；如果匹配，返回304</span></span><br><span class="line">    <span class="comment">// 请求头中只要存在三者中任意一个，进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 5、如果缓存响应中存在 Cache-Control:immutable 响应内容将一直不会改变,可以使用缓存</span></span><br><span class="line">    CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">    <span class="keyword">if</span> (responseCaching.immutable()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, cacheResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 6、根据 缓存响应的 控制缓存的响应头 判断是否允许使用缓存</span></span><br><span class="line">    <span class="comment">// 6.1、获得缓存的响应从创建到现在的时间</span></span><br><span class="line">    <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.2、获取这个响应有效缓存的时长</span></span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//todo 如果请求中指定了 max-age 表示指定了能拿的缓存有效时长，就需要综合响应有效缓存时长与请求能拿缓存的时长，获得最小的能够使用响应缓存的时长</span></span><br><span class="line">        freshMillis = Math.min(freshMillis,</span><br><span class="line">                SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.3 请求包含  Cache-Control:min-fresh=[秒]  能够使用还未过指定时间的缓存 （请求认为的缓存有效时间）</span></span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.4</span></span><br><span class="line">    <span class="comment">//  6.4.1、Cache-Control:must-revalidate 可缓存但必须再向源服务器进行确认</span></span><br><span class="line">    <span class="comment">//  6.4.2、Cache-Control:max-stale=[秒] 缓存过期后还能使用指定的时长  如果未指定多少秒，则表示无论过期多长时间都可以；如果指定了，则只要是指定时间内就能使用缓存</span></span><br><span class="line">    <span class="comment">// 前者会忽略后者，所以判断了不必须向服务器确认，再获得请求头中的max-stale</span></span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 6.5 不需要与服务器验证有效性 &amp;&amp; 响应存在的时间+请求认为的缓存有效时间 小于 缓存有效时长+过期后还可以使用的时间</span></span><br><span class="line">    <span class="comment">// 允许使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="comment">//todo 如果已过期，但未超过 过期后继续使用时长，那还可以继续使用，只用添加相应的头部字段</span></span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//todo 如果缓存已超过一天并且响应中没有设置过期时间也需要添加警告</span></span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a condition to add to the request. If the condition is satisfied, the</span></span><br><span class="line">    <span class="comment">// response body</span></span><br><span class="line">    <span class="comment">// will not be transmitted.</span></span><br><span class="line">    <span class="comment">//todo 7、缓存过期了</span></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-None-Match&quot;</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 如果设置了 If-None-Match/If-Modified-Since 服务器是可能返回304(无修改)的,使用缓存的响应体</span></span><br><span class="line">    Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">    Request conditionalRequest = request.newBuilder()</span><br><span class="line">            .headers(conditionalRequestHeaders.build())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="ps请求头与响应头">PS：请求头与响应头</span></h5><table>
<thead>
<tr>
<th>响应头</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>Date</td>
<td>消息发送的时间</td>
<td>Date: Sat, 18 Nov 2028 06:17:41 GMT</td>
</tr>
<tr>
<td>Expires</td>
<td>资源过期的时间</td>
<td>Expires: Sat, 18 Nov 2028 06:17:41 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源最后修改时间</td>
<td>Last-Modified: Fri, 22 Jul 2016 02:57:17 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>资源在服务器的唯一标识</td>
<td>ETag: “16df0-5383097a03d40”</td>
</tr>
<tr>
<td>Age</td>
<td>服务器用缓存响应请求，该缓存从产生到现在经过多长时间(秒)</td>
<td>Age: 3825683</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>If-Modified-Since</code></td>
<td>服务器没有在指定的时间后修改请求对应资源,返回304(无修改)</td>
<td>If-Modified-Since: Fri, 22 Jul 2016 02:57:17 GMT</td>
</tr>
<tr>
<td><code>If-None-Match</code></td>
<td>服务器将其与请求对应资源的<code>Etag</code>值进行比较，匹配返回304</td>
<td>If-None-Match: “16df0-5383097a03d40”</td>
</tr>
<tr>
<td><code>Cache-Control</code></td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>其中<code>Cache-Control</code>可以在请求头存在，也能在响应头存在，对应的value可以设置多种组合：</p>
<ol>
<li><code>max-age=[秒]</code> ：资源最大有效时间;</li>
<li><code>public</code> ：表明该资源可以被任何用户缓存，比如客户端，代理服务器等都可以缓存资源;</li>
<li><code>private</code>：表明该资源只能被单个用户缓存，默认是private。</li>
<li><code>no-store</code>：资源不允许被缓存</li>
<li><code>no-cache</code>：(请求)不使用缓存</li>
<li><code>immutable</code>：(响应)资源不会改变</li>
<li> <code> min-fresh=[秒]</code>：(请求)缓存最小新鲜度(用户认为这个缓存有效的时长)</li>
<li><code>must-revalidate</code>：(响应)不允许使用过期缓存</li>
<li><code>max-stale=[秒]</code>：(请求)缓存过期后多久内仍然有效</li>
</ol>
<blockquote>
<p>假设存在max-age=100，min-fresh=20。这代表了用户认为这个缓存的响应，从服务器创建响应 到 能够缓存使用的时间为100-20=80s。但是如果max-stale=100。这代表了缓存有效时间80s过后，仍然允许使用100s，可以看成缓存有效时长为180s。</p>
</blockquote>
<h4><span id="四-连接拦截器">四、连接拦截器</span></h4><h5><span id="连接流程">连接流程：</span></h5><p><img src="/2020/12/10/okhttp/%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B.png" alt="连接流程"></p>
<p><code>ConnectInterceptor</code>，打开与目标服务器的连接，并执行下一个拦截器。它简短的可以直接完整贴在这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 首先我们看到的<code>StreamAllocation</code>这个对象是在第一个拦截器：重定向拦截器创建的，但是真正使用的地方却在这里。</p>
<p>*”当一个请求发出，需要建立连接，连接建立后需要使用流用来读写数据”*；而这个StreamAllocation就是协调请求、连接与数据流三者之间的关系，它负责为一次请求寻找连接，然后获得流来实现网络通信。</p>
<p>这里使用的<code>newStream</code>方法实际上就是去查找或者建立一个与请求主机有效的连接，返回的<code>HttpCodec</code>中包含了输入输出流，并且封装了对HTTP请求报文的编码与解码，直接使用它就能够与请求主机完成HTTP通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//todo  找到一个健康的连接</span></span><br><span class="line">        RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">                writeTimeout, pingIntervalMillis, connectionRetryEnabled,</span><br><span class="line">                doExtensiveHealthChecks);</span><br><span class="line">        <span class="comment">//todo 利用连接实例化流HttpCodec对象，如果是HTTP/2返回Http2Codec，否则返回Http1Codec</span></span><br><span class="line">        HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            codec = resultCodec;</span><br><span class="line">            <span class="keyword">return</span> resultCodec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>StreamAllocation</code>中简单来说就是维护连接：<code>RealConnection</code>——封装了Socket与一个Socket连接池。可复用的<code>RealConnection</code></strong></p>
<p>findHealthyConnection方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> connectionRetryEnabled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//todo 找到一个连接</span></span><br><span class="line">        RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">                pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 如果这个连接是新建立的，那肯定是健康的，直接返回</span></span><br><span class="line">        <span class="comment">//If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 如果不是新创建的，需要检查是否健康</span></span><br><span class="line">        <span class="comment">//Do a (potentially slow) check to confirm that the pooled connection is still good.</span></span><br><span class="line">      <span class="comment">// If it</span></span><br><span class="line">        <span class="comment">// isn&#x27;t, take it out of the pool and start again.</span></span><br><span class="line">        <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">            <span class="comment">//todo 不健康 关闭连接，释放Socket,从连接池移除</span></span><br><span class="line">            <span class="comment">// 继续下次寻找连接操作</span></span><br><span class="line">            noNewStreams();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findConnection方法中的</p>
<ul>
<li>尝试从连接池获取连接，如果有可复用的连接,会给第三个参数 this的connection赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>调到了（ConnectionPool）connectionPool.get方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class="line">      streamAllocation.acquire(connection, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isEligible判断是否能够复用</p>
<ul>
<li>使用http1.1就不能用</li>
<li>如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口</li>
<li>都相同那就可以复用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligible</span><span class="params">(Address address, <span class="meta">@Nullable</span> Route route)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If this connection is not accepting new streams, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 实际上就是在使用http1.1就不能用</span></span><br><span class="line">    <span class="keyword">if</span> (allocations.size() &gt;= allocationLimit || noNewStreams) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the non-host fields of the address don&#x27;t overlap, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 如果地址不同就不能复用（Address.equalsNonHost）DNS、代理、SSL证书、服务器域名、端口（域名没有判断，所以下面马上判断）</span></span><br><span class="line">    <span class="keyword">if</span> (!Internal.instance.equalsNonHost(<span class="keyword">this</span>.route.address(), address)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the host exactly matches, we&#x27;re done: this connection can carry the address.</span></span><br><span class="line">    <span class="comment">//todo: 都相同那就可以复用了</span></span><br><span class="line">    <span class="keyword">if</span> (address.url().host().equals(<span class="keyword">this</span>.route().address().url().host())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// This connection is a perfect match.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we don&#x27;t have a hostname match. But we still be able to carry the</span></span><br><span class="line">  <span class="comment">// request if</span></span><br><span class="line">    <span class="comment">// our connection coalescing requirements are met. See also:</span></span><br><span class="line">    <span class="comment">// https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding</span></span><br><span class="line">    <span class="comment">// https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. This connection must be HTTP/2.</span></span><br><span class="line">    <span class="keyword">if</span> (http2Connection == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. The routes must share an IP address. This requires us to have a DNS address for both</span></span><br><span class="line">    <span class="comment">// hosts, which only happens after route planning. We can&#x27;t coalesce connections that use a</span></span><br><span class="line">    <span class="comment">// proxy, since proxies don&#x27;t tell us the origin server&#x27;s IP address.</span></span><br><span class="line">    <span class="keyword">if</span> (route == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.route.socketAddress().equals(route.socketAddress())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. This connection&#x27;s server certificate&#x27;s must cover the new host.</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!supportsUrl(address.url())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Certificate pinning must match the host.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        address.certificatePinner().check(address.url().host(), handshake().peerCertificates());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SSLPeerUnverifiedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// The caller&#x27;s address can be carried by this connection.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没找到，必须新建一个连接了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">            selectedRoute = routeSelection.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a connection and assign it to this allocation immediately. This makes</span></span><br><span class="line">      <span class="comment">// it possible</span></span><br><span class="line">        <span class="comment">// for an asynchronous cancel() to interrupt the handshake we&#x27;re about to do.</span></span><br><span class="line">        route = selectedRoute;</span><br><span class="line">        refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">        result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">        acquire(result, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="连接池清理">连接池清理：</span></h5><p><img src="/2020/12/10/okhttp/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B8%85%E7%90%86.png" alt="连接池清理"></p>
<p>findConnection方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 将新创建的连接放到连接池中</span></span><br><span class="line">Internal.instance.put(connectionPool, result);</span><br></pre></td></tr></table></figure>

<p>调的是ConnectionPool.put方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">    cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//启动清理</span></span><br><span class="line">    executor.execute(cleanupRunnable);</span><br><span class="line">  &#125;</span><br><span class="line">  connections.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//todo:最快多久后需要清理</span></span><br><span class="line">      <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">      <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//todo:因为等待是纳秒级，wait方法可以接收纳秒级控制，但是把毫秒与纳秒分开</span></span><br><span class="line">        <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">        waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//todo:参数多一个纳秒，控制更加精确</span></span><br><span class="line">            ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">  RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">      <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        inUseConnectionCount++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      idleConnectionCount++;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 获得这个连接闲置多久</span></span><br><span class="line">      <span class="comment">// If the connection is ready to be evicted, we&#x27;re done.</span></span><br><span class="line">      <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">      <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">        longestIdleDurationNs = idleDurationNs;</span><br><span class="line">        longestIdleConnection = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超过保活时间（5分钟）或者池内数量超过了5个，马上移除，然后返回0，表示不等待，马上再次检查</span></span><br><span class="line">    <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">        || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class="line">      <span class="comment">// of the synchronized block).</span></span><br><span class="line">      connections.remove(longestIdleConnection);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// A connection will be ready to evict soon.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 池内存在闲置连接，就等待，保活时间（5分钟）-最长闲置时间=还能闲置多久 再检查</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// All connections are in use. It&#x27;ll be at least the keep alive duration &#x27;til we run again.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 有使用中的连接就等待5分钟，再检查</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No connections, idle or in use.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 都不满足，可能池内没任何连接，直接停止清理（put后再次启用）</span></span><br><span class="line">      cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5><span id="代理连接">代理连接：</span></h5><p><img src="/2020/12/10/okhttp/%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5.png" alt="代理连接"></p>
<p>findConnection中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 实际上就是创建socket连接，但是要注意的是如果存在http代理的情况</span></span><br><span class="line">result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br></pre></td></tr></table></figure>

<p>RealConnection.connect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">    <span class="comment">//todo http隧道代理</span></span><br><span class="line">    connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">    <span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We were unable to connect the tunnel but properly closed down our</span></span><br><span class="line">      <span class="comment">// resources.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//todo 创建socket连接</span></span><br><span class="line">    connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有http代理先设置代理头，最终都用调用connectSocket方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTunnel</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                           EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request tunnelRequest = createTunnelRequest();</span><br><span class="line">    HttpUrl url = tunnelRequest.url();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_TUNNEL_ATTEMPTS; i++) &#123;</span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">        tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tunnelRequest == <span class="keyword">null</span>) <span class="keyword">break</span>; <span class="comment">// Tunnel successfully created.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The proxy decided to close the connection after an auth challenge. We need to</span></span><br><span class="line">      <span class="comment">// create a new</span></span><br><span class="line">        <span class="comment">// connection, but this time with the auth credentials.</span></span><br><span class="line">        closeQuietly(rawSocket);</span><br><span class="line">        rawSocket = <span class="keyword">null</span>;</span><br><span class="line">        sink = <span class="keyword">null</span>;</span><br><span class="line">        source = <span class="keyword">null</span>;</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">createTunnelRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(route.address().url())</span><br><span class="line">            .header(<span class="string">&quot;Host&quot;</span>, Util.hostHeader(route.address().url(), <span class="keyword">true</span>))</span><br><span class="line">            .header(<span class="string">&quot;Proxy-Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>) <span class="comment">// For HTTP/1.0 proxies like Squid.</span></span><br><span class="line">            .header(<span class="string">&quot;User-Agent&quot;</span>, Version.userAgent())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * todo:创建socket连接</span></span><br><span class="line"><span class="comment"> * Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                           EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Proxy proxy = route.proxy();</span><br><span class="line">    Address address = route.address();</span><br><span class="line">    <span class="comment">//todo:没有代理直接new一个Socket（），有代理就创建一个带代理参数的socket</span></span><br><span class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">            ? address.socketFactory().createSocket()</span><br><span class="line">            : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line"></span><br><span class="line">    eventListener.connectStart(call, route.socketAddress(), proxy);</span><br><span class="line">    rawSocket.setSoTimeout(readTimeout);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> socket.connect</span></span><br><span class="line">        Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">        ConnectException ce =</span><br><span class="line">                <span class="keyword">new</span> ConnectException(<span class="string">&quot;Failed to connect to &quot;</span> + route.socketAddress());</span><br><span class="line">        ce.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0</span></span><br><span class="line">    <span class="comment">// More details:</span></span><br><span class="line">    <span class="comment">// https://github.com/square/okhttp/issues/3245</span></span><br><span class="line">    <span class="comment">// https://android-review.googlesource.com/#/c/271775/</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">        sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">        <span class="keyword">if</span> (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(npe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="五-请求服务器拦截器">五、请求服务器拦截器</span></h4><h5><span id="expect-100-continue">Expect: 100-continue</span></h5><p>一般出现于上传大容量请求体或者需要验证。代表了先询问服务器是否原因接收发送请求体数据。（先只发送请求头）</p>
<p>OkHttp的做法：<br>如果服务器允许则返回100，客户端继续发送请求体；<br>如果服务器不允许则直接返回给用户。</p>
<p>同时服务器也可能会忽略此请求头，一直无法读取应答，此时抛出超时异常。</p>
<p><img src="/2020/12/10/okhttp/100-continue.png" alt="100-continue"></p>
<p><code>CallServerInterceptor</code>，利用<code>HttpCodec</code>发出请求到服务器并且解析生成<code>Response</code>。</p>
<p>首先调用<code>httpCodec.writeRequestHeaders(request);</code> 将请求头写入到缓存中(直到调用<code>flushRequest()</code>才真正发送给服务器)。然后马上进行第一个逻辑判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallServerInterceptor</span><span class="params">(<span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">        <span class="comment">//todo:拼接请求的数据</span></span><br><span class="line">        httpCodec.writeRequestHeaders(request);</span><br><span class="line">        realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line"></span><br><span class="line">        Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//todo:如果没有请求体或者不是post跳过</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span></span><br><span class="line">            <span class="comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span></span><br><span class="line">            <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">            <span class="comment">// todo: 如果是post请求，并包含了100-continue,不发请求体，读服务器的响应</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equalsIgnoreCase(request.header(<span class="string">&quot;Expect&quot;</span>))) &#123;</span><br><span class="line">                <span class="comment">// todo: 发送请求头</span></span><br><span class="line">                httpCodec.flushRequest();</span><br><span class="line">                realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">                responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//服务返回100，responseBuilder会置为null</span></span><br><span class="line">            <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">                realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">                <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">                CountingSink requestBodyOut =</span><br><span class="line">                        <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                <span class="comment">//todo：写入请求体</span></span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">                realChain.eventListener()</span><br><span class="line">                        .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">                <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1</span></span><br><span class="line">              <span class="comment">// connection</span></span><br><span class="line">                <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request</span></span><br><span class="line">              <span class="comment">// body to</span></span><br><span class="line">                <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        httpCodec.finishRequest();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 读取服务器响应</span></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = responseBuilder</span><br><span class="line">                .request(request)</span><br><span class="line">                .handshake(streamAllocation.connection().handshake())</span><br><span class="line">                .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> code = response.code();</span><br><span class="line">        <span class="comment">// todo: 服务器允许继续发送响应体</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">            <span class="comment">// try again to read the actual response</span></span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            response = responseBuilder</span><br><span class="line">                    .request(request)</span><br><span class="line">                    .handshake(streamAllocation.connection().handshake())</span><br><span class="line">                    .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            code = response.code();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        realChain.eventListener()</span><br><span class="line">                .responseHeadersEnd(realChain.call(), response);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">            <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null</span></span><br><span class="line">          <span class="comment">// response body.</span></span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(httpCodec.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.request().header(<span class="string">&quot;Connection&quot;</span>))</span><br><span class="line">                || <span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.header(<span class="string">&quot;Connection&quot;</span>))) &#123;</span><br><span class="line">            streamAllocation.noNewStreams();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">                    <span class="string">&quot;HTTP &quot;</span> + code + <span class="string">&quot; had non-zero Content-Length: &quot;</span> + response.body().contentLength());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSink</span> <span class="keyword">extends</span> <span class="title">ForwardingSink</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> successfulCount;</span><br><span class="line"></span><br><span class="line">        CountingSink(Sink delegate) &#123;</span><br><span class="line">            <span class="keyword">super</span>(delegate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Buffer source, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.write(source, byteCount);</span><br><span class="line">            successfulCount += byteCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个if都和一个请求头有关： <code>Expect: 100-continue</code>。这个请求头代表了在发送请求体之前需要和服务器确定是否愿意接受客户端发送的请求体。所以<code>permitsRequestBody</code>判断为是否会携带请求体的方式(POST)，如果命中if，则会先给服务器发起一次查询是否愿意接收请求体，这时候如果服务器愿意会响应100(没有响应体，responseBuilder 即为nul)。这时候才能够继续发送剩余请求数据。</p>
<p>但是如果服务器不同意接受请求体，那么我们就需要标记该连接不能再被复用，调用<code>noNewStreams()</code>关闭相关的Socket。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 读取服务器响应</span></span><br><span class="line"><span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(streamAllocation.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>这时<code>responseBuilder</code>的情况即为：</p>
<p>1、POST方式请求，请求头中包含<code>Expect</code>，服务器允许接受请求体，并且已经发出了请求体，<code>responseBuilder</code>为null;</p>
<p>2、POST方式请求，请求头中包含<code>Expect</code>，服务器不允许接受请求体，<code>responseBuilder</code>不为null</p>
<p>3、POST方式请求，未包含<code>Expect</code>，直接发出请求体，<code>responseBuilder</code>为null;</p>
<p>4、POST方式请求，没有请求体，<code>responseBuilder</code>为null;</p>
<p>5、GET方式请求，<code>responseBuilder</code>为null;</p>
<p>对应上面的5种情况，读取响应头并且组成响应<code>Response</code>，注意：此<code>Response</code>没有响应体。同时需要注意的是，如果服务器接受 <code>Expect: 100-continue</code>这是不是意味着我们发起了两次<code>Request</code>？那此时的响应头是第一次查询服务器是否支持接受请求体的，而不是真正的请求对应的结果响应。</p>
<p>所以 如果响应是100，这代表了是请求<code>Expect: 100-continue</code>成功的响应，需要马上再次读取一份响应头，这才是真正的请求对应结果响应头。</p>
<p>最后：</p>
<p><code>forWebSocket</code>代表websocket的请求，我们直接进入else，这里就是读取响应体数据。然后判断请求和服务器是不是都希望长连接，一旦有一方指明<code>close</code>，那么就需要关闭<code>socket</code>。而如果服务器返回204/205，一般情况而言不会存在这些返回码，但是一旦出现这意味着没有响应体，但是解析到的响应头中包含<code>Content-Lenght</code>且不为0，这表响应体的数据字节长度。此时出现了冲突，直接抛出协议异常！</p>
<h5><span id="总结">总结</span></h5><p>在这个拦截器中就是完成HTTP协议报文的封装与解析。</p>
<h2><span id="自定义拦截器">自定义拦截器</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> OkHttpClient().newBuilder().addInterceptor(<span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// todo: .......</span></span><br><span class="line">        <span class="keyword">final</span> Response response = chain.proceed(chain.request());</span><br><span class="line">        <span class="comment">// todo: .......</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一定要调用chain.proceed,并将response返回。</p>
<p>不调用的话，会使责任链中断，后面其他就没法执行了。</p>
<h2><span id="okhttp总结">OkHttp总结</span></h2><p>整个OkHttp功能的实现就在这五个默认的拦截器中，所以先理解拦截器模式的工作机制是先决条件。这五个拦截器分别为: 重试拦截器、桥接拦截器、缓存拦截器、连接拦截器、请求服务拦截器。每一个拦截器负责的工作不一样，就好像工厂流水线，最终经过这五道工序，就完成了最终的产品。</p>
<p>但是与流水线不同的是，OkHttp中的拦截器每次发起请求都会在交给下一个拦截器之前干一些事情，在获得了结果之后又干一些事情。整个过程在请求向是顺序的，而响应向则是逆序。</p>
<p>当用户发起一个请求后，会由任务分发起<code>Dispatcher</code>将请求包装并交给重试拦截器处理。</p>
<p>1、重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。</p>
<p>2、桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。</p>
<p>3、缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。</p>
<p>4、连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。</p>
<p>5、请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。</p>
<p>在经过了这一系列的流程后，就完成了一次HTTP请求！</p>
<h2><span id="补充-代理">补充: 代理</span></h2><p>在使用OkHttp时，如果用户在创建<code>OkHttpClient</code>时，配置了<code>proxy</code>或者<code>proxySelector</code>，则会使用配置的代理，并且<code>proxy</code>优先级高于<code>proxySelector</code>。而如果未配置，则会获取机器配置的代理并使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK : ProxySelector</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	URI uri = <span class="keyword">new</span> URI(<span class="string">&quot;http://restapi.amap.com&quot;</span>);</span><br><span class="line">	List&lt;Proxy&gt; proxyList = ProxySelector.getDefault().select(uri);</span><br><span class="line">	System.out.println(proxyList.get(<span class="number">0</span>).address());</span><br><span class="line">	System.out.println(proxyList.get(<span class="number">0</span>).type());</span><br><span class="line">&#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果我们不需要自己的App中的请求走代理，则可以配置一个<code>proxy(Proxy.NO_PROXY)</code>，这样也可以避免被抓包。<code>NO_PROXY</code>的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Proxy NO_PROXY = <span class="keyword">new</span> Proxy();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.type = Proxy.Type.DIRECT;</span><br><span class="line">	<span class="keyword">this</span>.sa = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理在Java中对应的抽象类有三种类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        DIRECT,</span><br><span class="line">        HTTP,</span><br><span class="line">        SOCKS;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DIRECT</code>：无代理，<code>HTTP</code>：http代理，<code>SOCKS</code>：socks代理。第一种自然不用多说，而Http代理与Socks代理有什么区别？</p>
<p>对于Socks代理，在HTTP的场景下，代理服务器完成TCP数据包的转发工作;<br>而Http代理服务器，在转发数据之外，还会解析HTTP的请求及响应，并根据请求及响应的内容做一些处理。</p>
<blockquote>
<p><code>RealConnection</code>的<code>connectSocket</code>方法:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是Socks代理则 new Socket(proxy); 否则相当于直接:new Socket()</span></span><br><span class="line">rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">                ? address.socketFactory().createSocket()</span><br><span class="line">                : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line"><span class="comment">//connect方法</span></span><br><span class="line">socket.connect(address);</span><br></pre></td></tr></table></figure>

<p>设置了SOCKS代理的情况下，创建Socket时，为其传入proxy，连接时还是以HTTP服务器为目标地址；但是如果设置的是Http代理，创建Socket是与Http代理服务器建立连接。</p>
<blockquote>
<p>在<code>connect</code>方法时传递的<code>address</code>来自于下面的集合<code>inetSocketAddresses</code><br><code>RouteSelector</code>的<code>resetNextInetSocketAddress</code>方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetNextInetSocketAddress</span><span class="params">(Proxy proxy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">        <span class="comment">//无代理和socks代理，使用http服务器域名与端口</span></span><br><span class="line">      socketHost = address.url().host();</span><br><span class="line">      socketPort = address.url().port();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SocketAddress proxyAddress = proxy.address();</span><br><span class="line">      <span class="keyword">if</span> (!(proxyAddress <span class="keyword">instanceof</span> InetSocketAddress)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">&quot;Proxy.address() is not an &quot;</span> + <span class="string">&quot;InetSocketAddress: &quot;</span> + proxyAddress.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;</span><br><span class="line">      socketHost = getHostString(proxySocketAddress);</span><br><span class="line">      socketPort = proxySocketAddress.getPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">        <span class="comment">//socks代理 connect http服务器 （DNS没用，由代理服务器解析域名）</span></span><br><span class="line">      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//无代理，dns解析http服务器</span></span><br><span class="line">        <span class="comment">//http代理,dns解析http代理服务器</span></span><br><span class="line">      List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;</span><br><span class="line">        InetAddress inetAddress = addresses.get(i);</span><br><span class="line">        inetSocketAddresses.add(<span class="keyword">new</span> InetSocketAddress(inetAddress, socketPort));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置代理时，Http服务器的域名解析会被交给代理服务器执行。但是如果是设置了Http代理，会对Http代理服务器的域名使用<code>OkhttpClient</code>配置的dns解析代理服务器，Http服务器的域名解析被交给代理服务器解析。</p>
<p>上述代码就是代理与DNS在OkHttp中的使用，但是还有一点需要注意，Http代理也分成两种类型：普通代理与隧道代理。</p>
<p>其中普通代理不需要额外的操作，扮演「中间人」的角色，在两端之间来回传递报文。这个“中间人”在收到客户端发送的请求报文时，需要正确的处理请求和连接状态，同时向服务器发送新的请求，在收到响应后，将响应结果包装成一个响应体返回给客户端。在普通代理的流程中，代理两端都是有可能察觉不到”中间人“的存在。</p>
<p>但是隧道代理不再作为中间人，无法改写客户端的请求，而仅仅是在建立连接后，将客户端的请求，通过建立好的隧道，无脑的转发给终端服务器。隧道代理需要发起Http <strong>CONNECT</strong>请求，这种请求方式没有请求体，仅供代理服务器使用，并不会传递给终端服务器。请求头 部分一旦结束，后面的所有数据，都被视为应该转发给终端服务器的数据，代理需要把他们无脑的直接转发，直到从客户端的 TCP 读通道关闭。<strong>CONNECT</strong> 的响应报文，在代理服务器和终端服务器建立连接后，可以向客户端返回一个 <code>200 Connect established</code> 的状态码，以此表示和终端服务器的连接，建立成功。</p>
<blockquote>
<p>RealConnection的connect方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.requiresTunnel()) &#123;         </span><br><span class="line">	connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">	<span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// We were unable to connect the tunnel but properly closed down our</span></span><br><span class="line">		<span class="comment">// resources.</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>requiresTunnel</code>方法的判定为：当前请求为https并且存在http代理，这时候<code>connectTunnel</code>中会发起:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">xxxx</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: xxxx</span><br><span class="line"><span class="attribute">Proxy-Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">User-Agent</span>: okhttp/$&#123;version&#125;</span><br></pre></td></tr></table></figure>

<p>的请求，连接成功代理服务器会返回200；如果返回407表示代理服务器需要鉴权(如：付费代理)，这时需要在请求头中加入<code>Proxy-Authorization</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> Authenticator authenticator = <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(response.code == <span class="number">407</span>)&#123;</span><br><span class="line">            <span class="comment">//代理鉴权</span></span><br><span class="line">            String credential = Credentials.basic(<span class="string">&quot;代理服务用户名&quot;</span>, <span class="string">&quot;代理服务密码&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">                    .header(<span class="string">&quot;Proxy-Authorization&quot;</span>, credential)</span><br><span class="line">                    .build();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="keyword">new</span> OkHttpClient.Builder().proxyAuthenticator(authenticator);</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>OkHttp源码分析</p><p><a href="http://example.com/2020/12/10/okhttp/">http://example.com/2020/12/10/okhttp/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://example.com"><p>John Doe</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-12-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-07-04</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2021/06/15/view/" target="_blank">View基础</a><br></span><span>  2.<a class="is-size-6" href="/2020/12/11/activity/" target="_blank">Activity启动模式</a><br></span><span>  3.<a class="is-size-6" href="/2020/12/09/dispatch/" target="_blank">View事件分发</a><br></span><span>  4.<a class="is-size-6" href="/2020/12/08/gradle/" target="_blank">AndroidStudio开发Gradle插件</a><br></span><span>  5.<a class="is-size-6" href="/2020/12/08/hello-world/" target="_blank">Hello World</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/06/15/view/" target="_blank">View基础</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/12/11/activity/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Activity启动模式</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/12/09/dispatch/"><span class="level-item">View事件分发</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'e7299605d4e64bb7e8fce5c37308cb8c',
            repo: 'blog_comment',
            owner: 'removeif',
            clientID: '46a9f3481b46ea0129d8',
            clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24',
            admin: ["removeif"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png" alt="Lis"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Lis</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="/"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="/"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Next" href="/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2021/06/15/view/"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20190919221611.png" alt="View基础"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-06-15T06:56:23.000Z">2021-06-15</time></p><p class="title"><a href="/2021/06/15/view/">View基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-11T02:40:35.000Z">2020-12-11</time></p><p class="title"><a href="/2020/12/11/activity/">Activity启动模式</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-10T05:26:56.000Z">2020-12-10</time></p><p class="title"><a href="/2020/12/10/okhttp/">OkHttp源码分析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-09T02:01:42.000Z">2020-12-09</time></p><p class="title"><a href="/2020/12/09/dispatch/">View事件分发</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-08T03:46:53.099Z">2020-12-08</time></p><p class="title"><a href="/2020/12/08/gradle/">AndroidStudio开发Gradle插件</a></p></div></article></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/OkHttp/"><span class="tag">OkHttp</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/activity/"><span class="tag">activity</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dispatch/"><span class="tag">dispatch</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/logo.png" alt="Lis" height="28"></a><p class="size-small"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/xunyixiangchao"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="325625528" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','removeif','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(false){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','removeif','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>