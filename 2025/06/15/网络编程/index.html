<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java网络编程 - Lis</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Lis"><meta name="msapplication-TileImage" content="/img/2018.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Lis"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="网络协议和常用网络工具 计算机网络体系结构 TCP&amp;#x2F;IP协议族 TCP UDP   网络传输中的数据 地址和端口号 MAC地址 IP地址 端口号   TCP概述 TCP基本特性 TCP三次握手 三次握手 为什么TCP握手需要三次? TCP的三次握手的漏洞-SYN洪泛攻击   TCP四次挥手（分手） 四次挥手 为什么需要四次挥手？ 为什么需要TIME-WAIT状态？     常用的网络工具Wi"><meta property="og:type" content="blog"><meta property="og:title" content="Lis"><meta property="og:url" content="https://xunyixiangchao.github.io/"><meta property="og:site_name" content="Lis"><meta property="og:description" content="网络协议和常用网络工具 计算机网络体系结构 TCP&amp;#x2F;IP协议族 TCP UDP   网络传输中的数据 地址和端口号 MAC地址 IP地址 端口号   TCP概述 TCP基本特性 TCP三次握手 三次握手 为什么TCP握手需要三次? TCP的三次握手的漏洞-SYN洪泛攻击   TCP四次挥手（分手） 四次挥手 为什么需要四次挥手？ 为什么需要TIME-WAIT状态？     常用的网络工具Wi"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xunyixiangchao.github.io/img/2018.jpg"><meta property="article:published_time" content="2025-06-15T07:21:54.000Z"><meta property="article:modified_time" content="2025-06-15T07:55:07.200Z"><meta property="article:author" content="Lis"><meta property="article:tag" content="Java"><meta property="article:tag" content="网络编程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/2018.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},"headline":"Lis","image":["http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcpip%E5%8D%8F%E8%AE%AE%E6%97%8F.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcpip%E5%8D%8F%E8%AE%AE%E6%97%8F2.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/MAC%E5%9C%B0%E5%9D%80.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/ip%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B72.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%8D%95%E8%8E%B7IP.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%8D%95%E8%8E%B7.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E9%80%9A%E4%BF%A1.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E4%BC%AA%E5%BC%82%E6%AD%A5.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/nio%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/buffer%E8%AF%BB%E5%86%99.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/mmap.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/sendfile.png","http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/splice.png"],"datePublished":"2025-06-15T07:21:54.000Z","dateModified":"2025-06-15T07:55:07.200Z","author":{"@type":"Person","name":"Lis"},"description":"网络协议和常用网络工具 计算机网络体系结构 TCP&#x2F;IP协议族 TCP UDP   网络传输中的数据 地址和端口号 MAC地址 IP地址 端口号   TCP概述 TCP基本特性 TCP三次握手 三次握手 为什么TCP握手需要三次? TCP的三次握手的漏洞-SYN洪泛攻击   TCP四次挥手（分手） 四次挥手 为什么需要四次挥手？ 为什么需要TIME-WAIT状态？     常用的网络工具Wi"}</script><link rel="canonical" href="http://example.com/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><link rel="icon" href="/img/2018.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Lis" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2018.jpg" alt="Lis" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://xunyixiangchao.github.io/"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://xunyixiangchao.github.io/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-06-15  <a class="commentCountImg" href="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#comment-container"><span class="display-none-class">8aa616adcdce489684cd911204ecd549</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="8aa616adcdce489684cd911204ecd549">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>16.5 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Java网络编程</h1><div class="content"><!-- toc -->

<ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7">网络协议和常用网络工具</a><ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络体系结构</a></li>
<li><a href="#tcpip%E5%8D%8F%E8%AE%AE%E6%97%8F">TCP/IP协议族</a><ul>
<li><a href="#tcp">TCP</a></li>
<li><a href="#udp">UDP</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE">网络传输中的数据</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7">地址和端口号</a><ul>
<li><a href="#mac%E5%9C%B0%E5%9D%80">MAC地址</a></li>
<li><a href="#ip%E5%9C%B0%E5%9D%80">IP地址</a></li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7">端口号</a></li>
</ul>
</li>
<li><a href="#tcp%E6%A6%82%E8%BF%B0">TCP概述</a><ul>
<li><a href="#tcp%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">TCP基本特性</a></li>
<li><a href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP三次握手</a><ul>
<li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><strong>三次握手</strong></a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88tcp%E6%8F%A1%E6%89%8B%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1"><strong>为什么TCP握手需要三次?</strong></a></li>
<li><a href="#tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%BC%8F%E6%B4%9E-syn%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><strong>TCP的三次握手的漏洞-SYN洪泛攻击</strong></a></li>
</ul>
</li>
<li><a href="#tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%88%86%E6%89%8B">TCP四次挥手（分手）</a><ul>
<li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><strong>四次挥手</strong></a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><strong>为什么需要四次挥手？</strong></a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81time-wait%E7%8A%B6%E6%80%81">为什么需要TIME-WAIT状态？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7wireshark%E5%92%8Ctcpdump">常用的网络工具Wireshark和tcpdump</a><ul>
<li><a href="#wireshark">Wireshark</a><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">数据包的捕获和基本用法</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E7%94%A8wireshark%E7%9C%8B%E7%9C%8Btcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">实战：用Wireshark看看TCP的三次握手</a></li>
</ul>
</li>
<li><a href="#tcpdump">TCPDUMP</a></li>
</ul>
</li>
<li><a href="#http">HTTP</a><ul>
<li><a href="#%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4http%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B">一次完整http请求的过程</a></li>
<li><a href="#dns%E5%8A%AB%E6%8C%81%E5%92%8Chttp%E5%8A%AB%E6%8C%81">DNS劫持和HTTP劫持</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#java%E5%8E%9F%E7%94%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">Java原生网络编程</a><ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86">网络通信基本常识</a><ul>
<li><a href="#socket">Socket</a></li>
<li><a href="#%E7%9F%AD%E8%BF%9E%E6%8E%A5">短连接</a></li>
<li><a href="#%E9%95%BF%E8%BF%9E%E6%8E%A5">长连接</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9F%AD%E8%BF%9E%E6%8E%A5">什么时候用长连接，短连接？</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B%E5%85%B3%E6%B3%A8%E7%9A%84%E4%B8%89%E4%BB%B6%E4%BA%8B">服务端、客户端、通信编程关注的三件事</a></li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E7%94%9Fjdk%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Bbio">原生JDK网络编程BIO</a><ul>
<li><a href="#socket%E5%AE%9E%E7%8E%B0">Socket实现</a></li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E7%94%9Fjdk%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-nio">原生JDK网络编程- NIO</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFnio">什么是NIO？</a></li>
<li><a href="#%E5%92%8Cbio%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB">和BIO的主要区别</a></li>
<li><a href="#nio%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">NIO三大核心组件</a></li>
<li><a href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5selectionkey">重要概念SelectionKey</a></li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E7%94%9Fjdk%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-buffer">原生JDK网络编程- Buffer</a><ul>
<li><a href="#%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7">重要属性</a></li>
<li><a href="#buffer%E7%9A%84%E5%88%86%E9%85%8D">Buffer的分配</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">直接内存</a><ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83">直接内存（堆外内存）与堆内存比较</a></li>
</ul>
</li>
<li><a href="#buffer%E7%9A%84%E8%AF%BB%E5%86%99">Buffer的读写</a><ul>
<li><a href="#%E5%90%91buffer%E4%B8%AD%E5%86%99%E6%95%B0%E6%8D%AE">向Buffer中写数据</a></li>
<li><a href="#flip%E6%96%B9%E6%B3%95">flip()方法</a></li>
<li><a href="#%E4%BB%8Ebuffer%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">从Buffer中读取数据</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8buffer%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E5%B8%B8%E8%A7%81%E6%AD%A5%E9%AA%A4">使用Buffer读写数据常见步骤</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">其他常用操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E7%94%9Fjdk%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-nio%E5%AE%9E%E6%88%98">原生JDK网络编程-NIO实战</a></li>
<li><a href="#%E5%8E%9F%E7%94%9Fjdk%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-nio%E4%B9%8Breactor%E6%A8%A1%E5%BC%8F">原生JDK网络编程- NIO之Reactor模式</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">网络协议常见面试题</a><ul>
<li><a href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">说一下 TCP 的三次握手过程</a></li>
<li><a href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">解释一下 TCP 的四次挥手</a></li>
<li><a href="#%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E6%AF%94%E8%BE%83%E9%80%82%E5%90%88%E7%94%A8-udp-%E5%AE%9E%E7%8E%B0">哪些应用比较适合用 udp 实现</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-qq%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%8A%E4%BD%A0%E4%BC%9A%E8%80%83%E8%99%91%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1">如果要你来设计一个 QQ，在网络协议上你会考虑如何设计？</a></li>
<li><a href="#http-%E4%B8%8E-https-%E7%9A%84%E5%8C%BA%E5%88%AB">Http 与 Https 的区别：</a></li>
<li><a href="#https-%E6%96%B9%E5%BC%8F%E4%B8%8E-web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E6%97%B6%E7%9A%84%E6%AD%A5%E9%AA%A4">HTTPS 方式与 Web 服务器通信时的步骤</a></li>
<li><a href="#tcp-%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">TCP 粘包/拆包的原因及解决方法？</a></li>
<li><a href="#select-poll-epoll-%E7%9A%84%E5%8C%BA%E5%88%AB">select、poll、epoll 的区别？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91lt%E5%92%8C%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91et">什么是水平触发(LT)和边缘触发(ET)？</a></li>
<li><a href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">堆外内存的优点和缺点</a></li>
</ul>
</li>
<li><a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D">零拷贝</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D">什么是零拷贝?</a></li>
<li><a href="#linux-%E6%94%AF%E6%8C%81%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9B%B6%E6%8B%B7%E8%B4%9D">Linux 支持的(常见)零拷贝</a><ul>
<li><a href="#mmap-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84">mmap 内存映射</a></li>
<li><a href="#sendfile">sendfile</a></li>
<li><a href="#splice">splice</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8Cjdk%E5%AF%B9%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%9E%E7%8E%B0">操作系统和JDK对网络通信的实现</a></li>
</ul>
<!-- tocstop -->

<a id="more"></a>



<h2><span id="网络协议和常用网络工具">网络协议和常用网络工具</span></h2><h3><span id="计算机网络体系结构">计算机网络体系结构</span></h3><p><strong>OSI七层模型</strong>：物理层、数据链路层、网络层、传输层，传话层、表示层、应用层</p>
<p><strong>TCP/IP模型</strong>：链路层、网络层、传输层、应用层</p>
<p>两个模型这间的对应关系</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="对应关系"></p>
<p>每一个抽象层建立在低一层提供的服务上，并且为高一层提供服务。</p>
<h3><span id="tcpip协议族">TCP/IP协议族</span></h3><p>Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。协议采用了4层的层级结构。然而在很多情况下，它是利用 IP 进行通信时所必须用到的协议群的统称。也就是说，它其实是个协议家族，由很多个协议组成，并且是在不同的层， 是互联网的基础通信架构。</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcpip%E5%8D%8F%E8%AE%AE%E6%97%8F.png" alt="TCP/IP协议族"></p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcpip%E5%8D%8F%E8%AE%AE%E6%97%8F2.png" alt="tcpip协议族2"></p>
<h4><span id="tcp">TCP</span></h4><p>​        TCP提供了一种可靠的数据传输服务，TCP是面向连接的，也就是说，利用TCP通信的两台主机首先要经历一个建立连接的过程，等到连接建立后才开始传输数据，而且传输过程中采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，发送完成后还会关闭连接。所以TCP要比UDP可靠的多。</p>
<h4><span id="udp">UDP</span></h4><p>​        UDP（User Datagram Protocol的简称， 中文名是用户数据报协议）是把数据直接发出去，而不管对方是不是在接收，也不管对方是否能接收的了，也不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</p>
<blockquote>
<p><strong>注意：我们一些常见的网络应用基本上都是基于TCP和UDP的，这两个协议又会使用网络层的IP协议。但是我们完全可以绕过传输层的TCP和UDP，直接使用IP，比如Linux中LVS，甚至直接访问链路层，比如tcpdump程序就是直接和链路层进行通信的。</strong></p>
</blockquote>
<p><strong>QA：移动通信中的4G，5G属于链路层及以下（物理层）。</strong></p>
<h3><span id="网络传输中的数据">网络传输中的数据</span></h3><p>​        网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。</p>
<ul>
<li><strong>包</strong>是全能性术语；</li>
<li><strong>帧</strong>用于表示数据链路层中包的单位；</li>
<li><strong>片</strong>是IP中数据的单位；</li>
<li><strong>段</strong>则表示TCP数据流中的信息；</li>
<li><strong>消息</strong>是指应用协议中数据的单位；</li>
</ul>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt="网络传输中的数据"></p>
<p>​        每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<h3><span id="地址和端口号">地址和端口号</span></h3><h4><span id="mac地址">MAC地址</span></h4><p>​        由网络设备制造商生产时写在硬件内部。MAC地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、路由器等）接入到网络的何处，都有相同的MAC地址，它由厂商写在网卡的BIOS里，从理论上讲，除非盗来硬件（网卡），否则是没有办法冒名顶替的。</p>
<p>​        MAC地址共48位（6个字节）。前24位由IEEE（电气和电子工程师协会）决定如何分配，后24位由实际生产该网络设备的厂商自行制定。例如：FF:FF:FF:FF:FF:FF或FF-FF-FF-FF-FF-FF</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/MAC%E5%9C%B0%E5%9D%80.png" alt="MAC地址"></p>
<h4><span id="ip地址">IP地址</span></h4><p>​        IP地址（Internet Protocol Address）的全称叫作互联网协议地址，它的本义是为互联网上的每一个网络和每一台主机配置一个唯一的逻辑地址，用来与物理地址作区分。</p>
<p>​        所以IP 地址用来识别 TCP/IP 网络中互连的主机和路由器。IP地址基于逻辑，比较灵活，不受硬件限制，也容易记忆。</p>
<p>​        IP地址分为：IPv4和IPv6。我们这里着重讲的是IPv4地址，IP地址是由32位的二进制数组成，它们通常被分为4个“8位二进制数”，我们可以把它理解为4个字节，格式表示为：（A.B.C.D）。其中，A，B，C，D这四个英文字母表示为0-255的十进制的整数。例：192.168.1.1</p>
<h4><span id="端口号">端口号</span></h4><p>端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为<strong>程序地址</strong>。</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/ip%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="IP和端口号"></p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="网络通信中的地址和端口号"></p>
<p>​        一般来说，不管计算机中有多少网卡，每个网卡都会有自己的MAC 地址，这个MAC地址是不会变化的。而每个网卡在正常工作的情况下，都会有一个IP地址，这个IP地址完全是可以变化的。而这台计算机中承载的各种应用程序可以拥有自己的端口号，然后通过服务器的网卡，正确地进行网络通信。</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B72.png" alt="网络通信中的地址和端口号2"></p>
<p>​        <strong>所以通过源IP地址、目标IP地址、协议号（协议类型）、源端口号以及目标端口号这五个元素唯一性的识别一个网络上的通信。</strong></p>
<h3><span id="tcp概述">TCP概述</span></h3><p>​        TCP（Transmission Control Protocol）是面向连接的通信协议，通过三次握手建立连接，然后才能开始数据的读写，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。</p>
<h4><span id="tcp基本特性">TCP基本特性</span></h4><ul>
<li><p>面向连接</p>
<p>通过三次握手建立连接后才开始传输数据，完成后拆除连接（四次挥手）</p>
</li>
<li><p>可靠性</p>
<p>数据被拆分后发送，采用超时重传机制和应答确认机制进行可靠的传输</p>
</li>
<li><p>超时重传机制</p>
<p>依靠RTT（往返时延）的时长，依靠算法确认重传超时值。</p>
<p>​        采样统计一个数据包从发送端发送出去到接收到这个包的回复这段时长来动态设置重传超时值，这个时长就是为RTT</p>
</li>
<li><p>数据排序</p>
<p>TCP数据包中包括序号和确认，所以未按照顺序收到的包可以被排序，而损坏的包可以被重传。</p>
</li>
<li><p>流量控制</p>
<p>采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p>
</li>
<li><p>全双工</p>
<p>TCP允许在一个TCP连接上，通信的双方可以同时传输数据，也就是所谓的全双工。</p>
</li>
</ul>
<h4><span id="tcp三次握手">TCP三次握手</span></h4><h5><span id="三次握手"><strong>三次握手</strong></span></h5><p>建立一个TPC连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p>
<ul>
<li><p>第一次握手</p>
<p>客户端请求建立连接。</p>
</li>
<li><p>第二次握手</p>
<p>服务端应答客户端，并请求建立连接。</p>
</li>
<li><p>第三次握手</p>
<p>客户端针对服务端请求确认应答。</p>
</li>
</ul>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<h5><span id="为什么tcp握手需要三次"><strong>为什么TCP握手需要三次?</strong></span></h5><p>​        TCP是可靠的传输控制协议，而三次握手是保证数据可靠传输又能提高传输效率的最小次数。</p>
<p>​        三次握手的过程即是通信双方<strong>相互告知</strong>序列号起始值，并<strong>确认对方</strong>已经收到了序列号起始值的必经步骤。</p>
<h5><span id="tcp的三次握手的漏洞-syn洪泛攻击"><strong>TCP的三次握手的漏洞-SYN洪泛攻击</strong></span></h5><p><strong>定义</strong>：通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的<code>半开连接</code>队列被占满，从而阻止其他用户进行访问。</p>
<p><strong>原理</strong>：攻击者客户端利用伪造的IP地址向服务端发出请求（第一次握手），而服务端的响应（第二次握手）的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手（永远都不会有），服务端在等待这种<code>半开的连接</code>过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><p>无效连接监控释放</p>
<p>监视所有的连接，包括三次握手的，还有握手一次的，反正是所有的，当达到一定(与)阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，不管是正常的还是攻击的，所以这种方式不推荐。</p>
</li>
<li><p>延缓TCB分配方法</p>
<p>一般的做完第一次握手之后，服务器就需要为该请求分配一个TCB（连接控制资源），通常这个资源需要200多个字节。延迟TCB的分配，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。</p>
</li>
<li><p>防火墙（常用）</p>
<p>防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起SYN请求。</p>
</li>
</ul>
<h4><span id="tcp四次挥手分手">TCP四次挥手（分手）</span></h4><h5><span id="四次挥手"><strong>四次挥手</strong></span></h5><p>断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</p>
<ul>
<li>第一次挥手：客户端发送关闭请求</li>
<li>第二次挥手：服务端响应客户端关闭请求</li>
<li>第三次挥手：服务端发送关闭请求</li>
<li>第四次挥手：客户端发送关闭确认请求</li>
</ul>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<h5><span id="为什么需要四次挥手"><strong>为什么需要四次挥手？</strong></span></h5><p>​        TCP是全双工模式，对全双工模式来说，为了彻底关闭，就需要通信两端的4次交互。（实际中四次挥手有可能是合并的，只能看到两次或三次交互）</p>
<h5><span id="为什么需要time-wait状态">为什么需要TIME-WAIT状态？</span></h5><p>TIME_WAIT状态存在的原因有两点 </p>
<ol>
<li>可靠的终止TCP连接。<ul>
<li>客户端收到服务器的连接释放的FIN报文后，必须发出确认。如最后这个ACK确认报文丢失，那么服务器没有收到这个ACK确认报文，就要重发FIN连接释放报文，客户端要在某个状态等待这个FIN连接释放报文段然后回复确认报文段，这样才能可靠的终止TCP连接。</li>
</ul>
</li>
<li>保证让迟来的TCP报文有足够的时间被识别并丢弃。<ul>
<li>在Linux系统上，一个TCP端口不能被同时打开多次，当一个TCP连接处于TIME_WAIT状态时，我们无法使用该链接的端口来建立一个新连接。反过来思考，<code>如果不存在TIME_WAIT状态，则应用程序能过立即建立一个和刚关闭的连接相似的连接（这里的相似，是指他们具有相同的IP地址和端口号）。这个新的、和原来相似的连接被称为原来连接的化身。新的化身可能受到属于原来连接携带应用程序数据的TCP报文段（迟到的报文段），这显然是不该发生的。</code>这是TIME_WAIT状态存在的第二个原因。</li>
</ul>
</li>
</ol>
<h3><span id="常用的网络工具wireshark和tcpdump">常用的网络工具Wireshark和tcpdump</span></h3><h4><span id="wireshark">Wireshark</span></h4><p>为什么要抓包</p>
<ol>
<li>定位网络问题；</li>
<li>分析接口数据；</li>
<li>学习网络协议，使用抓包工具分析网络数据更直观。</li>
</ol>
<p>​    常用的抓包工具有：F12（浏览器自带的抓包工具）、Fiddler、Charles，Wireshark。而Wireshark在支持的协议，用户友好度、价格（开源）、程序支持、支持的操作系统上都很好，所以Wireshark也是我们最常用的抓包工具和报文分析工具。</p>
<h5><span id="数据包的捕获和基本用法">数据包的捕获和基本用法</span></h5><p>参照二期2020.12.10 Java原生网络编程 1中00:55:00</p>
<h5><span id="实战用wireshark看看tcp的三次握手">实战：用Wireshark看看TCP的三次握手</span></h5><p>使用远程服务器连接查看TCP的三次握手</p>
<p>捕获服务器IP</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%8D%95%E8%8E%B7IP.png" alt="捕获IP"></p>
<p>最上方的三次记录即为我们需要的三次握手的记录</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%8D%95%E8%8E%B7.png" alt="1749458679509"></p>
<p><strong>第一次握手</strong></p>
<p>flags标识Syn为1，seq为2899911141</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="第一次握手"></p>
<p><strong>第二次握手</strong></p>
<p>flags标识Syn为1，Ack为1，ack为2899911142， seq为3441296542</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="第二次握手"></p>
<p><strong>第三次握手</strong></p>
<p>flags标识Ack为1，ack为3441296543</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="第三次握手"></p>
<p>这样就完成了三次握手的全过程</p>
<h4><span id="tcpdump">TCPDUMP</span></h4><p>​    TcpDump是Linux中强大的网络数据采集分析工具之一。用简单的话来定义tcpdump，就是:dump<br>the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。注意tcpdump必须以超级管理员的身份登录系统才能使用。</p>
<p><strong>tcpdump的参数</strong>比较多：                                        </p>
<p>各个参数的意义如下：</p>
<p>A：以ascii编码打印每个报文（不包括链路的头）。</p>
<p>a：将网络地址和广播地址转变成名字。</p>
<p>c：抓取指定数目的包。</p>
<p>C：用于判断用 -w 选项将报文写入的文件的大小是否超过这个值，如果超过了就新建文件（文件名后缀是1、2、3依次增加）；</p>
<p>d：将匹配信息包的代码以人们能够理解的汇编格式给出；</p>
<p>dd：将匹配信息包的代码以c语言程序段的格式给出；</p>
<p>ddd：将匹配信息包的代码以十进制的形式给出；</p>
<p>D：列出当前主机的所有网卡编号和名称，可以用于选项 -i；</p>
<p>e：在输出行打印出数据链路层的头部信息；</p>
<p>f：将外部的Internet地址以数字的形式打印出来；</p>
<p>F&lt;表达文件&gt;：从指定的文件中读取表达式,忽略其它的表达式；</p>
<p>i&lt;网络界面&gt;：监听主机的该网卡上的数据流，如果没有指定，就会使用最小网卡编号的网卡（在选项-D可知道，但是不包括环路接口），linux 2.2 内核及之后的版本支持 any 网卡，用于指代任意网卡；</p>
<p>l：如果没有使用 -w 选项，就可以将报文打印到 标准输出终端（此时这是默认）；</p>
<p>n：显示ip，而不是主机名；</p>
<p>nn：显示port，而不是服务名；</p>
<p>N：不列出域名；</p>
<p>O：不将数据包编码最佳化；</p>
<p>p：不让网络界面进入混杂模式；</p>
<p>q：快速输出，仅列出少数的传输协议信息；</p>
<p>r&lt;数据包文件&gt;：从指定的文件中读取包(这些包一般通过-w选项产生)；</p>
<p>s&lt;数据包大小&gt;：指定抓包显示一行的宽度，-s0表示可按包长显示完整的包，经常和-A一起用，默认截取长度为60个字节，但一般ethernet MTU都是1500字节。所以，要抓取大于60字节的包时，使用默认参数就会导致包数据丢失；</p>
<p>S：用绝对而非相对数值列出TCP关联数；</p>
<p>t：在输出的每一行不打印时间戳；</p>
<p>tt：在输出的每一行显示未经格式化的时间戳记；</p>
<p>T&lt;数据包类型&gt;：将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议）；</p>
<p>v：输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；</p>
<p>vv：输出详细的报文信息；</p>
<p>x/-xx/-X/-XX：以十六进制显示包内容，几个选项只有细微的差别，详见man手册；</p>
<p>w&lt;数据包文件&gt;：直接将包写入文件中，并不分析和打印出来；</p>
<p>expression：用于筛选的逻辑表达式。manip</p>
<p><strong>tcp抓取mysql报文：</strong></p>
<p>tcpdump -i eth0 tcp port 3306 -w ./mysql.cap</p>
<p>抓取设备eth0上协议tcp端口号3306保存到mysql.cap文件中</p>
<p>这个文件可以直接用Wireshark打开查看</p>
<h3><span id="http">HTTP</span></h3><p>​        HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<h4><span id="一次完整http请求的过程">一次完整http请求的过程</span></h4><p>1、首先进行 DNS 域名解析（本地浏览器缓存、操作系统缓存或者 DNS 服务器）</p>
<p>​        a）首先会搜索浏览器自身的 DNS 缓存（缓存时间比较短，大概只有 1 分钟，且只能容纳 1000 条缓存）<br>​        b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的 DNS缓存<br>​        c）如果还没有找到，那么尝试从 hosts 文件里面去找<br>​        d）在前面三个过程都没获取到的情况下，就去域名服务器去查找</p>
<p>2、三次握手建立 TCP 连接<br>        在 HTTP 工作开始之前，客户端首先要通过网络与服务器建立连接，HTTP 连接是通过 TCP 来完成的。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80；</p>
<p>3、客户端发起 HTTP 请求</p>
<p>4、服务器响应 HTTP 请求</p>
<p>5、客户端解析 html 代码，并请求 html 代码中的资源</p>
<p>​        浏览器拿到 html 文件后，就开始解析其中的 html 代码，遇到 js/css/image等静态资源时，就向服务器端去请求下载</p>
<p>6、客户端渲染展示内容</p>
<p>7、关闭 TCP 连接</p>
<blockquote>
<p>一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求，也就是说前面的3到6，可以反复进行。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
</blockquote>
<h4><span id="dns劫持和http劫持">DNS劫持和HTTP劫持</span></h4><p>​        DNS是Domain Name System的简写，即域名系统，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。简单地说，如果我们想访问DNS.COM的官网，本来需要输入网站主机的IP地址，但是DNS可以将<a target="_blank" rel="noopener" href="http://www.dns.com/">www.dns.com</a>  解析成对应的IP地址，我们就不需要记住复杂的IP地址了。</p>
<p>​        DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</p>
<p>​        在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返回的HTML数据中插入js或dom节点（广告）。比如访问GitHub，出现了“我是渣渣辉，是兄弟就来砍我”之类的小弹窗。</p>
<p>HTTP劫持防劫持思路</p>
<ul>
<li>采用https协议加密请求。</li>
<li>隐藏http请求的特征，例如使用对称加密算法加密整个url。</li>
</ul>
<h2><span id="java原生网络编程">Java原生网络编程</span></h2><h3><span id="网络通信基本常识">网络通信基本常识</span></h3><h4><span id="socket">Socket</span></h4><p><strong>Socket</strong>是应用层与TCP/IP协议族通信的中间软件抽象层， 它是一组接口，其实就是一个门面模式。TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）。</p>
<h4><span id="短连接">短连接</span></h4><p>​    连接-&gt;传输数据-&gt;关闭连接   </p>
<p>​        传统HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。   也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。</p>
<h4><span id="长连接">长连接</span></h4><p>​        连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。 -&gt;关闭连接。   </p>
<p>​        长连接指建立SOCKET连接后不管是否使用都保持连接。</p>
<h4><span id="什么时候用长连接短连接">什么时候用长连接，短连接？</span></h4><p>​        长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。<br>         而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。<br>         总之，长连接和短连接的选择要视情况而定。</p>
<h4><span id="服务端-客户端-通信编程关注的三件事">服务端、客户端、通信编程关注的三件事</span></h4><p>​        在通信编程里，我们关注的其实也就是三个事情：<code>连接</code>（客户端连接服务器，服务器等待和接收连接）、<code>读网络数据</code>、<code>写网络数据</code>，所有模式的通信编程都是围绕着这三件事情进行的。</p>
<p>​        服务端提供IP和监听端口，客户端通过连接操作想服务端监听的地址发起连接请求，通过三次握手连接，如果连接成功建立，双方就可以通过套接字进行通信。</p>
<h3><span id="原生jdk网络编程bio">原生JDK网络编程BIO</span></h3><p>BIO（Blocking　IO）阻塞式IO</p>
<p>​        传统的同步阻塞模型开发中，<code>ServerSocket</code>负责绑定IP地址，启动监听端口；<code>Socket</code>负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。 </p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E9%80%9A%E4%BF%A1.png" alt="socket通信"></p>
<p>ServerSocket-&gt;bind()绑定端口-&gt;accept()接收客户端连接</p>
<p>Socket-&gt;connect()连接服务器IP和端口</p>
<h4><span id="socket实现">Socket实现</span></h4><p><strong>Server</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">            SocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">7858</span>);</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            serverSocket.bind(address);</span><br><span class="line">            System.out.println(<span class="string">&quot;Server started on port 7858&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//创建线程，监听连接</span></span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerTask(serverSocket.accept())).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServerTask</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//输入流</span></span><br><span class="line">            <span class="keyword">try</span> (ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                 <span class="comment">//输出流</span></span><br><span class="line">                 ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream())</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">/*接收客户端的输出，也就是服务端的输入*/</span></span><br><span class="line">                String name = inputStream.readUTF();</span><br><span class="line">                System.out.println(<span class="string">&quot;accept name is &quot;</span> + name);</span><br><span class="line">                <span class="comment">/*服务端的输出，也就是客户端的输入*/</span></span><br><span class="line">                outputStream.writeUTF(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">                outputStream.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        SocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7858</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.connect(address);</span><br><span class="line">            out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            in = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            out.writeUTF(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="comment">//输入</span></span><br><span class="line">            System.out.println(in.readUTF());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">                out.close();</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Server使用线程池优化</strong></p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E4%BC%AA%E5%BC%82%E6%AD%A5.png" alt="伪异步"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">            SocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">7858</span>);</span><br><span class="line">            serverSocket.bind(address);</span><br><span class="line">            System.out.println(<span class="string">&quot;Server started on port 7858&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//new Thread(new ServerTask(serverSocket.accept())).start();</span></span><br><span class="line">                executorService.execute(<span class="keyword">new</span> ServerTask(serverSocket.accept()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        但是，正因为限制了线程数量，如果发生读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，只能一直等待，这就是最大的弊端。</p>
<h3><span id="原生jdk网络编程-nio">原生JDK网络编程- NIO</span></h3><h4><span id="什么是nio">什么是NIO？</span></h4><p>​        NIO 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 I/O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。NIO翻译成 no-blocking io 或者 new io都说得通。</p>
<h4><span id="和bio的主要区别">和BIO的主要区别</span></h4><ol>
<li><strong>面向流与面向缓冲</strong></li>
</ol>
<p>​        Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<ol start="2">
<li><strong>阻塞与非阻塞IO</strong></li>
</ol>
<p>​        Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p>
<p>​         Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h4><span id="nio三大核心组件">NIO三大核心组件</span></h4><ul>
<li>Selector选择器</li>
<li>Channel管道</li>
<li>buffer缓冲区</li>
</ul>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/nio%E7%BB%84%E4%BB%B6%E6%B5%81%E7%A8%8B.png" alt="nio组件流程"></p>
<p><strong>Selector</strong></p>
<p>​        Selector的英文含义是“选择器”，也可以称为为“轮询代理器”、“事件订阅器”、“channel容器管理机”都行。</p>
<p>​        Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器(Selectors)，然后使用一个单独的线程来操作这个选择器，进而“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<p>​        应用程序将向Selector对象注册需要它关注的Channel，以及具体的某一个Channel会对哪些IO事件感兴趣。Selector中也会维护一个“已经注册的Channel”的容器。</p>
<p><strong>Channels</strong></p>
<p>​        通道，被建立的一个应用程序和操作系统交互事件、传递内容的渠道（注意是连接到操作系统）。那么既然是和操作系统进行内容的传递，那么说明应用程序可以通过通道读取数据，也可以通过通道向操作系统写数据，而且可以同时进行读写。</p>
<ul>
<li>所有被Selector（选择器）注册的通道，只能是继承了SelectableChannel类的子类</li>
<li>ServerSocketChannel：应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持“多路复用IO”的端口监听。同时支持UDP协议和TCP协议。</li>
<li>ScoketChannel：TCP Socket套接字的监听通道，一个Socket套接字对应了一个客户端IP：端口 到 服务器IP：端口的通信连接。<br>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li>
</ul>
<p><strong>buffer缓冲区</strong></p>
<p>后面会详细讲到其中的api等相关内容。</p>
<h4><span id="重要概念selectionkey">重要概念SelectionKey</span></h4><p><strong>什么是SelectionKey</strong></p>
<p>​        SelectionKey是一个抽象类,表示selectableChannel在Selector中注册的标识.每个Channel向Selector注册时,都将会创建一个SelectionKey。SelectionKey将Channel与Selector建立了关系,并维护了channel事件。<br>​        可以通过cancel方法取消键,取消的键不会立即从selector中移除,而是添加到cancelledKeys中,在下一次select操作时移除它.所以在调用某个key时,需要使用isValid进行校验.</p>
<p><strong>SelectionKey类型和就绪条件</strong></p>
<p>​        在向Selector对象注册感兴趣的事件时，JAVA NIO共定义了四种：OP_READ、OP_WRITE、OP_CONNECT、OP_ACCEPT（定义在SelectionKey中），分别对应读、写、请求连接、接受连接等网络Socket操作。</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>就绪条件及说明</th>
</tr>
</thead>
<tbody><tr>
<td>OP_READ</td>
<td>当操作系统读缓冲区有数据可读时就绪。并非时刻都有数据可读，所以一般需要注册该操作，仅当有就绪时才发起读操作，有的放矢，避免浪费CPU。</td>
</tr>
<tr>
<td>OP_WRITE</td>
<td>当操作系统写缓冲区有空闲空间时就绪。一般情况下写缓冲区都有空闲空间，小块数据直接写入即可，没必要注册该操作类型，否则该条件不断就绪浪费CPU；但如果是写密集型的任务，比如文件下载等，缓冲区很可能满，注册该操作类型就很有必要，同时注意写完后取消注册。</td>
</tr>
<tr>
<td>OP_CONNECT</td>
<td>当SocketChannel.connect()请求连接成功后就绪。该操作只给客户端使用。</td>
</tr>
<tr>
<td>OP_ACCEPT</td>
<td>当接收到一个客户端连接请求时就绪。该操作只给服务器使用。</td>
</tr>
</tbody></table>
<p>​        服务器启动ServerSocketChannel，关注OP_ACCEPT事件，</p>
<p>​        客户端启动SocketChannel，连接服务器，关注OP_CONNECT事件</p>
<p>​        服务器接受连接，启动一个服务器的SocketChannel，这个SocketChannel可以关注OP_READ、OP_WRITE事件，一般连接建立后会直接关注OP_READ事件</p>
<p>&emsp;&emsp;客户端这边的客户端SocketChannel发现连接建立后，可以关注OP_READ、OP_WRITE事件，一般是需要客户端需要发送数据了才关注OP_READ事件</p>
<p>​        连接建立后客户端与服务器端开始相互发送消息（读写），根据实际情况来关注OP_READ、OP_WRITE事件。</p>
<h3><span id="原生jdk网络编程-buffer">原生JDK网络编程- Buffer</span></h3><h4><span id="重要属性">重要属性</span></h4><ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p><strong>capacity</strong><br>        作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。<br><strong>position</strong><br>        当你写数据到Buffer中时，position表示当前能写的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.<br>        <code>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</code><br><strong>limit</strong><br>        在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。<br>        <code>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</code></p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/buffer%E8%AF%BB%E5%86%99.png" alt="buffer读写"></p>
<h4><span id="buffer的分配">Buffer的分配</span></h4><p>​        要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有allocate方法(可以在堆上分配，也可以在直接内存上分配)。</p>
<p>​        分配48字节capacity的ByteBuffer的例子:ByteBuffer buf = ByteBuffer.allocate(48);</p>
<p>​        分配一个可存储1024个字符的CharBuffer：CharBuffer buf = CharBuffer.allocate(1024);</p>
<p>​        wrap方法：把一个byte数组或byte数组的一部分包装成ByteBuffer：</p>
<p>​        ByteBuffer wrap(byte [] array)</p>
<p>​        ByteBuffer wrap(byte [] array, int offset, int length) </p>
<h4><span id="直接内存">直接内存</span></h4><p>​        HeapByteBuffer与DirectByteBuffer，在原理上，前者可以看出分配的buffer是在heap区域的，其实真正flush到远程的时候会先拷贝到直接内存，再做下一步操作；在NIO的框架下，很多框架会采用DirectByteBuffer来操作，这样分配的内存不再是在java heap上，经过性能测试，可以得到非常快速的网络交互，在大量的网络交互下，一般速度会比HeapByteBuffer要快速好几倍。</p>
<p>​        直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。</p>
<p>​        NIO可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。</p>
<h5><span id="直接内存堆外内存与堆内存比较">直接内存（堆外内存）与堆内存比较</span></h5><p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显<br>直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显</p>
<h4><span id="buffer的读写">Buffer的读写</span></h4><h5><span id="向buffer中写数据">向Buffer中写数据</span></h5><p><strong>写数据到Buffer有两种方式：</strong></p>
<ul>
<li>读取Channel写到Buffer。<ul>
<li>从Channel写到Buffer的例子<br>int bytesRead = inChannel.read(buf); //read into buffer.</li>
</ul>
</li>
<li>通过Buffer的put()方法写到Buffer里。<ul>
<li>通过put方法写Buffer的例子：<br>buf.put(127);<br>put方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如， 写到一个指定的位置，或者把一个字节数组写入到Buffer。在比如：<br>put(byte b) 相对写，向position的位置写入一个byte，并将postion+1，为下次读写作准备。</li>
</ul>
</li>
</ul>
<h5><span id="flip方法">flip()方法</span></h5><p>​        flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p>
<p>​    换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。</p>
<h5><span id="从buffer中读取数据">从Buffer中读取数据</span></h5><p>从Buffer中读取数据有两种方式：</p>
<ol>
<li>从Buffer读取数据写入到Channel。<ol>
<li>从Buffer读取数据到Channel的例子：<br>int bytesWritten = inChannel.write(buf);</li>
</ol>
</li>
<li>使用get()方法从Buffer中读取数据。<ol>
<li>使用get()方法从Buffer中读取数据的例子<br>byte aByte = buf.get();<br>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组，再比如<br>get()属于相对读，从position位置读取一个byte，并将position+1，为下次读写作准备;</li>
</ol>
</li>
</ol>
<h5><span id="使用buffer读写数据常见步骤">使用Buffer读写数据常见步骤</span></h5><ol>
<li>   写入数据到Buffer</li>
<li>   调用flip()方法</li>
<li>   从Buffer中读取数据</li>
<li>   调用clear()方法或者compact()方法，准备下一次的写入</li>
</ol>
<p>​        当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</p>
<p>​        一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。</p>
<h5><span id="其他常用操作">其他常用操作</span></h5><p><strong>绝对读写</strong></p>
<p>​        put(int index, byte b) 绝对写，向byteBuffer底层的bytes中下标为index的位置插入byte b，不改变position的值。<br>​         get(int index)属于绝对读，读取byteBuffer底层的bytes中下标为index的byte，不改变position。<br>​        更多Buffer实现的细节参考JavaDoc。</p>
<p><strong>rewind()方法</strong></p>
<p>​        Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p>
<p><strong>clear()与compact()方法</strong></p>
<p>​        一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。<br>​        如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。<br>​        如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。<br>​        如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。<br>​        compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
<p><strong>mark()与reset()方法</strong></p>
<p>​        通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如：<br>​        buffer.mark();//call buffer.get() a couple of times, e.g. during parsing.<br>​        buffer.reset(); //set position back to mark.</p>
<p><strong>equals()与compareTo()方法</strong></p>
<p>​        可以使用equals()和compareTo()方法两个Buffer。<br><strong>equals()</strong></p>
<p>当满足下列条件时，表示两个Buffer相等：</p>
<ol>
<li>   有相同的类型（byte、char、int等）。</li>
<li>   Buffer中剩余的byte、char等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。<br>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</li>
</ol>
<p><strong>compareTo()方法</strong></p>
<p>​        compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p>
<ol>
<li>   第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>   所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li>
</ol>
<h3><span id="原生jdk网络编程-nio实战">原生JDK网络编程-NIO实战</span></h3><p><strong>NioServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NioServerHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        handler = <span class="keyword">new</span> NioServerHandler(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(handler, <span class="string">&quot;Server&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started;</span><br><span class="line">        <span class="keyword">private</span> ServerSocketChannel serverChannel;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NioServerHandler</span><span class="params">(Integer port)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//打开监听通道</span></span><br><span class="line">                serverChannel = ServerSocketChannel.open();</span><br><span class="line">                <span class="comment">//实例一个selector</span></span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                <span class="comment">//设置非阻塞模式,true为阻塞模式</span></span><br><span class="line">                serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                serverChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">                <span class="comment">//注册OP_ACCEPT事件,表明serverChannel对客户端连接事件感兴趣</span></span><br><span class="line">                serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">                started = <span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器已启动，端口号：&quot;</span> + port);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (started) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每隔一秒被唤醒一次，如果有事件产生也会被唤醒</span></span><br><span class="line">                    selector.select(<span class="number">1000</span>);</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        key = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            handlerInput(key);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                key.cancel();</span><br><span class="line">                                <span class="keyword">if</span> (key.channel() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    key.channel().close();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出循环 selector也要关闭</span></span><br><span class="line">            <span class="keyword">if</span> (selector != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlerInput</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (key.isValid()) &#123;</span><br><span class="line">                <span class="comment">//当前连接进来我们需要处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel sc = channel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;有客户端连接&quot;</span>);</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//读数据</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">//从channel读写到buffer,返回值表示我们从channel读取了多少数据</span></span><br><span class="line">                    <span class="keyword">int</span> readBytes = sc.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (readBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//因为channel写入buffer,所以要进行切换。</span></span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[readBytes];</span><br><span class="line">                        <span class="comment">//从buffer读出来写到byte数组</span></span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line">                        <span class="comment">//转换成String</span></span><br><span class="line">                        String message = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;服务器收到消息：&quot;</span> + message);</span><br><span class="line">                        String result = message + <span class="string">&quot;的回执消息&quot;</span>;</span><br><span class="line">                        doWrite(sc, result);</span><br><span class="line">                        <span class="comment">//表示链路已经关闭，释放资源</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        key.cancel();</span><br><span class="line">                        sc.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SocketChannel sc, String result)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = result.getBytes();</span><br><span class="line">            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">            <span class="comment">//将字节数组写入buffer</span></span><br><span class="line">            writeBuffer.put(bytes);</span><br><span class="line">            writeBuffer.flip();</span><br><span class="line">            <span class="comment">//从buffer中读取写往channel</span></span><br><span class="line">            sc.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            started = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NioClient</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NioClientHandler nioClientHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (NioClient.sendMsg(scanner.next())) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nioClientHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nioClientHandler.sendMsg(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nioClientHandler = <span class="keyword">new</span> NioClientHandler(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(nioClientHandler, <span class="string">&quot;client&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClientHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String host;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started;</span><br><span class="line">        <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NioClientHandler</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.host = host;</span><br><span class="line">            <span class="keyword">this</span>.port = port;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                socketChannel = SocketChannel.open();</span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                started = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            started = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doConnect();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (started) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每隔一秒被唤醒一次，如果有事件产生也会被唤醒</span></span><br><span class="line">                    selector.select(<span class="number">1000</span>);</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        key = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            handlerInput(key);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                key.cancel();</span><br><span class="line">                                <span class="keyword">if</span> (key.channel() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    key.channel().close();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出循环 selector也要关闭</span></span><br><span class="line">            <span class="keyword">if</span> (selector != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//非阻塞方法,如果为true表示连接完成,如果为false表示未完成还在三次握手</span></span><br><span class="line">            <span class="keyword">if</span> (socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(host, port))) &#123;</span><br><span class="line">                socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//selector要告诉我连接已经完成</span></span><br><span class="line">                socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlerInput</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (key.isValid()) &#123;</span><br><span class="line">                SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                <span class="comment">//连接事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sc.finishConnect()) &#123;</span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.exit(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//读数据</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">//从channel读写到buffer,返回值表示我们从channel读取了多少数据</span></span><br><span class="line">                    <span class="keyword">int</span> readBytes = sc.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (readBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//因为channel写入buffer,所以要进行切换。</span></span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[readBytes];</span><br><span class="line">                        <span class="comment">//从buffer读出来写到byte数组</span></span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line">                        <span class="comment">//转换成String</span></span><br><span class="line">                        String message = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端收到消息：&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//表示链路已经关闭，释放资源</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        key.cancel();</span><br><span class="line">                        sc.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SocketChannel sc, String result)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = result.getBytes();</span><br><span class="line">            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">            <span class="comment">//将字节数组写入buffer</span></span><br><span class="line">            writeBuffer.put(bytes);</span><br><span class="line">            writeBuffer.flip();</span><br><span class="line">            <span class="comment">//从buffer中读取写往channel</span></span><br><span class="line">            <span class="comment">/*关心事件和读写网络并不冲突*/</span></span><br><span class="line">            sc.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            doWrite(socketChannel, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、 Selector对象是通过调用静态工厂方法open()来实例化的，如下：<br>Selector Selector=Selector.open()；</p>
<p>2、要实现Selector管理Channel，需要将channel注册到相应的Selector上，如下：<br>        channel.configureBlocking(false);<br>        SelectionKey key= channel.register(selector,SelectionKey,OP_READ);</p>
<p>​        通过调用通道的register()方法会将它注册到一个选择器上。与Selector一起使用时，Channel必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常，这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字通道都可以。另外通道一旦被注册，将不能再回到阻塞状态，此时若调用通道的configureBlocking(true)将抛出BlockingModeException异常。</p>
<p>​        register()方法的第二个参数是“interest集合”，表示选择器所关心的通道操作，它实际上是一个表示选择器在检查通道就绪状态时需要关心的操作的比特掩码。比如一个选择器对通道的read和write操作感兴趣，那么选择器在检查该通道时，只会检查通道的read和write操作是否已经处在就绪状态。</p>
<p>​        具体的操作类型和通道上能被支持的操作类型前面已经讲述过。<br>​        如果Selector对通道的多操作类型感兴趣，可以用“位或”操作符来实现：<br>​        int interestSet=SelectionKey.OP_READ|SelectionKey.OP_WRITE;</p>
<p>​        同时 一个 Channel 仅仅可以被注册到一个 Selector 一次, 如果将 Channel 注册到 Selector 多次, 那么其实就是相当于更新 SelectionKey 的 interest set。</p>
<p>​        通过SelectionKey可以判断Selector是否对Channel的某种事件感兴趣，比如<br>​        int interestSet = selectionKey.interestOps();<br>​        boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</p>
<p>​        通过SelctionKey对象的readyOps()来获取相关通道已经就绪的操作。它是interest集合的子集，并且表示了interest集合中从上次调用select()以后已经就绪的那些操作。JAVA中定义几个方法用来检查这些操作是否就绪，比如selectionKey.isAcceptable();</p>
<p>​        同时，通过SelectionKey可以取出这个SelectionKey所关联的Selector和Channel。<br>​        如果我们要取消关联关系，怎么办？SelectionKey对象的cancel()方法来取消特定的注册关系。</p>
<p>​        在实际的应用中，我们还可以为SelectionKey绑定附加对象，在需要的时候取出。<br>​        SelectionKey key=channel.register(selector,SelectionKey.OP_READ,theObject);<br>​        或selectionKey.attach(theObject);</p>
<p>​        取出这个附加对象，通过：<br>​        Object attachedObj = key.attachment();<br>3、在实际运行中，我们通过Selector的select（）方法可以选择已经准备就绪的通道（这些通道包含你感兴趣的的事件）。</p>
<p>​        下面是Selector几个重载的select()方法：<br>​        select():阻塞到至少有一个通道在你注册的事件上就绪了。<br>​        select(long timeout)：和select()一样，但最长阻塞时间为timeout毫秒。<br>​        selectNow():非阻塞，立刻返回。<br>​        select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。<br>​        一旦调用select()方法，并且返回值不为0时，则可以通过调用Selector的selectedKeys()方法来访问已选择键集合。<br>Set selectedKeys=selector.selectedKeys();<br>​        这个时候，循环遍历selectedKeys集中的每个键，并检测各个键所对应的通道的就绪事件，再通过SelectionKey关联的Selector和Channel进行实际的业务处理。</p>
<p>​        注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除，否则的话，下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p>
<h3><span id="原生jdk网络编程-nio之reactor模式">原生JDK网络编程- NIO之Reactor模式</span></h3><p>见：2020.12.17 Java原生网络编程 4   00:21:20</p>
<h3><span id="网络协议常见面试题">网络协议常见面试题</span></h3><h4><span id="说一下-tcp-的三次握手过程">说一下 TCP 的三次握手过程</span></h4><h4><span id="解释一下-tcp-的四次挥手">解释一下 TCP 的四次挥手</span></h4><h4><span id="哪些应用比较适合用-udp-实现">哪些应用比较适合用 udp 实现</span></h4><p>​        多播的信息一定要用 udp 实现，因为 tcp 只支持一对一通信。</p>
<p>​        如果一个应用场景中大多是简短的信息，适合用 udp 实现，因为 udp 是基于报文段的，它直接对上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输效率。</p>
<p>​        如果一个应用场景重性能甚于重完整性和安全性，那么适合于 udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达的速度快，因此比较适合用 udp。</p>
<p>​        如果要求快速响应，那么 udp 听起来比较合适。</p>
<p>​        如果又要利用 udp 的快速响应优点，又想可靠传输，那么只能考上层应用自己制定规则了，比如 UDT。</p>
<p>​        常见的使用 udp 的例子：ICQ,QQ 的聊天模块、DNS 等等。</p>
<h4><span id="如果要你来设计一个-qq在网络协议上你会考虑如何设计">如果要你来设计一个 QQ，在网络协议上你会考虑如何设计？</span></h4><p>​        登陆采用 TCP 协议和 HTTP 协议，你和好友之间发送消息，主要采用 UDP 协议，内网传文件采用了 P2P 技术。总来的说：<br>​        1.登陆过程，客户端 client 采用 TCP 协议向服务器 server 发送信息，HTTP协议下载信息。登陆之后，会有一个 TCP 连接来保持在线状态。</p>
<p>​        2.和好友发消息，客户端 client 采用 UDP 协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。</p>
<p>​        3.如果是在内网里面的两个客户端传文件，QQ 采用的是 P2P 技术，不需要服务器中转。</p>
<h4><span id="http-与-https-的区别">Http 与 Https 的区别：</span></h4><p>​        HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为 HTTP+SSL/TLS，通过 SSL 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p>
<p>​        HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头</p>
<p>​        HTTP 是不安全的，而 HTTPS 是安全的</p>
<p>​        HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443</p>
<p>​        在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层</p>
<p>​        HTTP 无法加密，而 HTTPS 对传输的数据进行加密</p>
<p>​        HTTP 无需证书，而 HTTPS 需要 CA 机构颁发的 SSL 证书</p>
<h4><span id="https-方式与-web-服务器通信时的步骤">HTTPS 方式与 Web 服务器通信时的步骤</span></h4><p>​        （1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立SSL 连接。</p>
<p>​        （2）Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含服务器公钥&lt;非对称加密&gt;）传送一份给客户端。(HTTPS 中，服务端将公钥发给数字证书认证机构进行安全认证并对公钥进行数字签名，完成后公钥和签名组合成数字证书。在和客户端通信时，服务端将数字证书发给客户端，客户端通过第三方安全认证机构（一般会在浏览器开发时，内置在浏览器中）对数字证书上的签名进行验证。)</p>
<p>（3）客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。</p>
<p>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥&lt;对称加密&gt;，然后利用服务器公钥将会话密钥加密，并传送给网站。</p>
<p>（5）Web 服务器利用自己的私钥解密出会话密钥。</p>
<p>（6）Web 服务器利用会话密钥加密与客户端之间的通信。</p>
<h4><span id="tcp-粘包拆包的原因及解决方法">TCP 粘包/拆包的原因及解决方法？</span></h4><p>​        TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p>
<p><strong>TCP 粘包/分包的原因：</strong><br>        应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；<br>        进行 MSS 大小的 TCP 分段，当 TCP 报文长度-TCP 头部长度&gt;MSS 的时候将发生拆包<br>        以太网帧的 payload（净荷）大于 MTU（1500 字节）进行 ip 分片。</p>
<p><strong>解决方法</strong></p>
<ol>
<li>消息定长：FixedLengthFrameDecoder 类</li>
<li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder 或自定义分</li>
<li>隔符类 ：DelimiterBasedFrameDecoder<br>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头<br>部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘<br>包。</li>
</ol>
<h4><span id="select-poll-epoll-的区别">select、poll、epoll 的区别？</span></h4><p>​        select，poll，epoll 都是 操作系统实现 IO 多路复用的机制。 我们知道，I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。那么这三种机制有什么区别呢。</p>
<p>1、支持一个进程所能打开的最大连接数</p>
<table>
<thead>
<tr>
<th>select</th>
<th>单个进程所能打开的最大连接数有 FD_SETSIZE 宏定义，其大小是 32 个整数的大小（在 32 位的机器上，大小就是 32<em>32，同理 64 位机器上 FD_SETSIZE 为 32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响。</th>
</tr>
</thead>
<tbody><tr>
<td>poll</td>
<td>poll 本质上和 select 没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td>
</tr>
<tr>
<td>epoll</td>
<td>连接数基本上只受限于机器的内存大小</td>
</tr>
</tbody></table>
<p>2、FD 剧增后带来的 IO 效率问题</p>
<table>
<thead>
<tr>
<th>select</th>
<th>因为每次调用时都会对连接进行线性遍历，所以随着 FD 的增加会造成遍历速度慢的“线性下降性能问题”。</th>
</tr>
</thead>
<tbody><tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>因为 epoll 内核中实现是根据每个 fd 上的 callback 函数来实现的，只有活跃的 socket 才会主动调用 callback，所以在活跃socket 较少的情况下，使用 epoll 没有前面两者的线性下降的性能问题，但是所有 socket 都很活跃的情况下，可能会有性能问题。</td>
</tr>
</tbody></table>
<p>3、 消息传递方式</p>
<table>
<thead>
<tr>
<th>select</th>
<th>内核需要将消息传递到用户空间，都需要内核拷贝动作</th>
</tr>
</thead>
<tbody><tr>
<td>poll</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>epoll 通过内核和用户空间共享一块内存来实现的。</td>
</tr>
</tbody></table>
<p><strong>总结：</strong><br>        综上，在选择 select，poll，epoll 时要根据具体的使用场合以及这三种方式的自身特点。</p>
<p>1、表面上看 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调。</p>
<p>2、select 低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p>
<h4><span id="什么是水平触发lt和边缘触发et">什么是水平触发(LT)和边缘触发(ET)？</span></h4><p>​        Level_triggered(水平触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！</p>
<p>​        Edge_triggered(边缘触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！select(),poll()模型都是水平触发模式，信号驱动 IO 是边缘触发模式，epoll()模型即支持水平触发，也支持边缘触发，默认是水平触发。</p>
<h4><span id="堆外内存的优点和缺点">堆外内存的优点和缺点</span></h4><p><strong>堆外内存相比于堆内内存有几个优势：</strong>        </p>
<p>​        1 减少了垃圾回收的工作，因为垃圾回收会暂停其他的工作（可能使用多线程或者时间片的方式，根本感觉不到）<br>​        2 加快了复制的速度。因为堆内在 flush 到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。</p>
<p><strong>而福之祸所依，自然也有不好的一面：</strong></p>
<p>1 堆外内存难以控制，如果内存泄漏，那么很难排查</p>
<p>2 堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合。</p>
<h3><span id="零拷贝">零拷贝</span></h3><h4><span id="什么是零拷贝">什么是零拷贝?</span></h4><p>​        零拷贝(英语: Zero-copy) 技术是指计算机执行操作时，CPU 不需要先将数据<br>从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU 周期和内存带宽。</p>
<ul>
<li>零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率</li>
<li>零拷贝技术减少了用户进程地址空间和内核地址空间之间因为上下文切换而带来的开销</li>
</ul>
<p>可以看出没有说不需要拷贝，只是说减少冗余[不必要]的拷贝。</p>
<p>下面这些组件、框架中均使用了零拷贝技术：Kafka、Netty、Rocketmq、Nginx、<br>Apache。</p>
<h4><span id="linux-支持的常见零拷贝">Linux 支持的(常见)零拷贝</span></h4><h5><span id="mmap-内存映射">mmap 内存映射</span></h5><p>​        硬盘上文件的位置和应用程序缓冲区(application buffers)进行映射（建立一种一一对应关系），由于 mmap()将文件直接映射到用户空间，所以实际文件读取时根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝，不再有文件内容从硬盘拷贝到内核空间的一个缓冲区。</p>
<p>​        mmap 内存映射将会经历：3 次拷贝: 1 次 cpu copy，2 次 DMA copy；</p>
<p>​        以及 4 次上下文切换</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/mmap.png" alt="mmap"></p>
<h5><span id="sendfile">sendfile</span></h5><p>​        linux 2.1 支持的 sendfile<br>​        当调用 sendfile()时，DMA 将磁盘数据复制到 kernel buffer，然后将内核中的kernel buffer 直接拷贝到 socket buffer。在硬件支持的情况下，甚至数据都并不需要被真正复制到 socket 关联的缓冲区内。取而代之的是，只有记录数据位置和长度的描述符被加入到 socket 缓冲区中，DMA 模块将数据直接从内核缓冲区传递给协议引擎，从而消除了遗留的最后一次复制。<br>​        一旦数据全都拷贝到 socket buffer，sendfile()系统调用将会 return，代表数<br>据转化的完成。socket buffer 里的数据就能在网络传输了。</p>
<p>​        sendfile 会经历：3 次拷贝，1 次 CPU copy ，2 次 DMA copy；硬件支持的情况下，则是 2 次拷贝，0 次 CPU copy， 2 次 DMA copy。</p>
<p>​        以及 2 次上下文切换</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/sendfile.png" alt="sendfile"></p>
<h5><span id="splice">splice</span></h5><p>​        Linux 从 2.6.17 支持 splice<br>​        数据从磁盘读取到 OS 内核缓冲区后，在内核缓冲区直接可将其转成内核空间其他数据 buffer，而不需要拷贝到用户空间。<br>​        如下图所示，从磁盘读取到内核 buffer 后，在内核空间直接与 socket buffer建立 pipe 管道。<br>​        和 sendfile()不同的是，splice()不需要硬件支持。<br>​        注意 splice 和 sendfile 的不同，sendfile 是将磁盘数据加载到 kernel buffer 后，需要一次 CPU copy，拷贝到 socket buffer。而 splice 是更进一步，连这个 CPU copy也不需要了，直接将两个内核空间的 buffer 进行 pipe。</p>
<p>​        splice 会经历 2 次拷贝: 0 次 cpu copy 2 次 DMA copy；</p>
<p>​        以及 2 次上下文切换</p>
<p><img src="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/splice.png" alt="splice"></p>
<h2><span id="操作系统和jdk对网络通信的实现">操作系统和JDK对网络通信的实现</span></h2><p>见：2020.12.20 操作系统和JDK对网络通信的实现</p>
<p>笔记-网络协议和编程.pdf</p>


	<div class="row">
    <embed src="/pdf/笔记-网络协议和编程.pdf" width="100%" height="550" type="application/pdf">
	</div>




</div><div class="article-licensing box"><div class="licensing-title"><p>Java网络编程</p><p><a href="http://example.com/2025/06/15/网络编程/">http://example.com/2025/06/15/网络编程/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://example.com"><p>Lis</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-06-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-06-15</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2025/05/28/JVM/" target="_blank">JVM</a><br></span><span>  2.<a class="is-size-6" href="/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%B8%8B/" target="_blank">注解与反射（下）</a><br></span><span>  3.<a class="is-size-6" href="/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/" target="_blank">注解与反射（上）</a><br></span><span>  4.<a class="is-size-6" href="/2021/11/28/%E6%B3%9B%E5%9E%8B/" target="_blank">泛型</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/06/15/view/" target="_blank">View基础</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/06/13/setContentView%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"><span class="level-item">setContentView流程分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '8aa616adcdce489684cd911204ecd549',
            repo: 'gitalk',
            owner: 'xunyixiangchao',
            clientID: '9e8b7b8cef8759344d50',
            clientSecret: 'e5ef7e0a75d0431208a8fc15f1b41bd45bf0ca2d',
            admin: ["xunyixiangchao"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/2018.jpg" alt="Lis"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Lis</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xunyixiangchao" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xunyixiangchao"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/xunyixiangchao"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:Lis@163.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Next" href="https://xunyixiangchao.github.io/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-15T07:21:54.000Z">2025-06-15</time></p><p class="title"><a href="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Java网络编程</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/">Java基础与进阶</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-13T06:14:54.000Z">2025-06-13</time></p><p class="title"><a href="/2025/06/13/setContentView%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">setContentView流程分析</a></p><p class="categories"><a href="/categories/Android%E6%BA%90%E7%A0%81/">Android源码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-11T09:08:54.000Z">2025-06-11</time></p><p class="title"><a href="/2025/06/11/Android%E7%9A%84ClassLoader/">Android-ClassLoader介绍</a></p><p class="categories"><a href="/categories/Android%E6%BA%90%E7%A0%81/">Android源码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-28T09:16:56.000Z">2025-05-28</time></p><p class="title"><a href="/2025/05/28/JVM/">JVM</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/">Java基础与进阶</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-15T08:51:54.000Z">2025-05-15</time></p><p class="title"><a href="/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%B8%8B/">注解与反射（下）</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/">Java基础与进阶</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">Android三方库源码分析</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android%E6%BA%90%E7%A0%81/"><span class="level-start"><span class="level-item">Android源码</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"><span class="level-start"><span class="level-item">Java基础与进阶</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/06/"><span class="level-start"><span class="level-item">六月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android%E6%BA%90%E7%A0%81/"><span class="tag">Android源码</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"><span class="tag">动态代理</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%B0%84/"><span class="tag">反射</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%A8%E8%A7%A3/"><span class="tag">注解</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OkHttp/"><span class="tag">OkHttp</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/View/"><span class="tag">View</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/activity/"><span class="tag">activity</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dispatch/"><span class="tag">dispatch</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/setContentView/"><span class="tag">setContentView</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%9B%E5%9E%8B/"><span class="tag">泛型</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"><span class="tag">热修复</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><span class="tag">类加载</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2018.jpg" alt="Lis" height="28"></a><p class="size-small"><span>&copy; 2025 Lis</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://xunyixiangchao.github.io/"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9e8b7b8cef8759344d50','e5ef7e0a75d0431208a8fc15f1b41bd45bf0ca2d','xunyixiangchao','gitalk',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9e8b7b8cef8759344d50','e5ef7e0a75d0431208a8fc15f1b41bd45bf0ca2d','xunyixiangchao','gitalk',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>