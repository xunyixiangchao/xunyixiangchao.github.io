<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>第三章 认识系统组件 - Lis</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Lis"><meta name="msapplication-TileImage" content="/img/2018.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Lis"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="[转]安卓系统定制：从入门到实践    3.1 源码结构介绍 3.2 Android系统启动流程 3.3 内核启动 3.4 Init进程启动 3.5 init.rc 3.6 Zygote启动 3.7 Android app应用启动 3.8 了解Service 3.9 了解Framework 3.10 了解libcore 3.11 了解sepolicy 3.12 了解Linker 3.12.1 EL"><meta property="og:type" content="blog"><meta property="og:title" content="Lis"><meta property="og:url" content="https://xunyixiangchao.github.io/"><meta property="og:site_name" content="Lis"><meta property="og:description" content="[转]安卓系统定制：从入门到实践    3.1 源码结构介绍 3.2 Android系统启动流程 3.3 内核启动 3.4 Init进程启动 3.5 init.rc 3.6 Zygote启动 3.7 Android app应用启动 3.8 了解Service 3.9 了解Framework 3.10 了解libcore 3.11 了解sepolicy 3.12 了解Linker 3.12.1 EL"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xunyixiangchao.github.io/img/2018.jpg"><meta property="article:published_time" content="2025-04-07T03:45:54.000Z"><meta property="article:modified_time" content="2025-04-07T03:45:52.429Z"><meta property="article:author" content="Lis"><meta property="article:tag" content="Android源码"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/2018.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2025/04/07/chapter-03/"},"headline":"Lis","image":["http://example.com/2025/04/07/chapter-03/startkernel.png","http://example.com/2025/04/07/chapter-03/android-boot.jpg","http://example.com/2025/04/07/chapter-03/android-framework.jpg","http://example.com/2025/04/07/chapter-03/image-20230304135859598.png","http://example.com/2025/04/07/chapter-03/image-20230304140328010.png","http://example.com/2025/04/07/chapter-03/image-20230304141143199.png","http://example.com/2025/04/07/chapter-03/image-20230304142500744.png","http://example.com/2025/04/07/chapter-03/image-20230304143100841.png","http://example.com/2025/04/07/chapter-03/image-20230304143003972.png"],"datePublished":"2025-04-07T03:45:54.000Z","dateModified":"2025-04-07T03:45:52.429Z","author":{"@type":"Person","name":"Lis"},"description":"[转]安卓系统定制：从入门到实践    3.1 源码结构介绍 3.2 Android系统启动流程 3.3 内核启动 3.4 Init进程启动 3.5 init.rc 3.6 Zygote启动 3.7 Android app应用启动 3.8 了解Service 3.9 了解Framework 3.10 了解libcore 3.11 了解sepolicy 3.12 了解Linker 3.12.1 EL"}</script><link rel="canonical" href="http://example.com/2025/04/07/chapter-03/"><link rel="icon" href="/img/2018.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Lis" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2018.jpg" alt="Lis" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://xunyixiangchao.github.io/"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://xunyixiangchao.github.io/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-04-07  <a class="commentCountImg" href="/2025/04/07/chapter-03/#comment-container"><span class="display-none-class">f52d1707a186fa63bd879736c1bdf0aa</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="f52d1707a186fa63bd879736c1bdf0aa">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>3 小时  <i class="fas fa-pencil-alt"> </i>28.9 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">第三章 认识系统组件</h1><div class="content"><p><strong>[转]安卓系统定制：从入门到实践</strong></p>
<!-- toc -->

<ul>
<li><a href="#31-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D">3.1 源码结构介绍</a></li>
<li><a href="#32-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">3.2 Android系统启动流程</a></li>
<li><a href="#33-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8">3.3 内核启动</a></li>
<li><a href="#34-init%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8">3.4 Init进程启动</a></li>
<li><a href="#35-initrc">3.5 init.rc</a></li>
<li><a href="#36-zygote%E5%90%AF%E5%8A%A8">3.6 Zygote启动</a></li>
<li><a href="#37-android-app%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8">3.7 Android app应用启动</a></li>
<li><a href="#38-%E4%BA%86%E8%A7%A3service">3.8 了解Service</a></li>
<li><a href="#39-%E4%BA%86%E8%A7%A3framework">3.9 了解Framework</a></li>
<li><a href="#310-%E4%BA%86%E8%A7%A3libcore">3.10 了解libcore</a></li>
<li><a href="#311-%E4%BA%86%E8%A7%A3sepolicy">3.11 了解sepolicy</a></li>
<li><a href="#312-%E4%BA%86%E8%A7%A3linker">3.12 了解Linker</a><ul>
<li><a href="#3121-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">3.12.1 ELF文件格式</a></li>
<li><a href="#3122-%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B">3.12.2 动态库加载流程</a></li>
</ul>
</li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
<!-- tocstop -->

<p>在上一章的学习中，我们成功编译了<code>Android</code>12，以及对应的系统内核，并且通过多种方式刷入手机。接下来需要先对<code>Android</code>源码的根结构有一定的了解，了解结构有助于更快地定位和分析源码，同时能让开发人员更好地理解<code>Android</code>系统。在修改系统时，有些简单的功能（例如<code>native</code>中的文件读写、<code>java</code>类型的转换<code>c++</code>类型等）并不需要我们重新实现，因为这些需求大多数在<code>Android</code>系统源码中都有类似的实现，熟练掌握<code>Android</code>系统源码，了解系统中常用的那些功能性函数，可以大大提高定制系统的效率。</p>
<p><strong>在学习系统源码时，碰到问题，要学会暂时记录并跳过，经历过一遍遍学习和实践后，之前遇到的问题可能简单思考便会明白，这不仅节省了时间，也不会在学习过程中逐渐失去信心。</strong></p>
<a id="more"></a>


<h2><span id="31-源码结构介绍">3.1 源码结构介绍</span></h2><p>​    首先看看<code>Android</code>源码根目录下，各个目录的简单介绍。</p>
<ol>
<li><code>art</code>：该目录是在<code>Android</code> 5.0中新增加的，主要是实现<code>Android RunTime（ART）</code>的目录，它作为<code>Android</code> 4.4中的<code>Dalvik</code>虚拟机的替代，主要处理<code>Java</code>字节码执行。</li>
<li><code>bionic</code>：<code>Android</code>的<code>C</code>库，包含了很多标准的<code>C</code>库函数和头文件，还有一些<code>Android</code>特有的函数和头文件。</li>
<li><code>build</code>：该目录包含了编译<code>Android</code>源代码所需要的脚本，包括<code>makefile</code>文件和一些构建工具。</li>
<li><code>compatibility</code>：<code>Android</code>设备的兼容性测试套件<code>（CTS）</code>和兼容性实现<code>（Compatibility Implementation）</code>。</li>
<li><code>cts</code>：<code>Android</code>设备兼容性测试套件<code>（CTS）</code>，主要用来测试设备是否符合<code>Android</code>标准。</li>
<li><code>dalvik</code>：<code>Dalvik</code>虚拟机，它是<code>Android 2.3</code>版本之前的主要虚拟机，它主要处理<code>Java</code>字节码执行。</li>
<li><code>developers</code>：<code>Android</code>开发者文档和样例代码。</li>
<li><code>development</code>：调试工具，如<code>systrace、monkey、ddms</code>等。</li>
<li><code>device</code>：特定的<code>Android</code>设备的驱动程序。</li>
<li><code>external</code>：第三方库，如<code>WebKit、OpenGL</code>等。</li>
<li><code>frameworks</code>：<code>Android</code>应用程序调用底层服务的<code>API</code>。</li>
<li><code>hardware</code>：<code>Android</code>设备硬件相关的驱动代码，如摄像头驱动、蓝牙驱动等。</li>
<li><code>kernel</code>：<code>Android</code>系统内核的源代码，它是<code>Android</code>系统的核心部分。</li>
<li><code>libcore</code>：<code>Android</code>底层库，它提供了一些基本的<code>API</code>，如文件系统操作、网络操作等。</li>
<li><code>packages</code>：<code>Android</code>系统中的系统应用程序的源码，例如短信、电话、浏览器、相机等</li>
<li><code>pdk</code>：<code>Android</code>平台开发套件，它包含了一些工具和<code>API</code>，以便开发者快速开发Android应用程序。</li>
<li><code>platform_testing</code>：测试工具，用于测试<code>Android</code>平台的稳定性和性能。</li>
<li><code>prebuilts</code>：预先编译的文件，如编译工具、驱动程序等。</li>
<li><code>sdk</code>：<code>Android SDK</code>的源代码，<code>Android SDK</code>的<code>API</code>文档、代码示例、工具等。</li>
<li><code>system</code>：<code>Android</code>系统的核心部分，如系统服务、应用程序、内存管理机制、文件系统、网络协议等。</li>
<li><code>test</code>：测试代码，用于测试<code>Android</code>系统的各个组件。</li>
<li><code>toolchain</code>：编译器和工具链，如<code>GCC、Clang</code>等，用于编译<code>Android</code>源代码。</li>
<li><code>tools</code>：开发工具，如<code>Android SDK</code>工具、<code>Android Studio、Eclipse</code>等。</li>
<li><code>vendor</code>：硬件厂商提供的驱动程序，如摄像头驱动、蓝牙驱动等。</li>
</ol>
<p>​    在上述目录中，并不需要全部记下，只需要记住几个重点即可，例如<code>art、framework、libcore、system、build</code>。在实践时，为了实现功能，查阅翻读源码时，就会不断加深你对这些目录划分的了解。</p>
<h2><span id="32-android系统启动流程">3.2 Android系统启动流程</span></h2><p>​    <code>Android</code>系统启动主要分为四个阶段：<code>Bootloader</code>阶段、<code>Kernel</code>阶段、<code>Init</code>进程阶段和<code>System Server</code>启动阶段，下面看一下这几个阶段的启动流程。</p>
<ol>
<li><code>Bootloader</code>阶段： 当手机或平板电脑开机时，首先会执行引导加载程序（<code>Bootloader</code>），它会在手机的<code>ROM</code>中寻找启动内核（<code>Kernel</code>）的镜像文件，并将其加载进<code>RAM</code>。在这个阶段，<code>Android</code>系统并没有完全启动，只是建立了基本的硬件和内核环境。</li>
<li><code>Kernel</code>阶段： <code>Kernel</code>阶段是<code>Android</code>启动的第二阶段，它主要负责初始化硬件设备、加载驱动程序、设置内存管理等。此外，<code>Kernel</code>还会加载<code>initramfs</code>，它是一个临时文件系统，包含了<code>init</code>程序和一些设备文件。</li>
<li><code>Init</code>进程阶段： <code>Kernel</code>会启动<code>init</code>进程，它是<code>Android</code>系统中的第一个用户空间进程。<code>Init</code>进程的主要任务是读取<code>init.rc</code>文件，并根据该文件中的配置信息启动和配置<code>Android</code>系统的各个组件。在这个阶段中，系统会依次启动各个服务和进程，包括启动<code>Zygote</code>进程和创建<code>System Server</code>进程。</li>
<li><code>System Server</code>启动阶段： <code>System Server</code>是<code>Android</code>系统的核心服务进程，它会启动所有的系统服务。其中包括<code>Activity Manager、Package Manager、Window Manager、Location Manager、Telephony Manager、Wi-Fi Service、Bluetooth Service</code>等。<code>System Server</code>启动后，<code>Android</code>系统就完全启动了，用户可以进入桌面，开始使用各种应用程序。</li>
</ol>
<p>​    在开始启动流程代码追踪前，最重要的是不要试图了解所有细节过程，分析代码时要抓住需求重点，然后围绕着需求点来进行深入分析。尽管<code>Android</code>源码是一个非常庞大的体系，选择一个方向来熟悉代码，这样就能快速的达成目标，避免深陷代码泥沼。</p>
<h2><span id="33-内核启动">3.3 内核启动</span></h2><p>​    <code>Bootloader</code>其实是一段程序，这个程序的主要功能就是用来引导系统启动，也称之为引导程序，而这个引导程序是存放在一个只读的寄存器中，从物理地址0开始的一段空间分配给了这个只读存储器来存放引导程序。</p>
<p>​    <code>Bootloader</code>会初始化硬件设备并准备内存空间映射，为启动内核准备环境。然后寻找内核的镜像文件，验证<code>boot</code>分区和<code>recovery</code>分区的完整性，然后将其加载到内存中，最后开始执行内核。可以通过命令<code>adb reboot bootloader</code>直接重启进入引导程序。</p>
<p>​    <code>Bootloader</code>初始化完成后，会在特定的物理地址处查找<code>EFI</code>引导头（<code>efi_head</code>）。如果查找到<code>EFI</code>引导头，<code>bootloader</code>就会加载<code>EFI</code>引导头指定的<code>EFI</code>引导程序，然后开始执行<code>EFI</code>引导程序，以进行后续的<code>EFI</code>引导流程。而这个<code>efi_head</code>就是<code>linux</code>内核最早的入口了。</p>
<p>​    不做系统引导开发的朋友，并不需要完全看懂内核中的汇编部分代码，了解其执行的流程即可，因此不需要读者有汇编的功底，只需要能看懂简单的几个指令即可。打开编译内核源码时的目录，找到文件<code>android-kernel/private/msm-google/arch/arm64/kernel/head.S</code>，查看其汇编代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	__HEAD</span><br><span class="line">_head:</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * This add instruction has no meaningful effect except that</span><br><span class="line">	 * its opcode forms the magic &quot;MZ&quot; signature required by UEFI.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	add	x13, x18, #0x16</span><br><span class="line">	b	stext</span><br><span class="line">#else</span><br><span class="line">	b	stext				&#x2F;&#x2F; branch to kernel start, magic</span><br></pre></td></tr></table></figure>

<p>​    在<code>arm</code>指令集中，指令<code>b</code>表示跳转，所以，继续找到<code>stext</code>的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;*</span><br><span class="line">	 * The following callee saved general purpose registers are used on the</span><br><span class="line">	 * primary lowlevel boot path:</span><br><span class="line">	 *</span><br><span class="line">	 *  Register   Scope                      Purpose</span><br><span class="line">	 *  x21        stext() .. start_kernel()  FDT pointer passed at boot in x0</span><br><span class="line">	 *  x23        stext() .. start_kernel()  physical misalignment&#x2F;KASLR offset</span><br><span class="line">	 *  x28        __create_page_tables()     callee preserved temp register</span><br><span class="line">	 *  x19&#x2F;x20    __primary_switch()         callee preserved temp registers</span><br><span class="line">	 *&#x2F;</span><br><span class="line">ENTRY(stext)</span><br><span class="line">	bl	preserve_boot_args			&#x2F;&#x2F; 把引导程序传的4个参数保存在全局数组boot_args</span><br><span class="line">	bl	el2_setup			&#x2F;&#x2F; Drop to EL1, w0&#x3D;cpu_boot_mode</span><br><span class="line">	adrp	x23, __PHYS_OFFSET</span><br><span class="line">	and	x23, x23, MIN_KIMG_ALIGN - 1	&#x2F;&#x2F; KASLR offset, defaults to 0</span><br><span class="line">	bl	set_cpu_boot_mode_flag</span><br><span class="line">	bl	__create_page_tables		&#x2F;&#x2F; 创建页表映射 x25&#x3D;TTBR0, x26&#x3D;TTBR1</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The following calls CPU setup code, see arch&#x2F;arm64&#x2F;mm&#x2F;proc.S for</span><br><span class="line">	 * details.</span><br><span class="line">	 * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class="line">	 * the TCR will have been set.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	bl	__cpu_setup			&#x2F;&#x2F; &#x2F;&#x2F; 初始化处理器 initialise processor</span><br><span class="line">	b	__primary_switch</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure>

<p>​    能看到最后一行是跳转到<code>__primary_switch</code>，接下来继续看它的实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__primary_switch:</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">	mov	x19, x0				&#x2F;&#x2F; preserve new SCTLR_EL1 value</span><br><span class="line">	mrs	x20, sctlr_el1			&#x2F;&#x2F; preserve old SCTLR_EL1 value</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	bl	__enable_mmu</span><br><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">	bl	__relocate_kernel</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">	ldr	x8, &#x3D;__primary_switched		&#x2F;&#x2F;将x8设置成__primary_switched的地址</span><br><span class="line">	adrp	x0, __PHYS_OFFSET</span><br><span class="line">	blr	x8							&#x2F;&#x2F;调用__primary_switched</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If we return here, we have a KASLR displacement in x23 which we need</span><br><span class="line">	 * to take into account by discarding the current kernel mapping and</span><br><span class="line">	 * creating a new one.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	msr	sctlr_el1, x20			&#x2F;&#x2F; disable the MMU</span><br><span class="line">	isb</span><br><span class="line">	bl	__create_page_tables		&#x2F;&#x2F; recreate kernel mapping</span><br><span class="line"></span><br><span class="line">	tlbi	vmalle1				&#x2F;&#x2F; Remove any stale TLB entries</span><br><span class="line">	dsb	nsh</span><br><span class="line">	isb</span><br><span class="line"></span><br><span class="line">	msr	sctlr_el1, x19			&#x2F;&#x2F; re-enable the MMU</span><br><span class="line">	isb</span><br><span class="line">	ic	iallu				&#x2F;&#x2F; flush instructions fetched</span><br><span class="line">	dsb	nsh				&#x2F;&#x2F; via old mapping</span><br><span class="line">	isb</span><br><span class="line"></span><br><span class="line">	bl	__relocate_kernel</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">	ldr	x8, &#x3D;__primary_switched</span><br><span class="line">	adrp	x0, __PHYS_OFFSET</span><br><span class="line">	br	x8</span><br><span class="line">ENDPROC(__primary_switch)</span><br></pre></td></tr></table></figure>

<p>​    继续跟踪<code>__primary_switched</code>函数，就能看到调用重点函数<code>start_kernel</code>了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">__primary_switched:</span><br><span class="line">	adrp	x4, init_thread_union</span><br><span class="line">	add	sp, x4, #THREAD_SIZE</span><br><span class="line">	adr_l	x5, init_task</span><br><span class="line">	msr	sp_el0, x5			&#x2F;&#x2F; Save thread_info</span><br><span class="line"></span><br><span class="line">	adr_l	x8, vectors			&#x2F;&#x2F; load VBAR_EL1 with virtual</span><br><span class="line">	msr	vbar_el1, x8			&#x2F;&#x2F; vector table address</span><br><span class="line">	isb</span><br><span class="line"></span><br><span class="line">	stp	xzr, x30, [sp, #-16]!</span><br><span class="line">	mov	x29, sp</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SHADOW_CALL_STACK</span><br><span class="line">	adr_l	x18, init_shadow_call_stack	&#x2F;&#x2F; Set shadow call stack</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	str_l	x21, __fdt_pointer, x5		&#x2F;&#x2F; Save FDT pointer</span><br><span class="line"></span><br><span class="line">	ldr_l	x4, kimage_vaddr		&#x2F;&#x2F; Save the offset between</span><br><span class="line">	sub	x4, x4, x0			&#x2F;&#x2F; the kernel virtual and</span><br><span class="line">	str_l	x4, kimage_voffset, x5		&#x2F;&#x2F; physical mappings</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Clear BSS</span><br><span class="line">	adr_l	x0, __bss_start</span><br><span class="line">	mov	x1, xzr</span><br><span class="line">	adr_l	x2, __bss_stop</span><br><span class="line">	sub	x2, x2, x0</span><br><span class="line">	bl	__pi_memset</span><br><span class="line">	dsb	ishst				&#x2F;&#x2F; Make zero page visible to PTW</span><br><span class="line">#ifdef CONFIG_KASAN</span><br><span class="line">	bl	kasan_early_init</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">	tst	x23, ~(MIN_KIMG_ALIGN - 1)	&#x2F;&#x2F; already running randomized?</span><br><span class="line">	b.ne	0f</span><br><span class="line">	mov	x0, x21				&#x2F;&#x2F; pass FDT address in x0</span><br><span class="line">	mov	x1, x23				&#x2F;&#x2F; pass modulo offset in x1</span><br><span class="line">	bl	kaslr_early_init		&#x2F;&#x2F; parse FDT for KASLR options</span><br><span class="line">	cbz	x0, 0f				&#x2F;&#x2F; KASLR disabled? just proceed</span><br><span class="line">	orr	x23, x23, x0			&#x2F;&#x2F; record KASLR offset</span><br><span class="line">	ldp	x29, x30, [sp], #16		&#x2F;&#x2F; we must enable KASLR, return</span><br><span class="line">	ret					&#x2F;&#x2F; to __primary_switch()</span><br><span class="line">0:</span><br><span class="line">#endif</span><br><span class="line">	b	start_kernel		&#x2F;&#x2F; 内核的入口函数</span><br><span class="line">ENDPROC(__primary_switched)</span><br></pre></td></tr></table></figure>

<p>​    上面能看到最后一个指令就是调用<code>start_kernel</code>了，这个函数是内核的入口函数，同时也是<code>C</code>语言部分的入口函数。接下来，查看文件<code>android-kernel/private/msm-google/init/main.c</code>，可以看到其中大量的<code>init</code>初始化各种子系统的函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加载各种子系统</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">	rest_init();</span><br><span class="line"></span><br><span class="line">	prevent_tail_call_optimization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    继续追踪关键的函数<code>rest_init</code>，在这里开启的内核初始化线程以及创建内核线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">void</span> __ref <span class="title">rest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">	numa_default_policy();</span><br><span class="line">	pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    继续看看<code>kernel_init</code>内核初始化线程的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __ref <span class="title">kernel_init</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">		ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">		       ramdisk_execute_command, ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这里，看到了原来<code>init</code>进程是用<code>run_init_process</code>启动的，<code>ramdisk_execute_command</code>被初始化为了”/init”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_run_init_process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = run_init_process(init_filename);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; ret != -ENOENT) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Starting init: %s exists but couldn&#x27;t execute it (error %d)\n&quot;</span>,</span><br><span class="line">		       init_filename, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单包装调用的<code>run_init_process</code>，继续看下面的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run_init_process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init_filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	argv_init[<span class="number">0</span>] = init_filename;</span><br><span class="line">	<span class="keyword">return</span> do_execve(getname_kernel(init_filename),</span><br><span class="line">		(<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)argv_init,</span><br><span class="line">		(<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *)envp_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里能看到最后是通过<code>execve</code>拉起来了系统的第一个进程，<code>init</code>进程。总结内核启动的简单流程图如下。</p>
<p><img src="/2025/04/07/chapter-03/startkernel.png" alt="startkernel"></p>
<h2><span id="34-init进程启动">3.4 Init进程启动</span></h2><p>​    <code>init</code>进程是<code>Android</code>系统的第一个进程，它在系统启动之后就被启动，并且一直运行到系统关闭，它是<code>Android</code>系统的核心进程，隶属于系统进程，具有最高的权限，所有的其他进程都是它的子进程，它的主要功能有以下几点：</p>
<p>​     1、启动<code>Android</code>系统的基础服务：<code>init</code>进程负责启动<code>Android</code>系统的基础服务。</p>
<p>​     2、管理系统进程：<code>init</code>进程管理系统进程，比如启动和关闭系统进程。</p>
<p>​     3、加载设备驱动：<code>init</code>进程会加载设备的驱动，使设备可以正常使用。</p>
<p>​     4、加载系统环境变量：<code>init</code>进程会加载系统所需要的环境变量，如<code>PATH、LD_LIBRARY_PATH</code>等。</p>
<p>​     5、加载系统配置文件：<code>init</code>进程会加载系统所需要的配置文件。</p>
<p>​     6、启动用户进程：<code>init</code>进程会启动用户进程，如桌面程序、默认浏览器等。</p>
<p>​    <code>init</code>进程的入口是在<code>Android</code>源码的<code>system/core/init/main.cpp</code>。下面，看看入口函数的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(address_sanitizer)</span></span><br><span class="line">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// Boost prio which will be restored later</span></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, <span class="number">-20</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">&quot;ueventd&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;subcontext&quot;</span>)) &#123;</span><br><span class="line">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 第二步 装载selinux策略</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SetupSelinux(argv);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 第三步</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;second_stage&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SecondStageMain(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 第一步 挂载设备节点，初次进入没有参数将执行这里</span></span><br><span class="line">    <span class="keyword">return</span> FirstStageMain(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    根据上一章的启动<code>init</code>的参数，可以判断第一次启动时执行的是<code>FirstStageMain</code>函数，继续看看这个函数的实现，可以看到初始化了一些基础系统支持的目录，以及使用<code>mount</code>进行挂载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    CHECKCALL(clearenv());</span><br><span class="line">    CHECKCALL(setenv(<span class="string">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line">    <span class="comment">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="string">&quot;mode=0755&quot;</span>));</span><br><span class="line">    CHECKCALL(mkdir(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mkdir(<span class="string">&quot;/dev/socket&quot;</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mkdir(<span class="string">&quot;/dev/dm-user&quot;</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="string">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAKE_STR</span></span><br><span class="line">    <span class="comment">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class="line">    CHECKCALL(chmod(<span class="string">&quot;/proc/cmdline&quot;</span>, <span class="number">0440</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cmdline;</span><br><span class="line">    android::base::ReadFileToString(<span class="string">&quot;/proc/cmdline&quot;</span>, &amp;cmdline);</span><br><span class="line">    <span class="comment">// Don&#x27;t expose the raw bootconfig to unprivileged processes.</span></span><br><span class="line">    chmod(<span class="string">&quot;/proc/bootconfig&quot;</span>, <span class="number">0440</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootconfig;</span><br><span class="line">    android::base::ReadFileToString(<span class="string">&quot;/proc/bootconfig&quot;</span>, &amp;bootconfig);</span><br><span class="line">    <span class="keyword">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class="line">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">&quot;selinuxfs&quot;</span>, <span class="string">&quot;/sys/fs/selinux&quot;</span>, <span class="string">&quot;selinuxfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class="number">0600</span>, makedev(<span class="number">1</span>, <span class="number">11</span>)));</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 重新调用拉起init进程，并且参数设置为selinux_setup</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;/system/bin/init&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">&quot;selinux_setup&quot;</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> fd = open(<span class="string">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">// 使用execv再次调用init进程</span></span><br><span class="line">    execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">    <span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">    PLOG(FATAL) &lt;&lt; <span class="string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;) failed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在目录初始化完成后又拉起了一个<code>init</code>进程，并且传入参数<code>selinux_setup</code>，接下来，直接看前面<code>main</code>入口函数中判断出现该参数时调用的<code>SetupSelinux</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetupSelinux</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">&quot;Opening SELinux policy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the policy before potentially killing snapuserd.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> policy;</span><br><span class="line">    ReadPolicy(&amp;policy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> snapuserd_helper = SnapuserdSelinuxHelper::CreateIfNeeded();</span><br><span class="line">    <span class="keyword">if</span> (snapuserd_helper) &#123;</span><br><span class="line">        <span class="comment">// Kill the old snapused to avoid audit messages. After this we cannot</span></span><br><span class="line">        <span class="comment">// read from /system (or other dynamic partitions) until we call</span></span><br><span class="line">        <span class="comment">// FinishTransition().</span></span><br><span class="line">        snapuserd_helper-&gt;StartTransition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LoadSelinuxPolicy(policy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snapuserd_helper) &#123;</span><br><span class="line">        <span class="comment">// Before enforcing, finish the pending snapuserd transition.</span></span><br><span class="line">        snapuserd_helper-&gt;FinishTransition();</span><br><span class="line">        snapuserd_helper = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SelinuxSetEnforcement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;re in the kernel domain and want to transition to the init domain.  File systems that</span></span><br><span class="line">    <span class="comment">// store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,</span></span><br><span class="line">    <span class="comment">// but other file systems do.  In particular, this is needed for ramdisks such as the</span></span><br><span class="line">    <span class="comment">// recovery image for A/B devices.</span></span><br><span class="line">    <span class="keyword">if</span> (selinux_android_restorecon(<span class="string">&quot;/system/bin/init&quot;</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">&quot;restorecon failed of /system/bin/init failed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setenv(kEnvSelinuxStartedAt, <span class="built_in">std</span>::to_string(start_time.time_since_epoch().count()).c_str(), <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 继续再拉起一个init进程,参数设置second_stage</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;/system/bin/init&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">&quot;second_stage&quot;</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">    <span class="comment">// panic and never return from this function.</span></span><br><span class="line">    PLOG(FATAL) &lt;&lt; <span class="string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;) failed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码可以看到，在完成<code>selinux</code>的加载处理后，又拉起了一个<code>init</code>进程，并且传入参数<code>second_stage</code>。接下来，看第三步<code>SecondStageMain</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 初始化属性系统</span></span><br><span class="line">    PropertyInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启属性服务</span></span><br><span class="line">    StartPropertyService(&amp;property_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析init.rc 以及启动其他相关进程</span></span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    继续跟踪<code>LoadBootScripts</code>函数，了解它是如何解析执行<code>init.rc</code>文件的。（修改的意思是否正确？）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootscript = GetProperty(<span class="string">&quot;ro.boot.init_rc&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootscript.empty()) &#123;</span><br><span class="line">        <span class="comment">// 解析各目录中的init.rc</span></span><br><span class="line">        parser.ParseConfig(<span class="string">&quot;/system/etc/init/hw/init.rc&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">&quot;/system/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// late_import is available only in Q and earlier release. As we don&#x27;t</span></span><br><span class="line">        <span class="comment">// have system_ext in those versions, skip late_import for system_ext.</span></span><br><span class="line">        parser.ParseConfig(<span class="string">&quot;/system_ext/etc/init&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">&quot;/vendor/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">&quot;/odm/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">&quot;/product/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    继续看看解析的逻辑，可以看到参数可以是目录或者文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfig</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;</span><br><span class="line">        <span class="keyword">return</span> ParseConfigDir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ParseConfigFile(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果是目录，则遍历所有文件再调用解析文件，所以直接看<code>ParseConfigFile</code>就好了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ParseData(path, &amp;config_contents.value());</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    最后看看<code>ParseData</code>是如何解析数据的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::ParseData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="built_in">std</span>::<span class="built_in">string</span>* data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">            <span class="keyword">case</span> T_EOF:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> T_NEWLINE: &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line">                    <span class="comment">// 从section_parsers_中获取出来的</span></span><br><span class="line">                    section_parser = section_parsers_[args[<span class="number">0</span>]].get();</span><br><span class="line">                    section_start_line = state.line;</span><br><span class="line">                    <span class="comment">// 使用了ParseSection进行解析</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                                section_parser-&gt;ParseSection(<span class="built_in">std</span>::move(args), filename, state.line);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; state.line &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; result.error();</span><br><span class="line">                        section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">                        bad_section_found = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                    <span class="comment">// 使用了ParseLineSection进行解析</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result = section_parser-&gt;ParseLineSection(<span class="built_in">std</span>::move(args), state.line);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; state.line &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> T_TEXT:</span><br><span class="line">                args.emplace_back(state.text);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    简单解读一下这里的代码，首先这里看到从<code>section_parsers_</code>中取出对应的节点解析对象<code>section_parser</code>，通过<code>section_parser</code>执行<code>ParseSection</code>或者<code>ParseLineSection</code>函数解析<code>.rc</code>文件中的数据。所以需要了解<code>section_parsers_</code>中存储的是什么，查看函数<code>CreateParser</code>就明白了。所谓的节点解析对象，就是<code>ServiceParser、ActionParser、ImportParser</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::AddSectionParser</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SectionParser&gt; parser)</span> </span>&#123;</span><br><span class="line">    section_parsers_[name] = <span class="built_in">std</span>::move(parser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Parser <span class="title">CreateParser</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser;</span><br><span class="line"></span><br><span class="line">    parser.AddSectionParser(<span class="string">&quot;service&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;(</span><br><span class="line">                                               &amp;service_list, GetSubcontext(), <span class="built_in">std</span>::nullopt));</span><br><span class="line">    parser.AddSectionParser(<span class="string">&quot;on&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;(&amp;action_manager, GetSubcontext()));</span><br><span class="line">    parser.AddSectionParser(<span class="string">&quot;import&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;(&amp;parser));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果了解过<code>init.rc</code>文件格式的，看到这里就很眼熟了，这就是<code>.rc</code>文件中配置时使用的节点名称了。它们的功能的简单描述如下。</p>
<ol>
<li><p><code>service</code>    定义一个服务</p>
</li>
<li><p><code>on</code>                触发某个<code>action</code>时，执行对应的指令</p>
</li>
<li><p><code>import</code>      表示导入另外一个<code>rc</code>文件</p>
</li>
</ol>
<p>​    再解读上面的代码就是，根据<code>rc</code>文件的配置不同，使用<code>ServiceParser</code>、<code>ActionParser</code>、<code>ImportParser</code>这三种节点解析对象的<code>ParseSection</code>或者<code>ParseLineSection</code>函数来处理（这句不完整？）。继续看看这三个对象的解析函数实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service节点的解析处理</span></span><br><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">ServiceParser::ParseSection</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.size() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;services must have a name and a program&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!IsValidName(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;invalid service name &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filename_ = filename;</span><br><span class="line"></span><br><span class="line">    Subcontext* restart_action_subcontext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (subcontext_ &amp;&amp; subcontext_-&gt;PathMatchesSubcontext(filename)) &#123;</span><br><span class="line">        restart_action_subcontext = subcontext_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">str_args</span><span class="params">(args.begin() + <span class="number">2</span>, args.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SelinuxGetVendorAndroidVersion() &lt;= __ANDROID_API_P__) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str_args[<span class="number">0</span>] == <span class="string">&quot;/sbin/watchdogd&quot;</span>) &#123;</span><br><span class="line">            str_args[<span class="number">0</span>] = <span class="string">&quot;/system/bin/watchdogd&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (SelinuxGetVendorAndroidVersion() &lt;= __ANDROID_API_Q__) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str_args[<span class="number">0</span>] == <span class="string">&quot;/charger&quot;</span>) &#123;</span><br><span class="line">            str_args[<span class="number">0</span>] = <span class="string">&quot;/system/bin/charger&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    service_ = <span class="built_in">std</span>::make_unique&lt;Service&gt;(name, restart_action_subcontext, str_args, from_apex_);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// on 节点的解析处理</span></span><br><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">ActionParser::ParseSection</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">triggers</span><span class="params">(args.begin() + <span class="number">1</span>, args.end())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (triggers.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;Actions must have a trigger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Subcontext* action_subcontext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (subcontext_ &amp;&amp; subcontext_-&gt;PathMatchesSubcontext(filename)) &#123;</span><br><span class="line">        action_subcontext = subcontext_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> event_trigger;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; property_triggers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                ParseTriggers(triggers, action_subcontext, &amp;event_trigger, &amp;property_triggers);</span><br><span class="line">        !result.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;ParseTriggers() failed: &quot;</span> &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> action = <span class="built_in">std</span>::make_unique&lt;Action&gt;(<span class="literal">false</span>, action_subcontext, filename, line, event_trigger,</span><br><span class="line">                                           property_triggers);</span><br><span class="line"></span><br><span class="line">    action_ = <span class="built_in">std</span>::move(action);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import节点的解析处理</span></span><br><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">ImportParser::ParseSection</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.size() != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;single argument needed for import\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> conf_file = ExpandProps(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!conf_file.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;Could not expand import: &quot;</span> &lt;&lt; conf_file.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">&quot;Added &#x27;&quot;</span> &lt;&lt; *conf_file &lt;&lt; <span class="string">&quot;&#x27; to import list&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (filename_.empty()) filename_ = filename;</span><br><span class="line">    imports_.emplace_back(<span class="built_in">std</span>::move(*conf_file), line);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    到这里大致的<code>init</code>进程的启动流程相信大家已经有了一定了解。明白<code>init</code>的原理后，对于<code>init.rc</code>相信大家已经有了简单的印象，接下来将详细展开讲解<code>init.rc</code>文件。</p>
<h2><span id="35-initrc">3.5 init.rc</span></h2><p>​    <code>init.rc</code>是<code>Android</code>系统中的一个脚本文件而并非配置文件，是一种名为<code>Android Init Language</code>的脚本语言写成的文件，当然也可以简单当作配置文件来理解，主要用于启动和管理<code>Android</code>上的其他进程以对系统进行初始化工作。</p>
<p>​    将<code>init.rc</code>看作是<code>init</code>进程功能的动态延申，一些可能需要改动的初始化系统任务就放在配置文件中，然后读取配置解析后再进行初始化执行，如此可以提高一定的灵活性，相信很多开发人员在工作中都有做过类似的封装。而<code>init.rc</code>就是配置文件的入口，在<code>init.rc</code>中通过<code>import</code>节点来导入其他的配置文件，所以这些文件都可以算是<code>init.rc</code>的一部分。在上一章（确定是章？），通过了解<code>init</code>进程的工作流程，明白了解析<code>init.rc</code>文件的过程。</p>
<p>​    <code>init.rc</code>是由多个<code>section</code>节点组成的，而节点的类型分别主要是<code>service、on、import</code>三种。上一节中，有简单的介绍，它们的作用分别是定义服务、事件触发、导入其他<code>rc</code>文件。下面，来看<code>init.rc</code>文件中的几个例子，查看文件<code>system/core/rootdir/init.rc</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入另一个rc文件</span><br><span class="line">import &#x2F;init.environ.rc</span><br><span class="line">import &#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.usb.rc</span><br><span class="line">import &#x2F;init.$&#123;ro.hardware&#125;.rc</span><br><span class="line">import &#x2F;vendor&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.$&#123;ro.hardware&#125;.rc</span><br><span class="line">import &#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.usb.configfs.rc</span><br><span class="line">import &#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.$&#123;ro.zygote&#125;.rc</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 当初始化触发时,执行section下的命令</span><br><span class="line">on init</span><br><span class="line">    sysclktz 0</span><br><span class="line"></span><br><span class="line">    # Mix device-specific information into the entropy pool</span><br><span class="line">    copy &#x2F;proc&#x2F;cmdline &#x2F;dev&#x2F;urandom</span><br><span class="line">    copy &#x2F;system&#x2F;etc&#x2F;prop.default &#x2F;dev&#x2F;urandom</span><br><span class="line"></span><br><span class="line">    symlink &#x2F;proc&#x2F;self&#x2F;fd&#x2F;0 &#x2F;dev&#x2F;stdin</span><br><span class="line">    symlink &#x2F;proc&#x2F;self&#x2F;fd&#x2F;1 &#x2F;dev&#x2F;stdout</span><br><span class="line">    symlink &#x2F;proc&#x2F;self&#x2F;fd&#x2F;2 &#x2F;dev&#x2F;stderr</span><br><span class="line"></span><br><span class="line">    # Create energy-aware scheduler tuning nodes</span><br><span class="line">    mkdir &#x2F;dev&#x2F;stune&#x2F;foreground</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当属性ro.debuggable变更为1时触发section内的命令</span><br><span class="line">on property:ro.debuggable&#x3D;1</span><br><span class="line">    # Give writes to anyone for the trace folder on debug builds.</span><br><span class="line">    # The folder is used to store method traces.</span><br><span class="line">    chmod 0773 &#x2F;data&#x2F;misc&#x2F;trace</span><br><span class="line">    # Give reads to anyone for the window trace folder on debug builds.</span><br><span class="line">    chmod 0775 &#x2F;data&#x2F;misc&#x2F;wmtrace</span><br><span class="line">    # Give reads to anyone for the accessibility trace folder on debug builds.</span><br><span class="line">    chmod 0775 &#x2F;data&#x2F;misc&#x2F;a11ytrace</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义系统服务 服务名称ueventd  服务路径&#x2F;system&#x2F;bin&#x2F;ueventd</span><br><span class="line">&#x2F;&#x2F; 服务类型core，关机行为critical，安全标签u:r:ueventd:s0</span><br><span class="line">service ueventd &#x2F;system&#x2F;bin&#x2F;ueventd</span><br><span class="line">    class core</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br><span class="line">    shutdown critical</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义系统服务 服务名称console 服务路径&#x2F;system&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;&#x2F; 服务类型core 服务状态disabled 服务所属用户shell 服务所属组shell log readproc</span><br><span class="line">&#x2F;&#x2F; 安全标签u:r:shell:s0 设置环境变量HOSTNAME console</span><br><span class="line">service console &#x2F;system&#x2F;bin&#x2F;sh</span><br><span class="line">    class core</span><br><span class="line">    console</span><br><span class="line">    disabled</span><br><span class="line">    user shell</span><br><span class="line">    group shell log readproc</span><br><span class="line">    seclabel u:r:shell:s0</span><br><span class="line">    setenv HOSTNAME console</span><br></pre></td></tr></table></figure>

<p>​    看完各种节点的样例后，大概了解<code>init.rc</code>中应该如何添加一个<code>section</code>了。<code>import</code>非常简单，只需要指定一个<code>rc</code>文件的路径即可。<code>on</code>节点在源码中，看到对应的处理是<code>ActionParser</code>，这个节点就是当触发了一个<code>Action</code>的事件后就自上而下，依次执行节点下的所有命令，所以，就得了解一下一共有哪些<code>Action</code>事件提供使用。详细介绍参考自<code>http://www.gaohaiyan.com/4047.html</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">on boot                     #系统启动触发</span><br><span class="line">on early-init               #在初始化之前触发</span><br><span class="line">on init                     #在初始化时触发（在启动配置文件&#x2F;init.conf被装载之后）</span><br><span class="line">on late-init                #在初始化晚期阶段触发</span><br><span class="line">on charger                  #当充电时触发</span><br><span class="line">on property:&lt;key&gt;&#x3D;&lt;value&gt;   #当属性值满足条件时触发</span><br><span class="line">on post-fs                  #挂载文件系统</span><br><span class="line">on post-fs-data             #挂载data</span><br><span class="line">on device-added-&lt;path&gt;      #在指定设备被添加时触发</span><br><span class="line">on device-removed-&lt;path&gt;    #在指定设备被移除时触发</span><br><span class="line">on service-exited-&lt;name&gt;    #在指定service退出时触发</span><br><span class="line">on &lt;name&gt;&#x3D;&lt;value&gt;           #当属性&lt;name&gt;等于&lt;value&gt;时触发</span><br></pre></td></tr></table></figure>

<p>​    在触发<code>Action</code>事件后可以执行的命令如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">chdir &lt;dirc&gt;                                  更改工作目录为&lt;dirc&gt;</span><br><span class="line">chmod &lt;octal-mode&gt; &lt;path&gt;                     更改文件访问权限</span><br><span class="line">chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;                  更改文件所有者和组群</span><br><span class="line">chroot &lt;direc&gt;                                更改根目录位置</span><br><span class="line">class_start &lt;serviceclass&gt;                    如果它们不在运行状态的话，启动由&lt;serviceclass&gt;类名指定的所有相关服务</span><br><span class="line">class_stop &lt;serviceclass&gt;                     如果它们在运行状态的话，停止</span><br><span class="line">domainname &lt;name&gt;                             设置域名</span><br><span class="line">exec &lt;path&gt; [ &lt;argument&gt; ]*                   fork并执行一个程序，其路径为&lt;path&gt;，这条命令将阻塞直到该程序启动完成，因此它有可能造成init程序在某个节点不停地等待</span><br><span class="line">export &lt;name&gt; &lt;value&gt;                         设置某个环境变量&lt;name&gt;的值为&lt;value&gt;，这是对全局有效的，即其后所有进程都将继承这个变量</span><br><span class="line">hostname &lt;name&gt;                               设置主机名</span><br><span class="line">ifup &lt;interface&gt;                              使网络接口&lt;interface&gt;成功连接</span><br><span class="line">import &lt;filename&gt;                             引入一个名为&lt;filename&gt;的文件</span><br><span class="line">insmod &lt;path&gt;                                 在&lt;path&gt;路径上安装一个模块</span><br><span class="line">mkdir &lt;path&gt; [mode] [owner] [group]           在&lt;path&gt;路径上新建一个目录</span><br><span class="line">mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [&lt;mountoption&gt;]*  尝试在指定路径上挂载一个设备</span><br><span class="line">setprop &lt;name&gt; &lt;value&gt;                        设置系统属性&lt;name&gt;的值为&lt;value&gt;</span><br><span class="line">setrlinit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;              设置一种资源的使用限制。这个概念亦存在于Linux系统中，&lt;cur&gt;表示软限制，&lt;max&gt;表示硬限制</span><br><span class="line">start &lt;service&gt;                               启动一个服务</span><br><span class="line">stop &lt;service&gt;                                停止一个服务</span><br><span class="line">symlink &lt;target&gt; &lt;path&gt;                       创建一个&lt;path&gt;路径的软链接，目标为&lt;target&gt;</span><br><span class="line">sysclk &lt;mins_west_of_gmt&gt;                     设置基准时间，如果当前时间时GMT，这个值是0</span><br><span class="line">trigger &lt;event&gt;                               触发一个事件</span><br><span class="line">write &lt;path&gt; &lt;string&gt; [&lt;string&gt;]*             打开一个文件，并写入字符串</span><br></pre></td></tr></table></figure>

<p>​    而<code>service</code>节点主要是将可执行程序作为服务启动，上面的例子，看到节点下面有一系列的参数，下面是这些参数的详细描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class &lt;name&gt;                                       为该服务指定一个class名，同一个class的所有服务必须同时启动或者停止。</span><br><span class="line">                                                   默认情况下服务的class名是“default”。另外还有core(其它服务依赖的基础性核心服务)、main(java须要的基本服务)、late_start(厂商定制的服务)</span><br><span class="line">critical                                           表示这是一个对设备至关重要的一个服务，如果它在四分钟内退出超过四次，则设备将重启进入恢复模式</span><br><span class="line">disabled                                           此服务不会自动启动，而是需要通过显式调用服务名来启动</span><br><span class="line">group &lt;groupname&gt; [&lt;groupname&gt;]*                   在启动服务前将用户组切换为&lt;groupname&gt;</span><br><span class="line">oneshot                                            只启动一次，当此服务退出时，不要主动去重启它</span><br><span class="line">onrestart                                          当此服务重启时，执行某些命令</span><br><span class="line">setenv &lt;name&gt; &lt;value&gt;                              设置环境变量&lt;name&gt;为某个值&lt;value&gt;</span><br><span class="line">socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [&lt;group&gt;]]    创建一个名为&#x2F;dev&#x2F;socket&#x2F;&lt;name&gt;的unix domain socket，然后将它的fd值传给启动它的进程，有效的&lt;type&gt;值包括dgram，stream和seqacket，而user和group的默认值是0</span><br><span class="line">user &lt;username&gt;                                    在启动服务前将用户组切换为&lt;username&gt;，默认情况下用户都是root</span><br></pre></td></tr></table></figure>

<p>​    到这里，相信大家应该能够看懂<code>init.rc</code>中的大多数<code>section</code>的含义了。下面的例子将组合使用，定义一个自己的服务，并且启动它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service kservice &#x2F;system&#x2F;bin&#x2F;app_process -Djava.class.path&#x3D;&#x2F;system&#x2F;framework&#x2F;ksvr.jar &#x2F;system&#x2F;bin cn.ksvr.kSystemSvr svr</span><br><span class="line">    class main</span><br><span class="line">    user root</span><br><span class="line">    group root</span><br><span class="line">    oneshot</span><br><span class="line">    seclabel u:r:su:s0</span><br><span class="line"></span><br><span class="line">on property:sys.boot_completed&#x3D;1</span><br><span class="line">    bootchart stop</span><br><span class="line">    start kservice</span><br></pre></td></tr></table></figure>

<p>​    上面的案例中，我定义了一个<code>kservice</code>的服务，使用<code>/system/bin/app_process</code>作为进程启动，并设置目标<code>jar</code>作为应用的<code>classpath</code>，最后设置<code>jar</code>文件的入口类<code>cn.ksvr.kSystemSvr</code>，最后的<code>svr</code>是做为参数传递给<code>kSystemSvr</code>中的<code>main</code>函数。接下来是当属性<code>sys.boot_completed</code>变更为1时表示手机完成引导，执行节点下的命令启动刚刚定义的服务。</p>
<h2><span id="36-zygote启动">3.6 Zygote启动</span></h2><p>​    了解<code>init.rc</code>定义的原理后，就可以继续阅读<code>init.rc</code>追踪后续的启动流程了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 导入含有zygote服务定义的rc文件，这个会根据系统所支持的对应架构导入</span><br><span class="line">import &#x2F;system&#x2F;etc&#x2F;init&#x2F;hw&#x2F;init.$&#123;ro.zygote&#125;.rc</span><br><span class="line"></span><br><span class="line"># init完成后触发zygote-start事件</span><br><span class="line">on late-init</span><br><span class="line">    ...</span><br><span class="line">    # Now we can start zygote for devices with file based encryption</span><br><span class="line">    trigger zygote-start</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"># zygote-start事件触发时执行的节点。最后启动了zygote和zygote_secondary</span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted</span><br><span class="line">    wait_for_prop odsign.verification.done 1</span><br><span class="line">    # A&#x2F;B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start statsd</span><br><span class="line">    start netd</span><br><span class="line">    start zygote</span><br><span class="line">    start zygote_secondary</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <code>zygote</code>服务定义的<code>rc</code>文件在路径<code>system/core/rootdir/</code>中。分别是<code>init.zygote32.rc</code>、<code>init.zygote64.rc</code>、<code>init.zygote32_64.rc</code>、<code>init.zygote64_32.rc</code>，下面查看<code>zygote64</code>的是如何定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; --zygote 传递给app_process程序的参数,表示这是启动一个孵化器。</span><br><span class="line">&#x2F;&#x2F; --start-system-server 传递给app_process程序的参数，表示进程启动后需要启动system_server进程</span><br><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br><span class="line">    critical window&#x3D;$&#123;zygote.critical_window.minute:-off&#125; target&#x3D;zygote-fatal</span><br></pre></td></tr></table></figure>

<p>​    从定义中可以看到<code>zygote</code>进程实际启动的就是<code>app_process</code>进程。</p>
<p>​    <code>app_process</code>是<code>Android</code>系统的主要进程，它是其他所有应用程序的容器，它负责创建新的进程，并启动它们。此外，它还管理应用程序的生命周期，防止任何一个应用程序占用资源过多，或者做出不良影响。<code>app_process</code>还负责在应用运行时为它们提供上下文，以及管理应用进程之间的通信。</p>
<p>​    跟踪<code>app_process</code>的实现，它的入口是在目录<code>frameworks/base/cmds/app_process/app_main.cpp</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> ABI_LIST_PROPERTY[] = <span class="string">&quot;ro.product.cpu.abilist64&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> ZYGOTE_NICE_NAME[] = <span class="string">&quot;zygote64&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> ABI_LIST_PROPERTY[] = <span class="string">&quot;ro.product.cpu.abilist32&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> ZYGOTE_NICE_NAME[] = <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused &quot;parent dir&quot; argument.</span></span><br><span class="line">    <span class="comment">// 参数的处理</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   	...</span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果启动时设置--zygote，则启动ZygoteInit，否则启动RuntimeInit</span></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* zygoteName=<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>;</span><br><span class="line">        runtime.start(zygoteName, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* zygoteName=<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>;</span><br><span class="line">        runtime.start(zygoteName, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从代码中可以看到主要是对参数进行处理包装后，然后根据是否携带<code>--zygote</code>选择启动<code>ZygoteInit</code>或者是<code>RuntimeInit</code>。</p>
<p>​    <code>ZygoteInit</code>负责加载和初始化<code>Android</code>运行时环境，例如应用程序运行器、垃圾收集器等，并且它启动<code>Android</code>系统中的所有核心服务。</p>
<p>​     <code>RuntimeInit</code>负责联系应用程序的执行环境与系统的运行环境，然后将应用程序的主类加载到运行时，最后将应用程序的控制权交给应用程序的主类。</p>
<p>​    下面继续看看<code>runtime.start</code>的实现，查看对应文件<code>frameworks/base/core/jni/AndroidRuntime.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);</span></span><br><span class="line">    <span class="comment">//ALOGD(&quot;Found LD_ASSUME_KERNEL=&#x27;%s&#x27;\n&quot;, kernelHack);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动vm虚拟机 */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注册框架使用的JNI调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	...</span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里调用ZygoteInit或者是RuntimeInit的main函数</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">&quot;Shutting down VM\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(<span class="string">&quot;Warning: unable to detach main thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">        ALOGW(<span class="string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过<code>JNI</code>函数<code>CallStaticVoidMethod</code>调用了<code>ZygoteInit</code>的<code>main</code>入口函数，现在就来到了<code>java</code>层中，查看文件代码<code>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        ZygoteServer zygoteServer = <span class="keyword">null</span>;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">                bootTimingsTraceLog.traceBegin(<span class="string">&quot;ZygotePreload&quot;</span>);</span><br><span class="line">                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">                        SystemClock.uptimeMillis());</span><br><span class="line">                <span class="comment">// 预加载资源，比如类、主题资源、字体资源等等</span></span><br><span class="line">                preload(bootTimingsTraceLog);</span><br><span class="line">                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class="line">                        SystemClock.uptimeMillis());</span><br><span class="line">                bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygotePreload</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            Zygote.initNativeState(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">            ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line">			<span class="comment">// 创建socket服务端</span></span><br><span class="line">            zygoteServer = <span class="keyword">new</span> ZygoteServer(isPrimaryZygote);</span><br><span class="line">			<span class="comment">// 前面在init.rc中有配置--start-system-server的进程则会进入fork启动SystemServer</span></span><br><span class="line">            <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">                Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">                <span class="comment">// child (system_server) process.</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Accepting command socket connections&quot;</span>);</span><br><span class="line">            <span class="comment">// socket服务端等待AMS的请求，收到请求后就会由Zygote服务端来通过fork创建应用程序的进程</span></span><br><span class="line">            caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;System zygote died with fatal exception&quot;</span>, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (zygoteServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                zygoteServer.closeServerSocket();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We&#x27;re in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">        <span class="comment">// command.</span></span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    这里的重点是创建了<code>zygoteServer</code>，然后根据参数决定是否<code>forkSystemServer</code>，最后<code>runSelectLoop</code>等待<code>AMS</code>发送消息创建应用程序的进程。依次从代码观察它们的本质。首先是<code>ZygoteServer</code>的构造函数，可以看到，主要是创建<code>Socket</code>套接字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ZygoteServer(<span class="keyword">boolean</span> isPrimaryZygote) &#123;</span><br><span class="line">        mUsapPoolEventFD = Zygote.getUsapPoolEventFD();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isPrimaryZygote) &#123;</span><br><span class="line">            mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line">            mUsapPoolSocket =</span><br><span class="line">                    Zygote.createManagedSocketFromInitSocket(</span><br><span class="line">                            Zygote.USAP_POOL_PRIMARY_SOCKET_NAME);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME);</span><br><span class="line">            mUsapPoolSocket =</span><br><span class="line">                    Zygote.createManagedSocketFromInitSocket(</span><br><span class="line">                            Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mUsapPoolSupported = <span class="keyword">true</span>;</span><br><span class="line">        fetchUsapPoolPolicyProps();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    接着分析<code>forkSystemServer</code>，目的是了解返回值到底是什么，返回值的<code>r.run()</code>会调用到哪里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 服务启动的相关参数，这里注意到类名是com.android.server.SystemServer</span></span><br><span class="line">        String[] args = &#123;</span><br><span class="line">                <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,&quot;</span></span><br><span class="line">                        + <span class="string">&quot;1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--capabilities=&quot;</span> + capabilities + <span class="string">&quot;,&quot;</span> + capabilities,</span><br><span class="line">                <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--runtime-args&quot;</span>,</span><br><span class="line">                <span class="string">&quot;--target-sdk-version=&quot;</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">                <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        ZygoteArguments parsedArgs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 使用fork创建一个SystemServer进程</span></span><br><span class="line">            <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">            pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.mUid, parsedArgs.mGid,</span><br><span class="line">                    parsedArgs.mGids,</span><br><span class="line">                    parsedArgs.mRuntimeFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.mPermittedCapabilities,</span><br><span class="line">                    parsedArgs.mEffectiveCapabilities);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For child process */</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            <span class="comment">// pid为0的部分，就是由这里fork出来的SystemServer执行的了。</span></span><br><span class="line">            <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteArguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ClassLoader cl = getOrCreateSystemServerClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 初始化SystemServer</span></span><br><span class="line">    <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                                 parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                                 parsedArgs.mRemainingArgs, cl);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    	<span class="comment">// 继续跟进去</span></span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">                classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 反射获取com.android.server.SystemServer的入口函数并返回</span></span><br><span class="line">    <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到就是通过反射，获取到对应类的main函数，最后封装到MethodAndArgsCaller返回</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Missing class when invoking static main &quot;</span> + className,</span><br><span class="line">            ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Missing static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Problem getting static main on &quot;</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Main method is not public and static on &quot;</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">         * by invoking the exception&#x27;s run() method. This arrangement</span></span><br><span class="line"><span class="comment">         * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">         * up the process.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forkSystemServer最终返回的就是MethodAndArgsCaller对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** method to call */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** argument array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <code>forkSystemServer</code>函数走到最后是通过反射获取<code>com.android.server.SystemServer</code>的入口函数<code>main</code>，并封装到<code>MethodAndArgsCaller</code>对象中返回。最后的返回结果调用<code>run</code>时，就会执行到<code>SystemServer</code>中的<code>main</code>函数。继续看看<code>main</code>函数的实现，查看文件<code>frameworks/base/services/java/com/android/server/SystemServer.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="comment">// 创建主线程Looper</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化系统Context上下文</span></span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建SystemServiceManager，由它管理系统的所有服务</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">        mSystemServiceManager.setStartInfo(mRuntimeRestart,</span><br><span class="line">                                           mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">        mDumper.addDumpable(mSystemServiceManager);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动各种服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t.traceBegin(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动引导服务</span></span><br><span class="line">        startBootstrapServices(t);</span><br><span class="line">        <span class="comment">// 启动核心服务</span></span><br><span class="line">        startCoreServices(t);</span><br><span class="line">        <span class="comment">// 启动其他服务</span></span><br><span class="line">        startOtherServices(t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        t.traceEnd(); <span class="comment">// StartServices</span></span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动负责引导的服务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    t.traceBegin(<span class="string">&quot;startBootstrapServices&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 启动ActivityManagerService</span></span><br><span class="line">    t.traceBegin(<span class="string">&quot;StartActivityManager&quot;</span>);</span><br><span class="line">    ActivityTaskManagerService atm = mSystemServiceManager.startService(</span><br><span class="line">        ActivityTaskManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">        mSystemServiceManager, atm);</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    mWindowManagerGlobalLock = atm.getGlobalLock();</span><br><span class="line">    t.traceEnd();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    t.traceBegin(<span class="string">&quot;startOtherServices&quot;</span>);</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 从systemReady开始可以启动第三方应用</span></span><br><span class="line">    mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;, t);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后看看systemReady的处理</span></span><br><span class="line"><span class="comment">// frameworks/base/services/java/com/android/server/am/ActivitymanagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback, <span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;System now ready&quot;</span>);</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 启动多用户下的Home Activity，最终会开启系统应用Luncher桌面显示</span></span><br><span class="line">        <span class="keyword">if</span> (bootingSystemUser) &#123;</span><br><span class="line">            t.traceBegin(<span class="string">&quot;startHomeOnAllDisplays&quot;</span>);</span><br><span class="line">            mAtmInternal.startHomeOnAllDisplays(currentUserId, <span class="string">&quot;systemReady&quot;</span>);</span><br><span class="line">            t.traceEnd();</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    到这里大致的服务启动流程就清楚了，最后成功抵达了<code>Luncher</code>的启动，重新回到流程中，继续看看<code>runSelectLoop</code>函数是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        socketFDs.add(mZygoteSocket.getFileDescriptor());</span><br><span class="line">        peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        mUsapPoolRefillTriggerTimestamp = INVALID_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            fetchUsapPoolPolicyPropsWithMinInterval();</span><br><span class="line">            mUsapPoolRefillAction = UsapPoolRefillAction.NONE;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] usapPipeFDs = <span class="keyword">null</span>;</span><br><span class="line">            StructPollfd[] pollFDs;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pollReturnValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pollReturnValue = Os.poll(pollFDs, pollTimeoutMs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;poll failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">			...</span><br><span class="line">            <span class="keyword">if</span> (mUsapPoolRefillAction != UsapPoolRefillAction.NONE) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] sessionSocketRawFDs =</span><br><span class="line">                        socketFDs.subList(<span class="number">1</span>, socketFDs.size())</span><br><span class="line">                                .stream()</span><br><span class="line">                                .mapToInt(FileDescriptor::getInt$)</span><br><span class="line">                                .toArray();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> isPriorityRefill =</span><br><span class="line">                        mUsapPoolRefillAction == UsapPoolRefillAction.IMMEDIATE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Runnable command =</span><br><span class="line">                        fillUsapPool(sessionSocketRawFDs, isPriorityRefill);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> command;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPriorityRefill) &#123;</span><br><span class="line">                    <span class="comment">// Schedule a delayed refill to finish refilling the pool.</span></span><br><span class="line">                    mUsapPoolRefillTriggerTimestamp = System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    重点主要放在返回值的跟踪上，直接看<code>fillUsapPool</code>函数做了些什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">fillUsapPool</span><span class="params">(<span class="keyword">int</span>[] sessionSocketRawFDs, <span class="keyword">boolean</span> isPriorityRefill)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (--numUsapsToSpawn &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Runnable caller =</span><br><span class="line">                    Zygote.forkUsap(mUsapPoolSocket, sessionSocketRawFDs, isPriorityRefill);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> caller;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续追踪关键返回值的函数forkUsap</span></span><br><span class="line"><span class="comment">// 对应文件frameworks/base/core/java/com/android/internal/os/Zygote.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Runnable <span class="title">forkUsap</span><span class="params">(LocalServerSocket usapPoolSocket,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span>[] sessionSocketRawFDs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> isPriorityFork)</span> </span>&#123;</span><br><span class="line">        FileDescriptor readFD;</span><br><span class="line">        FileDescriptor writeFD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileDescriptor[] pipeFDs = Os.pipe2(O_CLOEXEC);</span><br><span class="line">            readFD = pipeFDs[<span class="number">0</span>];</span><br><span class="line">            writeFD = pipeFDs[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException errnoEx) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable to create USAP pipe.&quot;</span>, errnoEx);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 这里fork出一个子进程并初始化信息，最后返回pid</span></span><br><span class="line">        <span class="keyword">int</span> pid = nativeForkApp(readFD.getInt$(), writeFD.getInt$(),</span><br><span class="line">                                sessionSocketRawFDs, <span class="comment">/*argsKnown=*/</span> <span class="keyword">false</span>, isPriorityFork);</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            IoUtils.closeQuietly(readFD);</span><br><span class="line">            <span class="comment">// 如果是子进程就调用childMain获取返回值</span></span><br><span class="line">            <span class="keyword">return</span> childMain(<span class="keyword">null</span>, usapPoolSocket, writeFD);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Fork failed.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// readFD will be closed by the native code. See removeUsapTableEntry();</span></span><br><span class="line">            IoUtils.closeQuietly(writeFD);</span><br><span class="line">            nativeAddUsapTableEntry(pid, readFD.getInt$());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续看childMain的实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">childMain</span><span class="params">(<span class="meta">@Nullable</span> ZygoteCommandBuffer argBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="meta">@Nullable</span> LocalServerSocket usapPoolSocket,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      FileDescriptor writePipe)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 初始化应用程序环境，设置应用程序上下文，初始化应用程序线程等等</span></span><br><span class="line">        specializeAppProcess(args.mUid, args.mGid, args.mGids,</span><br><span class="line">                             args.mRuntimeFlags, rlimits, args.mMountExternal,</span><br><span class="line">                             args.mSeInfo, args.mNiceName, args.mStartChildZygote,</span><br><span class="line">                             args.mInstructionSet, args.mAppDataDir, args.mIsTopApp,</span><br><span class="line">                             args.mPkgDataInfoList, args.mAllowlistedDataInfoList,</span><br><span class="line">                             args.mBindMountAppDataDirs, args.mBindMountAppStorageDirs);</span><br><span class="line"></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">		<span class="comment">// 又看到这个了，在SystemServer的启动中，之前追踪过</span></span><br><span class="line">    	<span class="comment">// 这里最后是反射获取某个java类的main函数封装后返回</span></span><br><span class="line">        <span class="keyword">return</span> ZygoteInit.zygoteInit(args.mTargetSdkVersion,</span><br><span class="line">                                     args.mDisabledCompatChanges,</span><br><span class="line">                                     args.mRemainingArgs,</span><br><span class="line">                                     <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    前面分析过了<code>zygoteInit</code>函数，所以这里就不需要再继续进去看了，看看孵化器进程是如何初始化应用程序环境的，追踪<code>specializeAppProcess</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">specializeAppProcess</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> startChildZygote, String instructionSet, String appDataDir, <span class="keyword">boolean</span> isTopApp,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] pkgDataInfoList, String[] allowlistedDataInfoList,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> bindMountAppDataDirs, <span class="keyword">boolean</span> bindMountAppStorageDirs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 参数传递到了native层进行初始化处理了。</span></span><br><span class="line">        nativeSpecializeAppProcess(uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo,</span><br><span class="line">                niceName, startChildZygote, instructionSet, appDataDir, isTopApp,</span><br><span class="line">                pkgDataInfoList, allowlistedDataInfoList,</span><br><span class="line">                bindMountAppDataDirs, bindMountAppStorageDirs);</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续查看nativeSpecializeAppProcess</span></span><br><span class="line"><span class="comment">// 文件所在frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_Zygote_nativeSpecializeAppProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids, jint runtime_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean is_top_app, jobjectArray pkg_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobjectArray allowlisted_data_info_list, jboolean mount_data_dirs,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">    jlong capabilities = CalculateCapabilities(env, uid, gid, gids, is_child_zygote);</span><br><span class="line"></span><br><span class="line">    SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits, capabilities, capabilities,</span><br><span class="line">                     mount_external, se_info, nice_name, <span class="keyword">false</span>, is_child_zygote == JNI_TRUE,</span><br><span class="line">                     instruction_set, app_data_dir, is_top_app == JNI_TRUE, pkg_data_info_list,</span><br><span class="line">                     allowlisted_data_info_list, mount_data_dirs == JNI_TRUE,</span><br><span class="line">                     mount_storage_dirs == JNI_TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续查看SpecializeCommon实现</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecializeCommon</span><span class="params">(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray rlimits, jlong permitted_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jlong effective_capabilities, jint mount_external,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_se_info, jstring managed_nice_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool is_system_server, bool is_child_zygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_instruction_set, jstring managed_app_data_dir,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool is_top_app, jobjectArray pkg_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray allowlisted_data_info_list, bool mount_data_dirs,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* process_name = is_system_server ? <span class="string">&quot;system_server&quot;</span> : <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line">    auto fail_fn = std::bind(ZygoteFailure, env, process_name, managed_nice_name, _1);</span><br><span class="line">    auto extract_fn = std::bind(ExtractJString, env, process_name, managed_nice_name, _1);</span><br><span class="line"></span><br><span class="line">    auto se_info = extract_fn(managed_se_info);</span><br><span class="line">    auto nice_name = extract_fn(managed_nice_name);</span><br><span class="line">    auto instruction_set = extract_fn(managed_instruction_set);</span><br><span class="line">    auto app_data_dir = extract_fn(managed_app_data_dir);</span><br><span class="line">    <span class="comment">// 在这里的nick_name就是应用的包名了</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* nice_name_ptr = nice_name.has_value() ? nice_name.value().c_str() : nullptr;</span><br><span class="line">	<span class="comment">// 如果是系统服务，就初始化系统服务的classloader</span></span><br><span class="line">    <span class="keyword">if</span> (is_system_server) &#123;</span><br><span class="line">        <span class="comment">// Prefetch the classloader for the system server. This is done early to</span></span><br><span class="line">        <span class="comment">// allow a tie-down of the proper system server selinux domain.</span></span><br><span class="line">        env-&gt;CallStaticObjectMethod(gZygoteInitClass, gGetOrCreateSystemServerClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">            <span class="comment">// Be robust here. The Java code will attempt to create the classloader</span></span><br><span class="line">            <span class="comment">// at a later point (but may not have rights to use AoT artifacts).</span></span><br><span class="line">            env-&gt;ExceptionClear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> (selinux_android_setcontext(uid, is_system_server, se_info_ptr, nice_name_ptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">        fail_fn(CREATE_ERROR(<span class="string">&quot;selinux_android_setcontext(%d, %d, \&quot;%s\&quot;, \&quot;%s\&quot;) failed&quot;</span>, uid,</span><br><span class="line">                             is_system_server, se_info_ptr, nice_name_ptr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make it easier to debug audit logs by setting the main thread&#x27;s name to the</span></span><br><span class="line">    <span class="comment">// nice name rather than &quot;app_process&quot;.</span></span><br><span class="line">    <span class="keyword">if</span> (nice_name.has_value()) &#123;</span><br><span class="line">        SetThreadName(nice_name.value());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_system_server) &#123;</span><br><span class="line">        SetThreadName(<span class="string">&quot;system_server&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用java层的callPostForkChildHooks函数</span></span><br><span class="line">    <span class="comment">// 这个函数主要用来在新创建的子进程中调用回调函数进行初始化。</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                              is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以在这里插入一个日志，看看在<code>android</code>启动完成时，孵化出了哪些进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                              is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line">ALOGW(<span class="string">&quot;start CallStaticVoidMethod current process:%s&quot;</span>, nice_name_ptr);</span><br></pre></td></tr></table></figure>

<p>​    然后编译aosp后刷入手机中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行脚本初始化编译环境</span><br><span class="line">source .&#x2F;build&#x2F;envsetup.sh</span><br><span class="line">&#x2F;&#x2F; 选择要编译的版本</span><br><span class="line">lunch aosp_blueline-userdebug</span><br><span class="line">&#x2F;&#x2F; 多线程编译</span><br><span class="line">make -j$(nproc --all)</span><br><span class="line">&#x2F;&#x2F; 设置刷机目录</span><br><span class="line">export ANDROID_PRODUCT_OUT&#x3D;~&#x2F;android_src&#x2F;out&#x2F;target&#x2F;product&#x2F;blueline</span><br><span class="line">&#x2F;&#x2F; 手机重启进入bootloader</span><br><span class="line">adb reboot bootloader</span><br><span class="line">&#x2F;&#x2F; 查看手机是否已经进入bootloader了</span><br><span class="line">fastboot devices</span><br><span class="line">&#x2F;&#x2F; 将刚刚编译的系统刷入手机</span><br><span class="line">fastboot flashall -w</span><br></pre></td></tr></table></figure>

<p>使用<code>android studio</code>的<code>logcat</code>查看日志，或者直接使用命令<code>adb logcat &gt; tmp.log</code>将日志输出到文件中，再进行观察。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">system_process                       W  start CallStaticVoidMethod current process:(null)</span><br><span class="line">com.android.bluetooth                W  start CallStaticVoidMethod current process:com.android.bluetooth</span><br><span class="line">com.android.systemui                 W  start CallStaticVoidMethod current process:com.android.systemui</span><br><span class="line">pid-2292                             W  start CallStaticVoidMethod current process:WebViewLoader-armeabi-v7a</span><br><span class="line">pid-2293                             W  start CallStaticVoidMethod current process:WebViewLoader-arm64-v8a</span><br><span class="line">com.android.networkstack             W  start CallStaticVoidMethod current process:com.android.networkstack.process</span><br><span class="line">com.qualcomm.qti.telephonyservice    W  start CallStaticVoidMethod current process:com.qualcomm.qti.telephonyservice</span><br><span class="line">pid-2401                             W  start CallStaticVoidMethod current process:webview_zygote</span><br><span class="line">com.android.se                       W  start CallStaticVoidMethod current process:com.android.se</span><br><span class="line">com.android.phone                    W  start CallStaticVoidMethod current process:com.android.phone</span><br><span class="line">com.android.settings                 W  start CallStaticVoidMethod current process:com.android.settings</span><br><span class="line">android.ext.services                 W  start CallStaticVoidMethod current process:android.ext.services</span><br><span class="line">com.android.launcher3                W  start CallStaticVoidMethod current process:com.android.launcher3</span><br><span class="line">com....cellbroadcastreceiver.module  W  start CallStaticVoidMethod current process:com.android.cellbroadcastreceiver.module</span><br><span class="line">com.android.carrierconfig            W  start CallStaticVoidMethod current process:com.android.carrierconfig</span><br><span class="line">com.android.providers.blockednumber  W  start CallStaticVoidMethod current process:android.process.acore</span><br><span class="line">pid-2859                             W  start CallStaticVoidMethod current process:com.android.deskclock</span><br><span class="line">pid-2899                             W  start CallStaticVoidMethod current process:com.android.nfc</span><br><span class="line">pid-2927                             W  start CallStaticVoidMethod current process:com.android.keychain</span><br><span class="line">pid-2944                             W  start CallStaticVoidMethod current process:com.android.providers.media.module</span><br><span class="line">pid-3028                             W  start CallStaticVoidMethod current process:com.android.quicksearchbox</span><br><span class="line">pid-3059                             W  start CallStaticVoidMethod current process:com.android.printspooler</span><br><span class="line">pid-3077                             W  start CallStaticVoidMethod current process:com.android.music</span><br><span class="line">pid-3112                             W  start CallStaticVoidMethod current process:com.android.traceur</span><br><span class="line">pid-3145                             W  start CallStaticVoidMethod current process:com.android.dialer</span><br><span class="line">pid-3151                             W  start CallStaticVoidMethod current process:android.process.media</span><br><span class="line">pid-3213                             W  start CallStaticVoidMethod current process:com.android.calendar</span><br><span class="line">pid-3230                             W  start CallStaticVoidMethod current process:com.android.imsserviceentitlement</span><br><span class="line">pid-3256                             W  start CallStaticVoidMethod current process:com.android.camera2</span><br><span class="line">pid-3277                             W  start CallStaticVoidMethod current process:com.android.contacts</span><br><span class="line">pid-3302                             W  start CallStaticVoidMethod current process:com.android.dynsystem</span><br><span class="line">pid-3322                             W  start CallStaticVoidMethod current process:com.android.dynsystem:dynsystem</span><br><span class="line">pid-3337                             W  start CallStaticVoidMethod current process:com.android.inputmethod.latin</span><br><span class="line">pid-3359                             W  start CallStaticVoidMethod current process:com.android.managedprovisioning</span><br><span class="line">pid-3380                             W  start CallStaticVoidMethod current process:com.android.messaging</span><br><span class="line">pid-3413                             W  start CallStaticVoidMethod current process:com.android.onetimeinitializer</span><br><span class="line">pid-3436                             W  start CallStaticVoidMethod current process:com.android.packageinstaller</span><br><span class="line">pid-3455                             W  start CallStaticVoidMethod current process:com.android.permissioncontroller</span><br><span class="line">pid-3480                             W  start CallStaticVoidMethod current process:com.android.providers.calendar</span><br><span class="line">pid-3503                             W  start CallStaticVoidMethod current process:com.android.settings</span><br><span class="line">pid-3504                             W  start CallStaticVoidMethod current process:com.android.localtransport</span><br><span class="line">pid-3545                             W  start CallStaticVoidMethod current process:com.android.shell</span><br><span class="line">pid-3568                             W  start CallStaticVoidMethod current process:com.android.statementservice</span><br><span class="line">pid-3595                             W  start CallStaticVoidMethod current process:com.android.quicksearchbox</span><br><span class="line">pid-3615                             W  start CallStaticVoidMethod current process:com.android.cellbroadcastreceiver.module</span><br><span class="line">pid-3638                             W  start CallStaticVoidMethod current process:com.android.externalstorage</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    从日志中可以看到<code>system_process</code>进程是孵化出来的第一个进程，接着孵化了一堆系统相关的进程，包括<code>launcher</code>桌面应用管理的系统应用。</p>
<p>​    根据前文看到的一系列的源码，分析后得出以下几个结论</p>
<ol>
<li><code>zygote</code>启动实际是启动<code>app_process</code>进程。</li>
<li>由<code>init</code>进程解析<code>init.rc</code>时启动了第一个<code>zygote</code>进程。</li>
<li>在第一个<code>zygote</code>进程中创建的<code>ZygoteServer</code>，并开始监听消息。</li>
<li>其他<code>zygote</code>进程是在<code>ZygoteServer</code>这个服务中收到消息后，再去<code>fork</code>出的新进程。</li>
<li>所有进程均来自于<code>zygote</code>进程的<code>fork</code>而来，所以<code>zygote</code>是进程的始祖。</li>
</ol>
<p>​    结合观测到的代码流程，再看下面的一个汇总图。不需要完全理解启动过程中的所有的处理，重点是在这里留下一个大致的印象以及简单的整理。</p>
<p><img src="/2025/04/07/chapter-03/android-boot.jpg" alt="image"></p>
<h2><span id="37-android-app应用启动">3.7 Android app应用启动</span></h2><p>​    经过一系列的代码跟踪，学习了<code>android</code>是如何启动的，系统服务是如何启动的，进程是如何启动。相信大家也好奇，当点击打开一个应用后，系统做了一系列的什么工作，最终打开了这个<code>app</code>，调用到<code>MainActivity</code>的<code>onCreate</code>的呢。</p>
<p>​    当<code>Android</code>成功进入系统后，在主界面中显示的桌面是一个叫做<code>Launcher</code>的系统应用，它是用来显示系统中已经安装的应用程序，并将这些信息的图标作为快捷方式显示在屏幕上，当用户点击图标时，<code>Launcher</code>就会启动对应的应用。在前文中，从<code>forkSystemServer</code>的流程中，最后能看到系统启动准备就绪后拉起了<code>Launcher</code>的应用。</p>
<p>​    <code>Launcher</code>是如何打开一个应用的呢？其实<code>Launcher</code>本身就是作为第一个应用在系统启动后首先打开的，既然<code>Launcher</code>就是应用。那么在手机上看到各种应用的图标，就是它读取到需要展示的数据，然后布局展示出来的，点击后打开应用，就是给每个<code>item</code>设置的点击事件进行处理的。接着，来看看这个<code>Launcher</code>应用的源码。</p>
<p>​    查看代码<code>frameworks/base/core/java/android/app/LauncherActivity.java</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LauncherActivity</span> <span class="keyword">extends</span> <span class="title">ListActivity</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        Intent intent = intentForPosition(position);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果你是一名<code>android</code>开发人员，相信你对<code>startActivity</code>这个函数非常熟悉了，但是<code>startActivity</code>是如何打开一个应用的呢，很多人不会深入了解，有了前文中的一系列基础铺垫，这时你已经能尝试追踪调用链了。现在，继续深入挖掘<code>startActivity</code>的原理。</p>
<p>​    查看代码<code>frameworks/base/core/java/android/app/Activity.java</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, <span class="meta">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">            <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">            startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    继续追踪<code>startActivityForResult</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 继续追踪startActivityForResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String who, Intent intent, <span class="keyword">int</span> requestCode, <span class="meta">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class="line">        Uri referrer = onProvideReferrer();</span><br><span class="line">        <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">        &#125;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">    	<span class="comment">// 运行Activity</span></span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, who,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, who, requestCode,</span><br><span class="line">                ar.getResultCode(), ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    接下来的关键函数是<code>execStartActivity</code>，继续深入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继续追踪execStartActivity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData(who);</span><br><span class="line">            intent.prepareToLeaveProcess(who);</span><br><span class="line">            <span class="comment">// 启动Activity</span></span><br><span class="line">            <span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">                    who.getOpPackageName(), who.getAttributionTag(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">                    target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <code>ActivityTaskManager</code>下的<code>service</code>调用的<code>startActivity</code>。</p>
<p>​    查看代码<code>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">                               String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">                               String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">                               resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">                               UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> String callingFeatureId, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">&quot;startActivityAsUser&quot;</span>)</span><br><span class="line">                .setCaller(caller)</span><br><span class="line">                .setCallingPackage(callingPackage)</span><br><span class="line">                .setCallingFeatureId(callingFeatureId)</span><br><span class="line">                .setResolvedType(resolvedType)</span><br><span class="line">                .setResultTo(resultTo)</span><br><span class="line">                .setResultWho(resultWho)</span><br><span class="line">                .setRequestCode(requestCode)</span><br><span class="line">                .setStartFlags(startFlags)</span><br><span class="line">                .setProfilerInfo(profilerInfo)</span><br><span class="line">                .setActivityOptions(bOptions)</span><br><span class="line">                .setUserId(userId)</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    先看看<code>obtainStarter</code>返回的对象类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityStarter <span class="title">obtainStarter</span><span class="params">(Intent intent, String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFactory.obtain().setIntent(intent).setReason(reason);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    看到返回的是<code>ActivityStarter</code>类型，接着找到对应的<code>excute</code>的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理 Activity 启动请求的接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        res = executeRequest(mRequest);</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种权限检查，合法的请求则继续</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">                request.voiceInteractor, startFlags, <span class="keyword">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask,</span><br><span class="line">                restrictedBgActivity, intentGrants);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;startActivityInner&quot;</span>);</span><br><span class="line">       result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">       startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 判断是否需要为 Activity 创建新的 Task</span></span><br><span class="line">        mTargetRootTask.startActivityLocked(mStartActivity,</span><br><span class="line">                topRootTask != <span class="keyword">null</span> ? topRootTask.getTopNonFinishingActivity() : <span class="keyword">null</span>, newTask,</span><br><span class="line">                mKeepCurTransition, mOptions, sourceRecord);</span><br><span class="line">    	<span class="comment">// 如果需要恢复 Activity</span></span><br><span class="line">        <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                    mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">            <span class="comment">// 判断当前 Activity 是否可见以及是否需要暂停后台 Activity</span></span><br><span class="line">            <span class="keyword">if</span> (!mTargetRootTask.isTopActivityFocusable()</span><br><span class="line">                    || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.isTaskOverlay()</span><br><span class="line">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">               	...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前 Activity 可见，则将其移动到前台</span></span><br><span class="line">                <span class="keyword">if</span> (mTargetRootTask.isTopActivityFocusable()</span><br><span class="line">                        &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedRootTask(mTargetRootTask)) &#123;</span><br><span class="line">                    mTargetRootTask.moveToFront(<span class="string">&quot;startActivityInner&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 恢复处于焦点状态的 Activity 的顶部 Activity</span></span><br><span class="line">                mRootWindowContainer.resumeFocusedTasksTopActivities(</span><br><span class="line">                        mTargetRootTask, mStartActivity, mOptions, mTransientLaunch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复处于焦点状态的 Activity 的顶部 Activity。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedTasksTopActivities</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Task targetRootTask, ActivityRecord target, ActivityOptions targetOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> deferPause)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 遍历所有显示器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 获取当前焦点所在的任务根节点</span></span><br><span class="line">            <span class="keyword">final</span> Task focusedRoot = display.getFocusedRootTask();</span><br><span class="line">            <span class="comment">// 如果有任务根节点，则恢复任务根节点中顶部的 Activity</span></span><br><span class="line">            <span class="keyword">if</span> (focusedRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= focusedRoot.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetRootTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有焦点任务根节点，并且目标任务根节点为空，则恢复 Home Activity</span></span><br><span class="line">                result |= resumeHomeActivity(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="string">&quot;no-focusable-task&quot;</span>,</span><br><span class="line">                                             display.getDefaultTaskDisplayArea());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复位于任务根节点顶部的 Activity</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> deferPause)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        someActivityResumed = resumeTopActivityInnerLocked(prev, options, deferPause);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复位于任务根节点顶部的 Activity。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> deferPause)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mTaskSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <code>startSpecificActivity</code>将启动指定的<code>Activity</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivity</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否已经有进程在运行这个应用程序?</span></span><br><span class="line">        <span class="keyword">final</span> WindowProcessController wpc =</span><br><span class="line">                mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> knownToBeDead = <span class="keyword">false</span>;</span><br><span class="line">    	<span class="comment">// 如果应用程序正在运行，则直接启动 Activity</span></span><br><span class="line">        <span class="keyword">if</span> (wpc != <span class="keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Exception when starting activity &quot;</span></span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">            knownToBeDead = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 通知 Keyguard 正在启动一个不确定的 Activity（仅在 Keyguard 转换期间使用）</span></span><br><span class="line">        r.notifyUnknownVisibilityLaunchedForKeyguardTransition();</span><br><span class="line">		<span class="comment">// 如果应用程序未运行，则异步启动新进程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isTop = andResume &amp;&amp; r.isTopRunningActivity();</span><br><span class="line">        mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? <span class="string">&quot;top-activity&quot;</span> : <span class="string">&quot;activity&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    主要关注开启一个新应用的流程，所以这里只追踪<code>startProcessAsync</code>调用即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startProcessAsync</span><span class="params">(ActivityRecord activity, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">boolean</span> isTop,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) &#123;</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;dispatchingStartProcess:&quot;</span></span><br><span class="line">                        + activity.processName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Post message to start process to avoid possible deadlock of calling into AMS with the</span></span><br><span class="line">            <span class="comment">// ATMS lock held.</span></span><br><span class="line">            <span class="keyword">final</span> Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,</span><br><span class="line">                    mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,</span><br><span class="line">                    isTop, hostingType, activity.intent.getComponent());</span><br><span class="line">            mH.sendMessage(m);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    上面开启新进程的代码是异步发送消息给了<code>ActivityManagerService</code>。找到<code>AMS</code>中对应的<code>startProcess</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcess</span><span class="params">(String processName, ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> isTop, String hostingType, ComponentName hostingName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;startProcess:&quot;</span></span><br><span class="line">                             + processName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// If the process is known as top app, set a hint so when the process is</span></span><br><span class="line">            <span class="comment">// started, the top priority can be applied immediately to avoid cpu being</span></span><br><span class="line">            <span class="comment">// preempted by other processes before attaching the process of top app.</span></span><br><span class="line">            startProcessLocked(processName, info, knownToBeDead, <span class="number">0</span> <span class="comment">/* intentFlags */</span>,</span><br><span class="line">                               <span class="keyword">new</span> HostingRecord(hostingType, hostingName, isTop),</span><br><span class="line">                               ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, <span class="keyword">false</span> <span class="comment">/* allowWhileBooting */</span>,</span><br><span class="line">                               <span class="keyword">false</span> <span class="comment">/* isolated */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续追踪startProcessLocked</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       HostingRecord hostingRecord, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> isolated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,</span><br><span class="line">                                           hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>,</span><br><span class="line">                                           <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>,</span><br><span class="line">                                           <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>, <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里初始化了一堆进程信息，然后调用了另一个重载</span></span><br><span class="line"><span class="comment">// 并且注意entryPoint赋值android.app.ActivityThread</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> disableHiddenApiChecks, <span class="keyword">boolean</span> disableTestApiChecks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String abiOverride)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line">        <span class="keyword">final</span> String entryPoint = <span class="string">&quot;android.app.ActivityThread&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids,</span><br><span class="line">                              runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi,</span><br><span class="line">                              instructionSet, invokeWith, startTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(HostingRecord hostingRecord, String entryPoint, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">final</span> Process.ProcessStartResult startResult = startProcess(hostingRecord,</span><br><span class="line">                                                                    entryPoint, app,</span><br><span class="line">                                                                    uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo,</span><br><span class="line">                                                                    requiredAbi, instructionSet, invokeWith, startTime);</span><br><span class="line">    handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                               startSeq, <span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> app.getPid() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续查看startProcess</span></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startProcess</span><span class="params">(HostingRecord hostingRecord, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">int</span> mountExternal, String seInfo, String requiredAbi, String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                String invokeWith, <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">final</span> Process.ProcessStartResult startResult;</span><br><span class="line">    <span class="keyword">boolean</span> regularZygote = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 这里根据应用情况使用不同类型的zygote来启动进程</span></span><br><span class="line">    <span class="keyword">if</span> (hostingRecord.usesWebviewZygote()) &#123;</span><br><span class="line">        startResult = startWebView(entryPoint,</span><br><span class="line">                                   app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                                   app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                                   app.info.dataDir, <span class="keyword">null</span>, app.info.packageName,</span><br><span class="line">                                   app.getDisabledCompatChanges(),</span><br><span class="line">                                   <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.getStartSeq()&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hostingRecord.usesAppZygote()) &#123;</span><br><span class="line">        <span class="keyword">final</span> AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can&#x27;t isolate app data and storage data as parent zygote already did that.</span></span><br><span class="line">        startResult = appZygote.getProcess().start(entryPoint,</span><br><span class="line">                                                   app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                                                   app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                                                   app.info.dataDir, <span class="keyword">null</span>, app.info.packageName,</span><br><span class="line">                                                   <span class="comment">/*zygotePolicyFlags=*/</span> ZYGOTE_POLICY_FLAG_EMPTY, isTopApp,</span><br><span class="line">                                                   app.getDisabledCompatChanges(), pkgDataInfoMap, allowlistedAppDataInfoMap,</span><br><span class="line">                                                   <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                                                   <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.getStartSeq()&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        regularZygote = <span class="keyword">true</span>;</span><br><span class="line">        startResult = Process.start(entryPoint,</span><br><span class="line">                                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                                    app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags,</span><br><span class="line">                                    isTopApp, app.getDisabledCompatChanges(), pkgDataInfoMap,</span><br><span class="line">                                    allowlistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs,</span><br><span class="line">                                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.getStartSeq()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!regularZygote) &#123;</span><br><span class="line">        <span class="comment">// webview and app zygote don&#x27;t have the permission to create the nodes</span></span><br><span class="line">        <span class="keyword">if</span> (Process.createProcessGroup(uid, startResult.pid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.e(ActivityManagerService.TAG, <span class="string">&quot;Unable to create process group for &quot;</span></span><br><span class="line">                   + app.processName + <span class="string">&quot; (&quot;</span> + startResult.pid + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    这里，看到了<code>zygote</code>有三种类型，根据启动的应用信息使用不同类型的<code>zygote</code>来启动。</p>
<ol>
<li><p><code>regularZygote</code>常规进程，<code>zygote32/zygote64</code>进程，是所有<code>Android Java</code>应用的父进程</p>
</li>
<li><p><code>appZygote</code>应用进程，比常规进程多一些限制。</p>
</li>
<li><p><code>webviewZygote</code>辅助<code>zygote</code>进程，渲染不可信的<code>web</code>内容，最严格的安全限制</p>
</li>
</ol>
<p>​    三种<code>zygote</code>类型的启动流程差不多的，看常规进程启动即可。首先看<code>getProcess</code>返回的是什么类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChildZygoteProcess <span class="title">getProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mZygote != <span class="keyword">null</span>) <span class="keyword">return</span> mZygote;</span><br><span class="line"></span><br><span class="line">            connectToZygoteIfNeededLocked();</span><br><span class="line">            <span class="keyword">return</span> mZygote;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    应该找<code>ChildZygoteProcess</code>的<code>start</code>函数，然后找到类定义后，发现没有<code>start</code>，那么应该就是父类中的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildZygoteProcess</span> <span class="keyword">extends</span> <span class="title">ZygoteProcess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mPid;</span><br><span class="line"></span><br><span class="line">    ChildZygoteProcess(LocalSocketAddress socketAddress, <span class="keyword">int</span> pid) &#123;</span><br><span class="line">        <span class="keyword">super</span>(socketAddress, <span class="keyword">null</span>);</span><br><span class="line">        mPid = pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mPid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    继续找到父类<code>ZygoteProcess</code>的<code>start</code>函数，参数太长，这里省略掉参数的描述</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, <span class="comment">/*startChildZygote=*/</span> <span class="keyword">false</span>,</span><br><span class="line">                    packageName, zygotePolicyFlags, isTopApp, disabledCompatChanges,</span><br><span class="line">                    pkgDataInfoMap, allowlistedDataInfoList, bindMountAppsData,</span><br><span class="line">                    bindMountAppStorageDirs, zygoteArgs);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">// 前面是将前面准备的参数填充好</span></span><br><span class="line">        <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">        <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">        argsForZygote.add(<span class="string">&quot;--runtime-args&quot;</span>);</span><br><span class="line">        argsForZygote.add(<span class="string">&quot;--setuid=&quot;</span> + uid);</span><br><span class="line">        argsForZygote.add(<span class="string">&quot;--setgid=&quot;</span> + gid);</span><br><span class="line">        argsForZygote.add(<span class="string">&quot;--runtime-flags=&quot;</span> + runtimeFlags);</span><br><span class="line">        <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">&quot;--mount-external-default&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_INSTALLER) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">&quot;--mount-external-installer&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_PASS_THROUGH) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">&quot;--mount-external-pass-through&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_ANDROID_WRITABLE) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">&quot;--mount-external-android-writable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="comment">// The USAP pool can not be used if the application will not use the systems graphics</span></span><br><span class="line">            <span class="comment">// driver.  If that driver is requested use the Zygote application start path.</span></span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),</span><br><span class="line">                                              zygotePolicyFlags,</span><br><span class="line">                                              argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteState zygoteState, <span class="keyword">int</span> zygotePolicyFlags, <span class="meta">@NonNull</span> ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//是否用非特定的应用程序进程池进行处理，默认不使用</span></span><br><span class="line">        <span class="keyword">if</span> (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> attemptUsapSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="comment">// If there was an IOException using the USAP pool we will log the error and</span></span><br><span class="line">                <span class="comment">// attempt to start the process through the Zygote.</span></span><br><span class="line">                Log.e(LOG_TAG, <span class="string">&quot;IO Exception while communicating with USAP pool - &quot;</span></span><br><span class="line">                        + ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">attemptZygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteState zygoteState, String msgStr)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">            <span class="keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line">			<span class="comment">// 这里实际就是连接SocketServer了，发送一个消息给zygote孵化出来的第一个进程</span></span><br><span class="line">            zygoteWriter.write(msgStr);</span><br><span class="line">            zygoteWriter.flush();</span><br><span class="line"></span><br><span class="line">            Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line">            result.pid = zygoteInputStream.readInt();</span><br><span class="line">            result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class="line">			<span class="comment">// ZygoteServer创建好进程后，返回pid</span></span><br><span class="line">            <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            zygoteState.close();</span><br><span class="line">            Log.e(LOG_TAG, <span class="string">&quot;IO Exception while communicating with Zygote - &quot;</span></span><br><span class="line">                    + ex.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    到这里，回首看看前文中介绍<code>ZygoteServer</code>启动进程的流程，当时看到执行到最后是<code>findStaticMain</code>函数，是获取一个类名下的<code>main</code>函数，并返回后进行调用。现在启动进程时，在<code>startProcessLocked</code>函数中能看到类名赋值是<code>android.app.ActivityThread</code>，所以这里和<code>ZygoteServer</code>进行通信创建线程，最后调用的函数就是<code>android.app.ActivityThread</code>中的<code>main</code>函数。这样一来，启动流程就进入的应用的主线程。</p>
<p>​    <code>ActivityThread</code>是<code>Android</code>应用程序运行的<code>UI</code>主线程，负责处理应用程序的所有生命周期事件，接收系统消息并处理它们，<code>main</code>函数就是安卓应用的入口函数。<code>prepareMainLooper</code>函数将实例化一个<code>Looper</code>对象，然后由<code>Looper</code>对象创建一个消息队列，当<code>loop</code>函数调用时，<code>UI</code>线程就会进入消息循环，不断从消息队列获取到消息去进行相应的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ...</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line">    <span class="comment">// 主线程消息循环处理的handler</span></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在loop函数中是一个死循环进行`loopOnce`调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    继续看<code>loopOnce</code>的实现，看到了从队列中获取一条消息，并且将消息派发给对应的<code>Handler</code>来执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">long</span> ident, <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride)</span> </span>&#123;</span><br><span class="line">        Message msg = me.mQueue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    对应的消息处理的<code>Handler</code>就是前面在入口函数<code>main</code>中看到的<code>sMainThreadHandler</code>对象，是通过<code>getHandler</code>函数获取的，跟进去寻找具体的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br></pre></td></tr></table></figure>

<p>​    找到的这个<code>H</code>类型就是对应的主线程消息处理<code>Handler</code>了。看看相关实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIND_APPLICATION        = <span class="number">110</span>;</span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_APPLICATION        = <span class="number">111</span>;</span><br><span class="line">		...</span><br><span class="line">        <span class="function">String <span class="title">codeToString</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                    <span class="keyword">case</span> BIND_APPLICATION: <span class="keyword">return</span> <span class="string">&quot;BIND_APPLICATION&quot;</span>;</span><br><span class="line">                    <span class="keyword">case</span> EXIT_APPLICATION: <span class="keyword">return</span> <span class="string">&quot;EXIT_APPLICATION&quot;</span>;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Integer.toString(code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">                    <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInitialApplication.onTerminate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Looper.myLooper().quit();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    再回头看看<code>thread.attach</code>中的处理，<code>mgr</code>就是<code>AMS</code>，所以来到<code>ActivityManagerService</code>查看<code>attachApplication</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main中调用的thread.attach函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将应用程序线程与 ActivityThread 绑定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Invalid application interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续追踪attachApplicationLocked</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        	...</span><br><span class="line">            <span class="keyword">if</span> (app.getIsolatedEntryPoint() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// This is an isolated process which should just call an entry point instead of</span></span><br><span class="line">                <span class="comment">// being bound to an application.</span></span><br><span class="line">                thread.runIsolatedEntryPoint(</span><br><span class="line">                        app.getIsolatedEntryPoint(), app.getIsolatedEntryPointArgs());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果该应用程序未运行在隔离进程中，且有 Instrumentation</span></span><br><span class="line">                thread.bindApplication(processName, appInfo, providerList,</span><br><span class="line">                        instr2.mClass,</span><br><span class="line">                        profilerInfo, instr2.mArguments,</span><br><span class="line">                        instr2.mWatcher,</span><br><span class="line">                        instr2.mUiAutomationConnection, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                        <span class="keyword">new</span> Configuration(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                        app.getCompat(), getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">                        app.getDisabledCompatChanges(), serializedSystemFontMap);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有 Instrumentation</span></span><br><span class="line">                thread.bindApplication(processName, appInfo, providerList, <span class="keyword">null</span>, profilerInfo,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                        <span class="keyword">new</span> Configuration(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                        app.getCompat(), getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">                        app.getDisabledCompatChanges(), serializedSystemFontMap);</span><br><span class="line">            &#125;</span><br><span class="line">			...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    最后调用回<code>ActivityThread</code>的<code>bindApplication</code>，继续跟进去查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将应用程序和应用程序线程绑定所需的信息存储到AppBindData的各个字段中。</span></span><br><span class="line">    AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providerList.getList();</span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line">    data.buildSerial = buildSerial;</span><br><span class="line">    data.autofillOptions = autofillOptions;</span><br><span class="line">    data.contentCaptureOptions = contentCaptureOptions;</span><br><span class="line">    data.disabledCompatChanges = disabledCompatChanges;</span><br><span class="line">    data.mSerializedSystemFontMap = serializedSystemFontMap;</span><br><span class="line">    <span class="comment">// 发送消息给应用程序线程，调用 bindApplication 方法</span></span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>AppBindData</code>数据绑定完成后，最后发送消息<code>BIND_APPLICATION</code>通知准备就绪，并将准备好的数据发送过去。查看消息循环的处理部分<code>handleMessage</code>函数，看这个数据传给哪个函数处理了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">             ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    发现调用到了<code>handleBindApplication</code>，继续跟进查看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//前面准备好的data数据赋值给了mBoundApplication</span></span><br><span class="line">    mBoundApplication = data;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建出了Context</span></span><br><span class="line">    <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info);</span><br><span class="line">    ...</span><br><span class="line">    Application app;</span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建出了Application</span></span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Application赋值给了mInitialApplication</span></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看是如何创建出Application的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">    cl, appClass, appContext);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续看newApplication的实现</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">ClassNotFoundException </span>&#123;</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    <span class="comment">// 最后发现调用了attach</span></span><br><span class="line">    app.attach(context);</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    在上面看到了<code>Context</code>的创建和<code>Application</code>的创建，继续看看怎么调用到自己开发的<code>app</code>中的<code>onCreate</code>的，追踪<code>callApplicationOnCreate</code>的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callApplicationOnCreate</span><span class="params">(Application app)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    app.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    到这里，成功跟踪到最后调用<code>app</code>应用的<code>onCreate</code>函数，为什么很多人喜欢<code>hook attach</code>函数，因为在<code>Application</code>创建出来最早先调用了这个函数，该函数是一个较早<code>hook</code>时机。</p>
<h2><span id="38-了解service">3.8 了解Service</span></h2><p>​    <code>Service</code>是一种运行在后台的组件也可以称之为服务，它不像<code>Activity</code>那样有前台显示用户界面的能力，而是一种更加抽象的组件，它可以提供后台服务，在后台定时执行某些任务。<code>Service</code>可以被应用程序绑定，也可以独立运行，它可以接收外部的命令，执行耗时的任务。</p>
<p>​    在<code>Android</code>启动流程中，就已经看到了很多<code>Service</code>的启动，前文代码看到当系统启动后通过<code>forkSystemServer</code>执行到<code>SystemServer</code>来启动一系列的<code>Service</code>。这些<code>Service</code>有着各自负责的功能，其中最关键的是<code>ActivityManagerService</code>，常常被简称为<code>AMS</code>。而启动了<code>AMS</code>的<code>SystemServer</code>也是一个服务，这个服务负责在<code>Android</code>完成启动后，加载和启动所有的系统服务，管理系统级别的资源。</p>
<p>​    <code>AMS</code>是<code>Android</code>系统中的一个核心服务，负责<code>Android</code>系统中的所有活动管理，包括应用程序的启动，暂停，恢复，终止，以及对系统资源的管理和分配。负责<code>Android</code>系统中所有活动的管理。它负责管理任务栈，并允许任务栈中的任务来回切换，以便在任务之间改变焦点。它还负责管理进程，并将进程启动，暂停，恢复，终止，以及分配系统资源。在启动流程中能看到，所有<code>Service</code>都是由它来启动的.</p>
<p>​    除了<code>AMS</code>外，还有其他重要的<code>Service</code>为<code>Android</code>应用提供基础的功能，下面简单介绍这些常见的<code>Service</code>。</p>
<p>​     <code>WindowManagerService</code>，它是负责管理系统上所有窗口的显示和操作，包括管理全屏窗口、小窗口、弹窗、菜单和其他应用程序的窗口，使窗口在手机屏幕上正确的显示。</p>
<p>​    <code>PackageManagerService</code>，<code>Android</code>系统中提供给应用程序访问<code>Android</code>软件包的主要服务。负责管理<code>Android</code>软件包的安装、删除和更新，以及软件包的查询和配置。它有一个名为<code>Packages.xml</code>的<code>XML</code>文档，该文档是<code>Android</code>系统中所有软件包的列表，其中包含了每个软件包的基本信息，如应用程序的版本，安装时间，文件大小等。</p>
<p>​    <code>PowerManagerService</code>，管理设备电源状态的服务，可以有效地管理设备的电源，从而大大提升设备的电池续航能力，也可以降低设备运行时的功耗。它负责处理设备上的所有电源相关操作，例如屏幕亮度、屏幕超时时间、电池和充电时的运行模式、设备锁以及设备唤醒功能。</p>
<p>​    <code>InputMethodManagerService</code>，输入法服务，它负责处理用户输入，管理输入法状态，以及向应用程序提供输入服务，例如可以安装、卸载和更新输入法，还可以管理系统的输入法开关，应用程序可以通过它来访问输入法的当前状态和内容，以及实时输入的文本内容，可以接收并处理用户的输入事件，包括按键、触摸屏、语音输入等。</p>
<p>​    <code>NotificationManagerService</code>，通知服务。它主要是用来管理系统的通知，包括消息、提醒、更新等，它实现了通知的管理，收集、组织、过滤通知，并将它们发送给用户。它能够管理所有应用程序发出的通知，包括系统通知、应用程序发出的通知，并可以根据用户的偏好，显示哪些通知。</p>
<p>​    <code>LocationManagerService</code>，位置管理服务。可以根据应用程序的要求调用<code>GPS</code>、网络和其他位置技术来获取当前设备的定位信息。根据设备的位置信息，控制应用程序的定位功能，以及设备的位置报警功能。</p>
<p>​    <code>InputManagerService</code>，负责输入设备的管理和控制，以及系统中所有输入事件的处理。例如触摸屏、虚拟按键、键盘、轨迹球等。会将输入事件传递给应用程序，以便处理和响应。</p>
<p>​    <code>AlarmManagerService</code>负责处理所有系统定时任务，如闹钟，定时器等。它可以安排可执行的任务，使它们在指定的时刻开始执行。监控系统中的各种时间事件，以执行指定的任务。可以发送唤醒广播，以启动指定的服务或应用程序。可以用于处理设备睡眠、唤醒等系统状态切换。</p>
<p>​    <code>NetworkManagementService</code>，网络管理服务。用于控制和管理<code>Android</code>系统中的网络连接，能够在不同的网络之间进行切换，检查和管理手机的网络状态，监控网络设备的连接状态，如WiFi、蓝牙、移动数据等。</p>
<p>​    <code>BluetoothService</code>，蓝牙服务，它可以实现蓝牙设备之间的无线通信。它提供了一种方便的方式来建立和管理蓝牙连接，使蓝牙设备之间能够进行文件传输、远程打印、蓝牙键盘连接等活动。</p>
<p>​    还有更多的系统服务为<code>Android</code>的运行提供着各模块的基础功能，这里就不展开详细叙述了，当对某一个服务的功能实现感兴趣时，可以顺着启动服务的地方开始跟踪代码，分析实现的逻辑。也可以直接参考系统服务的定义方式来自定义系统服务来提供特殊需求的功能。</p>
<h2><span id="39-了解framework">3.9 了解Framework</span></h2><p>​    <code>Framework</code>指的是软件开发框架，由于系统处于内核中，无法直接对系统的功能进行请求，而是由框架层为开发的顶层应用提供接口调用，从而不必烦恼如何与底层交互，开发框架为开发人员提供各种功能，以及<code>Android</code>应用工具的支持来便于创建和管理<code>Android</code>应用程序，最终达到让用户能高效开发<code>Android</code>应用的目的，以生活中的事务为例，<code>Framework</code>就像是一个配套完善的小区，有高效的物业，周边配套有学校、医院、商场，各类设施非常齐全，而用户就像是小区内的业主。</p>
<p>​    看一张经典的<code>Android</code>架构图。</p>
<p><img src="/2025/04/07/chapter-03/android-framework.jpg" alt="在这里插入图片描述"></p>
<p>​    从上图中可以看到<code>Framewok</code>的组成部分，它们的功能分别是：</p>
<ol>
<li><code>Activity Manager</code>：用于管理和协调所有<code>Android</code>应用程序的活动和任务。</li>
<li><code>Content Providers</code>：允许<code>Android</code>应用程序之间共享数据。</li>
<li><code>Package Manager</code>：用于安装，升级和管理应用程序，以及处理应用程序的权限。</li>
<li><code>Resource Manager</code>：管理应用程序使用的资源，例如图像，字符串，布局。</li>
<li><code>Notification Manager</code>：处理<code>Android</code>系统的通知机制。</li>
<li><code>Telephony Manager</code>：提供电话功能，例如拨打电话，接听电话等。</li>
<li><code>Location Manager</code>：用于获取设备的位置信息。</li>
<li><code>View System</code>：提供用户界面的基本组件或部件，例如按钮，文本框等。</li>
<li><code>Window Manager</code>：处理屏幕上的窗口，例如在屏幕上绘制UI元素和管理窗口焦点。</li>
<li><code>Package Installer</code>：用于在设备上安装应用程序的控制面板。</li>
<li><code>Resource Manager</code>：管理所有允许应用程序访问的公共资源，例如铃声，照片和联系人信息。</li>
<li><code>Activity</code>和<code>Fragment</code>：提供应用程序的用户界面和控制器。</li>
</ol>
<p>​    可以看到前文中的各种系统服务就是属于<code>Framework</code>中的一部分，但是用户层并不能直接访问系统服务提供的功能，而是通过各服务对应的管理器来对系统服务进行调用。接下来开始跟踪，在开发应用中，当调用一个系统服务功能时发生了哪些调用，使用<code>Android Studio</code>创建一个项目，添加如下代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    TelephonyManager tm = (TelephonyManager) <span class="keyword">this</span>.getSystemService(TELEPHONY_SERVICE);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 电话状态：</span></span><br><span class="line"><span class="comment">         * 1.tm.CALL_STATE_IDLE=0     无活动</span></span><br><span class="line"><span class="comment">         * 2.tm.CALL_STATE_RINGING=1  响铃</span></span><br><span class="line"><span class="comment">         * 3.tm.CALL_STATE_OFFHOOK=2  摘机</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">int</span> state= tm.getCallState();<span class="comment">//int</span></span><br><span class="line">    Log.i(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;phone state &quot;</span>+state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过<code>getSystemService</code>函数提供了一个系统服务的名称，获取到了对应系统服务对应管理器，通过调用管理器的函数来触发对应系统服务的功能，看看具体是如何获取到系统服务的。找到<code>Android</code>源码中<code>Activity.java</code>文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(<span class="meta">@ServiceName</span> <span class="meta">@NonNull</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBaseContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;System services not available to Activities before onCreate()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WINDOW_SERVICE.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mWindowManager;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SEARCH_SERVICE.equals(name)) &#123;</span><br><span class="line">        ensureSearchManager();</span><br><span class="line">        <span class="keyword">return</span> mSearchManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果是<code>WINDOW_SERVICE</code>或者<code>SEARCH_SERVICE</code>就快速的返回对应的管理器了，其他系统服务则继续调用父类的函数。<code>Activity</code>继承自<code>ContextThemeWrapper</code>，找到对应实现代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInflater;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBaseContext().getSystemService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    找到<code>ContextImpl</code>中的对应实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    继续查看<code>SystemServiceRegistry</code>中的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    <span class="keyword">if</span> (fetcher == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sEnableServiceNotFoundWtf) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Unknown manager requested: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object ret = fetcher.getService(ctx);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    发现服务是从<code>SYSTEM_SERVICE_FETCHERS</code>中获取出来，然后返回的。看看这个对象的值是如何插进去的。搜索该对象的<code>put</code>函数调用处找到相关函数如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(<span class="meta">@NonNull</span> String serviceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="meta">@NonNull</span> Class&lt;T&gt; serviceClass, <span class="meta">@NonNull</span> ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class="line">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">    SYSTEM_SERVICE_CLASS_NAMES.put(serviceName, serviceClass.getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从名字就能看的出来，这是一个注册系统服务的函数，在该函数中对大多数系统服务进行注册，想要查找到一个系统服务，可以顺着<code>registerService</code>注册函数进行跟踪，如果添加一个自定义的系统服务，同样也是需要在这里进行系统服务的注册。</p>
<p>​    下面继续观察<code>TelephonyManager</code>中<code>getCallState</code>函数的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@CallState</span> <span class="function"><span class="keyword">int</span> <span class="title">getCallState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TelecomManager telecomManager = mContext.getSystemService(TelecomManager.class);</span><br><span class="line">        <span class="keyword">if</span> (telecomManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> telecomManager.getCallState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CALL_STATE_IDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里又通过另一个管理器进行的函数调用，继续跟进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@CallState</span> <span class="function"><span class="keyword">int</span> <span class="title">getCallState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ITelecomService service = getTelecomService();</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> service.getCallStateUsingPackage(mContext.getPackageName(),</span><br><span class="line">                                                    mContext.getAttributionTag());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;RemoteException calling getCallState().&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TelephonyManager.CALL_STATE_IDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上述代码可以看出，<code>TelephonyManager</code>管理器不负责业务相关的处理，主要是调用对应的系统服务来获取结果。继续查看<code>getCallStateUsingPackage</code>函数实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCallStateUsingPackage</span><span class="params">(String callingPackage, String callingFeatureId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Log.startSession(<span class="string">&quot;TSI.getCallStateUsingPackage&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (CompatChanges.isChangeEnabled(</span><br><span class="line">            TelecomManager.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION, callingPackage,</span><br><span class="line">            Binder.getCallingUserHandle())) &#123;</span><br><span class="line">            <span class="comment">// Bypass canReadPhoneState check if this is being called from SHELL UID</span></span><br><span class="line">            <span class="keyword">if</span> (Binder.getCallingUid() != Process.SHELL_UID &amp;&amp; !canReadPhoneState(</span><br><span class="line">                callingPackage, callingFeatureId, <span class="string">&quot;getCallState&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;getCallState API requires READ_PHONE_STATE&quot;</span></span><br><span class="line">                                            + <span class="string">&quot; for API version 31+&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> mCallsManager.getCallState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Log.endSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在系统服务中就看到了管理状态相关的具体业务代码了，继续观察<code>mCallsManager.getCallStae</code>的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCallState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mPhoneStateBroadcaster.getCallState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    最后是由<code>PhoneStateBroadcaster</code>对象维护着电话的状态信息了，<code>PhoneStateBroadcaster</code>是<code>Android</code>中的一个系统广播机制，它用于在电话状态发生变化时发出通知，以便其他组件和应用程序能够接收和处理这些变化。它可以发出包括新来电，挂断电话，拨号等状态变化的通知，以使系统中的其他组件能够更新和处理这些变化。<code>PhoneStateBroadcaster</code>还提供了一些其他的功能，例如电话状态监控，用于检测电话状态的变化，以便能够及时响应。简单的贴一下相关的代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneStateBroadcaster</span> <span class="keyword">extends</span> <span class="title">CallsManagerListenerBase</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallStateChanged</span><span class="params">(Call call, <span class="keyword">int</span> oldState, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (call.isExternalCall()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updateStates(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallAdded</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (call.isExternalCall()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updateStates(call);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (call.isEmergencyCall() &amp;&amp; !call.isIncoming()) &#123;</span><br><span class="line">            sendOutgoingEmergencyCallEvent(call);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallRemoved</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (call.isExternalCall()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updateStates(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExternalCallChanged</span><span class="params">(Call call, <span class="keyword">boolean</span> isExternalCall)</span> </span>&#123;</span><br><span class="line">        updateStates(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateStates</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> callState = TelephonyManager.CALL_STATE_IDLE;</span><br><span class="line">        <span class="keyword">if</span> (mCallsManager.hasRingingOrSimulatedRingingCall()) &#123;</span><br><span class="line">            callState = TelephonyManager.CALL_STATE_RINGING;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCallsManager.getFirstCallWithState(CallState.DIALING, CallState.PULLING,</span><br><span class="line">                CallState.ACTIVE, CallState.ON_HOLD) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callState = TelephonyManager.CALL_STATE_OFFHOOK;</span><br><span class="line">        &#125;</span><br><span class="line">        sendPhoneStateChangedBroadcast(call, callState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCallState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mCurrentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendPhoneStateChangedBroadcast</span><span class="params">(Call call, <span class="keyword">int</span> phoneState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (phoneState == mCurrentState) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCurrentState = phoneState;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="310-了解libcore">3.10 了解libcore</span></h2><p>​    <code>libcore</code>是<code>Android</code>平台下的<code>Java</code>核心库，主要提供与<code>Java</code>语言核心相关的类，如<code>Object</code>类、<code>String</code>类，<code>Java</code>集合类以及输入/输出流等。同时，<code>libcore</code>还包括了平台支持库，提供了一些用于<code>Android</code>平台特定功能的实现，如<code>Socket、SSL、File、URI</code>等类的平台特定实现。在<code>Android</code>应用程序开发中，<code>libcore</code>库是必不可少的一部分，其提供的类和实现对于开发和调试应用程序都具有非常重要的作用。</p>
<p>​    在<code>libcore</code>库中，<code>luni</code>是其中的一个子库，是指<code>Java</code>的基础类库（<code>LUNI = LANG + UTIL + NET + IO</code>），而<code>ojluni</code>是<code>OpenJDK</code>的代码在<code>Android</code>中的实现，其目录结构与<code>luni</code>子库类似，包含了<code>Java</code>语言核心类、<code>Java</code>集合类和<code>I/O</code>类等。<code>ojluni</code>是在<code>Java</code>标准库的基础上进行了一些定制化的修改，以便更好地适配<code>Android</code>系统。下面看看<code>ojluni</code>的目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">tree .&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F; -d</span><br><span class="line"></span><br><span class="line">├── com</span><br><span class="line">│   └── sun</span><br><span class="line">│       ├── net</span><br><span class="line">│       │   └── ssl</span><br><span class="line">│       │       └── internal</span><br><span class="line">│       │           └── ssl</span><br><span class="line">│       ├── nio</span><br><span class="line">│       │   └── file</span><br><span class="line">│       └── security</span><br><span class="line">│           └── cert</span><br><span class="line">│               └── internal</span><br><span class="line">│                   └── x509</span><br><span class="line">├── java</span><br><span class="line">│   ├── awt</span><br><span class="line">│   │   └── font</span><br><span class="line">│   ├── beans</span><br><span class="line">│   ├── io</span><br><span class="line">│   ├── lang</span><br><span class="line">│   │   ├── annotation</span><br><span class="line">│   │   ├── invoke</span><br><span class="line">│   │   ├── ref</span><br><span class="line">│   │   └── reflect</span><br><span class="line">│   ├── math</span><br><span class="line">│   ├── net</span><br><span class="line">│   ├── nio</span><br><span class="line">│   │   ├── channels</span><br><span class="line">│   │   │   └── spi</span><br><span class="line">│   │   ├── charset</span><br><span class="line">│   │   │   └── spi</span><br><span class="line">│   │   └── file</span><br><span class="line">│   │       ├── attribute</span><br><span class="line">│   │       └── spi</span><br><span class="line">│   ├── security</span><br><span class="line">│   │   ├── acl</span><br><span class="line">│   │   ├── cert</span><br><span class="line">│   │   ├── interfaces</span><br><span class="line">│   │   └── spec</span><br><span class="line">│   ├── sql</span><br><span class="line">│   ├── text</span><br><span class="line">│   ├── time</span><br><span class="line">│   │   ├── chrono</span><br><span class="line">│   │   ├── format</span><br><span class="line">│   │   ├── temporal</span><br><span class="line">│   │   └── zone</span><br><span class="line">│   └── util</span><br><span class="line">│       ├── concurrent</span><br><span class="line">│       │   ├── atomic</span><br><span class="line">│       │   └── locks</span><br><span class="line">│       ├── function</span><br><span class="line">│       ├── jar</span><br><span class="line">│       ├── logging</span><br><span class="line">│       ├── prefs</span><br><span class="line">│       ├── regex</span><br><span class="line">│       ├── stream</span><br><span class="line">│       └── zip</span><br><span class="line">├── javax</span><br><span class="line">│   ├── crypto</span><br><span class="line">│   │   ├── interfaces</span><br><span class="line">│   │   └── spec</span><br><span class="line">│   ├── net</span><br><span class="line">│   │   └── ssl</span><br><span class="line">│   ├── security</span><br><span class="line">│   │   ├── auth</span><br><span class="line">│   │   │   ├── callback</span><br><span class="line">│   │   │   ├── login</span><br><span class="line">│   │   │   └── x500</span><br><span class="line">│   │   └── cert</span><br><span class="line">│   └── sql</span><br><span class="line">│       └── rowset</span><br><span class="line">├── jdk</span><br><span class="line">│   ├── internal</span><br><span class="line">│   │   ├── util</span><br><span class="line">│   │   └── vm</span><br><span class="line">│   │       └── annotation</span><br><span class="line">│   └── net</span><br><span class="line">└── sun</span><br><span class="line">    ├── invoke</span><br><span class="line">    │   └── util</span><br><span class="line">    ├── misc</span><br><span class="line">    ├── net</span><br><span class="line">    │   ├── ftp</span><br><span class="line">    │   │   └── impl</span><br><span class="line">    │   ├── spi</span><br><span class="line">    │   │   └── nameservice</span><br><span class="line">    │   ├── util</span><br><span class="line">    │   └── www</span><br><span class="line">    │       └── protocol</span><br><span class="line">    │           ├── file</span><br><span class="line">    │           ├── ftp</span><br><span class="line">    │           └── jar</span><br><span class="line">    ├── nio</span><br><span class="line">    │   ├── ch</span><br><span class="line">    │   ├── cs</span><br><span class="line">    │   └── fs</span><br><span class="line">    ├── reflect</span><br><span class="line">    │   └── misc</span><br><span class="line">    ├── security</span><br><span class="line">    │   ├── action</span><br><span class="line">    │   ├── jca</span><br><span class="line">    │   ├── pkcs</span><br><span class="line">    │   ├── provider</span><br><span class="line">    │   │   └── certpath</span><br><span class="line">    │   ├── timestamp</span><br><span class="line">    │   ├── util</span><br><span class="line">    │   └── x509</span><br><span class="line">    └── util</span><br><span class="line">        ├── calendar</span><br><span class="line">        ├── locale</span><br><span class="line">        │   └── provider</span><br><span class="line">        ├── logging</span><br><span class="line">        └── resources</span><br></pre></td></tr></table></figure>

<h2><span id="311-了解sepolicy">3.11 了解sepolicy</span></h2><p>​    <code>sepolicy</code>主要用来存放<code>SELinux</code>策略的目录，<code>SELinux</code>是一种强制访问控制机制，<code>Android</code>系统中实现访问控制的一种安全机制，它在<code>Linux</code>内核的基础上实现，用于保证手机安全。</p>
<p>​    <code>SELinux</code>主要用于限制应用程序的权限，使其只能访问其所需的资源，并在需要时向用户请求权限。通过限制应用程序的权限，可以防止恶意软件和攻击者攻击系统。具体而言，<code>sepolicy</code>可以做到以下几点：</p>
<ol>
<li>限制应用程序访问系统的资源，例如系统设置、网络接口等。</li>
<li>限制应用程序的使用权限，例如读取联系人、访问存储空间等。</li>
<li>保护系统文件和目录，防止应用程序和攻击者修改和删除系统关键文件。</li>
</ol>
<p>​    <code>Type Enforcement</code>是<code>SELinux</code>中的一个安全策略机制，用于对系统中每个对象和主体的访问进行强制访问控制。在<code>Type Enforcement</code>的模型中，每个对象和主体都被赋予了一个安全上下文（<code>Security Context</code>），该上下文由多个标签组成。</p>
<p>​    <code>Role-Based Access Control（RBAC）</code>也是 <code>SELinux</code> 中的一种访问控制机制，用于对系统中多个用户、角色和对象的访问进行授权和限制。在<code>RBAC</code>模型中，每个用户都被分配了一个或多个角色，每个角色都有一组特定的权限和访问控制规则。与传统的访问控制方式不同，<code>RBAC</code>可以根据用户的职责和角色来授权和限制其访问，并且可以通过添加或删除角色等方式对访问控制进行动态管理。这种机制可以确保系统中不同用户之间的隔离和资源保护，并提高系统的安全性和可靠性。</p>
<p>​    在<code>SELinux</code>中，标签分为三种类型：用户标签（<code>User ID</code>）、角色标签（<code>Role</code>）和类型标签（<code>Type</code>）。每个安全上下文都包含了这三种标签的组合，如“<code>u:r:system_app:s0</code>”表示该上下文对应一个用户标签为“<code>system_app</code>”的进程，其角色标签和类型标签分别为“<code>r</code>”和“<code>s0</code>”。</p>
<p>​    通过安全上下文，<code>SELinux</code>可以对系统中的对象和主体进行细粒度控制，并限制它们之间的交互。例如，如果两个对象或主体的安全上下文不匹配，则它们不能相互通信或共享资源。这种机制可以有效地防止恶意应用程序或者攻击者对系统进行攻击或滥用。也可以通过修改 <code>sepolicy</code> 目录下的文件来调整安全策略，从而适应不同的应用程序和系统需求。</p>
<p>​    在<code>ROM</code>定制时，常会添加某些功能时由于权限问题导致系统输出警告信息提示错误，这种情况需要调整安全策略。调整策略的位置在<code>Android</code>源代码的 <code>./system/sepolicy/</code> 目录中，<code>public</code>、<code>private</code>目录下。</p>
<ol>
<li><code>public</code>：该目录包含<code>Android</code>系统与函数库等公共的<code>sepolicy</code>规则。这些规则是开发人员和厂商可以自由使用和修改的，因为这些规则涉及到的是公共区域的访问控制。</li>
<li><code>private</code>：该目录包含硬编码到<code>Android</code>系统中的特定规则。这些规则用于控制既定的<code>Android</code>系统功能和应用程序，例如拨号应用程序、电源管理等，因此这些规则不能被修改或覆盖。</li>
</ol>
<p>​    当修改<code>Android</code>系统的<code>SELinux</code>策略时，系统会使用<code>prebuilts</code>目录中的策略进行对比，这是因为<code>prebuilts</code>中包含了在 <code>Android</code>设备上预置的<code>SELinux</code>策略和规则。</p>
<p>​    对安全策略有一个大致的了解后，先看一个简单的例子，找到文件<code>./system/sepolicy/public/adbd.te</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 定义类型</span><br><span class="line">type adbd, domain;</span><br><span class="line"></span><br><span class="line"># 允许adbd类型的进程，在类型shell_test_data_file中的目录内创建子目录</span><br><span class="line">allow adbd shell_test_data_file:dir create_dir_perms;</span><br></pre></td></tr></table></figure>

<p>​    这里使用了三个类型：</p>
<ul>
<li><code>adbd</code>：指定进程的类型；</li>
<li><code>domain</code>：指定域的类型；</li>
<li><code>shell_test_data_file</code>：指定目录的类型。</li>
</ul>
<p>​    规则使用了<code>allow</code>关键字，表示允许某些操作。具体来说，上述规则允许<code>adbd</code>类型的进程在<code>shell_test_data_file</code>类型的目录下创建目录，并且该目录将被赋予允许创建子目录的权限（由<code>create_dir_perms</code>定义）。</p>
<p>​    这个规则的实际意义是，当<code>adbd</code>进程需要在<code>shell_test_data_file</code>目录下创建子目录时，允许该操作，并为新创建的目录设置适当的权限。注意，这个规则只对该目录有效，不能用于其他目录。</p>
<p>​    通常情况下采用按需修改的方式调整安全策略，当添加的功能被安全策略拦住时，会输出警告提示。例如在文件<code>com_android_internal_os_Zygote.cpp</code>的<code>SpecializeCommon</code>函数中加入如下代码，访问data目录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> filepath=<span class="string">&quot;/data/app/demo&quot;</span>;</span><br><span class="line">ReadFileToString(filepath,&amp;file_contents)</span><br></pre></td></tr></table></figure>

<p>​    然后就会被<code>SELinux</code>拦截并提示警告信息如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avc: denied &#123; search &#125; for name&#x3D;&quot;app&quot; dev&#x3D;&quot;dm-8&quot; ino&#x3D;100 scontext&#x3D;u:r:zygote:s0 tcontext&#x3D;u:object_r:apk_data_file:s0 tclass&#x3D;dir permissive&#x3D;0</span><br></pre></td></tr></table></figure>

<p>​    在<code>SELinux</code>中，<code>avc: denied</code>是出现最频繁的提示之一，根据提示可以知道，进程<code>zygote</code>对安全上下文为<code>u:object_r:apk_data_file:s0</code>的目录进行<code>search</code>操作，该行为被拒绝了。除此之外，还有其他拒绝访问的提示消息如下。</p>
<ul>
<li><p><code>avc: denied &#123;open&#125; </code>- 表示进程被禁止打开文件或设备。</p>
</li>
<li><p><code>avc: denied &#123;read&#125; </code>- 表示进程被禁止读取一个文件、设备或目录。</p>
</li>
<li><p><code>avc: denied &#123;write&#125;</code> - 表示进程被禁止写入一个文件、设备或目录。</p>
</li>
<li><p><code>avc: denied &#123;getattr&#125;</code> - 表示进程被禁止读取一个文件或目录的元数据（例如，所有权、组、权限等）。</p>
</li>
<li><p><code>avc: denied &#123;execute&#125;</code> - 表示进程被禁止执行一个文件或进程。</p>
</li>
<li><p><code>avc: denied &#123;create&#125; </code>- 表示进程被禁止创建一个文件。</p>
</li>
<li><p><code>avc: denied &#123;search&#125; </code>- 表示此进程被禁止在某目录中搜索文件的操作</p>
</li>
</ul>
<p>​    除了 <code>avc: denied</code>之外，还有其他一些可能出现的提示信息。以下是一些常见提示信息以及它们的含义：</p>
<ul>
<li><p><code>avc: granted</code> - 操作被允许。</p>
</li>
<li><p><code>avc: audit</code> - 正在监视执行上下文之间的交互，并将相关信息记录到审计日志中。</p>
</li>
<li><p><code>avc: no audit</code> - 没有记录此操作的详细信息，这通常是因为没有启用<code>SELinux</code>的审计功能。</p>
</li>
<li><p><code>avc: invalid</code> - 操作请求的权限非法或无效。</p>
</li>
<li><p><code>avc: timeout</code> - <code>SELinux</code>规则分析器超时无法确定操作是否应该允许。在这种情况下，操作通常会被拒绝。</p>
</li>
<li><p><code>avc: failed</code> - <code>SELinux</code>规则分析器无法确定操作是否应该被允许或拒绝。</p>
</li>
</ul>
<p>​    在<code>SELinux</code>中，<code>scontext</code>代表系统中的安全上下文，<code>tcontext</code>代表对象的安全上下文。每个具有权限要求的进程和对象都有一个安全上下文。<code>SELinux</code>使用这些安全上下文来进行访问控制决策。</p>
<p><code>scontext</code>和<code>tcontext</code>中的“<code>u</code>”，“<code>r</code>”和“<code>s0</code>”是安全上下文标记的不同部分。含义如下：</p>
<ul>
<li><p><code>u </code>- 代表<code>selinux</code>中定义的用户，<code>tcontext</code>中的<code>u</code>代表对象所属用户。</p>
</li>
<li><p><code>r </code>- 代表进程的角色（<code>role</code>），<code>tcontext</code>中的r代表对象的角色。</p>
</li>
<li><p><code>s0</code> - 代表进程的安全策略范围（<code>security level</code>），<code>tcontext</code>中的<code>s0</code>代表对象的安全策略范围。<code>s0</code>通常表示为默认值。</p>
</li>
</ul>
<p>​    可以通过命令<code>ps -eZ</code>来查看进程的<code>scontext</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -eZ</span><br><span class="line"></span><br><span class="line">u:r:servicemanager:s0          system         672     1 10860740  3784 SyS_epoll+          0 S servicemanager</span><br><span class="line">u:r:hwservicemanager:s0        system         673     1 10880928  4648 SyS_epoll+          0 S hwservicemanager</span><br><span class="line">u:r:kernel:s0                  root           674     2       0      0 worker_th+          0 S [kworker&#x2F;7:1H]</span><br><span class="line">u:r:vndservicemanager:s0       system         675     1 10813436  2884 SyS_epoll+          0 S vndservicemanager</span><br><span class="line">u:r:kernel:s0                  root           676     2       0      0 kthread_w+          0 S [psimon]</span><br></pre></td></tr></table></figure>

<p>​    可以通过命令<code>ls -Z</code>来查看文件的<code>scontext</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;app</span><br><span class="line">ls -Z -all</span><br><span class="line"></span><br><span class="line">drwxrwxr-x  3 system system u:object_r:apk_data_file:s0          3488 2023-02-26 21:50:57.968696920 +0800 ~~QZ-rYHaywe6nr2ryYn3UoQ&#x3D;&#x3D;</span><br><span class="line">drwxrwxr-x  3 system system u:object_r:apk_data_file:s0          3488 2023-03-02 22:12:29.802016689 +0800 ~~W9dmzmphiDsjJm79RiBwdg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>​    重新对下面的这个提示进行一次解读。<code>selinux</code>拒绝搜索一个目录，目录名称为<code>app</code>，所在设备为<code>dm-8</code>，被拒绝的进程上下文特征是<code>u:r:zygote:s0</code>，角色是<code>zygote</code>，目标文件上下文特征是<code>u:object_r:apk_data_file:s0</code>，用户级别为<code>object_r</code>，文件的所属类型是<code>apk_data_file</code>，表示应用程序的数据文件。<code>tclass</code>表示请求对象的类型，<code>dir</code>为目录，<code>file</code>表示文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avc: denied &#123; search &#125; for name&#x3D;&quot;app&quot; dev&#x3D;&quot;dm-8&quot; ino&#x3D;100 scontext&#x3D;u:r:zygote:s0 tcontext&#x3D;u:object_r:apk_data_file:s0 tclass&#x3D;dir permissive&#x3D;0</span><br></pre></td></tr></table></figure>

<p>​    解读完成后，可以开始调整安全策略了，找到文件<code>system/sepolicy/private/zygote.te</code>，然后添加策略如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow zygote apk_data_file:dir search;</span><br></pre></td></tr></table></figure>

<p>​    修改完成后编译时，会报错，提示<code>diff</code>对比文件时发现内容不一致。最后再将文件<code>system/sepolicy/prebuilts/api/31.0/private/zygote.te</code>下添加相同的策略即可成功编译。</p>
<p>​    <code>neverallow</code>是<code>SELinux</code>策略语言中的一个规则，它用于指定某个操作永远不允许执行。<code>neverallow</code>规则用于设置一些强制访问控制规则，以在安全策略中明确禁止某些行为，从而提高其安全性。<code>neverallow</code>规则与<code>allow</code>规则在语法上非常相似，但在作用上截然不同。</p>
<p>​    有时按照警告信息提示，添加了对应策略后无法编译通过提示违反了<code>neverallow</code>。这种情况可以找到对应的<code>neverallow</code>，进行修改添加一个白名单来放过添加的规则。例如下面这个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">neverallow &#123;</span><br><span class="line">  coredomain</span><br><span class="line">  -fsck</span><br><span class="line">  -init</span><br><span class="line">  -ueventd</span><br><span class="line">  -zygote</span><br><span class="line">&#125; device:&#123; blk_file file &#125; no_rw_file_perms;</span><br></pre></td></tr></table></figure>

<p>​    这个规则禁止上述进程以可读可写权限读写 <code>device</code> 类型的文件，其中<code>-zygote</code>，这种前面带有<code>-</code>表示排除掉这种进程，如果被设置了永不允许，只要找到对应的设置处，添加上排除对应进程即可成功编译了。</p>
<h2><span id="312-了解linker">3.12 了解Linker</span></h2><p>​    <code>Linker</code>是安卓中的一个系统组件，负责加载和链接系统动态库文件。</p>
<p>​    在<code>Android</code>源代码中，<code>Linker</code>源码的主要目录是<code>bionic/linker</code>。该目录包含<code>Linker</code>的核心实现，如动态加载、符号表管理、重定位、符号解析、<code>SO</code>文件搜索等。其中，<code>linker.c</code>是<code>Linker</code>的主要入口点，该文件中包含了大量的实现细节。<code>linker_phdr.c</code>是负责加载和处理<code>ELF</code>格式库文件的代码，<code>linker_namespaces.cpp</code>负责管理命名空间的代码，<code>linker_relocs.cpp</code>负责处理重定位的代码，<code>linker_sleb128.cpp</code>和<code>linker_uleb128.cpp</code>负责压缩和解压缩数据的实现等。除了<code>bionic/linker</code>目录外，<code>Linker</code>相关的代码还分散在其他系统组件中，例如系统服务和应用程序框架。</p>
<p>​    <code>linker</code>提供的一些函数来操作动态库，相关函数如下。</p>
<p>​    1. <code>dlopen</code>：打开一个动态链接库并返回句柄。</p>
<p>​    2. <code>dlsym</code>：查找动态链接库中符号的地址。</p>
<p>​    3. <code>dlclose</code>：关闭先前打开的动态链接库。</p>
<p>​    4. <code>dlerror</code>：返回最近的动态链接库错误。</p>
<p>​    5. <code>dladdr</code>：根据一个内存地址，返回映射到该地址的函数或变量的信息。</p>
<p>​    6. <code>dl_iterate_phdr</code>：遍历进程的动态链接库模块，可以获取模块地址、同名模块列表等信息。</p>
<p>​    在开始了解<code>Linker</code>如何加载动态库<code>so</code>文件前，需要先对<code>so</code>文件有一个简单的了解。</p>
<h3><span id="3121-elf文件格式">3.12.1 ELF文件格式</span></h3><p>​    在<code>Android</code>中，<code>so（Shared Object）</code>动态库是一种是一种基于<code>ELF</code>格式<code>（Executable and Linkable Format）</code>的可执行文件，它包含已编译的函数和数据，可以在运行时被加载到内存中，并被多个应用程序或共享库使用。</p>
<p>​    与静态库不同，动态库中的代码在可执行文件中并不存在，取而代之的是一些动态链接器（<code>Linker</code>）编译时不知道的外部引用符号。在运行时，<code>Linker</code>会根据动态库中的符号表来解析这些引用，并将动态库中的函数和数据链接到可执行程序中。</p>
<p>​    进程间共享动态库可以大大减少内存使用，提高代码重用性和可维护性。例如，如果多个应用程序都需要使用同一组件库，可以将其实现作为共享库提供。这样一来，每个应用程序都可以使用同一份库，而不必将代码重复添加到每个应用程序中。</p>
<p>​    在<code>ELF</code>文件结构中，包含以下三个部分：</p>
<ol>
<li><p><code>ELF Header</code>，<code>ELF</code>文件头，包含了文件的基本信息，例如文件类型、程序入口地址、节表的位置和大小等。</p>
</li>
<li><p><code>Section Header</code>，节头部分，描述了文件中各个节的大小、类型和位置等信息。<code>ELF</code>文件中的每个节都包含某种类型的信息，例如代码、数据、符号表、重定位表以及其他调试信息等。</p>
</li>
<li><p><code>Program Header</code>，段头部分，描述了可执行文件在内存中的布局。由于ELF文件的节可以以任意顺序排列，因此<code>Linker</code>在加载前需要使用<code>Program Header</code>来释放并映射虚拟内存，创建进程虚拟内存段布局。<code>Program Header</code>也包含了动态链接器所需的信息，例如动态库的位置、依赖关系和符号表位置等。</p>
</li>
</ol>
<p>​    使用<code>Android Studio</code>创建一个<code>Native C++</code>的项目，成功编译后来到<code>output</code>目录中，解压<code>app-debug.apk</code>文件，然后进入<code>app-debug\lib\arm64-v8a\</code>目录，找到<code>so</code>文件将其拖入<code>010 Editor</code>编辑器工具中。</p>
<p>​    接着给<code>010 Editor</code>编辑器安装一个<code>ELF</code>格式解析的模板，在工具栏找到模板-&gt;模板存储库。搜索<code>ELF</code>，点击安装，操作见下图。</p>
<p><img src="/2025/04/07/chapter-03/image-20230304135859598.png" alt="image-20230304135859598"></p>
<p>​    模板安装后，关闭文件，重新使用<code>010 Editor</code>打开后，将编辑方式切换为模板后，就能成功看到使用ELF格式解析so文件的结果了，如下图。</p>
<p><img src="/2025/04/07/chapter-03/image-20230304140328010.png" alt="image-20230304140328010"></p>
<p>​        <code>ELF</code>头部定义了<code>ELF</code>文件的基本属性和结构，也为后续的段表和节表等信息提供了重要的指导作用。加载<code>ELF</code>文件的第一步就是解析<code>ELF</code>头部后，再根据头部信息去解析其他部分的数据，<code>ELF</code>头部（<code>elf_header</code>）结构包含以下成员：</p>
<ul>
<li><p><code>e_ident</code>：长度为 16 字节的数组，用于标识文件类型和文件版本等信息。</p>
</li>
<li><p><code>e_type：ELF</code>文件类型，如可执行文件、共享库、目标文件等等。</p>
</li>
<li><p><code>e_machine</code>：目标硬件架构。</p>
</li>
<li><p><code>e_version</code>：<code>ELF文</code>件的版本，其一般为<code>EV_CURRENT</code>。</p>
</li>
<li><p><code>e_entry</code>：程序入口点的虚拟地址。</p>
</li>
<li><p><code>e_phoff</code>：程序头表（<code>program header table</code>）的偏移量（以字节为单位）。</p>
</li>
<li><p><code>e_shoff</code>：节头表（<code>section header table</code>）的偏移量（以字节为单位）。</p>
</li>
<li><p><code>e_flags</code>：表示一些标志，比如针对硬件进行微调的标志。</p>
</li>
<li><p><code>e_ehsize</code>：<code>ELF</code>头部的长度（以字节为单位）。</p>
</li>
<li><p><code>e_phentsize</code>：程序头表中一个入口的长度（以字节为单位）。</p>
</li>
<li><p><code>e_phnum</code>：程序头表中入口的数量。</p>
</li>
<li><p><code>e_shentsize</code>：节头表中一个入口的长度（以字节为单位）。</p>
</li>
<li><p><code>e_shnum</code>：节头表中入口的数量。</p>
</li>
<li><p><code>e_shstrndx</code>：节头表中节名称字符串表的索引。</p>
</li>
</ul>
<p>​    下图是<code>010 Edtior</code>解析展示的结果图。</p>
<p><img src="/2025/04/07/chapter-03/image-20230304141143199.png" alt="image-20230304141143199"></p>
<p>​    <code>program header table</code>是一种用于描述可执行文件和共享库的各个段（<code>section</code>）在进程内存中的映射关系的结构，也称为段表。每个程序头表入口表示一个段。在<code>Linux</code>系统中，它是被操作系统用于将<code>ELF</code>文件加载到进程地址空间的重要数据结构之一。每个<code>program header table</code>具有相同的固定结构，相关字段如下：</p>
<ul>
<li><p><code>p_type</code>：指定该段的类型，如可执行代码、只读数据、可读写数据、动态链接表、注释等等。</p>
</li>
<li><p><code>p_offset</code>：该段在<code>ELF</code>文件中的偏移量（以字节为单位）。</p>
</li>
<li><p><code>p_vaddr</code>：该段在进程虚拟地址空间中的起始地址。</p>
</li>
<li><p><code>p_paddr</code>：该项通常与<code>p_vaddr</code>相等。用于操作系统在将<code>ELF</code>文件的一个段映射到进程地址空间前，进行虚拟地址和物理地址的转换等操作。</p>
</li>
<li><p><code>p_filesz</code>：该段在文件中的长度（以字节为单位）。</p>
</li>
<li><p><code>p_memsz</code>：该段在加到进程地址空间后的长度（以字节为单位）。</p>
</li>
<li><p><code>p_flags</code>：用于描述该段的标志，如可读、可写、可执行、不可缓存等等。</p>
</li>
<li><p><code>p_align</code>：对于某些类型的段，该字段用于指定段在地址空间中的对齐方式。</p>
</li>
</ul>
<p>​    下图是编辑器中解析so看到的值</p>
<p><img src="/2025/04/07/chapter-03/image-20230304142500744.png" alt="image-20230304142500744"></p>
<p>​    <code>section header table</code>（节头表）是用于描述<code>ELF</code>文件中所有节（<code>section</code>）的元信息列表，也称为节表。它包含了每个节在文件中的位置、大小、类型、属性等信息。节头表的中相关字段如下：</p>
<ul>
<li><p><code>sh_name</code>: 节的名字在<code>.shstrtab</code>节中的向偏移量。这个偏移量可以用于获取该节的名字。</p>
</li>
<li><p><code>sh_type</code>：节的类型（<code>type</code>），如代码段、数据段、符号表等。</p>
</li>
<li><p><code>sh_flags</code>：节的属性标志，如是否可读、可写、可执行等。</p>
</li>
<li><p><code>sh_addr</code>：节的内存地址（<code>virtual address</code>），当这个地址为零时，表示这个节没有被加载到内存中。</p>
</li>
<li><p><code>sh_offset</code>：节在<code>ELF</code>文件中的偏移量（<code>offset</code>）。</p>
</li>
<li><p><code>sh_size</code>：节的长度（<code>size</code>）属性。</p>
</li>
<li><p><code>sh_link</code>：节的连接节（<code>linking section</code>），可以帮助定位一些节，如符号表。</p>
</li>
<li><p><code>sh_info</code>：与<code>sh_link</code>一起使用，具体含义与<code>sh_link</code>的值有关。</p>
</li>
<li><p><code>sh_addralign</code>：节的对齐方式（<code>alignment</code>）。</p>
</li>
<li><p><code>sh_entsize</code>：节的<code>entry</code>的大小。</p>
</li>
</ul>
<p>​    通过这些信息，<code>section header table</code>可以为执行链接和动态加载提供必要的元数据信息。样例数据看下图</p>
<p><img src="/2025/04/07/chapter-03/image-20230304143100841.png" alt="image-20230304143100841"></p>
<p>​    <code>ELF</code>文件中有各种节用于存放对应的信息，几个常见的节点存放数据的描述如下。</p>
<ul>
<li><p><code>.dynsym</code> 节：该节包含动态链接符号表（<code>dynamic symbol table</code>），用于描述<code>.so</code>文件所包含的动态链接库中的符号。符号是程序中一些命名实体的名称，例如函数、变量、常量等等，描述了这些实体在程序中的地址和大小等信息。<code>.dynsym</code> 节可以协助动态加载器（<code>Dynamic Linker</code>）在程序运行时逐个查找符号。</p>
</li>
<li><p><code>.dynstr</code> 节：用于存放符号表中的字符串，包括函数名、变量名、库名等等。</p>
</li>
<li><p><code>.plt</code> 节：保存了远程函数调用实现的跳转代码。</p>
</li>
<li><p><code>.rodata</code> 节：包含程序中只读数据的代码段，如字符串常量、全局常量等等。</p>
</li>
<li><p><code>.text</code> 节：程序的主要代码存放在该节中。该节包含可执行代码的机器语言指令，例如函数代码、条件语句、循环语句等等。</p>
</li>
<li><p><code>.bss</code> 节点（<code>Block Started by Symbol</code>）存储未初始化的全局变量和静态变量，其大小在编译时无法确定。因此，<code>.bss</code>节点在<code>ELF</code>文件中只占据一些空间，该空间称为<code>bss</code>段。而在运行时，操作系统会分配实际的内存空间给这些变量。<code>.bss</code>节点的大小在 <code>ELF</code>文件头的<code>e_shsize</code>字段中给出。</p>
</li>
<li><p><code>.shstrtab</code> 节点（<code>Section Header String Table</code>）存储节名称字符串，即每个节的名称和节头表中的节名称偏移量。它包含了<code>ELF</code>文件中每个节的字符串名称，方便读取程序在加载时快速访问。在<code>Android</code>中，<code>.shstrtab</code>节点是一个特殊的节，它位于节头表的末尾，可以通过<code>ELF</code>文件头的<code>e_shstrndx</code>字段找到。</p>
</li>
</ul>
<p><img src="/2025/04/07/chapter-03/image-20230304143003972.png" alt="image-20230304143003972"></p>
<h3><span id="3122-动态库加载流程">3.12.2 动态库加载流程</span></h3><p>​    <code>Linker</code>动态库加载是把代码（函数、变量、数据结构等）从动态链接库（<code>so</code>文件）中加载到内存中，并建立起代码之间的相互引用关系的过程。在<code>Android</code>等操作系统中，<code>Linker</code>动态加载主要用于模块化开发，将程序分为多个独立的模块，以便于代码的管理和维护。下面是<code>Linker</code>动态加载的主要步骤：</p>
<ol>
<li>根据系统的运行时需求，将需要的库文件加载进内存中，实现代码重用和共享。此时，<code>Linker</code>会执行一些特定的逻辑，如依赖优化、<code>so</code>文件版本检查等。</li>
<li>在进行动态链接的过程中，<code>Linker</code>会为每个库和每个函数生成全局唯一的标识符，以确定代码所在的地址。这个标识符会在编译过程中嵌入到库文件的头部，并且保存到动态链接库的符号表中。</li>
<li>解析符号表。<code>Linker</code>会读取库文件的符号表，并把符号名和符号地址配对起来，以便于在程序运行期间在内存中动态地连接他们。</li>
<li>检查符号表中的函数的其他库依赖项。如果当前库依赖于其他库，<code>Linker</code>就会递归地对这些依赖库进行加载、解析和链接。</li>
<li>调整符号地址。<code>Linker</code>会修改符号表中的函数地址，将函数重定向到动态库中正确的位置，以确保函数调用能够正确地传递和接收数据。</li>
<li>执行初始化和清理代码。在所有库和函数都被解析、链接和装载之后，<code>Linker</code>会执行全局构造函数来初始化代码，以及执行全局析构函数来清理代码。</li>
<li><code>Linker</code>动态加载过程中还会涉及到如动态追加、卸载等操作。</li>
</ol>
<p>​    以上是<code>Linker</code>动态加载的主要步骤及涉及到的主要逻辑。接着从源码层面跟踪动态加载的具体过程。打开前面创建的样例<code>app</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Used to load the &#x27;linkertest&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;linkertest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在应用层直接通过调用<code>loadLibrary</code>就可以完成一系列的加载动态库的操作了，看看内部是如何实现的。首先是<code>System</code>下的<code>loadLibrary</code>函数，前文有介绍过<code>libcore</code>中存放着<code>openjdk</code>的核心库的实现，而<code>java.lang.System</code>就是其中，找到文件<code>libcore/ojluni/src/main/java/java/lang/System.java</code>查看函数实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    继续在<code>ojluni</code>的目录中搜索<code>loadLibrary0</code>的函数实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(Class&lt;?&gt; fromClass, String libname)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = ClassLoader.getClassLoader(fromClass);</span><br><span class="line">    loadLibrary0(classLoader, fromClass, libname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(ClassLoader loader, Class&lt;?&gt; callerClass, String libname)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    String libraryName = libname;</span><br><span class="line">    <span class="comment">// 如果classloader不是BootClassLoader</span></span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; !(loader <span class="keyword">instanceof</span> BootClassLoader)) &#123;</span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (loader.getClass() == PathClassLoader.class ||</span><br><span class="line">             loader.getClass() == DelegateLastClassLoader.class)) &#123;</span><br><span class="line"></span><br><span class="line">            filename = System.mapLibraryName(libraryName);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        String error = nativeLoad(filename, loader);</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getLibPaths();</span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    String error = nativeLoad(filename, loader, callerClass);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看到不管是哪个Classloader都是调用的nativeLoad，只是重载不一样。但是两个参数的实际也是调用了三个参数重载的实现。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nativeLoad(filename, loader, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个参数重载的是一个native函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader, Class&lt;?&gt; caller)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    继续搜索<code>nativeLoad</code>的相关实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用了JVM_NativeLoad</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Runtime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,</span><br><span class="line">                   jobject javaLoader, jclass caller)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_NativeLoad(env, javaFilename, javaLoader, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>JVM_NativeLoad</code>的代码在art目录中，继续查看相关实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring <span class="title">JVM_NativeLoad</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jstring javaFilename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jclass caller)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">filename</span><span class="params">(env, javaFilename)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (filename.c_str() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">  &#123;</span><br><span class="line">    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();</span><br><span class="line">    <span class="keyword">bool</span> success = vm-&gt;LoadNativeLibrary(env,</span><br><span class="line">                                         filename.c_str(),</span><br><span class="line">                                         javaLoader,</span><br><span class="line">                                         caller,</span><br><span class="line">                                         &amp;error_msg);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续找到相关实现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JavaVMExt::LoadNativeLibrary</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  jobject class_loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  jclass caller_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="built_in">std</span>::<span class="built_in">string</span>* error_msg)</span> </span>&#123;</span><br><span class="line">  error_msg-&gt;clear();</span><br><span class="line">  SharedLibrary* library;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 已经加载过的，存在则返回true了。</span></span><br><span class="line">  <span class="keyword">if</span> (library != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedLocalRef&lt;jstring&gt; <span class="title">library_path</span><span class="params">(env, GetLibrarySearchPath(env, class_loader))</span></span>;</span><br><span class="line"></span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* path_str = path.empty() ? <span class="literal">nullptr</span> : path.c_str();</span><br><span class="line">  <span class="keyword">bool</span> needs_native_bridge = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">char</span>* nativeloader_error_msg = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 加载动态链接库</span></span><br><span class="line">  <span class="keyword">void</span>* handle = android::OpenNativeLibrary(</span><br><span class="line">      env,</span><br><span class="line">      runtime_-&gt;GetTargetSdkVersion(),</span><br><span class="line">      path_str,</span><br><span class="line">      class_loader,</span><br><span class="line">      (caller_location.empty() ? <span class="literal">nullptr</span> : caller_location.c_str()),</span><br><span class="line">      library_path.get(),</span><br><span class="line">      &amp;needs_native_bridge,</span><br><span class="line">      &amp;nativeloader_error_msg);</span><br><span class="line">  VLOG(jni) &lt;&lt; <span class="string">&quot;[Call to dlopen(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;, RTLD_NOW) returned &quot;</span> &lt;&lt; handle &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">bool</span> created_library = <span class="literal">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SharedLibrary&gt; <span class="title">new_library</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">new</span> SharedLibrary(env,</span></span></span><br><span class="line"><span class="function"><span class="params">                          self,</span></span></span><br><span class="line"><span class="function"><span class="params">                          path,</span></span></span><br><span class="line"><span class="function"><span class="params">                          handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                          needs_native_bridge,</span></span></span><br><span class="line"><span class="function"><span class="params">                          class_loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                          class_loader_allocator))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">    <span class="comment">// 将刚刚加载好的链接库保存起来</span></span><br><span class="line">    <span class="keyword">if</span> (library == <span class="literal">nullptr</span>) &#123;  <span class="comment">// We won race to get libraries_lock.</span></span><br><span class="line">      library = new_library.release();</span><br><span class="line">      libraries_-&gt;Put(path, library);</span><br><span class="line">      created_library = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">bool</span> was_successful = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 查找符号JNI_OnLoad</span></span><br><span class="line">  <span class="keyword">void</span>* sym = library-&gt;FindSymbol(<span class="string">&quot;JNI_OnLoad&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (sym == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));</span><br><span class="line">    self-&gt;SetClassLoaderOverride(class_loader);</span><br><span class="line"></span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">&quot;[Calling JNI_OnLoad in \&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">using</span> JNI_OnLoadFn = <span class="keyword">int</span>(*)(JavaVM*, <span class="keyword">void</span>*);</span><br><span class="line">    JNI_OnLoadFn jni_on_load = <span class="keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);</span><br><span class="line">    <span class="comment">// 调用JNI_OnLoad</span></span><br><span class="line">    <span class="keyword">int</span> version = (*jni_on_load)(<span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	...</span><br><span class="line">  &#125;</span><br><span class="line">  library-&gt;SetResult(was_successful);</span><br><span class="line">  <span class="keyword">return</span> was_successful;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    在这个函数中，看到使用<code>OpenNativeLibrary</code>来加载一个动态库，然后将加载动态库的信息包装成<code>SharedLibrary</code>对象，存入<code>libraries_</code>中，下次再加载时，会在<code>libraries_</code>查看是否存在，存在则直接返回。接着又通过函数<code>FindSymbol</code>查找<code>JNI_OnLoad</code>的符号地址，然后进行调用。继续跟踪加载动态库的具体实现，最后再回头看查找符号的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">OpenNativeLibrary</span><span class="params">(JNIEnv* env, <span class="keyword">int32_t</span> target_sdk_version, <span class="keyword">const</span> <span class="keyword">char</span>* path,</span></span></span><br><span class="line"><span class="function"><span class="params">                        jobject class_loader, <span class="keyword">const</span> <span class="keyword">char</span>* caller_location, jstring library_path,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">bool</span>* needs_native_bridge, <span class="keyword">char</span>** error_msg)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ART_TARGET_ANDROID)</span></span><br><span class="line">  UNUSED(target_sdk_version);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (class_loader == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span>* handle = android_dlopen_ext(path, RTLD_NOW, &amp;dlextinfo);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *error_msg = strdup(dlerror());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      Result&lt;<span class="keyword">void</span>*&gt; handle = TryLoadNativeloaderExtraLib(path);</span><br><span class="line">      <span class="keyword">if</span> (!handle.ok()) &#123;</span><br><span class="line">        *error_msg = strdup(handle.error().message().c_str());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (handle.value() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handle.value();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">void</span>* handle = OpenSystemLibrary(path, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *error_msg = strdup(dlerror());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; lib_path : library_paths) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(path_arg, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> handle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NativeBridgeIsSupported(path_arg)) &#123;</span><br><span class="line">      *needs_native_bridge = <span class="literal">true</span>;</span><br><span class="line">      handle = NativeBridgeLoadLibrary(path_arg, RTLD_NOW);</span><br><span class="line">      <span class="keyword">if</span> (handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handle;</span><br><span class="line">      &#125;</span><br><span class="line">      *error_msg = strdup(NativeBridgeGetError());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *error_msg = strdup(dlerror());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这里函数看到，使用多种方式尝试进行动态加载，分别是<code>android_dlopen_ext</code>、<code>TryLoadNativeloaderExtraLib</code>、<code>OpenSystemLibrary</code>。它们都是在<code>Android</code>平台上用来加载动态库的方法，但是它们各自的使用场景略有不同：</p>
<ol>
<li><code>android_dlopen_ext</code>：是一个供开发者使用的公开函数，它支持指定库的绝对路径和不同的标志（如<code>RTLD_NOW</code>、<code>RTLD_LAZY</code>等），并返回一个指向已加载库的指针，供后续调用函数的时候使用。</li>
<li><code>TryLoadNativeloaderExtraLib</code>：是<code>Android</code>系统中的内部方法，用于加载额外的本地库。它被用于支持动态加载共享库的应用程序，例如使用反射实现的动态库加载方式。系统在应用程序启动时调用它，用于加载应用程序所需的额外本地库。使用该方法可以加载特定的本地库，并支持跨架构的执行。</li>
<li><code>OpenSystemLibrary</code>：也是<code>Android</code>系统中的内部方法，用于加载<code>Android</code>系统的本地库。它不需要指定库的路径，而是使用系统库路径中的路径名来加载相应的库文件。该方法主要用于加载<code>Android</code>操作系统核心中的一些固定的系统库，例如 <code>libz.so、liblog.so</code>等。</li>
</ol>
<p>​    总的来说，这三个方法都是用于加载动态库的方法，不同的是它们的使用场景略有不同。选一条路线分析即可，这里继续从<code>android_dlopen_ext</code>深入分析，该函数的相关代码在<code>libdl.cpp</code>中实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">android_dlopen_ext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">int</span> flag, <span class="keyword">const</span> android_dlextinfo* extinfo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* caller_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __loader_android_dlopen_ext(filename, flag, extinfo, caller_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    继续跟踪文件dlfcn.cpp中的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* __loader_android_dlopen_ext(<span class="keyword">const</span> <span class="keyword">char</span>* filename,</span><br><span class="line">                           <span class="keyword">int</span> flags,</span><br><span class="line">                           <span class="keyword">const</span> android_dlextinfo* extinfo,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">void</span>* caller_addr) &#123;</span><br><span class="line">  <span class="keyword">return</span> dlopen_ext(filename, flags, extinfo, caller_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">dlopen_ext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> android_dlextinfo* extinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">void</span>* caller_addr)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedPthreadMutexLocker <span class="title">locker</span><span class="params">(&amp;g_dl_mutex)</span></span>;</span><br><span class="line">  g_linker_logger.ResetState();</span><br><span class="line">  <span class="keyword">void</span>* result = do_dlopen(filename, flags, extinfo, caller_addr);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    __bionic_format_dlerror(<span class="string">&quot;dlopen failed&quot;</span>, linker_get_error_buffer());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    到这里<code>do_dlopen</code>则执行到了<code>Linker</code>部分的实现了，找到<code>linker.cpp</code>文件查看</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">do_dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> android_dlextinfo* extinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">void</span>* caller_addr)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  soinfo* si = find_library(ns, translated_name, flags, extinfo, caller);</span><br><span class="line">  loading_trace.End();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = si-&gt;to_handle();</span><br><span class="line">    LD_LOG(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;... dlopen calling constructors: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;</span>,</span><br><span class="line">           si-&gt;get_realpath(), si-&gt;get_soname(), handle);</span><br><span class="line">    si-&gt;call_constructors();</span><br><span class="line">    failure_guard.Disable();</span><br><span class="line">    LD_LOG(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;... dlopen successful: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;</span>,</span><br><span class="line">           si-&gt;get_realpath(), si-&gt;get_soname(), handle);</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里看到通过<code>find_library</code>进行查找的，找到后又调用了<code>call_constructors</code>函数。先看看<code>call_constructors</code>函数的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">soinfo::call_constructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (constructors_called || g_is_ldd) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  call_function(<span class="string">&quot;DT_INIT&quot;</span>, init_func_, get_realpath());</span><br><span class="line">  call_array(<span class="string">&quot;DT_INIT_ARRAY&quot;</span>, init_array_, init_array_count_, <span class="literal">false</span>, get_realpath());</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    根据上面代码发现这里就是<code>.init</code>和<code>.initarray</code>执行的地方，继续看加载的流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> soinfo* <span class="title">find_library</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> android_dlextinfo* extinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                            soinfo* needed_by)</span> </span>&#123;</span><br><span class="line">  soinfo* si = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    si = solist_get_somain();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!find_libraries(ns,</span><br><span class="line">                             needed_by,</span><br><span class="line">                             &amp;name,</span><br><span class="line">                             <span class="number">1</span>,</span><br><span class="line">                             &amp;si,</span><br><span class="line">                             <span class="literal">nullptr</span>,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             rtld_flags,</span><br><span class="line">                             extinfo,</span><br><span class="line">                             <span class="literal">false</span> <span class="comment">/* add_as_children */</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (si != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      soinfo_unload(si);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  si-&gt;increment_ref_count();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向下跟踪</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_libraries</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ZipArchiveCache zip_archive_cache;</span><br><span class="line">  <span class="keyword">soinfo_list_t</span> new_global_group_members;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i&lt;load_tasks.size(); ++i) &#123;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> (!find_library_internal(<span class="keyword">const_cast</span>&lt;<span class="keyword">android_namespace_t</span>*&gt;(task-&gt;get_start_from()),</span><br><span class="line">                               task,</span><br><span class="line">                               &amp;zip_archive_cache,</span><br><span class="line">                               &amp;load_tasks,</span><br><span class="line">                               rtld_flags)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    soinfo* si = task-&gt;get_soinfo();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//追踪find_library_internal</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">find_library_internal</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  LoadTask* task,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> rtld_flags)</span> </span>&#123;</span><br><span class="line">  soinfo* candidate;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (load_library(ns, task, zip_archive_cache, load_tasks, rtld_flags,</span><br><span class="line">                   <span class="literal">true</span> <span class="comment">/* search_linked_namespaces */</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">load_library</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                         LoadTask* task,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="function"><span class="params">                         LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">bool</span> search_linked_namespaces)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name = task-&gt;get_name();</span><br><span class="line">  soinfo* needed_by = task-&gt;get_needed_by();</span><br><span class="line">  ...</span><br><span class="line">  LD_LOG(kLogDlopen,</span><br><span class="line">         <span class="string">&quot;load_library(ns=%s, task=%s, flags=0x%x, search_linked_namespaces=%d): calling &quot;</span></span><br><span class="line">         <span class="string">&quot;open_library&quot;</span>,</span><br><span class="line">         ns-&gt;get_name(), name, rtld_flags, search_linked_namespaces);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the file.</span></span><br><span class="line">  <span class="keyword">off64_t</span> file_offset;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> realpath;</span><br><span class="line">  <span class="keyword">int</span> fd = open_library(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open_library打开动态库文件将指定的共享库文件加载到当前进程的地址空间中，创建一个新的动态链接对象，并返回其的句柄。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_library</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">char</span>* name, soinfo *needed_by,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">off64_t</span>* file_offset, <span class="built_in">std</span>::<span class="built_in">string</span>* realpath)</span> </span>&#123;</span><br><span class="line">  TRACE(<span class="string">&quot;[ opening %s from namespace %s ]&quot;</span>, name, ns-&gt;get_name());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the name contains a slash, we should attempt to open it directly and not search the paths.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strchr</span>(name, <span class="string">&#x27;/&#x27;</span>) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> open_library_at_path(zip_archive_cache, name, file_offset, realpath);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load_library加载解析ELF格式并将其链接到进程的地址空间中，将动态链接对象中的符号解析为当前进程中的符号，从而创建动态链接的关系。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">load_library</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                         LoadTask* task,</span></span></span><br><span class="line"><span class="function"><span class="params">                         LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; realpath,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">bool</span> search_linked_namespaces)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  soinfo* si = soinfo_alloc(ns, realpath.c_str(), &amp;file_stat, file_offset, rtld_flags);</span><br><span class="line"></span><br><span class="line">  task-&gt;set_soinfo(si);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取elf header</span></span><br><span class="line">  <span class="keyword">if</span> (!task-&gt;read(realpath.c_str(), file_stat.st_size)) &#123;</span><br><span class="line">    task-&gt;remove_cached_elf_reader();</span><br><span class="line">    task-&gt;set_soinfo(<span class="literal">nullptr</span>);</span><br><span class="line">    soinfo_free(si);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后看看read函数，这个函数负责从elf文件格式的数据中读取内容</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* realpath, <span class="keyword">off64_t</span> file_size)</span> </span>&#123;</span><br><span class="line">    ElfReader&amp; elf_reader = get_elf_reader();</span><br><span class="line">    <span class="keyword">return</span> elf_reader.Read(realpath, fd_, file_offset_, file_size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>ElfReader</code>是<code>Android</code>源文件中的工具，位于系统核心库<code>libcore</code>中，代码主要由<code>C++</code>编写。它可以读取<code>ELF</code>文件的所有信息，并将其解析为指定格式。</p>
<p><code>ElfReader</code>具备以下特点：</p>
<ul>
<li>读取<code>ELF</code>文件的头信息，包括<code>ELF</code>版本、目标体系结构、程序入口地址、节表偏移量等。</li>
<li>读取<code>ELF</code>文件的节表信息，包括节表名称、大小、偏移量、属性等。</li>
<li>通过节表信息可以获取符号表、重定位表、动态链接表等关键信息，如函数、变量、链接库、导出函数等。</li>
<li>支持通过指定节表名称获取某个节表的信息，如根据”<code>.rodata</code>“获取只读数据节表的信息等。</li>
</ul>
<h2><span id="小结">小结</span></h2><p>系统定制无论做怎样的修改，都要明白其原理，本章内容作为系统开发的内功心法，需要读者花费一些时间来吸收，在后面的内容的展开过程中，也可以随时重温本章内容，加深印象。</p>
<p>从设备开机到系统启动完成，整个启动链上涉及到的核心组件都在本节中进行了介绍。本节中介绍的系统组件，都是定制系统可能需要修改的地方。其中，Service与Framework的修改是最常见的，美化与安全定制都离不开它，读者朋友们可以重点阅读它们的代码来深入研究。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>第三章 认识系统组件</p><p><a href="http://example.com/2025/04/07/chapter-03/">http://example.com/2025/04/07/chapter-03/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://example.com"><p>Lis</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-04-07</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-04-07</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2025/04/07/chapter-07/" target="_blank">第七章 类加载和函数调用</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/06/15/view/" target="_blank">View基础</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/04/07/chapter-07/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">第七章 类加载和函数调用</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/11/28/%E6%B3%9B%E5%9E%8B/"><span class="level-item">泛型</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'f52d1707a186fa63bd879736c1bdf0aa',
            repo: 'gitalk',
            owner: 'xunyixiangchao',
            clientID: '9e8b7b8cef8759344d50',
            clientSecret: 'e5ef7e0a75d0431208a8fc15f1b41bd45bf0ca2d',
            admin: ["xunyixiangchao"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/2018.jpg" alt="Lis"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Lis</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xunyixiangchao" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xunyixiangchao"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/xunyixiangchao"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:Lis@163.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Next" href="https://xunyixiangchao.github.io/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-15T08:51:54.000Z">2025-05-15</time></p><p class="title"><a href="/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/">注解与反射（上）</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/">Java基础与进阶</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-15T08:51:54.000Z">2025-05-15</time></p><p class="title"><a href="/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%B8%8B/">注解与反射（下）</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/">Java基础与进阶</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-07T03:45:54.000Z">2025-04-07</time></p><p class="title"><a href="/2025/04/07/chapter-07/">第七章 类加载和函数调用</a></p><p class="categories"><a href="/categories/Android%E6%BA%90%E7%A0%81/">Android源码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-07T03:45:54.000Z">2025-04-07</time></p><p class="title"><a href="/2025/04/07/chapter-03/">第三章 认识系统组件</a></p><p class="categories"><a href="/categories/Android%E6%BA%90%E7%A0%81/">Android源码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-28T14:45:54.000Z">2021-11-28</time></p><p class="title"><a href="/2021/11/28/%E6%B3%9B%E5%9E%8B/">泛型</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/">Java基础与进阶</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">Android三方库源码分析</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android%E6%BA%90%E7%A0%81/"><span class="level-start"><span class="level-item">Android源码</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"><span class="level-start"><span class="level-item">Java基础与进阶</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android%E6%BA%90%E7%A0%81/"><span class="tag">Android源码</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"><span class="tag">动态代理</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%B0%84/"><span class="tag">反射</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%A8%E8%A7%A3/"><span class="tag">注解</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OkHttp/"><span class="tag">OkHttp</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/activity/"><span class="tag">activity</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dispatch/"><span class="tag">dispatch</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%9B%E5%9E%8B/"><span class="tag">泛型</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2018.jpg" alt="Lis" height="28"></a><p class="size-small"><span>&copy; 2025 Lis</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://xunyixiangchao.github.io/"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9e8b7b8cef8759344d50','e5ef7e0a75d0431208a8fc15f1b41bd45bf0ca2d','xunyixiangchao','gitalk',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9e8b7b8cef8759344d50','e5ef7e0a75d0431208a8fc15f1b41bd45bf0ca2d','xunyixiangchao','gitalk',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>