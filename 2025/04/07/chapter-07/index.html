<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>第七章 类加载和函数调用 - Lis</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Lis"><meta name="msapplication-TileImage" content="/img/2018.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Lis"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="[转]安卓系统定制：从入门到实践    7.1 双亲委派机制 7.2 类的加载流程 7.3 函数调用流程 7.4 ExecuteMterpImpl 7.5 ExecuteSwitch 7.6 本章小结    在上一章中，我们学习了分析Android运行的执行流程，并找到合适的时机来插入业务逻辑代码，以实现特定功能。例如，在应用启动流程中，我们可以通过注入DEX文件或动态库文件来实现某些功能。通过n"><meta property="og:type" content="blog"><meta property="og:title" content="Lis"><meta property="og:url" content="https://xunyixiangchao.github.io/"><meta property="og:site_name" content="Lis"><meta property="og:description" content="[转]安卓系统定制：从入门到实践    7.1 双亲委派机制 7.2 类的加载流程 7.3 函数调用流程 7.4 ExecuteMterpImpl 7.5 ExecuteSwitch 7.6 本章小结    在上一章中，我们学习了分析Android运行的执行流程，并找到合适的时机来插入业务逻辑代码，以实现特定功能。例如，在应用启动流程中，我们可以通过注入DEX文件或动态库文件来实现某些功能。通过n"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xunyixiangchao.github.io/img/2018.jpg"><meta property="article:published_time" content="2025-04-07T03:45:54.000Z"><meta property="article:modified_time" content="2025-04-07T03:46:33.447Z"><meta property="article:author" content="Lis"><meta property="article:tag" content="Android源码"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/2018.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2025/04/07/chapter-07/"},"headline":"Lis","image":["http://example.com/2025/04/07/chapter-07/classloader.png","http://example.com/2025/04/07/chapter-07/dex_header.png","http://example.com/2025/04/07/chapter-07/dex%E6%A8%A1%E6%9D%BF.png","http://example.com/2025/04/07/chapter-07/def_class.png","http://example.com/2025/04/07/chapter-07/codeitem1.png"],"datePublished":"2025-04-07T03:45:54.000Z","dateModified":"2025-04-07T03:46:33.447Z","author":{"@type":"Person","name":"Lis"},"description":"[转]安卓系统定制：从入门到实践    7.1 双亲委派机制 7.2 类的加载流程 7.3 函数调用流程 7.4 ExecuteMterpImpl 7.5 ExecuteSwitch 7.6 本章小结    在上一章中，我们学习了分析Android运行的执行流程，并找到合适的时机来插入业务逻辑代码，以实现特定功能。例如，在应用启动流程中，我们可以通过注入DEX文件或动态库文件来实现某些功能。通过n"}</script><link rel="canonical" href="http://example.com/2025/04/07/chapter-07/"><link rel="icon" href="/img/2018.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Lis" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2018.jpg" alt="Lis" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://xunyixiangchao.github.io/"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://xunyixiangchao.github.io/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-04-07  <a class="commentCountImg" href="/2025/04/07/chapter-07/#comment-container"><span class="display-none-class">6ea203cced8016621b1f6f5e2253dcc9</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="6ea203cced8016621b1f6f5e2253dcc9">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>15.8 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">第七章 类加载和函数调用</h1><div class="content"><p><strong>[转]安卓系统定制：从入门到实践</strong></p>
<!-- toc -->

<ul>
<li><a href="#71-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">7.1 双亲委派机制</a></li>
<li><a href="#72-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B">7.2 类的加载流程</a></li>
<li><a href="#73-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B">7.3 函数调用流程</a></li>
<li><a href="#74-executemterpimpl">7.4 ExecuteMterpImpl</a></li>
<li><a href="#75-executeswitch">7.5 ExecuteSwitch</a></li>
<li><a href="#76-%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93">7.6 本章小结</a></li>
</ul>
<!-- tocstop -->

<p>在上一章中，我们学习了分析Android运行的执行流程，并找到合适的时机来插入业务逻辑代码，以实现特定功能。例如，在应用启动流程中，我们可以通过注入DEX文件或动态库文件来实现某些功能。通过native函数的注册流程，我们可以对静态注册和动态注册信息进行打桩输出。而通过解析AndroidManifest.xml文件的过程，则可以额外添加默认权限。</p>
<p>在本章中，将详细介绍Android源码中加载类的执行流程。了解Android中类加载机制以及函数调用流程是非常重要的基础知识。通过学习这些执行流程原理，在定制功能时能为我们提供更多方向和思路。</p>
<a id="more"></a>


<h2><span id="71-双亲委派机制">7.1 双亲委派机制</span></h2><p>在Android系统中，应用程序运行在Dalvik或ART虚拟机上。当应用启动时，Android系统会根据应用程序包中的AndroidManifest.xml文件确定需要启动哪些组件，并在启动过程中加载所需的类。</p>
<p>Android中的类加载器遵循双亲委派模型。即每个类加载器在尝试加载一个类之前，都会先委托其父类加载器去加载该类。只有当父类加载器无法完成任务时，子类加载器才会尝试自己来进行加载。这个模型保证了不同的类只会被加载一次，并且保护了核心Java API不被恶意代码篡改。</p>
<p>在Android应用程序中，每个类都分配到一个特定的DEX文件（即Dalvik Executable）中。DEX文件包含该类所有方法和属性的字节码。当应用程序启动时，它的DEX文件将被加载到内存并由虚拟机执行其中的代码。</p>
<p>在函数调用流程中，当一个函数被调用时，虚拟机会保存当前线程状态，并跳转到被调函数入口地址开始执行该函数。虚拟机对函数指令进行执行，并维护执行过程所需数据结构（如栈帧）。当函数执行完毕后，虚拟机将结果返回给调用方并恢复之前保存的线程状态。</p>
<p>深入学习Android的类加载机制和函数执行调用流程可以更好地理解应用程序的运行机制。</p>
<p>在Android中，类通常保存在DEX文件中，而ClassLoader则负责加载DEX文件。每个应用程序包（APK）都包含一个或多个DEX文件，这些DEX文件包含应用程序的所有类信息。当需要使用某个类时，ClassLoader会从相应的DEX文件中加载该类，并将其转换为可执行的Java类。因此，ClassLoader和DEX密切相关，ClassLoader是DEX文件的载体和管理者。</p>
<p>Android 中的 ClassLoader 类型分为两种：</p>
<ol>
<li><p>系统类加载器。系统类加载器主要包括BootClassLoader、PathClassLoader和DexClassLoader。</p>
</li>
<li><p>自定义加载器。</p>
</li>
</ol>
<p>一些常见的加载器的用途如下：</p>
<ol>
<li><p><code>BootClassLoader</code>：位于 <code>ClassLoader </code>层次结构中的最顶层。负责加载系统级别的类，如<code> Java</code> 核心库和一些基础库。</p>
</li>
<li><p><code>PathClassLoader</code>：从应用程序的<code> APK</code> 文件中加载类和资源。继承自<code>BaseDexClassLoader</code>类，它能够加载已经被优化的 <code>Dex</code> 文件和未经过优化的 <code>Dex</code> 文件。<code>PathClassLoader</code> 主要用于加载已经打包在 <code>APK </code>文件中的代码和资源。</p>
</li>
<li><p><code>DexClassLoader</code>：从<code> .dex</code> 或<code> .odex</code> 文件中加载类。继承自<code>BaseDexClassLoader</code>类，它支持动态加载 <code>Dex </code>文件，并且可以在运行时进行优化操作。<code>DexClassLoader </code>主要用于加载未安装的 <code>APK</code> 文件中的代码。</p>
</li>
<li><p><code>InMemoryDexClassLoader</code>：用于从内存中加载已经存在于内存中的<code>dex</code>文件。继承自 <code>BaseDexClassLoader</code>，并且可以处理多个<code>dex</code>文件。<code>InMemoryDexClassLoader </code>可以在运行时动态加载 <code>dex</code> 文件，并且不需要将文件保存到磁盘上，从而提高应用程序的性能。</p>
</li>
<li><p><code>BaseDexClassLoader</code>：<code>DexClassLoader</code>、<code>InMemoryDexClassLoader</code> 和 <code>PathClassLoader</code> 的基类，封装了加载 <code>dex</code> 文件的基本逻辑，包括创建<code> DexPathList</code> 对象、打开 <code>dex </code>文件、查找类等操作。<code>BaseDexClassLoader </code>实现了双亲委派模型，即在自身无法加载类时，会委派给父类加载器进行查找。<code>BaseDexClassLoader</code> 还支持多个 <code>dex </code>文件的加载，并且可以在运行时进行优化操作。</p>
</li>
<li><p>SecureClassLoader：继承自ClassLoader抽象类，该类主要实现了一些权限相关的功能。</p>
</li>
<li><p>URLClassLoader：SecureClassLoader的子类，其可以使用url路径加载JAR文件中的类。</p>
</li>
</ol>
<p>整个类加载器的继承结构如下图所示：</p>
<p><img src="/2025/04/07/chapter-07/classloader.png" alt="ClassLoader 继承结构"></p>
<p>类加载器采用了双亲委派机制（Parent Delegation Model），这是一种经典的Java类加载机制。</p>
<p>双亲委派机制是指当一个类加载器收到请求去加载一个类时，它并不会自己去加载，而是把这个任务委托给父类加载器去完成。如果父类加载器还存在父类加载器，这个请求就会向上递归，直到达到最顶层的BootClassLoader为止。也就是说，最先调用加载的ClassLoader是最顶层的，最后尝试加载的是当前的ClassLoader。</p>
<p>采用双亲委派机制可以有效地避免类的重复加载，并保证核心API的安全性。具体表现为：</p>
<ul>
<li>在类加载时，首先从当前加载器的缓存中查找是否已经加在了该类，如果已经加在，则直接返回；</li>
<li>如果没有在缓存中找到该累，则将加在任务委派给父累加，在者完成；</li>
<li>父累加如果也没有找道该累，则将会递归向上委派, 直道BootClassLoader;</li>
<li>BootCLassLoader无法代理添加和发生错误之前所做过得努力, 则会让子类加载器自行加载。</li>
</ul>
<h2><span id="72-类的加载流程">7.2 类的加载流程</span></h2><p>在<code>Android</code>中，<code>ClassLoader</code>类是双亲委派机制的主要实现者。该类提供了<code>findClass</code>和<code>loadClass</code>方法，其中<code>findClass</code>是<code>ClassLoader</code>的抽象方法，需要由子类实现。接下来将跟踪源码实现，详细了解<code>ClassLoader</code>是如何进行类加载流程的。</p>
<p>在前文中曾经介绍过如何使用<code>DexClassLoader</code>加载一个类，并调用其中的函数，下面是当时的加载样例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        String dexPath = <span class="string">&quot;/system/framework/kjar.jar&quot;</span>;</span><br><span class="line">        String dexOutputDir = getApplicationInfo().dataDir;</span><br><span class="line">        ClassLoader classLoader = <span class="keyword">new</span> DexClassLoader(dexPath, dexOutputDir, <span class="keyword">null</span>,</span><br><span class="line">                getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz2 = classLoader.loadClass(<span class="string">&quot;cn.rom.myjar.MyCommon&quot;</span>);</span><br><span class="line">            Method addMethod = clazz2.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, <span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</span><br><span class="line">            Object result = addMethod.invoke(<span class="keyword">null</span>, <span class="number">12</span>,<span class="number">25</span>);</span><br><span class="line">            Log.i(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;getMyJarVer:&quot;</span>+result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>ClassLoader </code>加载类时，<code>loadClass</code> 和<code> findClass</code>都可以完成对类的加载工作，它们在加载类时有着不同的作用和执行流程。</p>
<p>​    首先看看<code>loadClass</code>的特征，它的方法签名如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass( <span class="keyword">final</span> String class_name, <span class="keyword">final</span> <span class="keyword">boolean</span> resolve ) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure>

<p>​    其中<code>name</code> 参数表示要加载的类的全名；<code>resolve</code> 参数表示是否需要在加载完成后进行链接操作。如果 <code>resolve</code> 参数为<code> true</code>，则会尝试在加载完成后对该类进行链接操作，包括验证、准备和解析等步骤。如果 <code>resolve</code> 参数为<code> false</code>，则不会进行链接操作。</p>
<p>​    在执行<code>loadClass</code>方法时，<code>ClassLoader </code>会先检查自身是否已经加载过该类，如果已经加载过，则直接返回该类的<code> Class</code> 对象。如果没有加载过，则将任务委托给父类加载器进行处理，如果父类加载器无法加载该类，则再次调用自身的<code> findClass</code> 方法进行加载。如果<code> findClass</code> 方法仍然无法找到该类，则抛出 <code>ClassNotFoundException</code> 异常。</p>
<p>​    接下来再了解下<code>findClass</code> 方法，它 是 <code>BaseClassLoader </code>类中定义的一个抽象方法，用于在特定的数据源（如文件、内存等）中查找指定名称的类，并返回对应的<code> Class</code> 对象。下面是方法签名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure>

<p>​    与<code> loadClass</code> 不同，<code>findClass</code> 方法并不会先委派给父类加载器进行处理，而是直接在当前 <code>ClassLoader </code>中进行查找。如果能够找到指定的类，则通过 <code>defineClass </code>方法将其转换成<code>Class</code>对象，并返回该对象；否则，抛出 <code>ClassNotFoundException </code>异常。</p>
<p>​    明白了两者的区别后，接下来开始跟踪源码，了解在<code>AOSP</code>具体是如何加载类的。首先找到<code>DexClassLoader</code>中<code>loadClass</code>的实现代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    发现内部并没有任何代码，说明该实现来自于父类中，接着来查看父类<code>BaseDexClassLoader</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Package <span class="title">getPackage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    同样没有找到<code>loadClass</code>的实现，继续看它的父类<code>ClassLoader</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用了另外一个重载，resolve参数不传的情况默认为false</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// 尝试在已经加载过的里面查找</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有父类的情况，就让父类来加载</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 到达父类顶端后，则使用这个函数查找，通常来查找引导类和扩展类</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 父类没有找到的情况，再通过findClass查找</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过这里的代码，能够很清晰的看到前文中<code>ClassLoader</code>的双亲委派机制，接着继续跟踪<code>findClass</code>分析当前<code>ClassLoader</code>是如何加载类的，由于<code>ClassLoader</code>是一个抽象类，而<code>findClass</code>在该类中并未实现具体代码，所以该方法是在子类中实现，上面在<code>BaseDexClassLoader</code>的类中，就已经看到的<code>findClass</code>的函数，下面是具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 首先检查当前ClassLoader是否有共享库，如果有则遍历每个共享库的ClassLoader去尝试加载该类</span></span><br><span class="line">        <span class="keyword">if</span> (sharedLibraryLoaders != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ClassLoader loader : sharedLibraryLoaders) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> loader.loadClass(name);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">        <span class="comment">// 当前ClassLoader操作的dex文件中查找该类</span></span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(</span><br><span class="line">                    <span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <code>pathList</code>是一个<code>DexPathList</code>对象，表示当前<code>ClassLoader</code>所管理的一组<code>dex</code>文件的路径列表。<code>findClass()</code>方法通过调用<code>DexPathList.findClass()</code>方法来查找指定名称的类。继续跟进查看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> Element[] dexElements;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>dexElements</code>的数组存放着所有已经加载的<code>dex</code>文件中的类信息。具体来说，每个<code>dex</code>文件都被解析为一个<code>DexFile</code>对象，而<code>dexElements</code>数组中的每个元素实际上就是一个<code>Element</code>对象，代表了一个<code>dex</code>文件和其中包含的类信息。这些<code>Element</code>对象按照优先级顺序排列，以便<code>ClassLoader</code>可以根据它们的顺序来查找类定义。继续查看<code>Element</code>的<code>findClass</code>方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="comment">// 管理着一个dex文件</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">getDexPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> path.isDirectory() ? <span class="keyword">null</span> : path.getAbsolutePath();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dexFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// DexFile.getName() returns the path of the dex file.</span></span><br><span class="line">                <span class="keyword">return</span> dexFile.getName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (dexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> (pathIsDirectory ? <span class="string">&quot;directory \&quot;&quot;</span> : <span class="string">&quot;zip file \&quot;&quot;</span>) + path + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;dex file \&quot;&quot;</span> + dexFile + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;zip file \&quot;&quot;</span> + path + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; findClass(String name, ClassLoader definingContext,</span><br><span class="line">                List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">            <span class="keyword">return</span> dexFile != <span class="keyword">null</span> ? dexFile.loadClassBinaryName(name, definingContext, suppressed)</span><br><span class="line">                    : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看到这里实际就是管理一个对应的<code>DexFile</code>对象，该对象关联着一个对应的<code>dex</code>文件，这里通过调用<code>DexFile</code>对象的<code>loadClassBinaryName</code>去加载这个类，继续跟踪它的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loader, mCookie, <span class="keyword">this</span>, suppressed);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, Object cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     DexFile dexFile, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        Class result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = defineClassNative(name, loader, cookie, dexFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title">defineClassNative</span><span class="params">(String name, ClassLoader loader, Object cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  DexFile dexFile)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ClassNotFoundException, NoClassDefFoundError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里看到经过几层调用后，进入了<code>native</code>实现了，根据<code>AOSP</code>中<code>native</code>注册的命名规则，直接搜索<code>DexFile_defineClassNative</code>找到对应的实现代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jclass <span class="title">DexFile_defineClassNative</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jstring javaName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        jobject dexFile)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">const</span> DexFile*&gt; dex_files;</span><br><span class="line">  <span class="keyword">const</span> OatFile* oat_file;</span><br><span class="line">  <span class="comment">// cookie转换成一组c++中的DexFile对象以及OatFile</span></span><br><span class="line">  <span class="keyword">if</span> (!ConvertJavaArrayToDexFiles(env, cookie, <span class="comment">/*out*/</span> dex_files, <span class="comment">/*out*/</span> oat_file)) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_file&quot;</span>;</span><br><span class="line">    DCHECK(env-&gt;ExceptionCheck());</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 将类名转换为c++的string存放在了descriptor中</span></span><br><span class="line">  <span class="comment">// 这里会将java中的类描述符转换为c++使用的类描述符，例如类中的.转换为\</span></span><br><span class="line">  <span class="keyword">const</span> std::<span class="function">string <span class="title">descriptor</span><span class="params">(DotToDescriptor(class_name.c_str()</span>))</span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> size_t <span class="title">hash</span><span class="params">(ComputeModifiedUtf8Hash(descriptor.c_str()</span>))</span>;</span><br><span class="line">  <span class="keyword">for</span> (auto&amp; dex_file : dex_files) &#123;</span><br><span class="line">    <span class="comment">// 根据类描述符找到对应的类</span></span><br><span class="line">    <span class="keyword">const</span> dex::ClassDef* dex_class_def =</span><br><span class="line">        OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash);</span><br><span class="line">    <span class="keyword">if</span> (dex_class_def != nullptr) &#123;</span><br><span class="line">      <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">      ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 使用类加载器和 DEX 文件定义一个新的 Java 类，并返回一个描述该类的 Class 对象指针</span></span><br><span class="line">      ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(),</span><br><span class="line">                                                               descriptor.c_str(),</span><br><span class="line">                                                               hash,</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               *dex_file,</span><br><span class="line">                                                               *dex_class_def);</span><br><span class="line">      <span class="comment">// 将DexFile插入到ClassLoader中。</span></span><br><span class="line">      class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile),</span><br><span class="line">                                                 class_loader.Get());</span><br><span class="line">      <span class="keyword">if</span> (result != nullptr) &#123;</span><br><span class="line">        VLOG(class_linker) &lt;&lt; <span class="string">&quot;DexFile_defineClassNative returning &quot;</span> &lt;&lt; result</span><br><span class="line">                           &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; class_name.c_str();</span><br><span class="line">        <span class="keyword">return</span> soa.AddLocalReference&lt;jclass&gt;(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_class_def &quot;</span> &lt;&lt; class_name.c_str();</span><br><span class="line">  <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码中看到<code>cookie</code>中能拿到所有<code>DexFile</code>，最终的<code>Class</code>对象是由<code>DefineClass</code>方法定义后返回的。继续看其实现过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjPtr&lt;mirror::Class&gt; ClassLinker::DefineClass(Thread* self,</span><br><span class="line">                                               <span class="keyword">const</span> <span class="keyword">char</span>* descriptor,</span><br><span class="line">                                               size_t hash,</span><br><span class="line">                                               Handle&lt;mirror::ClassLoader&gt; class_loader,</span><br><span class="line">                                               <span class="keyword">const</span> DexFile&amp; dex_file,</span><br><span class="line">                                               <span class="keyword">const</span> dex::ClassDef&amp; dex_class_def) &#123;</span><br><span class="line">  ...</span><br><span class="line">  DexFile <span class="keyword">const</span>* new_dex_file = nullptr;</span><br><span class="line">  dex::ClassDef <span class="keyword">const</span>* new_class_def = nullptr;</span><br><span class="line">  <span class="comment">// 类被加载前的预处理</span></span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassPreDefine(descriptor,</span><br><span class="line">                                                            klass,</span><br><span class="line">                                                            class_loader,</span><br><span class="line">                                                            dex_file,</span><br><span class="line">                                                            dex_class_def,</span><br><span class="line">                                                            &amp;new_dex_file,</span><br><span class="line">                                                            &amp;new_class_def);</span><br><span class="line">  <span class="comment">// 将dex文件加载到内存中</span></span><br><span class="line">  ObjPtr&lt;mirror::DexCache&gt; dex_cache = RegisterDexFile(*new_dex_file, class_loader.Get());</span><br><span class="line">  <span class="keyword">if</span> (dex_cache == nullptr) &#123;</span><br><span class="line">    self-&gt;AssertPendingException();</span><br><span class="line">    <span class="keyword">return</span> sdc.Finish(nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">  klass-&gt;SetDexCache(dex_cache);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化类</span></span><br><span class="line">  SetupClass(*new_dex_file, *new_class_def, klass, class_loader.Get());</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向类表中插入类对象</span></span><br><span class="line">  ObjPtr&lt;mirror::Class&gt; existing = InsertClass(descriptor, klass.Get(), hash);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载并初始化类，在必要时创建新的类对象</span></span><br><span class="line">  LoadClass(self, *new_dex_file, *new_class_def, klass);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  MutableHandle&lt;mirror::Class&gt; h_new_class = hs.NewHandle&lt;mirror::Class&gt;(nullptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链接类及其相关信息</span></span><br><span class="line">  <span class="keyword">if</span> (!LinkClass(self, descriptor, klass, interfaces, &amp;h_new_class)) &#123;</span><br><span class="line">    <span class="comment">// Linking failed.</span></span><br><span class="line">    <span class="keyword">if</span> (!klass-&gt;IsErroneous()) &#123;</span><br><span class="line">      mirror::Class::SetStatus(klass, ClassStatus::kErrorUnresolved, self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sdc.Finish(nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sdc.Finish(h_new_class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>ClassPreDefine</code>是一个回调函数，它在类被加载之前被调用，用于进行一些预处理工作。具体来说，<code>ClassPreDefin</code>会被调用以执行以下任务：</p>
<ul>
<li><p>对新定义的类进行验证和解析，以确保类结构的正确性。</p>
</li>
<li><p>为新定义的类分配内存空间，并构造新对象的实例。</p>
</li>
<li><p>设置类的访问控制权限并更新关联的缓存信息。</p>
</li>
</ul>
<p>​    <code>RegisterDexFile</code>用于注册 <code>DEX</code> 文件。该函数负责将 <code>DEX </code>文件加载到内存中，并将其中包含的类和相关信息注册到运行时环境中，以供后续的程序使用。该函数的主要负责：</p>
<ul>
<li><p>将 <code>DEX </code>文件加载到内存中，并为其分配一段连续的内存空间。</p>
</li>
<li><p>在运行时环境中创建<code>mirror::DexFile</code>对象，该对象包含了<code> DEX</code>文件的元数据信息，例如文件名、<code>MD5 </code>哈希值等。</p>
</li>
<li><p>为<code>DEX</code>文件中包含的每个类创建相应的<code> mirror::Class</code> 对象，并将其添加到类表中进行管理。</p>
</li>
<li><p>为新创建的<code> mirror::Class</code> 对象设置其访问权限和其他属性，例如类标志、字段、方法等。</p>
</li>
<li><p>创建并返回一个 <code>mirror::DexCache </code>对象，该对象表示已注册的<code>DEX</code>文件的缓存信息。</p>
</li>
</ul>
<p>​    <code>SetupClass</code> 函数用于初始化类。该函数的主要作用：</p>
<ul>
<li><p>解析类定义，并为其分配内存空间。</p>
</li>
<li><p>为新创建的类对象设置相关信息，例如类名、超类、接口信息等。</p>
</li>
<li><p>设置类对象的访问修饰符和标志。</p>
</li>
<li><p>将类对象添加到运行时环境中进行管理。</p>
</li>
<li><p>在必要的情况下，执行与类加载生命周期有关的回调函数。</p>
</li>
</ul>
<p>​    <code>InsertClass</code>函数用于向类表中插入新的类对象，并确保在插入之前对其进行必要的验证和初始化工作。该函数的主要作用：</p>
<ul>
<li><p>根据类描述符和哈希值查找类表中是否已经存在相同的类对象。</p>
</li>
<li><p>如果已经存在相同的类对象，则返回其指针，否则将新的类对象插入到类表中，并返回其指针。</p>
</li>
<li><p>在插入新的类对象之前，会先进行一些验证工作，例如检查类的访问权限，以及确保类的结构和超类的继承关系正确等。</p>
</li>
<li><p>在需要时，执行与类加载生命周期有关的回调函数。</p>
</li>
</ul>
<p>​    <code>LoadClass</code> 函数用于加载并初始化类。并将其插入到类表中进行管理。主要作用：</p>
<ul>
<li><p>根据类描述符查找类表中是否已经存在相同的类对象，如存在则直接返回其指针。</p>
</li>
<li><p>如果类表中不存在相同的类对象，则先使用 <code>SetupClass()</code> 函数创建新的类对象，并将其插入到类表中。此处调用了 <code>InsertClass()</code> 函数。</p>
</li>
<li><p>加载并初始化类的超类及接口信息，以确保类的继承关系正确。</p>
</li>
<li><p>执行与类加载生命周期有关的回调函数。</p>
</li>
</ul>
<p>​    <code>    LinkClass</code> 函数是在用于链接类，该函数会返回一个新的类对象指针，以供调用者使用。主要作用：</p>
<ul>
<li><p>链接类的超类，并执行与超类有关的初始化工作。</p>
</li>
<li><p>链接类实现的接口，并执行与接口有关的初始化工作。</p>
</li>
<li><p>链接类的字段，并执行与字段有关的初始化工作。</p>
</li>
<li><p>链接类的方法，并执行与方法有关的初始化工作。</p>
</li>
<li><p>在必要时创建新的类对象，并将其返回给调用者。</p>
</li>
</ul>
<p>​    将加载类的过程中几个关键的步骤搞清楚后，继续深入查看<code>LoadClass</code>是如何实现的，重点关注最后一个参数<code>kclass</code>做了些什么。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadClass</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> dex::ClassDef&amp; dex_class_def,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Runtime* <span class="keyword">const</span> runtime = Runtime::Current();</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取类加载器的线性内存分配器</span></span><br><span class="line">    LinearAlloc* <span class="keyword">const</span> allocator = GetAllocatorForClassLoader(klass-&gt;GetClassLoader());</span><br><span class="line">    <span class="comment">// 为类中的静态字段分配内存空间</span></span><br><span class="line">    LengthPrefixedArray&lt;ArtField&gt;* sfields = AllocArtFieldArray(self,</span><br><span class="line">                                                                allocator,</span><br><span class="line">                                                                accessor.NumStaticFields());</span><br><span class="line">    <span class="comment">// 为类中的实例字段分配内存空间</span></span><br><span class="line">    LengthPrefixedArray&lt;ArtField&gt;* ifields = AllocArtFieldArray(self,</span><br><span class="line">                                                                allocator,</span><br><span class="line">                                                                accessor.NumInstanceFields());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置类的方法列表指针</span></span><br><span class="line">    klass-&gt;SetMethodsPtr(</span><br><span class="line">        AllocArtMethodArray(self, allocator, accessor.NumMethods()),</span><br><span class="line">        accessor.NumDirectMethods(),</span><br><span class="line">        accessor.NumVirtualMethods());</span><br><span class="line">    <span class="keyword">size_t</span> class_def_method_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> last_dex_method_index = dex::kDexNoIndex;</span><br><span class="line">    <span class="keyword">size_t</span> last_class_def_method_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历类的所有方法和字段</span></span><br><span class="line">    accessor.VisitFieldsAndMethods([&amp;](</span><br><span class="line">        <span class="keyword">const</span> ClassAccessor::Field&amp; field) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">// 遍历所有字段，由last_static_field_idx判断是否正在处理的是静态字段</span></span><br><span class="line">          <span class="keyword">if</span> (num_sfields == <span class="number">0</span> || LIKELY(field_idx &gt; last_static_field_idx)) &#123;</span><br><span class="line">            <span class="comment">// 加载字段信息</span></span><br><span class="line">            LoadField(field, klass, &amp;sfields-&gt;At(num_sfields));</span><br><span class="line">            ++num_sfields;</span><br><span class="line">            last_static_field_idx = field_idx;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, [&amp;](<span class="keyword">const</span> ClassAccessor::Field&amp; field) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">// 加载实例字段信息</span></span><br><span class="line">          <span class="keyword">if</span> (num_ifields == <span class="number">0</span> || LIKELY(field_idx &gt; last_instance_field_idx)) &#123;</span><br><span class="line">            LoadField(field, klass, &amp;ifields-&gt;At(num_ifields));</span><br><span class="line">            ++num_ifields;</span><br><span class="line">            last_instance_field_idx = field_idx;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, [&amp;](<span class="keyword">const</span> ClassAccessor::Method&amp; method) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">          <span class="comment">// 获取实例方法</span></span><br><span class="line">          ArtMethod* art_method = klass-&gt;GetDirectMethodUnchecked(class_def_method_index,</span><br><span class="line">              image_pointer_size_);</span><br><span class="line">          <span class="comment">// 将dex_file参数中指向Java方法字节码的指针(method)解析为机器码，并将它存储到art_method参数对应的内存区域中，完成对Java方法实现代码的加载</span></span><br><span class="line">          LoadMethod(dex_file, method, klass, art_method);</span><br><span class="line">          <span class="comment">// 将art_method参数对应的实现代码链接到oat_class_ptr参数对应的oat文件中</span></span><br><span class="line">          LinkCode(<span class="keyword">this</span>, art_method, oat_class_ptr, class_def_method_index);</span><br><span class="line">          ...</span><br><span class="line">        &#125;, [&amp;](<span class="keyword">const</span> ClassAccessor::Method&amp; method) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 和上面差不多的，不过这里处理的是虚方法</span></span><br><span class="line">          ArtMethod* art_method = klass-&gt;GetVirtualMethodUnchecked(</span><br><span class="line">              class_def_method_index - accessor.NumDirectMethods(),</span><br><span class="line">              image_pointer_size_);</span><br><span class="line">          LoadMethod(dex_file, method, klass, art_method);</span><br><span class="line">          LinkCode(<span class="keyword">this</span>, art_method, oat_class_ptr, class_def_method_index);</span><br><span class="line">          ++class_def_method_index;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将加载好的字段保存到kclass</span></span><br><span class="line">    klass-&gt;SetSFieldsPtr(sfields);</span><br><span class="line">    DCHECK_EQ(klass-&gt;NumStaticFields(), num_sfields);</span><br><span class="line">    klass-&gt;SetIFieldsPtr(ifields);</span><br><span class="line">    DCHECK_EQ(klass-&gt;NumInstanceFields(), num_ifields);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Ensure that the card is marked so that remembered sets pick up native roots.</span></span><br><span class="line">  WriteBarrier::ForEveryFieldWrite(klass.Get());</span><br><span class="line">  self-&gt;AllowThreadSuspension();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    然后再了解一下<code>LoadField</code>和<code>LoadMethod</code>是如何加载的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadField</span><span class="params">(<span class="keyword">const</span> ClassAccessor::Field&amp; field,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Handle&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ArtField* dst)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可以看到实际就是将值填充给了dst</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> field_idx = field.GetIndex();</span><br><span class="line">  dst-&gt;SetDexFieldIndex(field_idx);</span><br><span class="line">  dst-&gt;SetDeclaringClass(klass.Get());</span><br><span class="line">  dst-&gt;SetAccessFlags(field.GetAccessFlags() | hiddenapi::CreateRuntimeFlags(field));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadMethod</span><span class="params">(<span class="keyword">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> ClassAccessor::Method&amp; method,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Handle&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ArtMethod* dst)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> dex_method_idx = method.GetIndex();</span><br><span class="line">  <span class="keyword">const</span> dex::MethodId&amp; method_id = dex_file.GetMethodId(dex_method_idx);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* method_name = dex_file.StringDataByIdx(method_id.name_idx_);</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedAssertNoThreadSuspension <span class="title">ants</span><span class="params">(<span class="string">&quot;LoadMethod&quot;</span>)</span></span>;</span><br><span class="line">  dst-&gt;SetDexMethodIndex(dex_method_idx);</span><br><span class="line">  dst-&gt;SetDeclaringClass(klass.Get());</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 如果加载的是finalize方法</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(<span class="built_in">strcmp</span>(<span class="string">&quot;finalize&quot;</span>, method_name) == <span class="number">0</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method_name[<span class="number">0</span>] == <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理构造函数</span></span><br><span class="line">    <span class="keyword">bool</span> is_init = (<span class="built_in">strcmp</span>(<span class="string">&quot;&lt;init&gt;&quot;</span>, method_name) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">bool</span> is_clinit = !is_init &amp;&amp; (<span class="built_in">strcmp</span>(<span class="string">&quot;&lt;clinit&gt;&quot;</span>, method_name) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(!is_init &amp;&amp; !is_clinit)) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">&quot;Unexpected &#x27;&lt;&#x27; at start of method name &quot;</span> &lt;&lt; method_name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY((access_flags &amp; kAccConstructor) == <span class="number">0</span>)) &#123;</span><br><span class="line">        LOG(WARNING) &lt;&lt; method_name &lt;&lt; <span class="string">&quot; didn&#x27;t have expected constructor access flag in class &quot;</span></span><br><span class="line">            &lt;&lt; klass-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot; in dex file &quot;</span> &lt;&lt; dex_file.GetLocation();</span><br><span class="line">        <span class="comment">// access_flags存储了Java方法的访问标志，如public、private、static等。kAccConstructor是一个常量，表示Java构造函数的访问标志</span></span><br><span class="line">        access_flags |= kAccConstructor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否为native函数</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY((access_flags &amp; kAccNative) != <span class="number">0u</span>)) &#123;</span><br><span class="line">    <span class="comment">// Check if the native method is annotated with @FastNative or @CriticalNative.</span></span><br><span class="line">    access_flags |= annotations::GetNativeMethodAnnotationAccessFlags(</span><br><span class="line">        dex_file, dst-&gt;GetClassDef(), dex_method_idx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置该方法的访问标志</span></span><br><span class="line">  dst-&gt;SetAccessFlags(access_flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为接口类的抽象方法</span></span><br><span class="line">  <span class="keyword">if</span> (klass-&gt;IsInterface() &amp;&amp; dst-&gt;IsAbstract()) &#123;</span><br><span class="line">	<span class="comment">// 计算并设置抽象方法的IMT索引。IMT(Interface Method Table)是一个虚拟表，用于存储接口类中的所有方法索引。</span></span><br><span class="line">    dst-&gt;CalculateAndSetImtIndex();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个java方法是否有可执行代码，也就是java字节码，方法的具体执行指令集</span></span><br><span class="line">  <span class="keyword">if</span> (dst-&gt;HasCodeItem()) &#123;</span><br><span class="line">    DCHECK_NE(method.GetCodeItemOffset(), <span class="number">0u</span>);</span><br><span class="line">    <span class="comment">// 根据当前是否采用AOT编译器来进行不同的方式填充可执行代码。</span></span><br><span class="line">    <span class="keyword">if</span> (Runtime::Current()-&gt;IsAotCompiler()) &#123;</span><br><span class="line">      dst-&gt;SetDataPtrSize(reinterpret_cast32&lt;<span class="keyword">void</span>*&gt;(method.GetCodeItemOffset()), image_pointer_size_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dst-&gt;SetCodeItem(dst-&gt;GetDexFile()-&gt;GetCodeItem(method.GetCodeItemOffset()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dst-&gt;SetDataPtrSize(<span class="literal">nullptr</span>, image_pointer_size_);</span><br><span class="line">    DCHECK_EQ(method.GetCodeItemOffset(), <span class="number">0u</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查该方法的参数类型和返回值类型是否符合要求</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* shorty = dst-&gt;GetShorty();</span><br><span class="line">  <span class="keyword">bool</span> all_parameters_are_reference = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">bool</span> all_parameters_are_reference_or_int = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">bool</span> return_type_is_fp = (shorty[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> || shorty[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>, e = <span class="built_in">strlen</span>(shorty); i &lt; e; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shorty[i] != <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">      all_parameters_are_reference = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (shorty[i] == <span class="string">&#x27;F&#x27;</span> || shorty[i] == <span class="string">&#x27;D&#x27;</span> || shorty[i] == <span class="string">&#x27;J&#x27;</span>) &#123;</span><br><span class="line">        all_parameters_are_reference_or_int = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Java方法设置是否启用Nterp快速路径，如果该函数非native的，并且参数全部为引用类型，则设置该方法的entry_point_from_interpreter_为Nterp快速路径</span></span><br><span class="line">  <span class="keyword">if</span> (!dst-&gt;IsNative() &amp;&amp; all_parameters_are_reference) &#123;</span><br><span class="line">    dst-&gt;SetNterpEntryPointFastPathFlag();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回值类型非浮点型，并且所有参数类型都是引用类型或整型，则设置该方法的invocation_count_为Nterp快速路径</span></span><br><span class="line">  <span class="keyword">if</span> (!return_type_is_fp &amp;&amp; all_parameters_are_reference_or_int) &#123;</span><br><span class="line">    dst-&gt;SetNterpInvokeFastPathFlag();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>finalize</code>是<code>Java</code>中的一个方法，定义在<code>Object</code>类中，用于执行垃圾回收前的资源清理工作。当某个对象不再被引用时，垃圾回收器会调用该对象的<code>finalize</code>方法来完成一些特定的清理操作，如释放非托管资源等。</p>
<p>​    <code>Nterp</code>快速路径<code>（Nterp Fast Path）</code>是<code>ART</code>虚拟机的一种执行模式，可以在不进行线程切换的情况下快速执行<code>Java</code>方法。具体来说，<code>Nterp</code>快速路径使用一种特殊的、基于指令计数器的执行模式来处理<code>Java</code>方法，以实现更高效的性能。</p>
<p>​    <code>Nterp</code>快速路径的作用是提高<code>Java</code>方法的执行速度和效率，特别是在热点代码部分，可以获得更高的吞吐量和更低的延迟。另外，由于采用了一些特殊的优化技术，如参数传递方式改变、返回值处理流程优化等，<code>Nterp</code>快速路径还可以减少<code>JNI</code>开销，从而提升整个应用程序的性能表现。</p>
<p>​    在前文介绍<code>native</code>的动态注册时，曾经简单的讲解<code>LinkCode</code>，这里再次对这个重点函数进行详细的了解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ClassLinker::ShouldUseInterpreterEntrypoint</span><span class="params">(ArtMethod* method, <span class="keyword">const</span> <span class="keyword">void</span>* quick_code)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (quick_code == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ..</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LinkCode</span><span class="params">(ClassLinker* class_linker,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ArtMethod* method,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> OatFile::OatClass* oat_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">uint32_t</span> class_def_method_index)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* quick_code = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (oat_class != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> OatFile::OatMethod oat_method = oat_class-&gt;GetOatMethod(class_def_method_index);</span><br><span class="line">    <span class="comment">// 获取一个方法的快速代码（Quick Code），用于设置该方法的入口点地址</span></span><br><span class="line">    quick_code = oat_method.GetQuickCode();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有方法的快速代码，否则使用解释器执行，在下一节的函数调用中会详细讲到</span></span><br><span class="line">  <span class="keyword">bool</span> enter_interpreter = class_linker-&gt;ShouldUseInterpreterEntrypoint(method, quick_code);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (quick_code == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置一个方法的入口点位置，可以是编译成机器码的快速执行入口、解释器入口，或者native函数的入口地址</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(</span><br><span class="line">        method-&gt;IsNative() ? GetQuickGenericJniStub() : GetQuickToInterpreterBridge());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enter_interpreter) &#123;</span><br><span class="line">    <span class="comment">// 设置解释器入口为该方法的入口点位置</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickToInterpreterBridge());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NeedsClinitCheckBeforeCall(method)) &#123;</span><br><span class="line">    DCHECK(!method-&gt;GetDeclaringClass()-&gt;IsVisiblyInitialized());</span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(GetQuickResolutionStub());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 已经编译好的机器码所在的快速执行入口</span></span><br><span class="line">    method-&gt;SetEntryPointFromQuickCompiledCode(quick_code);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给native设置入口地址的，在第六章动态注册中讲到。</span></span><br><span class="line">  <span class="keyword">if</span> (method-&gt;IsNative()) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    快速代码是指一种优化后的本地机器代码，它可以直接执行<code>Java</code>字节码对应的指令，从而实现更快的函数调用和执行。快速代码通常是通过即时编译器<code>（JIT）</code>或预编译技术生成的，并保存在<code>Oat</code>文件中。在运行时，如果一个方法已经被编译为快速代码，则<code>LinkCode</code>函数可以直接使用<code>Oat</code>文件中的方法描述符获取快速代码的地址，并将其设置为该方法的入口点地址。</p>
<p>​    接下来看看设置的解释器入口是什么，跟踪方法<code>GetQuickToInterpreterBridge</code>的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">GetQuickToInterpreterBridge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(art_quick_to_interpreter_bridge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里和<code>native</code>动态注册分析时看到入口设置非常类似，<code>GetQuickToInterpreterBridge</code>是一个静态内联函数，它将全局变量<code>art_quick_to_interpreter_bridge</code>的地址强制转换为<code>const void*</code>类型，然后返回该地址。<code>art_quick_to_interpreter_bridge</code>是一个指向解释器入口点的函数指针，它在链接器启动时被初始化，是由汇编进行实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ENTRY art_quick_to_interpreter_bridge</span><br><span class="line">    SETUP_SAVE_REFS_AND_ARGS_FRAME         &#x2F;&#x2F; Set up frame and save arguments.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  x0 will contain mirror::ArtMethod* method.</span><br><span class="line">    mov x1, xSELF                          &#x2F;&#x2F; How to get Thread::Current() ???</span><br><span class="line">    mov x2, sp</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; uint64_t artQuickToInterpreterBridge(mirror::ArtMethod* method, Thread* self,</span><br><span class="line">    &#x2F;&#x2F;                                      mirror::ArtMethod** sp)</span><br><span class="line">    bl   artQuickToInterpreterBridge</span><br><span class="line"></span><br><span class="line">    RESTORE_SAVE_REFS_AND_ARGS_FRAME</span><br><span class="line">    REFRESH_MARKING_REGISTER</span><br><span class="line"></span><br><span class="line">    fmov d0, x0</span><br><span class="line"></span><br><span class="line">    RETURN_OR_DELIVER_PENDING_EXCEPTION</span><br><span class="line">END art_quick_to_interpreter_bridge</span><br></pre></td></tr></table></figure>

<p>查看汇编代码时，可以注意到关键是使用<code>bl</code>指令调用<code>artQuickToInterpreterBridge</code>函数。这个函数就是解释器的入口函数。</p>
<p>解释器（Interpreter）是一种Java字节码执行引擎，它能够直接解释和执行Java字节码指令。与预编译的本地机器代码不同，解释器以Java字节码为基础，通过逐条解释执行来完成函数的执行过程。</p>
<p>当应用程序需要执行一个Java方法时，链接器会将该方法的字节码读入内存，并利用解释器逐条指令执行。解释器会根据Java字节码类型进行相应的操作，包括创建对象、读取/写入局部变量和操作数栈、跳转操作等。同时，解释器还会处理异常、垃圾回收、线程同步等方面的操作，从而保证Java程序的正确性和稳定性。</p>
<p>尽管解释器的执行速度比本地机器代码要慢一些，但它具有许多优点。例如，解释器可以实现更快的程序启动时间、更小的内存占用和更好的灵活性；同时，它还可以避免因硬件平台差异、编译器优化等问题导致代码执行异常和安全隐患。</p>
<p>当一个方法第一次被调用时，在进行初步解释和执行之后，解释器会生成相应的Profile数据。后续调用将根据Profile数据决定是否使用JIT编译器或AOT编译器进行优化。这种混合的执行方式可以有效地平衡运行效率和内存开销之间的关系，提高Java程序的整体性能和响应速度。</p>
<p>当类加载完成后，对应的类数据将会存储在相应的DexFile中。在后续使用中，可以通过DexFile来访问类中的成员和函数。下面简单了解一下DexFile结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// dex文件魔数的字节数。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kDexMagicSize = <span class="number">4</span>;</span><br><span class="line">  <span class="comment">// dex文件版本号的字节数。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kDexVersionLen = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kClassDefinitionOrderEnforcedVersion = <span class="number">37</span>;</span><br><span class="line">  <span class="comment">// SHA-1消息摘要的长度</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kSha1DigestSize = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// dex文件的大小端标志</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kDexEndianConstant = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无效索引的值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint16_t</span> kDexNoIndex16 = <span class="number">0xFFFF</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kDexNoIndex32 = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示dex文件头结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> magic_[<span class="number">8</span>] = &#123;&#125;;		<span class="comment">// 魔数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> checksum_ = <span class="number">0</span>;    <span class="comment">// 校验和</span></span><br><span class="line">    <span class="keyword">uint8_t</span> signature_[kSha1DigestSize] = &#123;&#125;;	<span class="comment">// SHA-1签名</span></span><br><span class="line">    <span class="keyword">uint32_t</span> file_size_ = <span class="number">0</span>;  <span class="comment">// 文件总大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> header_size_ = <span class="number">0</span>;  <span class="comment">// 偏移量到下一部分的起始位置</span></span><br><span class="line">    <span class="keyword">uint32_t</span> endian_tag_ = <span class="number">0</span>;	<span class="comment">// 大小端标志</span></span><br><span class="line">    <span class="keyword">uint32_t</span> link_size_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> link_off_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> map_off_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> string_ids_size_ = <span class="number">0</span>;  <span class="comment">// 字符串ID的数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> string_ids_off_ = <span class="number">0</span>;  <span class="comment">// 字符串ID数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> type_ids_size_ = <span class="number">0</span>;  <span class="comment">// 类型ID数，不支持超过65535个</span></span><br><span class="line">    <span class="keyword">uint32_t</span> type_ids_off_ = <span class="number">0</span>;  <span class="comment">// 类型ID数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> proto_ids_size_ = <span class="number">0</span>;  <span class="comment">// ProtoId的数量，不支持超过65535个</span></span><br><span class="line">    <span class="keyword">uint32_t</span> proto_ids_off_ = <span class="number">0</span>;  <span class="comment">// ProtoId数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> field_ids_size_ = <span class="number">0</span>;  <span class="comment">// FieldIds的数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> field_ids_off_ = <span class="number">0</span>;  <span class="comment">// FieldIds数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> method_ids_size_ = <span class="number">0</span>;  <span class="comment">// MethodIds的数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> method_ids_off_ = <span class="number">0</span>;  <span class="comment">// MethodIds数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> class_defs_size_ = <span class="number">0</span>;  <span class="comment">// ClassDefs的数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> class_defs_off_ = <span class="number">0</span>;  <span class="comment">// ClassDef数组的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> data_size_ = <span class="number">0</span>;  <span class="comment">// 数据部分的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> data_off_ = <span class="number">0</span>;  <span class="comment">// 数据部分的文件偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码dex文件版本号。</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">GetVersion</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 支持默认方法的第一个Dex格式版本。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kDefaultMethodsVersion = <span class="number">37</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// dex文件数据起始位置</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> begin_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内存分配的字节数。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> size_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据节的基地址（对于标准dex，与Begin()相同）。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> data_begin_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据节的大小。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> data_size_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> location_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> location_checksum_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dex文件头的指针</span></span><br><span class="line">  <span class="keyword">const</span> Header* <span class="keyword">const</span> header_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::StringId* <span class="keyword">const</span> string_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::TypeId* <span class="keyword">const</span> type_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字段标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::FieldId* <span class="keyword">const</span> field_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::MethodId* <span class="keyword">const</span> method_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原型标识符列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::ProtoId* <span class="keyword">const</span> proto_ids_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类定义列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::ClassDef* <span class="keyword">const</span> class_defs_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法句柄列表的指针</span></span><br><span class="line">  <span class="keyword">const</span> dex::MethodHandleItem* method_handles_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法句柄列表中元素的数量</span></span><br><span class="line">  <span class="keyword">size_t</span> num_method_handles_;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    接着查看<code>DexFile</code>的构造函数实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">DexFile::DexFile(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* base,</span><br><span class="line">                 <span class="keyword">size_t</span> size,</span><br><span class="line">                 <span class="keyword">const</span> <span class="keyword">uint8_t</span>* data_begin,</span><br><span class="line">                 <span class="keyword">size_t</span> data_size,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; location,</span><br><span class="line">                 <span class="keyword">uint32_t</span> location_checksum,</span><br><span class="line">                 <span class="keyword">const</span> OatDexFile* oat_dex_file,</span><br><span class="line">                 <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DexFileContainer&gt; container,</span><br><span class="line">                 <span class="keyword">bool</span> is_compact_dex)</span><br><span class="line">    : begin_(base),</span><br><span class="line">      size_(size),</span><br><span class="line">      data_begin_(data_begin),</span><br><span class="line">      data_size_(data_size),</span><br><span class="line">      location_(location),</span><br><span class="line">      location_checksum_(location_checksum),</span><br><span class="line">      header_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> Header*&gt;(base)),</span><br><span class="line">      string_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> StringId*&gt;(base + header_-&gt;string_ids_off_)),</span><br><span class="line">      type_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> TypeId*&gt;(base + header_-&gt;type_ids_off_)),</span><br><span class="line">      field_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> FieldId*&gt;(base + header_-&gt;field_ids_off_)),</span><br><span class="line">      method_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> MethodId*&gt;(base + header_-&gt;method_ids_off_)),</span><br><span class="line">      proto_ids_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> ProtoId*&gt;(base + header_-&gt;proto_ids_off_)),</span><br><span class="line">      class_defs_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> ClassDef*&gt;(base + header_-&gt;class_defs_off_)),</span><br><span class="line">      method_handles_(<span class="literal">nullptr</span>),</span><br><span class="line">      num_method_handles_(<span class="number">0</span>),</span><br><span class="line">      call_site_ids_(<span class="literal">nullptr</span>),</span><br><span class="line">      num_call_site_ids_(<span class="number">0</span>),</span><br><span class="line">      hiddenapi_class_data_(<span class="literal">nullptr</span>),</span><br><span class="line">      oat_dex_file_(oat_dex_file),</span><br><span class="line">      container_(<span class="built_in">std</span>::move(container)),</span><br><span class="line">      is_compact_dex_(is_compact_dex),</span><br><span class="line">      hiddenapi_domain_(hiddenapi::Domain::kApplication) &#123;</span><br><span class="line">  CHECK(begin_ != <span class="literal">nullptr</span>) &lt;&lt; GetLocation();</span><br><span class="line">  CHECK_GT(size_, <span class="number">0U</span>) &lt;&lt; GetLocation();</span><br><span class="line">  <span class="comment">// Check base (=header) alignment.</span></span><br><span class="line">  <span class="comment">// Must be 4-byte aligned to avoid undefined behavior when accessing</span></span><br><span class="line">  <span class="comment">// any of the sections via a pointer.</span></span><br><span class="line">  CHECK_ALIGNED(begin_, <span class="keyword">alignof</span>(Header));</span><br><span class="line"></span><br><span class="line">  InitializeSectionsFromMapList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看出<code>header_</code>这个<code>dex</code>文件头的结构体中存储着最重要的信息，初始化时先是填充了<code>header_</code>中的数据，然后再根据<code>header_</code>文件头，将其他重要信息初始化。当需要对这个<code>Dex</code>进行访问时，只需要通过文件头信息，就可以为我们索引找到任何一段信息了。它提供了整个文件的索引。</p>
<p>​    使用<code>010 Editor</code>工具，通过模板库在线安装<code>DEX.bt</code>模板，然后打开之前的样例文件，查看在例子中<code>header_</code>的真实数据。</p>
<p><img src="/2025/04/07/chapter-07/dex_header.png" alt="image-20230325190621427"></p>
<h2><span id="73-函数调用流程">7.3 函数调用流程</span></h2><p>在Android中，<strong>Java</strong>函数和<strong>native</strong>函数的调用方式略有不同。</p>
<p>对于<strong>Java</strong>函数，它们的执行是由<em>Android Runtime</em>虚拟机完成的。具体来说，当应用程序需要调用一个<strong>Java</strong>函数时，<em>Android Runtime</em>会根据该函数的状态和类型进行相应的处理，包括解释器执行、JIT编译器动态生成机器码等；当函数执行完毕后，结果会被传递回应用程序。</p>
<p>而对于<strong>native</strong>函数，则是由操作系统内核直接执行的。应用程序需要通过JNI（Java Native Interface）来调用<code>native</code> 函数。首先将<strong>Java数据结构转换为C/C++类型</strong>, 然后将参数传递给 <code>native</code> 函数, 最终再将结果转换为<strong>Java数据结构并返回给应用程序。</strong></p>
<p>在这个过程中, JNI提供了一系列的函数和接口来实现Java与本地代码/数据之间的交互和转换。</p>
<p>下面使用反编译工具<code>jadx</code>打开前文中的样例程序，样例程序的代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMyJarVer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;v1.0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    切换为展示<code>smali</code>指令，并右键选择显示<code>Dalvik</code>字节码，看到如下代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="keyword">static</span> <span class="title">add</span><span class="params">(II)</span>I</span></span><br><span class="line"><span class="function">    .registers 3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    .param p0, &quot;a&quot;:I</span></span><br><span class="line"><span class="function">    .param p1, &quot;b&quot;:I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                              .line 11</span></span><br><span class="line"><span class="function">    002bf89c: 9000 0102               0000: add-<span class="keyword">int</span>             v0, p0, p1</span></span><br><span class="line"><span class="function">                         .end local v1 # &quot;a&quot;:I</span></span><br><span class="line"><span class="function">                         .end local v2 # &quot;b&quot;:I</span></span><br><span class="line"><span class="function">    002bf8a0: 0f00                    0002: return              v0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.end method</span></span><br></pre></td></tr></table></figure>

<p>​    <code>.registers 3</code>表示该函数中使用到了3个寄存器，分别为两个参数和返回值。</p>
<p>​    <code>002bf89c</code> 表示的是当前指令的偏移地址。</p>
<p>​    <code>9000 0102</code> 就是该函数中的<code>java</code>字节码，其中前两个字节<code>9000</code>表示的是操作码，由于字节码是大端序存储的，所以这里实际操作码解读为<code>0x0090</code>，下面在<code>AOSP</code>中对<code>Opcodes</code>的定义中也能看到<code>0x90</code>操作码对应的操作是<code>add-int</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">int</span> OP_ADD_INT                      = <span class="number">0x0090</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    使用<code>010 Editor</code>工具，将样例程序解压后获得的<code>classes.dex</code>拖入<code>010 Editor</code>打开。看到结果如下。</p>
<p><img src="/2025/04/07/chapter-07/dex%E6%A8%A1%E6%9D%BF.png" alt="image-20230325133550347"></p>
<p>​    接下来在<code>dex_class_defs</code>中寻找刚刚分析的目标类<code>MyCommon</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct class_def_item class_def[2205]	public cn.rom.myjar.MyCommon	1243C4h	20h	Fg: Bg:0xE0E0E0	Class ID</span><br></pre></td></tr></table></figure>

<p>​    将其展开后，能看到该<code>class</code>的详细信息，在上一节的类加载中，当<code>DEX</code>被解析后，加载的类在内存中就是以这样的结构存储着数据。</p>
<p><img src="/2025/04/07/chapter-07/def_class.png" alt="image-20230325134213390"></p>
<p>​    在其中的函数结构体下面的<code>code_item</code>类型的数据，就存储着该函数要执行的<code>java</code>字节码，继续展开该结构。</p>
<p><img src="/2025/04/07/chapter-07/codeitem1.png" alt="image-20230325134632085"></p>
<p>​    这里就能看到对该函数结构的描述了，<code>insns</code>中则存储着函数要执行的指令。每个指令的单位是<code>ushort</code>，即两个字节存储，将这里的三个指令转换为16进制表示则是。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">144  &#x3D;  00 90 -&gt; 大端序 -&gt; 9000</span><br><span class="line"></span><br><span class="line">513  &#x3D;  02 01 -&gt; 大端序 -&gt; 0102</span><br><span class="line"></span><br><span class="line">15   &#x3D;  00 0F -&gt; 大端序 -&gt; 0f00</span><br></pre></td></tr></table></figure>

<p>​    结果和上面<code>smali</code>展示中的一致。这就是<code>java</code>字节码，在调用过程中，系统会经过层层的转换和解析，最终通过对函数中的指令进行执行来完成函数的调用。</p>
<p>​    接下来根据之前的例子，开始对函数调用流程的代码进行跟踪分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Object result = addMethod.invoke(<span class="keyword">null</span>, <span class="number">12</span>,<span class="number">25</span>);</span><br><span class="line">    Log.i(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;getMyJarVer:&quot;</span>+result);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    找到<code>Method</code>的<code>invoke</code>的实现，这是一个<code>native</code>函数，所以继续找对应的<code>Method_invoke</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FastNative</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">Method_invoke</span><span class="params">(JNIEnv* env, jobject javaMethod, jobject javaReceiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray javaArgs)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> InvokeMethod&lt;kRuntimePointerSize&gt;(soa, javaMethod, javaReceiver, javaArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">InvokeMethod</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa, jobject javaMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                     jobject javaReceiver, jobject javaArgs, size_t num_frames)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java方法和ArtMethod之间存在映射关系，SOA提供了一种方便的方式来将Java对象转换为Art虚拟机中的数据对象</span></span><br><span class="line">  ObjPtr&lt;mirror::Executable&gt; executable = soa.Decode&lt;mirror::Executable&gt;(javaMethod);</span><br><span class="line">  <span class="keyword">const</span> bool accessible = executable-&gt;IsAccessible();</span><br><span class="line">  ArtMethod* m = executable-&gt;GetArtMethod();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!m-&gt;IsStatic()) &#123;</span><br><span class="line">    <span class="comment">// Replace calls to String.&lt;init&gt; with equivalent StringFactory call.</span></span><br><span class="line">    <span class="keyword">if</span> (declaring_class-&gt;IsStringClass() &amp;&amp; m-&gt;IsConstructor()) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 查找虚方法的真实实现</span></span><br><span class="line">      m = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtualOrInterface(m, kPointerSize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对java方法的参数进行转换</span></span><br><span class="line">  ObjPtr&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt; objects =</span><br><span class="line">      soa.Decode&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt;(javaArgs);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  JValue result;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* shorty;</span><br><span class="line">  <span class="keyword">if</span> (!InvokeMethodImpl(soa, m, np_method, receiver, objects, &amp;shorty, &amp;result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> soa.AddLocalReference&lt;jobject&gt;(BoxPrimitive(Primitive::GetType(shorty[<span class="number">0</span>]), result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个函数中，主要使用<code>SOA</code>将<code>Java</code>函数以及函数的参数转换为<code>C++</code>对象。</p>
<p><code>Structured Object Access（SOA）</code>用于优化<code>Java</code>对象在<code>Native</code>代码和<code>Art</code>虚拟机之间的传递和处理。<code>SOA</code>技术提供了一种高效的方式，将<code>Java</code>对象转换为基于指针的本地<code>C++</code>对象，从而避免了频繁的对象复制和<code>GC</code>操作，提高了程序的性能和执行效率。</p>
<p>在<code>SOA</code>技术中使用<code>Handle</code>和<code>ObjPtr</code>等类型的指针来管理<code>Java</code>对象和本地<code>C++</code>对象之间的映射关系。<code>Handle</code>是一种包装器，用于管理<code>Java</code>对象的生命周期，并确保其在被访问时不会被<code>GC</code>回收。<code>ObjPtr</code>则是一种智能指针，用于管理本地<code>C++</code>对象的生命周期，并确保其正确释放和销毁。</p>
<p>通过<code>SOA</code>可以在<code>Native</code>代码中高效地访问和操作<code>Java</code>对象，例如调用<code>Java</code>方法、读取<code>Java</code>字段等。在执行过程中，<code>SOA</code>技术会自动进行对象的内存分配和管理，以确保程序的正确性和性能表现。</p>
<p>接下来继续了解<code>InvokeMethodImpl</code>函数的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InvokeMethodImpl</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ArtMethod* m,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ArtMethod* np_method,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ObjPtr&lt;mirror::Object&gt; receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ObjPtr&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt; objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">char</span>** shorty,</span></span></span><br><span class="line"><span class="function"><span class="params">                      JValue* result)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将函数的参数转换后，存放到arg_array中。</span></span><br><span class="line">  <span class="keyword">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">  *shorty = np_method-&gt;GetShorty(&amp;shorty_len);</span><br><span class="line">  <span class="function">ArgArray <span class="title">arg_array</span><span class="params">(*shorty, shorty_len)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!arg_array.BuildArgArrayFromObjectArray(receiver, objects, np_method, soa.Self())) &#123;</span><br><span class="line">    CHECK(soa.Self()-&gt;IsExceptionPending());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数调用</span></span><br><span class="line">  InvokeWithArgArray(soa, m, &amp;arg_array, result, *shorty);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>ArgArray</code>主要用于管理<code>Java</code>方法参数列表的类。<code>ArgArray</code>和<code>Java</code>中的类型对应如下：</p>
<p>​    1.基本类型：<code>ArgArray</code>中的基本类型分别对应<code>Java</code>中的八种基本类型</p>
<ul>
<li><code>boolean：&#39;Z&#39;</code></li>
<li><code>byte：&#39;B&#39;</code></li>
<li><code>short：&#39;S&#39;</code></li>
<li><code>char：&#39;C&#39;</code></li>
<li><code>int：&#39;I&#39;</code></li>
<li><code>long：&#39;J&#39;</code></li>
<li><code>float：&#39;F&#39;</code></li>
<li><code>double：&#39;D&#39;</code></li>
</ul>
<p>​    2.引用类型：<code>ArgArray</code>中的引用类型对应<code>Java</code>中的对象类型，包括<code>String、Object、</code>数组等。在<code>ArgArray</code>中，引用类型用字符<code>&#39;L&#39;</code>开头，并紧跟着完整类名和结尾的分号<code>&#39;;&#39;</code>表示，例如<code>&#39;Landroid/content/Context;&#39;</code>表示<code>android.content.Context</code>类。</p>
<p>​    3.可变参数：可变参数在<code>Java</code>中使用<code>“...”</code>符号表示，而在<code>ArgArray</code>中，则需要将所有可变参数打包为一个数组，并使用<code>‘[’</code>和<code>‘]’</code>符号表示。例如，如果<code>Java</code>方法声明为<code>“public void foo(int a, String... args)”</code>，则在<code>ArgArray</code>中，参数列表的短类型描述符为<code>“ILjava/lang/String;[”</code>。</p>
<p>​    理解了<code>C++</code>如何存放参数数据后，继续看下一层的函数调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvokeWithArgArray</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ArtMethod* method, ArgArray* arg_array, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取java参数的数组指针</span></span><br><span class="line">  <span class="keyword">uint32_t</span>* args = arg_array-&gt;GetArray();</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(soa.Env()-&gt;IsCheckJniEnabled())) &#123;</span><br><span class="line">    CheckMethodArguments(soa.Vm(), method-&gt;GetInterfaceMethodIfProxy(kRuntimePointerSize), args);</span><br><span class="line">  &#125;</span><br><span class="line">  method-&gt;Invoke(soa.Self(), args, arg_array-&gt;GetNumBytes(), result, shorty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用到了<code>ArtMethod</code>的<code>Invoke</code>函数，这里将参数的数组指针，参数数组大小，返回值指针，调用函数的描述符号传递了过去。在开始进入关键函数前，先对返回值指针<code>JValue* result</code>进行简单介绍。</p>
<p><code>JValue</code>是用于存储和传递<code>Java</code>方法返回值的联合体。包含了各种基本类型和引用类型的成员变量。下面是该联合体的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">union</span> <span class="title">PACKED</span><span class="params">(<span class="keyword">alignof</span>(mirror::Object*))</span> JValue </span>&#123;</span><br><span class="line">  <span class="comment">// We default initialize JValue instances to all-zeros.</span></span><br><span class="line">  JValue() : j(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; ALWAYS_INLINE <span class="keyword">static</span> JValue <span class="title">FromPrimitive</span><span class="params">(T v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int8_t</span> <span class="title">GetB</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> b; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetB</span><span class="params">(<span class="keyword">int8_t</span> new_b)</span> </span>&#123;</span><br><span class="line">    j = ((<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_b) &lt;&lt; <span class="number">56</span>) &gt;&gt; <span class="number">56</span>);  <span class="comment">// Sign-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint16_t</span> <span class="title">GetC</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetC</span><span class="params">(<span class="keyword">uint16_t</span> new_c)</span> </span>&#123;</span><br><span class="line">    j = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_c);  <span class="comment">// Zero-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">GetD</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetD</span><span class="params">(<span class="keyword">double</span> new_d)</span> </span>&#123; d = new_d; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">float</span> <span class="title">GetF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetF</span><span class="params">(<span class="keyword">float</span> new_f)</span> </span>&#123; f = new_f; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int32_t</span> <span class="title">GetI</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetI</span><span class="params">(<span class="keyword">int32_t</span> new_i)</span> </span>&#123;</span><br><span class="line">    j = ((<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_i) &lt;&lt; <span class="number">32</span>) &gt;&gt; <span class="number">32</span>);  <span class="comment">// Sign-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int64_t</span> <span class="title">GetJ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> j; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetJ</span><span class="params">(<span class="keyword">int64_t</span> new_j)</span> </span>&#123; j = new_j; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">mirror::Object* <span class="title">GetL</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line">  ALWAYS_INLINE</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetL</span><span class="params">(ObjPtr&lt;mirror::Object&gt; new_l)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int16_t</span> <span class="title">GetS</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetS</span><span class="params">(<span class="keyword">int16_t</span> new_s)</span> </span>&#123;</span><br><span class="line">    j = ((<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_s) &lt;&lt; <span class="number">48</span>) &gt;&gt; <span class="number">48</span>);  <span class="comment">// Sign-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint8_t</span> <span class="title">GetZ</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetZ</span><span class="params">(<span class="keyword">uint8_t</span> new_z)</span> </span>&#123;</span><br><span class="line">    j = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(new_z);  <span class="comment">// Zero-extend to 64 bits.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">mirror::Object** <span class="title">GetGCRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;l; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint8_t</span> z;</span><br><span class="line">  <span class="keyword">int8_t</span> b;</span><br><span class="line">  <span class="keyword">uint16_t</span> c;</span><br><span class="line">  <span class="keyword">int16_t</span> s;</span><br><span class="line">  <span class="keyword">int32_t</span> i;</span><br><span class="line">  <span class="keyword">int64_t</span> j;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  mirror::Object* l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>JValue</code>结构体的大小为8个字节对齐，结构体提供了一些成员函数，例如<code>GetXXX</code>和<code>SetXXX</code>等函数，用于获取和设置不同类型的返回值。<code>alignof(mirror::Object*)</code>的具体值取决于编译器和操作系统的不同，一般为4或8。</p>
<p>对参数以及返回值的在<code>C++</code>中的表示有了初步的了解后，开始继续查看函数调用过程中的关键函数<code>ArtMethod::Invoke</code>，下面是具体实现代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread* self, <span class="keyword">uint32_t</span>* args, <span class="keyword">uint32_t</span> args_size, JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span>* shorty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前的环境（也就是函数调用时的程序计数器、堆栈指针等信息）保存到一个栈帧中。这个栈帧通常会被分配在堆上，并且由垃圾回收器来管理。在函数返回时，这个栈帧会被弹出，恢复之前的环境。</span></span><br><span class="line">  ManagedStack fragment;</span><br><span class="line">  self-&gt;PushManagedStackFragment(&amp;fragment);</span><br><span class="line"></span><br><span class="line">  Runtime* runtime = Runtime::Current();</span><br><span class="line">  <span class="comment">// IsForceInterpreter为true表示强制使用解释器执行函数</span></span><br><span class="line">  <span class="comment">// 这里的条件是，如果设置了强制走解释器执行，并且非native函数，并且非代理函数，并且可执行的函数，则符合条件</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(!runtime-&gt;IsStarted() ||</span><br><span class="line">               (self-&gt;IsForceInterpreter() &amp;&amp; !IsNative() &amp;&amp; !IsProxyMethod() &amp;&amp; IsInvokable()))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (IsStatic()) &#123;</span><br><span class="line">      <span class="comment">// 静态函数调用</span></span><br><span class="line">      art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">          self, <span class="keyword">this</span>, <span class="literal">nullptr</span>, args, result, <span class="comment">/*stay_in_interpreter=*/</span> <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非静态函数调用</span></span><br><span class="line">      mirror::Object* receiver =</span><br><span class="line">          <span class="keyword">reinterpret_cast</span>&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[<span class="number">0</span>])-&gt;AsMirrorPtr();</span><br><span class="line">      art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">          self, <span class="keyword">this</span>, receiver, args + <span class="number">1</span>, result, <span class="comment">/*stay_in_interpreter=*/</span> <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 是否有已编译的快速执行代码的入口点</span></span><br><span class="line">    <span class="keyword">bool</span> have_quick_code = GetEntryPointFromQuickCompiledCode() != <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (LIKELY(have_quick_code)) &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 走快速调用方式，比解释器执行的性能高。</span></span><br><span class="line">      <span class="keyword">if</span> (!IsStatic()) &#123;</span><br><span class="line">        (*art_quick_invoke_stub)(<span class="keyword">this</span>, args, args_size, self, result, shorty);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*art_quick_invoke_static_stub)(<span class="keyword">this</span>, args, args_size, self, result, shorty);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; <span class="string">&quot;Not invoking &#x27;&quot;</span> &lt;&lt; PrettyMethod() &lt;&lt; <span class="string">&quot;&#x27; code=null&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        result-&gt;SetJ(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从栈帧中还原当前环境</span></span><br><span class="line">  self-&gt;PopManagedStackFragment(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上代码得到的结论是，函数执行的路线有两条，<code>EnterInterpreterFromInvoke</code>由解释器执行和<code>art_quick_invoke_stub</code>快速执行通道。</p>
<p><code>art_quick_invoke_stub</code>是由一段汇编完成对函数的执行，该函数充分利用寄存器并尽可能地减少堆栈访问次数，以提高<code>Java</code>方法的执行效率。虽然快速执行通道的效率会更加高，但是可读性差，但是对于学习执行过程和修改执行流程来说，解释器执行会更加简单易改。所以接下来跟进解释器执行，了解执行的细节。继续跟踪<code>EnterInterpreterFromInvoke</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnterInterpreterFromInvoke</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ArtMethod* method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ObjPtr&lt;mirror::Object&gt; receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">uint32_t</span>* args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                JValue* result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">bool</span> stay_in_interpreter)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取函数中的指令信息</span></span><br><span class="line">  <span class="function">CodeItemDataAccessor <span class="title">accessor</span><span class="params">(method-&gt;DexInstructionData())</span></span>;</span><br><span class="line">  <span class="keyword">uint16_t</span> num_regs;</span><br><span class="line">  <span class="keyword">uint16_t</span> num_ins;</span><br><span class="line">  <span class="keyword">if</span> (accessor.HasCodeItem()) &#123;</span><br><span class="line">    <span class="comment">// 获取寄存器的数量和参数的数量</span></span><br><span class="line">    num_regs =  accessor.RegistersSize();</span><br><span class="line">    num_ins = accessor.InsSize();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!method-&gt;IsInvokable()) &#123;</span><br><span class="line">    self-&gt;EndAssertNoThreadSuspension(old_cause);</span><br><span class="line">    method-&gt;ThrowInvocationTimeError();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DCHECK(method-&gt;IsNative()) &lt;&lt; method-&gt;PrettyMethod();</span><br><span class="line">    <span class="comment">// 从函数描述符中计算出寄存器数量和参数数量</span></span><br><span class="line">    <span class="comment">// 这里将num_regs和num_ins都赋值的原因是，方法的前几个参数通常会存储在寄存器中，而不是堆栈中。因此，num_regs和num_ins的值应该是相同的，都代表了当前方法使用的寄存器数量，也就是用于存储参数和局部变量等数据的寄存器数量。</span></span><br><span class="line">    num_regs = num_ins = ArtMethod::NumArgRegisters(method-&gt;GetShorty());</span><br><span class="line">    <span class="comment">// 非静态函数的情况，会多一个this参数，所以寄存器数量和参数数量+1</span></span><br><span class="line">    <span class="keyword">if</span> (!method-&gt;IsStatic()) &#123;</span><br><span class="line">      num_regs++;</span><br><span class="line">      num_ins++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的ShadowFrame作为当前栈，将当前环境保存在其中，并且推入栈帧，供当前线程调用方法时使用</span></span><br><span class="line">  ShadowFrame* last_shadow_frame = self-&gt;GetManagedStack()-&gt;GetTopShadowFrame();</span><br><span class="line">  ShadowFrameAllocaUniquePtr shadow_frame_unique_ptr =</span><br><span class="line">      CREATE_SHADOW_FRAME(num_regs, last_shadow_frame, method, <span class="comment">/* dex pc */</span> <span class="number">0</span>);</span><br><span class="line">  ShadowFrame* shadow_frame = shadow_frame_unique_ptr.get();</span><br><span class="line">  self-&gt;PushShadowFrame(shadow_frame);</span><br><span class="line">  <span class="comment">// 计算出将要使用的第一个寄存器</span></span><br><span class="line">  <span class="keyword">size_t</span> cur_reg = num_regs - num_ins;</span><br><span class="line">  <span class="comment">// 非静态函数的情况，第一个寄存器的值为this，所以设置其为引用类型</span></span><br><span class="line">  <span class="keyword">if</span> (!method-&gt;IsStatic()) &#123;</span><br><span class="line">    <span class="comment">// receiver变量表示方法调用的第一个参数</span></span><br><span class="line">    CHECK(receiver != <span class="literal">nullptr</span>);</span><br><span class="line">    shadow_frame-&gt;SetVRegReference(cur_reg, receiver);</span><br><span class="line">    ++cur_reg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* shorty = method-&gt;GetShorty(&amp;shorty_len);</span><br><span class="line">  <span class="comment">// 遍历所有参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> shorty_pos = <span class="number">0</span>, arg_pos = <span class="number">0</span>; cur_reg &lt; num_regs; ++shorty_pos, ++arg_pos, cur_reg++) &#123;</span><br><span class="line">    DCHECK_LT(shorty_pos + <span class="number">1</span>, shorty_len);</span><br><span class="line">    <span class="keyword">switch</span> (shorty[shorty_pos + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">//L 表示这个参数是个引用类型，比如Ljava/lang/String;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: &#123;</span><br><span class="line">        ObjPtr&lt;mirror::Object&gt; o =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[arg_pos])-&gt;AsMirrorPtr();</span><br><span class="line">        <span class="comment">// 将转换好的数据设置到当前栈中</span></span><br><span class="line">        shadow_frame-&gt;SetVRegReference(cur_reg, o);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// J或者D的数据类型要占用两个寄存器存放。</span></span><br><span class="line">        <span class="keyword">uint64_t</span> wide_value = (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(args[arg_pos + <span class="number">1</span>]) &lt;&lt; <span class="number">32</span>) | args[arg_pos];</span><br><span class="line">        <span class="comment">// 合并后的数据设置到栈中</span></span><br><span class="line">        shadow_frame-&gt;SetVRegLong(cur_reg, wide_value);</span><br><span class="line">        cur_reg++;</span><br><span class="line">        arg_pos++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 普通的整型数据设置到栈中</span></span><br><span class="line">        shadow_frame-&gt;SetVReg(cur_reg, args[arg_pos]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  self-&gt;EndAssertNoThreadSuspension(old_cause);</span><br><span class="line">  <span class="comment">// 静态函数的情况需要检查所在的类是否已经正常初始化。</span></span><br><span class="line">  <span class="keyword">if</span> (method-&gt;IsStatic()) &#123;</span><br><span class="line">    ObjPtr&lt;mirror::Class&gt; declaring_class = method-&gt;GetDeclaringClass();</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(!declaring_class-&gt;IsVisiblyInitialized())) &#123;</span><br><span class="line">      <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(self)</span></span>;</span><br><span class="line">      <span class="function">Handle&lt;mirror::Class&gt; <span class="title">h_class</span><span class="params">(hs.NewHandle(declaring_class))</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(!Runtime::Current()-&gt;GetClassLinker()-&gt;EnsureInitialized(</span><br><span class="line">                        self, h_class, <span class="comment">/*can_init_fields=*/</span> <span class="literal">true</span>, <span class="comment">/*can_init_parents=*/</span> <span class="literal">true</span>))) &#123;</span><br><span class="line">        CHECK(self-&gt;IsExceptionPending());</span><br><span class="line">        self-&gt;PopShadowFrame();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      DCHECK(h_class-&gt;IsInitializing());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非native函数执行</span></span><br><span class="line">  <span class="keyword">if</span> (LIKELY(!method-&gt;IsNative())) &#123;</span><br><span class="line">	<span class="comment">// 解释执行的关键函数</span></span><br><span class="line">    JValue r = Execute(self, accessor, *shadow_frame, JValue(), stay_in_interpreter);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *result = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// native函数的解释执行</span></span><br><span class="line">    args = shadow_frame-&gt;GetVRegArgs(method-&gt;IsStatic() ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Runtime::Current()-&gt;IsStarted()) &#123;</span><br><span class="line">      UnstartedRuntime::Jni(self, method, receiver.Ptr(), args, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      InterpreterJni(self, method, shorty, receiver, args, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 弹出栈帧，还原到执行后的栈环境</span></span><br><span class="line">  self-&gt;PopShadowFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这个函数中，为即将执行的函数准备好了栈帧环境，将参数填入了<code>shadow_frame</code>栈帧中。并且获取出了函数要执行的指令信息<code>accessor</code>。最后通过<code>Execute</code>执行该函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline JValue <span class="title">Execute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CodeItemDataAccessor&amp; accessor,</span></span></span><br><span class="line"><span class="function"><span class="params">    ShadowFrame&amp; shadow_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">    JValue result_register,</span></span></span><br><span class="line"><span class="function"><span class="params">    bool stay_in_interpreter = <span class="keyword">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    bool from_deoptimize = <span class="keyword">false</span>)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否需要从解释器模式切换到编译模式。</span></span><br><span class="line">  <span class="keyword">if</span> (LIKELY(!from_deoptimize)) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    instrumentation::Instrumentation* instrumentation = Runtime::Current()-&gt;GetInstrumentation();</span><br><span class="line">    <span class="comment">// 从当前线程栈帧中获取要执行的函数</span></span><br><span class="line">    ArtMethod *method = shadow_frame.GetMethod();</span><br><span class="line">	<span class="comment">// 是否有注册Method Entry 监听器</span></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(instrumentation-&gt;HasMethodEntryListeners())) &#123;</span><br><span class="line">      <span class="comment">// 触发 Method Entry 监听器，并传递相应的参数</span></span><br><span class="line">      instrumentation-&gt;MethodEnterEvent(self,</span><br><span class="line">                                        shadow_frame.GetThisObject(accessor.InsSize()),</span><br><span class="line">                                        method,</span><br><span class="line">                                        <span class="number">0</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 是否有未处理的异常</span></span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(self-&gt;IsExceptionPending())) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// stay_in_interpreter 表示是否需要停留在解释器模式，self-&gt;IsForceInterpreter() 表示是否强制使用解释器模式。所以内部是不走解释器执行的处理，走编译模式执行</span></span><br><span class="line">    <span class="keyword">if</span> (!stay_in_interpreter &amp;&amp; !self-&gt;IsForceInterpreter()) &#123;</span><br><span class="line">      jit::Jit* jit = Runtime::Current()-&gt;GetJit();</span><br><span class="line">      <span class="keyword">if</span> (jit != nullptr) &#123;</span><br><span class="line">        <span class="comment">// 判断当前方法是否可以使用 JIT 编译后的机器码执行</span></span><br><span class="line">        jit-&gt;MethodEntered(self, shadow_frame.GetMethod());</span><br><span class="line">        <span class="keyword">if</span> (jit-&gt;CanInvokeCompiledCode(method)) &#123;</span><br><span class="line">          JValue result;</span><br><span class="line">		  <span class="comment">// 直接栈帧推出</span></span><br><span class="line">          self-&gt;PopShadowFrame();</span><br><span class="line"></span><br><span class="line">          uint16_t arg_offset = accessor.RegistersSize() - accessor.InsSize();</span><br><span class="line">          <span class="comment">// 调用该函数的机器码实现</span></span><br><span class="line">          ArtInterpreterToCompiledCodeBridge(self, nullptr, &amp;shadow_frame, arg_offset, &amp;result);</span><br><span class="line">          <span class="comment">// 重新推入栈帧</span></span><br><span class="line">          self-&gt;PushShadowFrame(&amp;shadow_frame);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从栈帧中获取要执行的当前函数</span></span><br><span class="line">  ArtMethod* method = shadow_frame.GetMethod();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// kSwitchImplKind：表示当前实现是否使用基于 switch 语句的解释器实现。</span></span><br><span class="line">  <span class="keyword">if</span> (kInterpreterImplKind == kSwitchImplKind ||</span><br><span class="line">      UNLIKELY(!Runtime::Current()-&gt;IsStarted()) ||</span><br><span class="line">      !method-&gt;IsCompilable() ||</span><br><span class="line">      method-&gt;MustCountLocks() ||</span><br><span class="line">      Runtime::Current()-&gt;IsActiveTransaction()) &#123;</span><br><span class="line">    <span class="comment">// 使用switch解释器执行</span></span><br><span class="line">    <span class="keyword">return</span> ExecuteSwitch(</span><br><span class="line">        self, accessor, shadow_frame, result_register, <span class="comment">/*interpret_one_instruction=*/</span> <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CHECK_EQ(kInterpreterImplKind, kMterpImplKind);</span><br><span class="line">  <span class="comment">// 编译执行函数</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 是否支持Mterp解释器执行</span></span><br><span class="line">    <span class="keyword">if</span> (!self-&gt;UseMterp()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitch(</span><br><span class="line">          self, accessor, shadow_frame, result_register, <span class="comment">/*interpret_one_instruction=*/</span> <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行目标函数</span></span><br><span class="line">    bool returned = ExecuteMterpImpl(self,</span><br><span class="line">                                     accessor.Insns(),</span><br><span class="line">                                     &amp;shadow_frame,</span><br><span class="line">                                     &amp;result_register);</span><br><span class="line">    <span class="keyword">if</span> (returned) &#123;</span><br><span class="line">      <span class="keyword">return</span> result_register;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 失败的情况继续采用switch解释器执行</span></span><br><span class="line">      result_register = ExecuteSwitch(</span><br><span class="line">          self, accessor, shadow_frame, result_register, <span class="comment">/*interpret_one_instruction=*/</span> <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">if</span> (shadow_frame.GetDexPC() == dex::kDexNoIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> result_register;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完该函数后，在继续深入前，先将其中的几个知识点进行介绍。</p>
<p>编译模式<code>（Compiled Mode）</code>是一种执行方式，它将应用程序代码编译成机器码后再执行。相较于解释器模式，编译模式具有更高的执行效率和更好的性能表现。</p>
<p>在<code>Android</code>应用程序中，编译模式采用的是 <code>Just-In-Time（JIT）</code>编译技术。当一个方法被多次调用时，系统会自动将其编译成本地机器码，并缓存起来以备下次使用。</p>
<p>当一个方法被编译成本地机器码后，其执行速度将显著提高。因为与解释器模式相比，编译模式不需要逐条解释代码，而是直接执行编译好的机器码。</p>
<p>由于编译过程需要一定的时间，因此在程序启动或者第一次运行新方法时，可能会出现一些额外的延迟。所以，在实际应用中，系统通常会采用一些策略，如预热机制等，来优化编译模式的性能表现。编译模式是一种性能更高、效率更好的执行方式，可以帮助应用程序在运行时获得更好的响应速度和用户体验。</p>
<p><code>Method Entry</code> 监听器是<code>Android</code>系统中的一种监听器，它可以用来监听应用程序的方法入口。当一个方法被调用时，系统会触发<code>Method Entry</code>监听器，并将当前线程、当前方法和调用栈信息等相关数据传递给监听器。</p>
<p><code>Android Studio</code>在调试模式下会自动为每个线程启动一个监听器，并在方法进入和退出时触发相应的事件。这些事件包括 <code>Method Entry</code>（方法入口）、<code>Method Exit</code>（方法出口）等。</p>
<p>​    下面将分别介绍<code>ExecuteMterpImpl</code>和<code>ExecuteSwitch</code>是如何实现指令流的执行。</p>
<h2><span id="74-executemterpimpl">7.4 ExecuteMterpImpl</span></h2><p><code>ExecuteMterpImpl</code>是基于<code>Mterp（Method Interpreter）</code>技术实现。<code>Mterp</code>技术使用指令集解释器来执行应用程序的代码，相比于<code>JIT</code>编译模式可以更快地启动和执行短小精悍的方法，同时也可以避免<code>JIT</code>编译带来的额外开销。</p>
<p>在<code>Mterp</code>模式下，<code>Dex </code>指令集被转化成了一组<code>C++</code>的函数，这些函数对应<code>Dex</code>指令集中的每一条指令。<code>ExecuteMterpImpl</code>实际上就是调用这些函数来逐条解释执行当前方法的指令集。</p>
<p>​    在<code>Android 4.4</code>中，系统首次引入了 <code>Mterp</code> 技术来加速应用程序的解释执行。在此之后的 <code>Android</code>版本中，<code>Mterp </code>技术得到了不断优化和完善，并逐渐成为<code>Android</code>平台的主要方法执行方式之一。</p>
<p>​    从<code>Android 6.0</code>开始，<code>Dalvik </code>运行时环境被弃用，取而代之的是<code>ART</code>运行时环境。<code>ART</code> 运行时环境可以通过<code>JIT</code>编译、<code>AOT </code>编译和<code>Mterp</code>等多种方式来执行应用程序的代码，其中<code>Mterp</code>技术被广泛使用于 <code>Android</code> 应用程序的解释执行过程中。但是对于某些特定的场景和应用程序，系统可能还是会选择其他的执行方式来获得更好的性能和效率。</p>
<p>​    <code>ExecuteMterpImpl</code>使用了汇编语言和<code> C++</code>语言混合编写，需要有一定的汇编和<code>C++</code>编程经验才能理解其含义和功能。该代码主要实现了以下功能：</p>
<p>​    1.保存当前方法的返回值寄存器和指令集</p>
<p>​    2.设置方法执行的环境和参数，包括<code>vregs</code>数组、<code>dex_pc </code>寄存器等</p>
<p>​    3.为当前方法设置热度倒计时，并根据热度值来判断是否需要启用<code>Mterp</code>技术</p>
<p>​    4.执行当前方法的指令集，逐条解释执行 <code>Dex </code>指令</p>
<p>​    下面看<code>ExecuteMterpImpl</code>实现代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从xPC寄存器中获取一条指令</span><br><span class="line">.macro FETCH_INST</span><br><span class="line">    ldrh    wINST, [xPC]</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从指令中获取操作码，指令最顶部2个字节就是操作码，所以这里拿操作码是 &amp; 0xff的意思</span><br><span class="line">.macro GET_INST_OPCODE reg</span><br><span class="line">    and     \reg, xINST, #255</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 跳转到操作码处理逻辑</span><br><span class="line">.macro GOTO_OPCODE reg</span><br><span class="line">    add     \reg, xIBASE, \reg, lsl #$&#123;handler_size_bits&#125;</span><br><span class="line">    br      \reg</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">ENTRY ExecuteMterpImpl</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    &#x2F;&#x2F; 保存寄存器信息</span><br><span class="line">    SAVE_TWO_REGS_INCREASE_FRAME xPROFILE, x27, 80</span><br><span class="line">    SAVE_TWO_REGS                xIBASE, xREFS, 16</span><br><span class="line">    SAVE_TWO_REGS                xSELF, xINST, 32</span><br><span class="line">    SAVE_TWO_REGS                xPC, xFP, 48</span><br><span class="line">    SAVE_TWO_REGS                fp, lr, 64</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fp寄存器指向栈顶</span><br><span class="line">    add     fp, sp, #64</span><br><span class="line"></span><br><span class="line">    &#x2F;* 记录对应返回值的寄存器 *&#x2F;</span><br><span class="line">    str     x3, [x2, #SHADOWFRAME_RESULT_REGISTER_OFFSET]</span><br><span class="line"></span><br><span class="line">    &#x2F;* 记录dex文件中的指令的指针 *&#x2F;</span><br><span class="line">    str     x1, [x2, #SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET]</span><br><span class="line"></span><br><span class="line">    mov     xSELF, x0</span><br><span class="line">    ldr     w0, [x2, #SHADOWFRAME_NUMBER_OF_VREGS_OFFSET]</span><br><span class="line">    add     xFP, x2, #SHADOWFRAME_VREGS_OFFSET     &#x2F;&#x2F; 计算局部变量表的偏移地址</span><br><span class="line">    add     xREFS, xFP, w0, uxtw #2                &#x2F;&#x2F; 计算局部变量引用表的偏移地址</span><br><span class="line">    ldr     w0, [x2, #SHADOWFRAME_DEX_PC_OFFSET]   &#x2F;&#x2F; 获取当前Dex中的PC</span><br><span class="line">    add     xPC, x1, w0, uxtw #1                   &#x2F;&#x2F; 将Dex PC转换为地址，并保存到寄存器xPC中</span><br><span class="line">    CFI_DEFINE_DEX_PC_WITH_OFFSET(CFI_TMP, CFI_DEX, 0)</span><br><span class="line">    EXPORT_PC					&#x2F;&#x2F; 将Dex PC导出</span><br><span class="line"></span><br><span class="line">    &#x2F;* Starting ibase *&#x2F;</span><br><span class="line">    ldr     xIBASE, [xSELF, #THREAD_CURRENT_IBASE_OFFSET]</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set up for backwards branches &amp; osr profiling *&#x2F;</span><br><span class="line">    ldr     x0, [xFP, #OFF_FP_METHOD]				&#x2F;&#x2F; 获取当前方法的方法指针</span><br><span class="line">    add     x1, xFP, #OFF_FP_SHADOWFRAME			&#x2F;&#x2F; 计算拿到当前线程的栈帧</span><br><span class="line">    mov     x2, xSELF								&#x2F;&#x2F; 将当前线程对象保存到寄存器x2中</span><br><span class="line">    bl      MterpSetUpHotnessCountdown		 		&#x2F;&#x2F; 热度计数器调整</span><br><span class="line">    mov     wPROFILE, w0                &#x2F;&#x2F; 将热度计数器的宽度赋值给寄存器wPROFILE</span><br><span class="line"></span><br><span class="line">    &#x2F;* start executing the instruction at rPC *&#x2F;</span><br><span class="line">    FETCH_INST                          &#x2F;&#x2F; 获取下一条指令</span><br><span class="line">    GET_INST_OPCODE ip                  &#x2F;&#x2F; 从指令中获取操作码</span><br><span class="line">    GOTO_OPCODE ip                      &#x2F;&#x2F; 跳转到操作码处理逻辑</span><br><span class="line">    &#x2F;* NOTE: no fallthrough *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; cfi info continues, and covers the whole mterp implementation.</span><br><span class="line">    END ExecuteMterpImpl</span><br></pre></td></tr></table></figure>

<p>​    这些操作码可以通过<code>Opcodes</code>找到其对应的对应，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">int</span> OP_IPUT_CHAR                    = <span class="number">0x005e</span>;</span><br><span class="line">    <span class="keyword">int</span> OP_IPUT_SHORT                   = <span class="number">0x005f</span>;</span><br><span class="line">    <span class="keyword">int</span> OP_SGET                         = <span class="number">0x0060</span>;</span><br><span class="line">    <span class="keyword">int</span> OP_SGET_WIDE                    = <span class="number">0x0061</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    而在在汇编文件中，会有其对应操作码的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%def field(helper&#x3D;&quot;&quot;):</span><br><span class="line">    .extern $helper</span><br><span class="line">    mov      x0, xPC                       &#x2F;&#x2F; arg0: 指令的地址</span><br><span class="line">    mov      x1, xINST                     &#x2F;&#x2F; arg1: 指令对应的16位数值</span><br><span class="line">    add      x2, xFP, #OFF_FP_SHADOWFRAME  &#x2F;&#x2F; arg2: ShadowFrame* sf</span><br><span class="line">    mov      x3, xSELF                     &#x2F;&#x2F; arg3: Thread* self</span><br><span class="line">    PREFETCH_INST 2                        &#x2F;&#x2F; 预备取下一条指令</span><br><span class="line">    bl       $helper					   &#x2F;&#x2F; 调用 $helper 函数</span><br><span class="line">    cbz      x0, MterpPossibleException</span><br><span class="line">    ADVANCE 2</span><br><span class="line">    GET_INST_OPCODE ip                     &#x2F;&#x2F; 从指令中获取操作码</span><br><span class="line">    GOTO_OPCODE ip                         &#x2F;&#x2F; 跳转到操作码处理逻辑</span><br><span class="line"></span><br><span class="line">%def op_iput(helper&#x3D;&quot;MterpIPutU32&quot;):</span><br><span class="line">%  field(helper&#x3D;helper)</span><br><span class="line"></span><br><span class="line">%def op_sget(helper&#x3D;&quot;MterpSGetU32&quot;):</span><br><span class="line">%  field(helper&#x3D;helper)</span><br><span class="line"></span><br><span class="line">%def op_iput_char():</span><br><span class="line">%  op_iput(helper&#x3D;&quot;MterpIPutU16&quot;)</span><br><span class="line"></span><br><span class="line">%def op_iput_short():</span><br><span class="line">%  op_iput(helper&#x3D;&quot;MterpIPutI16&quot;)</span><br><span class="line"></span><br><span class="line">%def op_sget_wide():</span><br><span class="line">%  op_sget(helper&#x3D;&quot;MterpSGetU64&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    到这里，就找到对应的执行<code>C++</code>函数将<code>Dex</code>的指令逐一进行执行处理，其对应的<code>C++</code>执行部分则在文件<code>mterp.cc</code>文件中找到。<code>Mterp</code>的执行流程到这里就非常清晰了。</p>
<h2><span id="75-executeswitch">7.5 ExecuteSwitch</span></h2><p>​    <code>ExecuteSwitch</code>是基于 <code>switch </code>语句实现的一种解释器，用于执行当前方法的指令集。在 <code>Android</code> 应用程序中，每个方法都会对应一组指令集，用于描述该方法的具体实现。当该方法被调用时，系统需要按照指令集来执行相应的操作，从而实现该方法的功能并计算出结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> JValue <span class="title">ExecuteSwitch</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> CodeItemDataAccessor&amp; accessor,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ShadowFrame&amp; shadow_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                            JValue result_register,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">bool</span> interpret_one_instruction)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是否处于事务中</span></span><br><span class="line">  <span class="keyword">if</span> (Runtime::Current()-&gt;IsActiveTransaction()) &#123;</span><br><span class="line">    <span class="comment">// 是否跳过访问检查</span></span><br><span class="line">    <span class="keyword">if</span> (shadow_frame.GetMethod()-&gt;SkipAccessChecks()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">true</span>&gt;(</span><br><span class="line">          self, accessor, shadow_frame, result_register, interpret_one_instruction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">true</span>, <span class="literal">true</span>&gt;(</span><br><span class="line">          self, accessor, shadow_frame, result_register, interpret_one_instruction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shadow_frame.GetMethod()-&gt;SkipAccessChecks()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">false</span>, <span class="literal">false</span>&gt;(</span><br><span class="line">          self, accessor, shadow_frame, result_register, interpret_one_instruction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ExecuteSwitchImpl&lt;<span class="literal">true</span>, <span class="literal">false</span>&gt;(</span><br><span class="line">          self, accessor, shadow_frame, result_register, interpret_one_instruction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这个函数中，根据条件调整参数，最终都是调用<code>ExecuteSwitchImpl</code>，下面继续看解释器的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> do_access_check, <span class="keyword">bool</span> transaction_active&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteSwitchImplCpp</span><span class="params">(SwitchImplContext* ctx)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 获取到当前正在执行的Dex指令在CodeItem中的索引位置</span></span><br><span class="line">  <span class="keyword">uint32_t</span> dex_pc = shadow_frame.GetDexPC();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>* <span class="keyword">const</span> instrumentation = Runtime::Current()-&gt;GetInstrumentation();</span><br><span class="line">  <span class="comment">// 获取指令流</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint16_t</span>* <span class="keyword">const</span> insns = accessor.Insns();</span><br><span class="line">  <span class="comment">// 将当前指令转换为专门用来操作指令的Instruction类</span></span><br><span class="line">  <span class="keyword">const</span> Instruction* next = Instruction::At(insns + dex_pc);</span><br><span class="line"></span><br><span class="line">  DCHECK(!shadow_frame.GetForceRetryInstruction())</span><br><span class="line">      &lt;&lt; <span class="string">&quot;Entered interpreter from invoke without retry instruction being handled!&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">const</span> interpret_one_instruction = ctx-&gt;interpret_one_instruction;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取下一条待执行的指令</span></span><br><span class="line">    <span class="keyword">const</span> Instruction* <span class="keyword">const</span> inst = next;</span><br><span class="line">    dex_pc = inst-&gt;GetDexPc(insns);</span><br><span class="line">    <span class="comment">// 更新pc位置</span></span><br><span class="line">    shadow_frame.SetDexPC(dex_pc);</span><br><span class="line">    TraceExecution(shadow_frame, inst, dex_pc);</span><br><span class="line">    <span class="comment">// 从指令中获取到操作码</span></span><br><span class="line">    <span class="keyword">uint16_t</span> inst_data = inst-&gt;Fetch16(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">exit</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> success;  <span class="comment">// Moved outside to keep frames small under asan.</span></span><br><span class="line">    <span class="comment">// 执行指令前的预处理</span></span><br><span class="line">    <span class="keyword">if</span> (InstructionHandler&lt;do_access_check, transaction_active, Instruction::kInvalidFormat&gt;(</span><br><span class="line">            ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, <span class="built_in">exit</span>).</span><br><span class="line">            Preamble()) &#123;</span><br><span class="line">      DCHECK_EQ(self-&gt;IsExceptionPending(), inst-&gt;Opcode(inst_data) == Instruction::MOVE_EXCEPTION);</span><br><span class="line">      <span class="comment">// 这是一个超大的switch，根据操作码来选择如何执行</span></span><br><span class="line">      <span class="keyword">switch</span> (inst-&gt;Opcode(inst_data)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_CASE(OPCODE, OPCODE_NAME, NAME, FORMAT, i, a, e, v)                                \</span></span><br><span class="line">        <span class="keyword">case</span> OPCODE: &#123;                                                                            \</span><br><span class="line">          next = inst-&gt;RelativeAt(Instruction::SizeInCodeUnits(Instruction::FORMAT));             \</span><br><span class="line">          success = OP_##OPCODE_NAME&lt;do_access_check, transaction_active&gt;(                        \</span><br><span class="line">              ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, <span class="built_in">exit</span>);     \</span><br><span class="line">          <span class="keyword">if</span> (success &amp;&amp; LIKELY(!interpret_one_instruction)) &#123;                                    \</span><br><span class="line">            <span class="keyword">continue</span>;                                                                             \</span><br><span class="line">          &#125;                                                                                       \</span><br><span class="line">          <span class="keyword">break</span>;                                                                                  \</span><br><span class="line">        &#125;</span><br><span class="line">  DEX_INSTRUCTION_LIST(OPCODE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OPCODE_CASE</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>switch</code>解释器，就是指的这个函数中，使用<code>switch</code>来对不同的所有操作码进行对应的处理，但是这里并没有看到非常大的<code>case</code>条件，这是因为代码都在<code>OPCODE_CASE</code>定义中，找到这个定义的实现如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_CASE(OPCODE, OPCODE_NAME, NAME, FORMAT, i, a, e, v)                                \</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> do_access_check, <span class="keyword">bool</span> transaction_active&gt;                                           \</span><br><span class="line">ASAN_NO_INLINE <span class="keyword">static</span> <span class="keyword">bool</span> OP_##OPCODE_NAME(                                                      \</span><br><span class="line">    SwitchImplContext* ctx,                                                                       \</span><br><span class="line">    <span class="keyword">const</span> instrumentation::Instrumentation* instrumentation,                                      \</span><br><span class="line">    Thread* self,                                                                                 \</span><br><span class="line">    ShadowFrame&amp; shadow_frame,                                                                    \</span><br><span class="line">    <span class="keyword">uint16_t</span> dex_pc,                                                                              \</span><br><span class="line">    <span class="keyword">const</span> Instruction* inst,                                                                      \</span><br><span class="line">    <span class="keyword">uint16_t</span> inst_data,                                                                           \</span><br><span class="line">    <span class="keyword">const</span> Instruction*&amp; next,                                                                     \</span><br><span class="line">    <span class="keyword">bool</span>&amp; <span class="built_in">exit</span>) REQUIRES_SHARED(Locks::mutator_lock_) &#123;                                           \</span><br><span class="line">  InstructionHandler&lt;do_access_check, transaction_active, Instruction::FORMAT&gt; handler(           \</span><br><span class="line">      ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, <span class="built_in">exit</span>);             \</span><br><span class="line">  <span class="keyword">return</span> LIKELY(handler.OPCODE_NAME());                                                           \</span><br><span class="line">&#125;</span><br><span class="line">DEX_INSTRUCTION_LIST(OPCODE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OPCODE_CASE</span></span><br></pre></td></tr></table></figure>

<p>​    可以看到内部是调用了初始化了一个<code>InstructionHandler</code>对象，然后<code>handler.OPCODE_NAME()</code>调用了对应的操作码函数。最后看看其实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstructionHandler</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="function">ALWAYS_INLINE <span class="title">InstructionHandler</span><span class="params">(SwitchImplContext* ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> instrumentation::Instrumentation* instrumentation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ShadowFrame&amp; shadow_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint16_t</span> dex_pc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> Instruction* inst,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint16_t</span> inst_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> Instruction*&amp; next,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">bool</span>&amp; exit_interpreter_loop)</span></span></span><br><span class="line">    : ctx_(ctx),</span><br><span class="line">      instrumentation_(instrumentation),</span><br><span class="line">      self_(self),</span><br><span class="line">      shadow_frame_(shadow_frame),</span><br><span class="line">      dex_pc_(dex_pc),</span><br><span class="line">      inst_(inst),</span><br><span class="line">      inst_data_(inst_data),</span><br><span class="line">      next_(next),</span><br><span class="line">      exit_interpreter_loop_(exit_interpreter_loop) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">HANDLER_ATTRIBUTES <span class="keyword">bool</span> <span class="title">INVOKE_STATIC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HandleInvoke&lt;kStatic, <span class="comment">/*is_range=*/</span> <span class="literal">false</span>&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">HANDLER_ATTRIBUTES <span class="keyword">bool</span> <span class="title">INVOKE_STATIC_RANGE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HandleInvoke&lt;kStatic, <span class="comment">/*is_range=*/</span> <span class="literal">true</span>&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有操作码对应的实现都是在<code>InstructionHandler</code>中进行实现，<code>switch</code>解释器的做法非常简单粗暴，尽量性能较差，但是可读性高，当需求是对调用流程进行打桩，或者定制修改时，可以选择强制其走<code>switch</code>解释器来执行该函数。</p>
<p>需要注意的是，在执行的优化中，当强制走解释器流程调用后，它会交给<code>JIT</code>编译器进行编译，生成本地机器码。在生成机器码的同时，<code>JIT</code>编译器会将该函数的入口地址设置为生成的机器码的地址。在下一次调用该函数时，虚拟机就会跳过解释器阶段，直接执行机器码，从而提高程序的执行效率。</p>
<h2><span id="76-本章小结">7.6 本章小结</span></h2><p>本章主要介绍了安卓系统中DEX文件的类的加载机制与细节。相比于实际操作动手修改代码，本章介绍的内容显示更加枯燥乏味，但是深入了解系统内部的运行机制，有助于更宏观视角的去理解的程序执行。掌握这一部分内容，在代码修改点的选择上，尤其是系统组件的部分代码，将会更加精准。而且，本章内容同样适合于二进制安全对抗研究领域，是研究软件加密与解密必不可少的基础知识。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>第七章 类加载和函数调用</p><p><a href="http://example.com/2025/04/07/chapter-07/">http://example.com/2025/04/07/chapter-07/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://example.com"><p>Lis</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-04-07</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-04-07</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2025/06/19/View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" target="_blank">View绘制流程</a><br></span><span>  2.<a class="is-size-6" href="/2025/06/13/setContentView%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" target="_blank">setContentView流程分析</a><br></span><span>  3.<a class="is-size-6" href="/2025/06/11/Android%E7%9A%84ClassLoader/" target="_blank">Android-ClassLoader介绍</a><br></span><span>  4.<a class="is-size-6" href="/2025/04/07/chapter-03/" target="_blank">第三章 认识系统组件</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/06/15/view/" target="_blank">View基础</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/ali.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wei.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/05/15/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84-%E4%B8%8B/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">注解与反射（下）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/04/07/chapter-03/"><span class="level-item">第三章 认识系统组件</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '6ea203cced8016621b1f6f5e2253dcc9',
            repo: 'gitalk',
            owner: 'xunyixiangchao',
            clientID: '9e8b7b8cef8759344d50',
            clientSecret: 'e5ef7e0a75d0431208a8fc15f1b41bd45bf0ca2d',
            admin: ["xunyixiangchao"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/2018.jpg" alt="Lis"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Lis</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xunyixiangchao" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xunyixiangchao"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/xunyixiangchao"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:Lis@163.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Next" href="https://xunyixiangchao.github.io/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-21T08:22:54.000Z">2025-06-21</time></p><p class="title"><a href="/2025/06/21/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BViewGroup/">自定义View之ViewGroup</a></p><p class="categories"><a href="/categories/View/">View</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-19T08:22:54.000Z">2025-06-19</time></p><p class="title"><a href="/2025/06/19/View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">View绘制流程</a></p><p class="categories"><a href="/categories/Android%E6%BA%90%E7%A0%81/">Android源码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-15T07:21:54.000Z">2025-06-15</time></p><p class="title"><a href="/2025/06/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Java网络编程</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/">Java基础与进阶</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-13T06:14:54.000Z">2025-06-13</time></p><p class="title"><a href="/2025/06/13/setContentView%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">setContentView流程分析</a></p><p class="categories"><a href="/categories/Android%E6%BA%90%E7%A0%81/">Android源码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-11T09:08:54.000Z">2025-06-11</time></p><p class="title"><a href="/2025/06/11/Android%E7%9A%84ClassLoader/">Android-ClassLoader介绍</a></p><p class="categories"><a href="/categories/Android%E6%BA%90%E7%A0%81/">Android源码</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">Android三方库源码分析</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android%E6%BA%90%E7%A0%81/"><span class="level-start"><span class="level-item">Android源码</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"><span class="level-start"><span class="level-item">Java基础与进阶</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/View/"><span class="level-start"><span class="level-item">View</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/06/"><span class="level-start"><span class="level-item">六月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android%E6%BA%90%E7%A0%81/"><span class="tag">Android源码</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/View/"><span class="tag">View</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ViewGroup/"><span class="tag">ViewGroup</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"><span class="tag">动态代理</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%B0%84/"><span class="tag">反射</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%A8%E8%A7%A3/"><span class="tag">注解</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"><span class="tag">自定义View</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OkHttp/"><span class="tag">OkHttp</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"><span class="tag">View绘制流程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/activity/"><span class="tag">activity</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dispatch/"><span class="tag">dispatch</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/setContentView/"><span class="tag">setContentView</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%9B%E5%9E%8B/"><span class="tag">泛型</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"><span class="tag">热修复</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><span class="tag">类加载</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2018.jpg" alt="Lis" height="28"></a><p class="size-small"><span>&copy; 2025 Lis</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://xunyixiangchao.github.io/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://xunyixiangchao.github.io/"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9e8b7b8cef8759344d50','e5ef7e0a75d0431208a8fc15f1b41bd45bf0ca2d','xunyixiangchao','gitalk',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9e8b7b8cef8759344d50','e5ef7e0a75d0431208a8fc15f1b41bd45bf0ca2d','xunyixiangchao','gitalk',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>